_id,name,code,docstring,human_label,enriched_description
6367676d1a6d9265ec018229,trimArrayElements,"public static String[] trimArrayElements(String[] array){
  if (Objects.isEmpty(array)) {
    return new String[0];
  }
  String[] result=new String[array.length];
  for (int i=0; i < array.length; i++) {
    String element=array[i];
    result[i]=(element != null ? element.trim() : null);
  }
  return result;
}
","/** 
 * Trim the elements of the given String array, calling <code>String.trim()</code> on each of them.
 * @param array the original String array
 * @return the resulting array (of the same size) with trimmed elements
 */
",Trim each element in the given string array and return the resulting array.,"1. One-line summary: Trims whitespace from each element of an array.
2. Function behavior: The function trims leading and trailing whitespace from each string in the input array. If the array or its elements are null, it returns an empty string or null respectively.
3. Function signature: 
@param array String[]: The input array of strings to be trimmed.
@return String[]: A new array with trimmed strings.
4. Examples: 
[""  hello "", "" world  ""] -> [""hello"", ""world""] (trims spaces)
[""foo"", ""bar""] -> [""foo"", ""bar""] (no spaces to trim)
null -> [] (handles null input)
5. Preconditions & Postconditions: Input array may contain null elements and will be safely handled, resulting in trimmed strings or nulls in the output."
6367670b1a6d9265ec017a00,isSameLength,"public static boolean isSameLength(final byte[] array1,final byte[] array2){
  if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {
    return false;
  }
  return true;
}
","/** 
 * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array
 */
",Check whether the length of the given two byte arrays is the same.,"1. One-line summary: Checks if two byte arrays have the same length.
2. Function behavior: Returns true if both arrays are null or have the same length; otherwise, returns false.
3. Function signature: 
@param array1 byte[]: first byte array
@param array2 byte[]: second byte array
@return boolean: true if same length or both null, false otherwise
4. Examples: null, null -> true (both null) null, new byte[]{1} -> false (one null, one not) new byte[]{1,2}, new byte[]{3,4} -> true (same length) new byte[]{1,2}, new byte[]{3} -> false (different lengths)
5. Preconditions & Postconditions: Arrays can be null, valid output respecting null and length conditions."
636766a91a6d9265ec0175c2,pop,"private int pop(){
  if (outputStackTop > 0) {
    return outputStack[--outputStackTop];
  }
 else {
    return STACK_KIND | -(--outputStackStart);
  }
}
","/** 
 * Pops an abstract type from the output frame stack and returns its value.
 * @return the abstract type that has been popped from the output frame stack.
 */
",Pop an abstract type from the output frame stack and return its value.,"1. One-line summary: Returns the top element of the stack or a special code.
2. Function behavior: Removes and returns the top element from `outputStack` if there is one, otherwise returns a special code computed with `STACK_KIND` and `outputStackStart`.
3. Function signature:
@return int: The top element of `outputStack` or a special code.
4. Examples: (outputStackTop=2, outputStack={5,3}) -> 3 (normal pop) (outputStackTop=0, outputStackStart=1) -> STACK_KIND-0 (special case return)
5. Preconditions & Postconditions: The stack must have non-negative indices; returns stack element or computed special code."
636767081a6d9265ec017989,toPrimitive,"public static boolean[] toPrimitive(final Boolean[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;
  }
  final boolean[] result=new boolean[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].booleanValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Booleans to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Boolean</code> array, may be <code>null</code>
 * @return a <code>boolean</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Convert the given Boolean array to primitives. Return ArrayUtils.EMPTY_BOOLEAN_ARRAY for an empty array, return null for null array.","1. One-line summary: Converts a Boolean array to a boolean array.
2. Function behavior: Transforms a Boolean array to a primitive boolean array, returning null for null input or an empty array for empty input.
3. Function signature: @param array Boolean[]: Array of Boolean objects
@return boolean[]: Array of primitive boolean values
4. Examples: [true, false, true] -> [true, false, true] (convert to primitives) null -> null (returns null for null input) [] -> [] (returns empty array for empty input)
5. Preconditions & Postconditions: Input can be null or empty, output will match nullability and emptiness of input while converting values."
6367672d1a6d9265ec017c73,shouldPrintMessage,"public boolean shouldPrintMessage(int timestamp,String message){
  if (messages.containsKey(message)) {
    if (timestamp - messages.get(message) >= 10) {
      messages.put(message,timestamp);
      return true;
    }
 else {
      return false;
    }
  }
 else {
    messages.put(message,timestamp);
    return true;
  }
}
","/** 
 * Returns true if the message should be printed in the given timestamp, otherwise returns false. If this method returns false, the message will not be printed. The timestamp is in seconds granularity. 
 */
"," If the message does not exist in the dict messages, or it exists but the timestamp (seconds) difference is bigger than 10, put the message and timestamp into messages and return true, otherwise return false.","1. One-line summary: Checks if a message should be printed based on timestamp criteria.
2. Function behavior: Determines if a message can be printed based on whether it has been logged within the last 10 seconds. Updates the message timestamp if it can be printed.
3. Function signature:
@param timestamp int: The time at which the message is attempted to be printed.
@param message String: The message to be potentially printed.
@return boolean: Returns true if the message should be printed, false otherwise.
4. Examples: 
(10, ""foo"") -> true (First time message)
(15, ""foo"") -> false (Within 10 seconds of last print)
(22, ""foo"") -> true (After 10 seconds of last print)
5. Preconditions & Postconditions: Messages are checked against a timestamp map to see if they were logged in the last 10 seconds; timestamps are updated if printed."
636766f81a6d9265ec01775c,toString,"public static String toString(Object obj){
  return obj == null ? """" : obj.toString();
}
","/** 
 * <p>Gets the <code>toString</code> of an <code>Object</code> returning an empty string ("""") if <code>null</code> input.</p> <pre> ObjectUtils.toString(null)         = """" ObjectUtils.toString("""")           = """" ObjectUtils.toString(""bat"")        = ""bat"" ObjectUtils.toString(Boolean.TRUE) = ""true"" </pre>
 * @see StringUtils#defaultString(String)
 * @see String#valueOf(Object)
 * @param obj  the Object to <code>toString</code>, may be null
 * @return the passed in Object's toString, or nullStr if <code>null</code> input
 * @since 2.0
 */
","Return the string representation of the given object, return an empty string if the object is null.","1. One-line summary: Returns object's string representation or empty string if null.
2. Function behavior: Converts an object to its string representation using `toString()` method. Returns an empty string if the object is null.
3. Function signature:
   @param obj Object: The object to convert to a string.
   @return String: The string representation of the object or an empty string for null objects.
4. Examples: 
   null -> """" (null object returns empty string)
   ""Hello"" -> ""Hello"" (string object returns itself)
   new Integer(5) -> ""5"" (integer object returns its string representation)
5. Preconditions & Postconditions: Accepts any object type, returns a string. Will not throw exceptions or modify the input object."
6367667f1a6d9265ec017457,decodeOctets,"private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){
  if (bb.limit() == 1 && (bb.get(0) & 0xFF) < 0x80) {
    sb.append((char)bb.get(0));
    return i + 2;
  }
 else {
    CharBuffer cb=UTF_8_CHARSET.decode(bb);
    sb.append(cb);
    return i + bb.limit() * 3 - 1;
  }
}
","/** 
 * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.
 * @return the index to the next unchecked character in the string to decode
 */
","Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.","1. One-line summary: Decode and append bytes to a StringBuilder.
2. Function behavior: The function reads bytes from ByteBuffer, decodes them as a UTF-8 string, appends the result to StringBuilder, and returns an incremented index based on the byte sequence length.
3. Function signature: 
@param i int: The initial index.
@param bb ByteBuffer: The byte buffer containing octets.
@param sb StringBuilder: The StringBuilder to append decoded characters.
@return int: The updated index after decoding.
4. Examples: 
1 byte with value < 0x80 -> index+2 (decoded single byte)
Multiple bytes -> index + bytes_count*3 - 1 (decoded multiple bytes)
5. Preconditions & Postconditions: ByteBuffer contains valid UTF-8 encoding, CharBuffer decoding must succeed."
636766aa1a6d9265ec0175ce,visitFrameStart,"int visitFrameStart(final int offset,final int numLocal,final int numStack){
  int frameLength=3 + numLocal + numStack;
  if (currentFrame == null || currentFrame.length < frameLength) {
    currentFrame=new int[frameLength];
  }
  currentFrame[0]=offset;
  currentFrame[1]=numLocal;
  currentFrame[2]=numStack;
  return 3;
}
","/** 
 * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}.
 * @param offset   the bytecode offset of the instruction to which the frame corresponds.
 * @param numLocal the number of local variables in the frame.
 * @param numStack the number of stack elements in the frame.
 * @return the index of the next element to be written in this frame.
 */
","Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.","1. One-line summary: Initializes or resizes an integer array for frame data.
2. Function behavior: Allocates or resets currentFrame to store offset, numLocal, and numStack values, storing them at specified indices.
3. Function signature:
@param offset int: Frame offset.
@param numLocal int: Number of local variables.
@param numStack int: Number of stack elements.
@return int: Always returns 3.
4. Examples: 5, 2, 3 -> 3 (Initializes currentFrame array of length 8 with given values) 10, 0, 5 -> 3 (Initializes currentFrame array of length 8 with given values) 0, 3, 4 -> 3 (Initializes currentFrame array of length 10 with given values)
5. Preconditions & Postconditions: Preconditions: numLocal and numStack are non-negative. Postconditions: currentFrame is initialized or resized to correctly hold the frame data."
636767191a6d9265ec017c0f,enlarge,"private void enlarge(final int size){
  int doubleCapacity=2 * data.length;
  int minimalCapacity=length + size;
  byte[] newData=new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];
  System.arraycopy(data,0,newData,0,length);
  data=newData;
}
","/** 
 * Enlarges this byte vector so that it can receive 'size' more bytes.
 * @param size number of additional bytes that this byte vector should be able to receive.
 */
","Enlarge the byte vector data, by increasing it by the given size.","1. One-line summary: Enlarges byte array to accommodate additional size.
2. Function behavior: Creates a new byte array with a size that is either double the original or large enough to fit the current data plus an additional size. Copies existing data to the new array and updates the reference.
3. Function signature: @param size int: The additional capacity needed.
4. Examples: data length = 10, size = 5 -> new array of size 20 (capacity doubled) data length = 10, size = 15 -> new array of size 25 (capacity based on minimal need) 
5. Preconditions & Postconditions: Preconditions: 'data' must be a valid byte array; 'length' is the current data size. Postconditions: 'data' has been enlarged to accommodate additional elements."
636767821a6d9265ec0183a0,deleteFile,"protected static void deleteFile(String fileName){
  File file=new File(fileName);
  if (file.exists()) {
    file.delete();
  }
}
","/** 
 * Delete's the specified file if it exists 
 */
",Delete the given file if it exists,"1. One-line summary: Deletes a file if it exists.
2. Function behavior: The function checks if a file with the given name exists and deletes it if present.
3. Function signature: 
   @param fileName String: The name of the file to be deleted.
4. Examples: 
   ""test.txt"" -> null (Deletes ""test.txt"" if it exists)
   ""nonexistent.txt"" -> null (Does nothing if ""nonexistent.txt"" doesn't exist)
   ""/path/to/file.txt"" -> null (Deletes the file at specified path if it exists)
5. Preconditions & Postconditions: The file must be present for deletion; after execution, the file is either deleted or remains unchanged if it doesnâ€™t exist."
636767691a6d9265ec0181aa,nullSafeHashCode,"public static int nullSafeHashCode(long[] array){
  if (array == null) {
    return 0;
  }
  int hash=INITIAL_HASH;
  int arraySize=array.length;
  for (int i=0; i < arraySize; i++) {
    hash=MULTIPLIER * hash + hashCode(array[i]);
  }
  return hash;
}
","/** 
 * Return a hash code based on the contents of the specified array. If <code>array</code> is <code>null</code>, this method returns 0.
 * @param array the long array to obtain a hashcode
 * @return the long array's hashcode, which could be 0 if the array is null.
 */
","Compute the hash code of the whole array, by accumulating the multiplication of each element hash code and the  MULTIPLIER.","1. One-line summary: Computes the hash code for a long array, handling null safely.
2. Function behavior: Calculates a combined hash code for all elements in the array or returns 0 if the array is null.
3. Function signature: 
@param array long[]: The array to compute the hash code for.
@return int: The computed hash code or 0 if the array is null.
4. Examples: null -> 0 (array is null) [1, 2, 3] -> someHash (combines hashes) [] -> anotherHash (empty array)
5. Preconditions & Postconditions: Array may be null, result is integer hash code, 0 if null."
636767441a6d9265ec017cc1,rotateRight,"private TreeNode<T> rotateRight(TreeNode<T> node){
  TreeNode<T> left=node.left;
  left.parent=null;
  node.setLeftChild(left.right);
  left.setRightChild(node);
  node.updateHeightAndSubtreeSize();
  left.updateHeightAndSubtreeSize();
  return left;
}
","/** 
 * Performs a right node rotation.
 * @param node a node to rotate
 * @return a new parent of the {@code node}
 */
",Perform a right node rotation on the AVL tree.,"1. One-line summary: Performs a right rotation on a binary tree node.
2. Function behavior: The function rotates the subtree rooted at the input node to the right by making its left child the new root of the subtree and updates the heights and sizes of the involved nodes.
3. Function signature: 
   @return TreeNode<T>: The new root of the rotated subtree.
4. Examples: 
   node with left child -> left child becomes new root (tree rotates right)
   node without left child -> unchanged (rotation not possible)
5. Preconditions & Postconditions: Input node must have a non-null left child; tree structure and properties adjusted after rotation."
6367677e1a6d9265ec01830f,format,"public String format(LoggingEvent event){
  if (sbuf.capacity() > MAX_CAPACITY) {
    sbuf=new StringBuffer(BUF_SIZE);
  }
 else {
    sbuf.setLength(0);
  }
  PatternConverter c=head;
  while (c != null) {
    c.format(sbuf,event);
    c=c.next;
  }
  return sbuf.toString();
}
","/** 
 * Produces a formatted string as specified by the conversion pattern.
 */
","Format the buffered string with the pattern converter, and return the result.","1. One-line summary: Formats a logging event into a string.
2. Function behavior: The function uses a buffer to construct a formatted string representation of a logging event by utilizing a pattern converter chain. The buffer is reset or recreated based on its capacity before formatting.
3. Function signature: 
   @param event LoggingEvent: The logging event to format.
   @return String: The formatted string representation of the logging event.
4. Examples: event with info level -> ""[INFO] log message"" (formats an info level event) Event with error level -> ""[ERROR] log message"" (formats an error level event) Empty event -> """" (handles an empty event gracefully)
5. Preconditions & Postconditions: Preconditions include a valid LoggingEvent and initialized PatternConverter chain, while postconditions ensure the buffer is appropriately reset and contains the formatted event string."
636767031a6d9265ec0178dd,contentLength,"public long contentLength(){
  long size;
  try {
    size=Long.parseLong(request.getHeader(FileUpload.CONTENT_LENGTH));
  }
 catch (  NumberFormatException e) {
    size=request.getContentLength();
  }
  return size;
}
","/** 
 * Retrieve the content length of the request.
 * @return The content length of the request.
 * @since 1.3
 */
","Compute and return the length of the request content header, return the content length if NumberFormatException happens.","1. One-line summary: Returns the content length from request headers.
2. Function behavior: Attempts to get content length from the specified header, defaults to request's content length on failure.
3. Function signature: 
@return long: Content length of the request.
4. Examples: 
Header value ""1024"" -> 1024 (Parsed header value)
Header value ""invalid"" -> request.getContentLength() (Fallback to request method on parse failure)
Header absent -> request.getContentLength() (Fallback to request method on header absence)
5. Preconditions & Postconditions: Precondition: Request contains a potential content length value. Postcondition: Returns content length as long."
636766f11a6d9265ec017658,indexOfLastSeparator,"public static int indexOfLastSeparator(String filename){
  if (filename == null) {
    return -1;
  }
  int lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);
  int lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);
  return Math.max(lastUnixPos,lastWindowsPos);
}
","/** 
 * Returns the index of the last directory separator character. <p> This method will handle a file in either Unix or Windows format. The position of the last forward or backslash is returned. <p> The output will be the same irrespective of the machine that the code is running on.
 * @param filename  the filename to find the last path separator in, null returns -1
 * @return the index of the last separator character, or -1 if thereis no such character
 */
","Return the index of the last directory separator character, under Unix or Windows.","1. One-line summary: Finds the last occurrence of a path separator in a filename.
2. Function behavior: The function returns the last position of either a Unix or Windows separator in the given filename. If the filename is null, it returns -1.
3. Function signature: 
   @param filename String: Input filename to analyze.
   @return int: Index of the last separator or -1 if none or input is null.
4. Examples: 
   ""file/path/to/file.txt"" -> 8 (Last '/' at position 8)
   ""C:\\path\\to\\file.txt"" -> 11 (Last '\' at position 11)
   null -> -1 (Filename is null)
5. Preconditions & Postconditions: The filename can be null or any string. The return value is the index of the last separator or -1 if none is found or the filename is null."
636767121a6d9265ec017b0a,parseEndOfLine,"private int parseEndOfLine(String headerPart,int end){
  int index=end;
  for (; ; ) {
    int offset=headerPart.indexOf('\r',index);
    if (offset == -1 || offset + 1 >= headerPart.length()) {
      throw new IllegalStateException(""Expected headers to be terminated by an empty line."");
    }
    if (headerPart.charAt(offset + 1) == '\n') {
      return offset;
    }
    index=offset + 1;
  }
}
","/** 
 * Skips bytes until the end of the current line.
 * @param headerPart The headers, which are being parsed.
 * @param end Index of the last byte, which has yet been processed.
 * @return Index of the \r\n sequence, which indicates end of line.
 */
",Parse the header part starting from the given end position and return the index of the enter sequence. ,"1. One-line summary: Finds the position of a carriage return followed by a newline.  
2. Function behavior: The function scans a string to find a '\r\n' sequence starting from a given index and returns the position of the '\r'.  
3. Function signature: 
   @param headerPart String: Header content to be examined  
   @return int: Index of '\r' in the '\r\n' sequence  
   @throws IllegalStateException: If the expected new line after '\r' is not found  
4. Examples:  
   ""abc\r\ndef"", 0 -> 3 (finds '\r' at index 3)  
   ""abc\rghi"", 0 -> Exception (no '\n' after '\r')  
5. Preconditions & Postconditions: Requires '\r\n' sequence in the input; ensures valid index or exception if not found."
636766f61a6d9265ec017701,lastIndexOf,"public static int lastIndexOf(String str,String searchStr){
  if (StringUtils.isEmpty(str)) {
    return StringUtils.INDEX_NOT_FOUND;
  }
  return str.lastIndexOf(searchStr);
}
","/** 
 * Finds the last index within a String, handling <code>null</code>. This method uses  {@link String#lastIndexOf(String)}. 
 */
","Find the last index of the searchStr in str, and return INDEXNOTFOUND if str is empty.","1. One-line summary: Finds the last index of a substring.
2. Function behavior: Returns the last index of the search string in the given string or -1 if not found or if the string is empty.
3. Function signature:
@param str String: The main string to search within.
@param searchStr String: The substring to find.
@return int: The last index of the search string or -1 if not found.
4. Examples: 
""hello"", ""l"" -> 3 (last occurrence of 'l')
""hello"", ""x"" -> -1 (not found)
"""", ""any"" -> -1 (empty main string)
5. Preconditions & Postconditions: Input strings must not be null. The function returns the last index found or -1 if not found."
6367670b1a6d9265ec0179fe,write,"@Override public void write(byte b[]) throws IOException {
  checkThreshold(b.length);
  getStream().write(b);
  written+=b.length;
}
","/** 
 * Writes <code>b.length</code> bytes from the specified byte array to this output stream.
 * @param b The array of bytes to be written.
 * @exception IOException if an error occurs.
 */
",Write the given byte array b into the output stream that this class represents.,"1. One-line summary: A function to write data to a stream.
2. Function behavior: Writes the byte array to an output stream after checking if a size threshold is met. Updates a 'written' counter with the number of bytes written.
3. Function signature: 
   @param b byte[]: Data to be written
   @throws IOException: If an I/O error occurs
4. Examples: 
   byte[]{1, 2, 3} -> writes 3 bytes (if threshold allows)
   byte[]{} -> writes 0 bytes (empty array)
5. Preconditions & Postconditions: Preconditions: A valid byte array is provided, and the stream is open. Postconditions: Data is written to the stream, and 'written' is updated."
636767df1a6d9265ec01873c,id,"public String id(String entityId){
  if (entityId == null) {
    return String.valueOf(point);
  }
 else {
    return point + Const.ID_CONNECTOR + entityId;
  }
}
","/** 
 * @return the row id
 */
",Return the id by concatenating the point and the entity id with id connector.,"1. One-line summary: Joins a point with entityId using a connector or returns the point.
2. Function behavior: Returns a string combining point and entityId with a connector if entityId is not null; otherwise, returns point.
3. Function signature: 
@return String: Resulting concatenated or solo string based on the input.
4. Examples: 
null -> ""point_value"" (returns point)
""123"" -> ""point_value-CONNECTOR-123"" (combines point and entityId)
"""" -> ""point_value-CONNECTOR-"" (combines point and empty entityId)
5. Preconditions & Postconditions: entityId may be null; output will have the structure point or point-CONNECTOR-entityId."
636766f91a6d9265ec01777f,toBoolean,"public static boolean toBoolean(Boolean bool){
  if (bool == null) {
    return false;
  }
  return bool.booleanValue() ? true : false;
}
","/** 
 * <p>Converts a Boolean to a boolean handling <code>null</code> by returning <code>false</code>.</p> <pre> BooleanUtils.toBoolean(Boolean.TRUE)  = true BooleanUtils.toBoolean(Boolean.FALSE) = false BooleanUtils.toBoolean(null)          = false </pre>
 * @param bool  the boolean to convert
 * @return <code>true</code> or <code>false</code>, <code>null</code> returns <code>false</code>
 */
",Convert a Boolean to a boolean handling null by returning false.,"1. One-line summary: Converts a Boolean object to a primitive boolean.
2. Function behavior: Returns false for null values, otherwise returns the boolean value of the Boolean object.
3. Function signature: 
   @param bool Boolean: a Boolean object that may be null
   @return boolean: the primitive boolean value, or false if null
4. Examples: 
   true -> true (Boolean true returns true)
   false -> false (Boolean false returns false)
   null -> false (Null returns false)
5. Preconditions & Postconditions: Accepts a Boolean object or null, returns a primitive boolean value."
6367675f1a6d9265ec0180d3,identity,"public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){
  Map<V,V> fMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());
  Map<V,V> bMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());
  for (  V v : graph.vertexSet()) {
    fMap.put(v,v);
    bMap.put(v,v);
  }
  return new IsomorphicGraphMapping<>(fMap,bMap,graph,graph);
}
","/** 
 * Computes an identity automorphism (i.e. a self-mapping of a graph in which each vertex also maps to itself).
 * @param graph the input graph
 * @param < V > the graph vertex type
 * @param < E > the graph edge type
 * @return a mapping from graph to graph
 */
",Compute and return an identity automorphism for the given graph.,"1. One-line summary: Creates an isomorphic mapping of a graph to itself.
2. Function behavior: The function creates a mapping where each vertex in the graph maps to itself, establishing an identity isomorphism.
3. Function signature: 
   @param <V> : Vertex type
   @param <E> : Edge type
   @return IsomorphicGraphMapping<V,E>: Isomorphic mapping of the graph to itself
4. Examples: graph with vertices {A, B, C} -> identity mapping (each vertex maps to itself)
5. Preconditions & Postconditions: The graph must not be null; the function returns an identity mapping of the graph."
636766ff1a6d9265ec017851,findByte,"protected int findByte(byte value,int pos){
  for (int i=pos; i < tail; i++) {
    if (buffer[i] == value) {
      return i;
    }
  }
  return -1;
}
","/** 
 * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.
 * @param value The value to find.
 * @param pos   The starting position for searching.
 * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.
 */
","Searche for a byte of the specified value in the buffer, starting at the specified position.","1. One-line summary: Returns the index of a specified byte in a buffer starting from a given position.
2. Function behavior: The function searches for the byte value in the buffer array starting at index pos and returns the index if found, else returns -1.
3. Function signature:
@param value byte: the byte value to search for
@param pos int: the starting position for the search
@return int: the index of the byte if found, otherwise -1
4. Examples: 
value=5, pos=0, buffer=[1,2,5,3], tail=4 -> 2 (found at index 2)
value=7, pos=1, buffer=[8,7,6,7], tail=4 -> 1 (found at index 1)
value=2, pos=3, buffer=[9,2,4,5], tail=4 -> -1 (not found)
5. Preconditions & Postconditions: pos must be non-negative and less than or equal to tail; if the value is found, its index is returned, otherwise -1 is returned."
636767a41a6d9265ec018582,writeDelimitedTo,"public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {
  if (buffer.start != buffer.offset)   throw new IllegalArgumentException(""Buffer previously used and had not been reset."");
  final ProtobufOutput output=new ProtobufOutput(buffer);
  schema.writeTo(output,message);
  final int size=output.getSize();
  ProtobufOutput.writeRawVarInt32Bytes(out,size);
  final int msgSize=LinkedBuffer.writeTo(out,buffer);
  assert size == msgSize;
  return size;
}
","/** 
 * Serializes the  {@code message}, prefixed with its length, into an  {@link OutputStream}.
 * @return the size of the message
 */
","Use ProtobufOutput and the LinkedBuffer to write the message into the given OutputStream out, and return the message size.","1. One-line summary: Writes a serialized message with a header to an OutputStream.
2. Function behavior: Serializes a message using a schema and writes it to an output stream with a header representing the message's size.
3. Function signature: 
   @param out OutputStream: The output stream to write the serialized data.
   @param message T: The message to be serialized.
   @param schema Schema<T>: The schema used for message serialization.
   @param buffer LinkedBuffer: The buffer used for holding serialized data.
   @return int: The size of the serialized message.
   @throws IOException: If an I/O error occurs.
4. Examples: 
   out, message, schema, buffer -> size (writes message to output)
   out, null, schema, buffer -> exception (null message case)
   out, message, null, buffer -> exception (null schema case)
5. Preconditions & Postconditions: Buffer must be reset before use; function writes size-prefixed serialized message to stream."
636766821a6d9265ec0174b6,resolveArguments,"public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){
  Class<?>[] result=null;
  if (genericType instanceof ParameterizedType) {
    ParameterizedType paramType=(ParameterizedType)genericType;
    Type[] arguments=paramType.getActualTypeArguments();
    result=new Class[arguments.length];
    for (int i=0; i < arguments.length; i++)     result[i]=resolveClass(arguments[i],targetType);
  }
 else   if (genericType instanceof TypeVariable) {
    result=new Class[1];
    result[0]=resolveClass(genericType,targetType);
  }
  return result;
}
","/** 
 * Resolves the arguments for the  {@code genericType} using the type variable information for the{@code targetType}. Returns  {@code null} if {@code genericType} is not parameterized or ifarguments cannot be resolved.
 */
",Resolve and return the arguments for the genericType using the type variable information for the targetType. Returns null if  genericType is not parameterized or if arguments cannot be resolved.,"1. One-line summary: Resolves generic type arguments to their class types.
2. Function behavior: The function converts a generic type to an array of Class objects representing the resolved types, using the target type for context.
3. Function signature:
@param genericType Type: the generic type to resolve
@param targetType Class<?>: the target class for resolving types
@return Class<?>[]: an array of resolved class types
4. Examples: List<String> -> [String] (resolves List type argument) Map<K,V> -> [K, V] (resolves Map type arguments) T extends Number -> [Number] (resolves type variable)
5. Preconditions & Postconditions: Input types must be valid and compatible, results may be null if input isn't parameterized or a type variable."
636767e11a6d9265ec018781,accept,"@Override public void accept(final METRICS data){
  final String id=data.id();
  final METRICS existed=buffer.get(id);
  if (existed == null) {
    buffer.put(id,data);
  }
 else {
    final boolean isAbandoned=!existed.combine(data);
    if (isAbandoned) {
      buffer.remove(id);
    }
  }
}
","/** 
 * Accept the data into the cache and merge with the existing value. This method is not thread safe, should avoid concurrency calling.
 * @param data to be added potentially.
 */
","Accept the data into the buffer if its id does not exist in the buffer. Otherwise try to combine it with the existing value, and remove it if the combined is abandoned.","1. One-line summary: Update or remove METRICS data in a buffer.
2. Function behavior: The function checks if METRICS data already exists in the buffer, adds it if not, or combines it if it does; it removes the data if it's flagged as abandoned.
3. Function signature: 
   @param data METRICS: The METRICS object to be processed.
4. Examples: 
   new data -> buffer updated (Data added when new)
   repeat data, not combined -> buffer unchanged (Data exists and combined)
   repeat data, combined, abandoned -> buffer updated (Data removed when abandoned)
5. Preconditions & Postconditions: Assumes `data` implements `combine` method and `buffer` supports put, get, remove operations, ensures buffer consistently represents current METRICS state."
636766f11a6d9265ec017641,available,"@Override public int available() throws IOException {
  return this.index < this.length ? this.length - this.index : this.length >= 0 && this.reader.ready() ? 1 : 0;
}
","/** 
 * @see InputStream#available() 
 */
",Check the available space of this InputStream according to the index.,"1. One-line summary: Returns number of bytes available in stream without blocking.
2. Function behavior: The function checks if there are remaining bytes to read; otherwise, it verifies if the underlying reader is ready to provide more data.
3. Function signature:
@return int: Number of bytes available or a readiness indication.
@throws IOException: If an I/O error occurs.
4. Examples: index=2, length=5, reader.ready()=false -> 3 (5 - 2 means 3 bytes available) index=5, length=5, reader.ready()=true -> 1 (index=length, but reader is ready) index=5, length=5, reader.ready()=false -> 0 (no bytes available, reader not ready)
5. Preconditions & Postconditions: The stream has a defined length and index; returns available bytes or readiness check result; may throw IOException."
636767dd1a6d9265ec0186e5,addNewTarget,"public void addNewTarget(Channels channels,IConsumer consumer){
  Group group=new Group(channels,consumer);
  ArrayList<Group> newList=new ArrayList<Group>();
  for (  Group target : consumeTargets) {
    newList.add(target);
  }
  newList.add(group);
  consumeTargets=newList;
  size+=channels.size();
}
","/** 
 * Add a new target channels.
 */
",Add the given target channels to the consumeTargets.,"1. One-line summary: Adds a new target to the existing list of consume targets.
2. Function behavior: Creates a new Group object using provided channels and consumer, adds it to a list, and updates consumeTargets.
3. Function signature: 
   @param channels Channels: Channels instance for group.
   @param consumer IConsumer: Consumer instance for group.
4. Examples: 
   addNewTarget(ch1, cons1) -> adds group to consumeTargets (adds ch1, cons1 to list)
5. Preconditions & Postconditions: List of consumeTargets must be iterable, increased by one Group object after the function executes."
636767871a6d9265ec01846d,createConfigurationDirectory,"public static void createConfigurationDirectory(){
  String home=System.getProperty(""user.home"");
  String sep=System.getProperty(""file.separator"");
  File f=new File(home + sep + ""lf5"");
  if (!f.exists()) {
    try {
      f.mkdir();
    }
 catch (    SecurityException e) {
      e.printStackTrace();
    }
  }
}
","/** 
 * Creates the directory where the MRU file list will be written. The ""lf5"" directory is created in the Documents and Settings directory on Windows 2000 machines and where ever the user.home variable points on all other platforms.
 */
","Create the ""lf5"" directory in the Documents and Settings directory on Windows machines, or the user.home variable points on all other platforms.","1. One-line summary: Creates a directory named ""lf5"" in the user's home directory.
2. Function behavior: Checks if the ""lf5"" directory exists in the user's home directory and creates it if it doesn't. Handles security exceptions if directory creation is restricted.
3. Function signature: @throws SecurityException: If the directory cannot be created due to security restrictions.
4. Examples: Home directory doesn't have ""lf5"" -> Directory ""lf5"" created Home directory has ""lf5"" -> No action taken Directory creation security issue -> Security exception stack trace
5. Preconditions & Postconditions: Preconditions: The file system supports directory creation; Postconditions: A ""lf5"" directory exists in the user's home directory if it was initially absent."
636766f81a6d9265ec01775b,readLong,"public long readLong(final int offset){
  long l1=readInt(offset);
  long l0=readInt(offset + 4) & 0xFFFFFFFFL;
  return (l1 << 32) | l0;
}
","/** 
 * Reads a signed long value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
 * @param offset the start offset of the value to be read in this {@link ClassReader}.
 * @return the read value.
 */
",Read a signed long value.,"1. One-line summary: Concatenates two int values to form a long.
2. Function behavior: This function reads two 32-bit integers from a specified offset in memory, combines them into a 64-bit long value, and returns it. The first integer is the most significant, and the second is the least significant part.
3. Function signature: 
@param offset int: The starting position to read from memory.
@return long: The combined 64-bit long value created from two 32-bit integers.
4. Examples: 
8 -> 34359738368 (two 32-bit ints are combined)
0 -> 1234567890123 (example for non-zero result)
12 -> 0 (zero case result)
5. Preconditions & Postconditions: Offset should be within bounds of addressable memory, and two 32-bit integers will be correctly combined into one 64-bit long."
636767a51a6d9265ec01859d,equals,"public boolean equals(final byte[] data,int offset,final int len){
  final byte[] bytes=this.bytes;
  if (len != bytes.length)   return false;
  for (int i=0; i < len; ) {
    if (bytes[i++] != data[offset++]) {
      return false;
    }
  }
  return true;
}
","/** 
 * Returns true if the contents of the internal array and the provided array match.
 */
",Return true if the contents of the internal array bytes and the provided array data match.,"1. One-line summary: Compares a subarray of bytes with an instance array.
2. Function behavior: The function checks if a segment of the input array `data`, starting at `offset` and of length `len`, matches the instance byte array.
3. Function signature:
@param data byte[]: Array to compare with instance.
@param offset int: Starting index in data for comparison.
@param len int: Length of subarray in data to compare.
@return boolean: True if the specified segment of data equals the instance array, false otherwise.
4. Examples: [1,2,3], 0, 3 -> true (exact match)
[1,2,3,4], 1, 3 -> false (wrong length)
[1,2,4], 0, 3 -> false (different bytes)
5. Preconditions & Postconditions: The length of `bytes` must equal `len`, and `offset+len` must be within the bounds of `data`. The method returns true only if the specified segment matches `bytes`."
6367670b1a6d9265ec0179ff,nullToEmpty,"public static Byte[] nullToEmpty(final Byte[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
",Return an EMPTY_BYTE_OBJECT_ARRAY array for a null or empty input array.,"1. One-line summary: Converts null or empty Byte arrays to a predefined empty array.
2. Function behavior: The function returns a predefined empty Byte array if the input array is null or empty, otherwise it returns the original array.
3. Function signature:
@return Byte[]: Returns a non-null Byte array.
4. Examples: null -> predefined empty array (null case) [] -> predefined empty array (empty case) [1, 2, 3] -> [1, 2, 3] (non-empty case)
5. Preconditions & Postconditions: Input can be null or an array of any length. Output is always a non-null Byte array."
6367677f1a6d9265ec018347,send,"public synchronized void send(final String message){
  Iterator ce=connections.iterator();
  for (Iterator e=writers.iterator(); e.hasNext(); ) {
    ce.next();
    PrintWriter writer=(PrintWriter)e.next();
    writer.print(message);
    if (writer.checkError()) {
      ce.remove();
      e.remove();
    }
  }
}
","/** 
 * sends a message to each of the clients in telnet-friendly output. 
 */
",Send a message to each of the connections in telnet-friendly output. ,"1. One-line summary: Sends a message to all active connections.
2. Function behavior: Iterates through writers to send a message, removing those with errors from the list.
3. Function signature: 
   @param message String: The message to send to each connection.
4. Examples: ""Hello"" -> Messages sent (sends ""Hello"" to all connections) ""Test"" -> Errors checked (removes connections if errors detected) ""Update"" -> Connections cleaned (updates connections list)
5. Preconditions & Postconditions: Message is sent to connections; connections with errors are removed. Connections must be iterable and allow removal during iteration."
6367670a1a6d9265ec0179e8,nullToEmpty,"public static Boolean[] nullToEmpty(final Boolean[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
",Return an EMPTY_BOOLEAN_OBJECT_ARRAY array for a null or empty input array.,"1. One-line summary: Returns an empty Boolean array if input is null or empty.
2. Function behavior: If the input array is null or has no elements, it returns a constant empty Boolean array. Otherwise, it returns the original array.
3. Function signature: 
   @param array Boolean[]: input array of Boolean objects
   @return Boolean[]: empty array if input is null or empty, else original array
4. Examples: 
   null -> []
   [] -> [] 
   [true, false] -> [true, false]
5. Preconditions & Postconditions: Input can be null or an array; output is empty if input is null/empty, unchanged otherwise."
6367677f1a6d9265ec01834b,put,"public void put(LoggingEvent o){
  if (numElements != maxSize) {
    buf[next]=o;
    if (++next == maxSize) {
      next=0;
    }
    numElements++;
  }
}
","/** 
 * Place a  {@link LoggingEvent} in the buffer. If the buffer is fullthen the event is <b>silently dropped</b>. It is the caller's responsability to make sure that the buffer has free space.  
 */
",Place a  LoggingEvent in the buffer buf.,"1. One-line summary: Inserts a LoggingEvent into a circular buffer.
2. Function behavior: Adds a LoggingEvent to the next position if the buffer is not full and updates indices. No action if the buffer is full.
3. Function signature: 
   @param o LoggingEvent: The event to be logged into the buffer.
4. Examples: 
   empty buffer, event -> event added at position 0 (position increments, numElements increments)
   full buffer, event -> no change (buffer remains full)
   50% full buffer, event -> event added to next position (position and numElements increment)
5. Preconditions & Postconditions: Buffer has a fixed size, elements are added if space is available; buffer indices and element count are maintained."
636767df1a6d9265ec018744,buildTimeRanges,"protected List<TimeRange> buildTimeRanges(long start,long end){
  if (start >= end) {
    return null;
  }
  end+=1;
  final List<TimeRange> timeRanges=new ArrayList<>();
  do {
    long batchEnd=Math.min(start + FETCH_DATA_DURATION,end);
    timeRanges.add(new TimeRange(start,batchEnd));
    start=batchEnd;
  }
 while (start < end);
  return timeRanges;
}
","/** 
 * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}
 */
",Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.,"1. One-line summary: Splits a time range into smaller ranges based on a constant duration.
2. Function behavior: Divides a start-to-end time range into smaller ranges each with a maximum duration defined by FETCH_DATA_DURATION, returning a list of these ranges.
3. Function signature:
   @param start long: the start of the time range
   @param end long: the end of the time range
   @return List<TimeRange>: list of smaller time ranges
4. Examples: 100, 200 -> [TimeRange(100, 160), TimeRange(160, 201)] (time ranges split by FETCH_DATA_DURATION) 150, 150 -> null (start equals end, returns null) 80, 60 -> null (invalid range, start greater than end)
5. Preconditions & Postconditions: The start must be less than end to return a valid list, otherwise returns null. The list consists of TimeRanges each with a duration up to FETCH_DATA_DURATION."
636767031a6d9265ec0178e6,toPrimitive,"public static byte[] toPrimitive(final Byte[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_BYTE_ARRAY;
  }
  final byte[] result=new byte[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].byteValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Bytes to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Byte</code> array, may be <code>null</code>
 * @return a <code>byte</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Convert an array of object Bytes to primitives, return null for a null input array.","1. One-line summary: Converts an array of Byte objects to a primitive byte array.
2. Function behavior: The method checks for null and empty input, then iterates over an array of Byte objects and converts each element to its primitive byte value.
3. Function signature:
@param array Byte[]: Array containing Byte objects to convert
@return byte[]: Converted array of primitive byte values
4. Examples: null -> null (in case of null input), [] -> [] (empty array results in empty array), [Byte(1),Byte(2)] -> [1,2] (conversion from Byte objects to bytes)
5. Preconditions & Postconditions: Input may be null, output will be null if input is null; otherwise, output is a byte array of the same length as input."
636767dc1a6d9265ec0186be,compressTimeBucket,"static long compressTimeBucket(long timeBucket,int dayStep){
  if (dayStep > 1) {
    DateTime time=TIME_BUCKET_FORMATTER.parseDateTime("""" + timeBucket);
    int days=Days.daysBetween(DAY_ONE,time).getDays();
    int groupBucketOffset=days % dayStep;
    return Long.parseLong(time.minusDays(groupBucketOffset).toString(TIME_BUCKET_FORMATTER));
  }
 else {
    return timeBucket;
  }
}
","/** 
 * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123
 */
","Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.","1. One-line summary: Adjusts the given time bucket to align with a specified day step.
2. Function behavior: The function calculates a new time bucket by adjusting the input bucket back to the nearest multiple of the given day step. It returns the original bucket if the day step is 1.
3. Function signature: 
@param timeBucket long: The time bucket value to adjust.
@param dayStep int: The number of days defining the step for bucket alignment.
@return long: The adjusted time bucket.
@throws IllegalArgumentException: If parsing of the time bucket fails.
4. Examples: 20230101, 2 -> 20230101 (original value returned) 20230102, 2 -> 20230101 (adjusted to previous day step) 20230110, 3 -> 20230109 (adjusted by day step)
5. Preconditions & Postconditions: Input must be a valid time representation; output is a valid time bucket aligned to the nearest day step."
636767a41a6d9265ec01856c,computeUTF8Size,"public static int computeUTF8Size(final CharSequence str,final int index,final int len){
  int size=len;
  for (int i=index; i < len; i++) {
    final char c=str.charAt(i);
    if (c < 0x0080)     continue;
    if (c < 0x0800)     size++;
 else     size+=2;
  }
  return size;
}
","/** 
 * Computes the size of the utf8 string beginning at the specified  {@code index} with the specified {@code length}.
 */
",Compute the size of the utf8 string beginning at the specified  index  with the specified length.,"1. One-line summary: Calculates UTF-8 encoded size of a substring.
2. Function behavior: Computes the size in bytes of a Unicode string's UTF-8 encoding for a specified range. Applies size rules based on code points from index to len.
3. Function signature:
@param str CharSequence: Input string sequence
@param index int: Start index in the string
@param len int: Number of characters to process
@return int: UTF-8 encoded byte size
4. Examples:
""Hello"", 0, 5 -> 5 (All characters < 0x0080)
""Â©opyright"", 0, 9 -> 10 (Â© is > 0x0080 and < 0x0800)
""ðˆTest"", 0, 5 -> 10 (ðˆ needs 4 bytes)
5. Preconditions & Postconditions: The function assumes valid UTF-16 input and that range indices are within bounds. Always returns the byte size for UTF-8 encoding."
636766f01a6d9265ec017639,asList,"public static <T>List<T> asList(T[] a){
  if (a == null)   return Collections.emptyList();
  return Arrays.asList(a);
}
","/** 
 * Array to List. <p> Works like  {@link Arrays#asList(Object)}, but handles null arrays.
 * @return a list backed by the array.
 */
","Convert an array to list, return empty list for null array.","1. One-line summary: Converts an array to a list.
2. Function behavior: Converts a given array into a list. If the array is null, returns an empty list.
3. Function signature: 
   @param a T[]: The input array.
   @return List<T>: A list representing the elements of the array.
4. Examples: 
   asList(new String[]{""a"", ""b""}) -> [""a"", ""b""] (non-null array converted to list)
   asList(null) -> [] (null array results in an empty list)
5. Preconditions & Postconditions: Inputs potentially null; output list is based on array content or empty if null."
6367672d1a6d9265ec017c74,remove,"public boolean remove(int val){
  if (map.containsKey(val)) {
    map.remove(val);
    values.remove(values.indexOf(val));
    return true;
  }
  return false;
}
","/** 
 * Removes a value from the set. Returns true if the set contained the specified element. 
 */
","Remove a value from the values if the map keys contains the val. Returns true if actually removed, and false otherwise.","1. One-line summary: Removes a value from a map and list.
2. Function behavior: Checks if the value exists in the map, removes it from both the map and list if present, and returns true. Returns false if the value is not found.
3. Function signature: 
   @param val int: The value to be removed.
   @return boolean: True if the removal was successful, false otherwise.
4. Examples: 
   remove(5) -> true (5 is removed from both map and list)
   remove(10) -> false (10 does not exist)
   remove(-3) -> true (Negative value removal successful if present)
5. Preconditions & Postconditions: Map and list are non-null, removal updates both structures consistently."
6367676b1a6d9265ec0181df,startsWithIgnoreCase,"public static boolean startsWithIgnoreCase(String str,String prefix){
  if (str == null || prefix == null) {
    return false;
  }
  if (str.startsWith(prefix)) {
    return true;
  }
  if (str.length() < prefix.length()) {
    return false;
  }
  String lcStr=str.substring(0,prefix.length()).toLowerCase();
  String lcPrefix=prefix.toLowerCase();
  return lcStr.equals(lcPrefix);
}
","/** 
 * Returns  {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.
 * @param str the String to check
 * @param prefix the prefix to look for
 * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.
 * @see java.lang.String#startsWith
 */
","Return true if the given string starts with the specified case-insensitive prefix, false otherwise.","1. One-line summary: Case-insensitive prefix matching function.
2. Function behavior: Checks if a string starts with a given prefix, ignoring case. Ensures null inputs return false.
3. Function signature:
@param str String: The main string to check.
@param prefix String: The prefix to check against.
@return boolean: True if str starts with prefix ignoring case, false otherwise.
4. Examples: ""Hello"", ""he"" -> true (case ignored) ""Hello"", ""Ho"" -> false (different letters) ""test"", ""testers"" -> false (prefix longer)
5. Preconditions & Postconditions: Both inputs must be non-null for checking, returns false otherwise; handles case insensitivity."
636767001a6d9265ec017873,reverse,"public static String reverse(final String str){
  if (str == null) {
    return null;
  }
  return new StringBuilder(str).reverse().toString();
}
","/** 
 * <p>Reverses a String as per  {@link StringBuilder#reverse()}.</p> <p>A <code>null</code> String returns <code>null</code>.</p> <pre> StringUtils.reverse(null)  = null StringUtils.reverse("""")    = """" StringUtils.reverse(""bat"") = ""tab"" </pre>
 * @param str  the String to reverse, may be null
 * @return the reversed String, <code>null</code> if null String input
 */
",Reverse the given String as per.,"1. One-line summary: Reverses a string.
2. Function behavior: This function takes a string and returns a new string with the characters in reverse order. If the input string is null, it returns null.
3. Function signature:
   @param str String: The input string to be reversed
   @return String: The reversed string or null if the input is null
4. Examples: 
   ""hello"" -> ""olleh"" (reverses characters)
   ""12345"" -> ""54321"" (reverses numeric string)
   null -> null (null input returns null)
5. Preconditions & Postconditions: The function expects a string or null as input; it returns a reversed string or null if the input is null."
636766ff1a6d9265ec01783b,sub,"public static String sub(String str,int start,int end){
  return StringUtils.substring(str,start,end);
}
","/** 
 * Gets a substring from the specified String avoiding exceptions. 
 */
",Get a substring from the specified String avoiding exceptions. ,"1. One-line summary: Extracts a substring from the input string.
2. Function behavior: Returns a substring from the given `start` index to the `end` index, exclusive, using `StringUtils.substring`.
3. Function signature:
@param str String: the input string
@param start int: the starting index for the substring
@param end int: the ending index (exclusive) for the substring
@return String: the extracted substring
4. Examples: 
""hello"", 0, 2 -> ""he"" (extracts characters from index 0 to 1)
""world"", 1, 4 -> ""orl"" (extracts characters from index 1 to 3)
""java"", 2, 4 -> ""va"" (extracts characters from index 2 to 3)
5. Preconditions & Postconditions: The input indices should be within the bounds of the string, ensuring extracted substring exists, and original string remains unchanged."
6367671a1a6d9265ec017c15,putByteArray,"public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){
  if (length + byteLength > data.length) {
    enlarge(byteLength);
  }
  if (byteArrayValue != null) {
    System.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);
  }
  length+=byteLength;
  return this;
}
","/** 
 * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.
 * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.
 * @param byteOffset index of the first byte of byteArrayValue that must be copied.
 * @param byteLength number of bytes of byteArrayValue that must be copied.
 * @return this byte vector.
 */
","Put an array of bytes into this byte vector, enlarge the byte vector automatically if necessary.","1. One-line summary: Inserts a byte array into a ByteVector, enlarging if necessary.
2. Function behavior: Copies the specified segment of a byte array into the ByteVector's data array starting from the current length, enlarges the array if too small, then updates the length.
3. Function signature: 
@param byteArrayValue byte[]: the source byte array
@param byteOffset int: the starting offset in byteArrayValue
@param byteLength int: the number of bytes to insert
@return ByteVector: the modified ByteVector instance
4. Examples: 
(byte[], 0, 3) -> ByteVector instance (inserts first three bytes)
(byte[], 2, 2) -> ByteVector instance (inserts two bytes starting from index 2)
(null, 0, 0) -> ByteVector instance (no changes made)
5. Preconditions & Postconditions: Assumes data array has enough space or can be enlarged; modifies ByteVector and increases length by byteLength."
6367675c1a6d9265ec01805b,removeFromTreeEdgeList,"public void removeFromTreeEdgeList(){
  for (int dir=0; dir < 2; dir++) {
    if (prev[dir] != null) {
      prev[dir].next[dir]=next[dir];
    }
 else {
      head[1 - dir].first[dir]=next[dir];
    }
    if (next[dir] != null) {
      next[dir].prev[dir]=prev[dir];
    }
  }
  head[0]=head[1]=null;
}
","/** 
 * Removes this edge from both doubly linked lists of tree edges.
 */
",Remove this edge from both doubly linked lists of the tree edges.,"1. One-line summary: Removes the current node from a doubly-linked list that represents a tree edge list.
2. Function behavior: The function updates pointers to remove a node from a bidirectional structure by adjusting previous and next links in both directions.
3. Function signature: 
4. Examples: 
Node A with prev and next adjusted -> Node A removed from tree edge list (prev and next are rearranged)
Node B at the start -> Node B's next becomes the new head (start of list changes)
Node C at the end -> Node C's prev becomes new last (end of list changes)
5. Preconditions & Postconditions: The input structure is a valid doubly-linked list, and after execution, the list remains valid without the removed node."
636767791a6d9265ec01826d,findAndSubst,"public static String findAndSubst(String key,Properties props){
  String value=props.getProperty(key);
  if (value == null)   return null;
  try {
    return substVars(value,props);
  }
 catch (  IllegalArgumentException e) {
    LogLog.error(""Bad option value ["" + value + ""]."",e);
    return value;
  }
}
","/** 
 * Find the value corresponding to <code>key</code> in <code>props</code>. Then perform variable substitution on the found value.
 */
","Find the value corresponding to key in props, then perform variable substitution on the found value. Return the substitution result, or the value in case of exception. ","1. One-line summary: Substitute variables in a property value.
2. Function behavior: Retrieves a property by key, substitutes its variables, and returns the updated value. Logs an error and returns the original value on IllegalArgumentException.
3. Function signature: 
   @param key String: The key to look up in the properties.
   @param props Properties: The collection of key-value pairs where substitution will occur.
   @return String: The value with substituted variables or null if the key is not found.
4. Examples: 
   key=""path"", props={""path"":""${base}/dir"", ""base"":""/home""} -> ""/home/dir"" (substitution successful)
   key=""missing"", props={""path"":""${base}/dir""} -> null (key not found)
   key=""invalid"", props={""invalid"":""${foo""} -> ""${foo"" (invalid placeholder)
5. Preconditions & Postconditions: Keys and properties must be defined. The return is either a substituted string or original/nonexistent value."
636766fe1a6d9265ec017834,sessionId,"public static String sessionId(){
  HttpSession httpSession=servletSession();
  if (httpSession == null) {
    return null;
  }
  return httpSession.getId();
}
","/** 
 * Session ID. 
 */
",Return the servlet session id,"1. One-line summary: Retrieves the HTTP session ID.
2. Function behavior: Returns the ID of the current HTTP session if it exists, otherwise returns null.
3. Function signature: 
@return String: the session ID or null if no session exists.
4. Examples: 
sessionId() -> ""abc123"" (returns session ID if session exists)
sessionId() -> null (returns null if no session exists)
5. Preconditions & Postconditions: No session means the function returns null; otherwise, it provides a valid session ID."
636766ff1a6d9265ec01784b,isDigits,"public static boolean isDigits(String str){
  if ((str == null) || (str.length() == 0)) {
    return false;
  }
  for (int i=0; i < str.length(); i++) {
    if (!Character.isDigit(str.charAt(i))) {
      return false;
    }
  }
  return true;
}
","/** 
 * <p>Checks whether the <code>String</code> contains only digit characters.</p> <p><code>Null</code> and empty String will return <code>false</code>.</p>
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if str contains only unicode numeric
 */
","Check whether a character string is a dight. If yes, true is returned. Otherwise, false is returned.","1. One-line summary: Checks if a string contains only digits.  
2. Function behavior: Determines if a given string is solely composed of digit characters, returning false for null or empty strings.  
3. Function signature:  
@param str String: the string to be checked  
@return boolean: true if the string contains only digits, false otherwise  
4. Examples:  
""12345"" -> true (all digits)  
""abc123"" -> false (contains non-digit characters)  
"""" -> false (empty string)  
null -> false (null input)  
5. Preconditions & Postconditions: Input is a string, output is true if all characters are digits; false otherwise, including empty or null strings."
636766fc1a6d9265ec0177da,isParameterSeparator,"private static boolean isParameterSeparator(final char c){
  if (Character.isWhitespace(c)) {
    return true;
  }
  for (  char separator : PARAMETER_SEPARATORS) {
    if (c == separator) {
      return true;
    }
  }
  return false;
}
","/** 
 * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. 
 */
","Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.","1. One-line summary: Checks if a character is a parameter separator.
2. Function behavior: Determines if the character is whitespace or matches any character in PARAMETER_SEPARATORS.
3. Function signature: 
   @param c char: the character to check
   @return boolean: true if the character is a separator, otherwise false
4. Examples: 
   ' ' -> true (whitespace is a separator)
   ',' -> true (comma is a separator in PARAMETER_SEPARATORS)
   'a' -> false (letter is not a separator)
5. Preconditions & Postconditions: Only single characters are processed; returns a boolean indicating separator status."
6367670c1a6d9265ec017a35,endsWith,"private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){
  if (str == null || suffix == null) {
    return str == null && suffix == null;
  }
  if (suffix.length() > str.length()) {
    return false;
  }
  int strOffset=str.length() - suffix.length();
  return str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());
}
","/** 
 * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>
 * @see String#endsWith(String)
 * @param str  the String to check, may be null
 * @param suffix the suffix to find, may be null
 * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.
 * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>
 */
",Determines whether a character string ends with a specified suffix.,"1. One-line summary: Check if a string ends with a specific suffix.
2. Function behavior: Determines if the given string ends with the specified suffix, optionally ignoring case differences.
3. Function signature:
@param str String: The main string to check.
@param suffix String: The ending sequence to match.
@param ignoreCase boolean: Whether to ignore case differences in matching.
@return boolean: True if string ends with the suffix, considering case sensitivity.
4. Examples: ""hello"", ""lo"", false -> true (matches suffix exactly) ""hello"", ""LO"", true -> true (ignores case and matches) ""hello"", ""HE"", true -> false (suffix length mismatch)
5. Preconditions & Postconditions: Strings should not be null unless both are. Returns true if suffix length is not greater than string length and matches the end."
6367667f1a6d9265ec01745d,decodePath,"public static List<PathSegmentImpl> decodePath(URI u,boolean decode){
  String rawPath=u.getRawPath();
  if (rawPath != null && rawPath.length() > 0 && rawPath.charAt(0) == '/') {
    rawPath=rawPath.substring(1);
  }
  return decodePath(rawPath,decode);
}
","/** 
 * Decode the path component of a URI as path segments.
 * @param u the URI. If the path component is an absolute path componentthen the leading '/' is ignored and is not considered a delimiator of a path segment.
 * @param decode true if the path segments of the path componentshould be in decoded form.
 * @return the list of path segments.
 */
",Decode the raw path.,"1. One-line summary: Decodes URI paths based on given flag.  
2. Function behavior: Processes and optionally decodes the path segments of a URI, removing any leading slash, and returns processed segments.  
3. Function signature:  
@param u URI: The URI containing the path to decode.  
@param decode boolean: Flag indicating whether to decode the path.  
@return List<PathSegmentImpl>: The list of processed path segments.  
4. Examples:  
URI(""/example/path"", true) -> List[pathSegment1, pathSegment2] (Decodes and splits path)  
URI(""/example/path"", false) -> List[pathSegment1, pathSegment2] (Splits path, no decoding)  
URI("""", true) -> List[] (Empty path results in empty list)  
5. Preconditions & Postconditions: The input URI can be empty or with leading slash; the output is a list of path segments, optionally decoded."
636766f11a6d9265ec017651,nullToEmpty,"public static Character[] nullToEmpty(final Character[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
","If array is null or its length is 0, convert array to EMPTY_CHARACTER_OBJECT_ARRAY. Otherwise, return array itself.","1. One-line summary: Converts null or empty Character arrays to a predefined empty array.
2. Function behavior: Returns a predefined empty Character array if the input is null or empty; otherwise, returns the original array.
3. Function signature: 
   @param array Character[]: The array to be checked and possibly replaced.
   @return Character[]: The original array or an empty predefined array.
4. Examples: 
   null -> predefined empty array (input is null)
   [] -> predefined empty array (input is empty)
   ['a', 'b'] -> ['a', 'b'] (non-empty input is returned)
5. Preconditions & Postconditions: Input is a Character array or null; the output is either the input array or a predefined empty array."
636767821a6d9265ec0183ab,hasThrown,"public boolean hasThrown(){
  Throwable thrown=getThrown();
  if (thrown == null) {
    return false;
  }
  String thrownString=thrown.toString();
  return thrownString != null && thrownString.trim().length() != 0;
}
","/** 
 * @return true if getThrown().toString() is a non-empty string.
 */
",Check whether there is a thrown,"1. One-line summary: Check if an exception has been thrown and is not an empty string.
2. Function behavior: Determines if there is a Throwable instance from getThrown(). Checks if its string equivalent is non-empty.
3. Function signature:
@return boolean: True if an exception is thrown and its string is not empty, false otherwise.
4. Examples: getThrown() returns null -> false (no exception) getThrown() returns new Throwable("""") -> false (empty string) getThrown() returns new Throwable(""Error"") -> true (non-empty string)
5. Preconditions & Postconditions: Preconditions: getThrown() must be defined and return a Throwable or null. Postconditions: Returns true only if an exception was thrown with a non-empty description."
636767831a6d9265ec0183c9,peek,"public static String peek(){
  Stack stack=getCurrentStack();
  if (stack != null && !stack.isEmpty())   return ((DiagnosticContext)stack.peek()).message;
 else   return """";
}
","/** 
 * Looks at the last diagnostic context at the top of this NDC without removing it. <p>The returned value is the value that was pushed last. If no context is available, then the empty string """" is returned.
 * @return String The innermost diagnostic context.
 */
",Return the value at the top of the stack,"1. One-line summary: Returns the message from the top of a stack if not empty.
2. Function behavior: Checks the current stack for non-null and non-empty status, then returns the top DiagnosticContext's message. Returns an empty string if conditions are not met.
3. Function signature:
   @return String: The message from the top of the stack or an empty string if the stack is null or empty.
4. Examples: 
   (stack contains DiagnosticContext with ""Error occurred"") -> ""Error occurred"" (Stack is non-empty)
   (empty stack) -> """" (Stack is empty)
   (null stack) -> """" (Stack is null)
5. Preconditions & Postconditions: The stack must be valid or empty before function call; function ensures safe return of message or empty string otherwise."
636767de1a6d9265ec01871c,valueAccumulation,"public void valueAccumulation(String key,Long value){
  Long element=data.get(key);
  if (element == null) {
    element=value;
  }
 else {
    element+=value;
  }
  data.put(key,element);
}
","/** 
 * Accumulate the value with existing value in the same given key.
 */
",Add the value to the original value of the key.,"1. One-line summary: Accumulates values in a map based on a key.
2. Function behavior: Adds a Long value to the existing value for a given key in the data map. If the key doesn't exist, it initializes it with the given value.
3. Function signature: 
   @param key String: the key for accumulating value in the map
   @param value Long: the value to add to the existing value in the map
4. Examples: ""a"", 5L -> updates ""a"" with 5 (key ""a"" is initialized to 5) ""a"", 3L -> updates ""a"" with 8 (key ""a"" sum is updated to 8 if already was 5) ""b"", 2L -> updates ""b"" with 2 (key ""b"" is initialized to 2)
5. Preconditions & Postconditions: The data map must be initialized; after execution, the key will have an updated accumulated value."
6367677e1a6d9265ec01832e,exists,"public Logger exists(String name){
  Object o=ht.get(new CategoryKey(name));
  if (o instanceof Logger) {
    return (Logger)o;
  }
 else {
    return null;
  }
}
","/** 
 * Check if the named logger exists in the hierarchy. If so return its reference, otherwise returns <code>null</code>.
 * @param name The name of the logger to search for.
 */
","Check if the named logger exists. If so return its reference, otherwise returns null.","1. One-line summary: Checks if a Logger object exists for a given name.
2. Function behavior: Retrieves a Logger from a hashtable based on a name key and returns it if found, otherwise returns null.
3. Function signature:
@param name String: name of the logger to look for
@return Logger: corresponding Logger object if found, null otherwise
4. Examples: ""Logger1"" -> Logger instance (Logger found) ""Logger2"" -> null (Logger not found)
5. Preconditions & Postconditions: Preconditions: A hashtable named 'ht' contains logger objects. Postconditions: Returns a Logger instance or null if it doesn't exist in 'ht'."
6367670a1a6d9265ec0179e7,lookup,"public Converter lookup(final Class<?> clazz){
  Converter conv=(Converter)this.converters.get(clazz);
  if (conv != null) {
    return conv;
  }
  for (  Object regType : this.converters.keySet()) {
    if (((Class<?>)regType).isAssignableFrom(clazz)) {
      return (Converter)this.converters.get(regType);
    }
  }
  return null;
}
","/** 
 * Look up and return any registered  {@link Converter} for the specifieddestination class; if there is no registered Converter, return <code>null</code>.
 * @param clazz Class for which to return a registered Converter
 * @return The registered {@link Converter} or <code>null</code> if not found
 */
","Check whether the specified converter exists in converters. If yes, converter is returned. If no, null is returned.","1. One-line summary: Retrieves a Converter for a given class type.
2. Function behavior: Checks if a converter exists for the exact class type; if not, returns a compatible converter from the map.
3. Function signature: 
   @param clazz Class<?>: The class type to find a converter for.
   @return Converter: The appropriate converter for the given class, or null if none exist.
4. Examples: String.class -> StringConverter (exact match) Number.class -> ObjectConverter (assignable match) Object.class -> null (no match)
5. Preconditions & Postconditions: Class type provided is non-null. Returns null if no converter is found."
636767a41a6d9265ec018572,readRawVarint64,"public long readRawVarint64() throws IOException {
  int shift=0;
  long result=0;
  while (shift < 64) {
    final byte b=readRawByte();
    result|=(long)(b & 0x7F) << shift;
    if ((b & 0x80) == 0) {
      return result;
    }
    shift+=7;
  }
  throw ProtobufException.malformedVarint();
}
","/** 
 * Read a raw Varint from the stream.
 */
",Read raw varint,"1. One-line summary: Parses a raw variable-length 64-bit integer.
2. Function behavior: Reads bytes to construct a 64-bit integer, stopping when a byte without the continuation bit is found.
3. Function signature:
@return long: The parsed 64-bit integer.
@throws IOException: If there's an error reading a byte.
@throws ProtobufException: If the varint is malformed (e.g., too long).
4. Examples:
binary data -> integer (successful parse)
invalid binary -> throws ProtobufException (malformed varint)
binary ending with 0x00 byte -> integer (final byte indicates end)
5. Preconditions & Postconditions: Reads must be successful, and the sequence must be valid varint; outputs parsed integer or throws an exception if malformed."
636767021a6d9265ec0178bb,nullToEmpty,"public static Double[] nullToEmpty(final Double[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
","If the double type array is null or its length is 0, convert array to EMPTY_CHARACTER_OBJECT_ARRAY. Otherwise, return array itself.","1. One-line summary: Converts null or empty Double arrays to a predefined empty array.
2. Function behavior: Returns an empty Double array if the input array is null or empty; otherwise, returns the original array.
3. Function signature: 
   @param array Double[]: The input Double array that might be null or empty.
   @return Double[]: The original or an empty Double array.
4. Examples: 
   null -> ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY (null input)
   {} -> ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY (empty array input)
   {1.2, 3.4} -> {1.2, 3.4} (non-empty input)
5. Preconditions & Postconditions: Input array can be null; output is never null, always returns a valid Double array."
636767021a6d9265ec0178b2,pop,"private void pop(final String descriptor){
  char firstDescriptorChar=descriptor.charAt(0);
  if (firstDescriptorChar == '(') {
    pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);
  }
 else   if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {
    pop(2);
  }
 else {
    pop(1);
  }
}
","/** 
 * Pops as many abstract types from the output frame stack as described by the given descriptor.
 * @param descriptor a type or method descriptor (in which case its argument types are popped).
 */
",Pop the various value according to the first character of the descriptor.,"1. One-line summary: Simulate stack popping based on descriptor types.
2. Function behavior: The function determines the stack slots to pop based on the descriptor's first character. Uses conditional logic to handle method descriptors, long/double types, and others.
3. Function signature: 
@param descriptor String: The type descriptor determining stack behavior.
4. Examples: 
""(II)V"" -> 2 (method with two int arguments and void return)
""J"" -> 2 (long type)
""I"" -> 1 (int type)
5. Preconditions & Postconditions: Descriptor must not be null, function pops specified stack slots based on descriptor analysis."
636766f91a6d9265ec01776e,write,"@Override public void write(final byte b[],final int off,final int len) throws IOException {
  if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {
    throw new IndexOutOfBoundsException();
  }
 else   if (len == 0) {
    return;
  }
  if (this.count + len > this.buf.length) {
    this.encodePendingBytes(false);
  }
  System.arraycopy(b,off,this.buf,this.count,len);
  this.count+=len;
}
","/** 
 * Writes <code>len</code> bytes from the specified byte array starting at offset <code>off</code> to this byte array output stream.
 * @param b   the data.
 * @param off the start offset in the data.
 * @param len the number of bytes to write.
 */
",Write bytes of length len from a byte array,"1. One-line summary: Copies bytes from input array to internal buffer with bounds checking.
2. Function behavior: This method writes a specified range of bytes from an input array to an internal buffer, performing boundary checks, and handling potential buffer overflows.
3. Function signature: 
   @param b byte[]: Input byte array.
   @param off int: Offset in byte array to start copying from.
   @param len int: Number of bytes to copy.
   @throws IOException: If an IO error occurs.
   @throws IndexOutOfBoundsException: If offset or length is out of bounds.
4. Examples: 
   write(byteArray, 0, 5) -> (successful copy)
   write(byteArray, -1, 5) -> IndexOutOfBoundsException (off < 0)
   write(byteArray, 5, 0) -> (no action taken, len == 0)
5. Preconditions & Postconditions: Offsets and lengths must be within array bounds; method will update buffer and count if conditions are met."
636767551a6d9265ec017f3f,swap,"public static final <V>void swap(V[] arr,int i,int j){
  V tmp=arr[j];
  arr[j]=arr[i];
  arr[i]=tmp;
}
","/** 
 * Swaps the two elements at the specified indices in the given array.
 * @param < V > the type of elements in the array
 * @param arr the array
 * @param i the index of the first element
 * @param j the index of the second element
 */
",Swap values at indexes i and j in arr,"1. One-line summary: Swaps elements in an array.
2. Function behavior: The swap function exchanges elements at indices i and j in an array arr.
3. Function signature: 
@param arr V[]: The array in which elements will be swapped.
@param i int: The index of the first element to swap.
@param j int: The index of the second element to swap.
4. Examples: swap([""a"", ""b"", ""c""], 0, 2) -> [""c"", ""b"", ""a""] (Exchanges elements at indices 0 and 2) swap([""x"", ""y""], 1, 1) -> [""x"", ""y""] (No change as the indices are the same) swap([1, 2, 3, 4], 1, 3) -> [1, 4, 3, 2] (Swaps elements 2 and 4)
5. Preconditions & Postconditions: Indices i and j must be valid within array bounds; array elements at i and j are swapped if valid."
636766ae1a6d9265ec0175dc,isPartialContentResponse,"public Boolean isPartialContentResponse(){
  Integer limit=drc.getLimit() == null ? 0 : drc.getLimit();
  Long count=drc.getCount() == null ? 0 : drc.getCount();
  return !((limit + 1) >= count);
}
","/** 
 * Check if the actual response is a Partial Content (HTTP 206 code)
 * @return is partial content or not
 */
",Determine whether the actual response is a Partial Content,"1. One-line summary: Check if response is partial.
2. Function behavior: Determines whether the response is considered partial by checking if the count exceeds the limit. Returns true if the count is greater than limit + 1.
3. Function signature: 
@return Boolean: True if the response is partial, false otherwise.
4. Examples: 
limit=5, count=6 -> true (Partial response)
limit=5, count=5 -> false (Complete response)
limit=5, count=4 -> false (Complete response)
5. Preconditions & Postconditions: Inputs are non-negative integers; ensures response is flagged partial based on defined criteria."
636766f01a6d9265ec01762e,isEmpty,"public static boolean isEmpty(final double[] array){
  return array == null || array.length == 0;
}
","/** 
 * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */
",Check whether the array of the double type is empty.,"1. One-line summary: Check if a double array is null or empty.
2. Function behavior: Returns true if the array is null or has no elements, otherwise returns false.
3. Function signature: 
@param array double[]: Array of double values to be checked
@return boolean: True if the array is null or empty, otherwise false
4. Examples: 
null -> true (Array is null)
[] -> true (Array is empty)
[1.0] -> false (Array has one element)
5. Preconditions & Postconditions: Input is a double array or null; output is a boolean indicating if the array is null or empty."
6367667e1a6d9265ec01743a,lastWriteTimeStampInMilliseconds,"public long lastWriteTimeStampInMilliseconds(){
  return lastWrite == -1 ? System.currentTimeMillis() : lastWrite;
}
","/** 
 * The last time, in milliseconds, a write operation occurred.
 * @return this
 */
","Check whether lastwrite is - 1. If yes, return - 1. Otherwise, return System.currentTimeMillis().","1. One-line summary: Returns the last write timestamp or the current time if not set.
2. Function behavior: If lastWrite equals -1, it returns the current system time in milliseconds; otherwise, it returns lastWrite.
3. Function signature:
@return long: The last write timestamp or current time in milliseconds.
4. Examples:
lastWrite = -1 -> current time (lastWrite not set)
lastWrite = 1622538093000 -> 1622538093000 (returns lastWrite)
lastWrite = 0 -> 0 (returns lastWrite)
5. Preconditions & Postconditions: lastWrite is an internal variable, initialized to -1 if unset; returns a valid long timestamp."
636766821a6d9265ec0174c9,classPath,"private static File[] classPath(){
  final String[] fileNames=System.getProperty(""java.class.path"").split(File.pathSeparator);
  final File[] files=new File[fileNames.length];
  for (int i=0; i < files.length; ++i) {
    files[i]=new File(fileNames[i]);
  }
  return files;
}
","/** 
 * Returns the class path of the current JVM instance as an array of  {@link File} objects.
 */
",Creates an array of the file type based on all file names in java.class.path and returns the array.,"1. One-line summary: Converts the Java class path to an array of Files.
2. Function behavior: The function retrieves the Java class path, splits it into individual paths using the system path separator, and creates a File object for each path.
3. Function signature: 
   @return File[]: Array of File objects representing Java class path entries.
4. Examples: 
   java.class.path ""lib1.jar:lib2.jar"" -> [lib1.jar, lib2.jar] (Class paths converted to File array)
   java.class.path ""/path/to/lib1:/path/to/lib2"" -> [/path/to/lib1, /path/to/lib2] (Absolute paths as File objects)
5. Preconditions & Postconditions: System property ""java.class.path"" must be set, output is an array of File objects representing the paths."
636767041a6d9265ec0178f8,copyStrings,"private static String[] copyStrings(final String[] src){
  String[] dst=new String[src.length];
  for (int i=0; i < src.length; ++i) {
    dst[i]=src[i].toLowerCase();
  }
  return dst;
}
","/** 
 * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.
 */
",Copy the source string and transfer each character to lowecase.,"1. One-line summary: Converts an array of strings to lowercase.
2. Function behavior: The function creates a new array, converting each string from the input array to lowercase, then returns it.
3. Function signature:
@param src String[]: Source array of strings.
@return String[]: New array with strings converted to lowercase.
4. Examples: 
{""Hello"", ""WORLD""} -> {""hello"", ""world""} (Converts to lowercase)
{""JAVA"", ""Python""} -> {""java"", ""python""} (Converts to lowercase)
{""Stay"", ""Positive""} -> {""stay"", ""positive""} (Converts to lowercase)
5. Preconditions & Postconditions: Input array contains non-null strings, output maintains the same order with all strings in lowercase."
636767521a6d9265ec017ecc,splitAlongXAxis,"public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){
  double newWidth=box.getWidth() / 2d;
  double height=box.getHeight();
  return Pair.of(Box2D.of(box.getMinX(),box.getMinY(),newWidth,height),Box2D.of(box.getMinX() + newWidth,box.getMinY(),newWidth,height));
}
","/** 
 * Split a box along the x axis into two equal boxes.
 * @param box the box to split
 * @return a pair with the two resulting boxes
 */
",Divide a box into two equal boxes on the x axis.,"1. One-line summary: Splits a Box2D object into two along the x-axis.
2. Function behavior: Splits the given Box2D into two equal width Box2D objects along the x-axis and returns them as a pair.
3. Function signature: 
   @param box Box2D: The Box2D object to be split.
   @return Pair<Box2D, Box2D>: A pair of Box2D objects split from the original.
4. Examples: Box2D(0,0,8,4) -> Pair(Box2D(0,0,4,4), Box2D(4,0,4,4)) (splits into two halves) Box2D(0,0,10,5) -> Pair(Box2D(0,0,5,5), Box2D(5,0,5,5)) (splits into two halves) Box2D(1,1,6,3) -> Pair(Box2D(1,1,3,3), Box2D(4,1,3,3)) (splits into two halves)
5. Preconditions & Postconditions: Box2D must have positive width and height; returns a Pair with two Box2D objects retaining the original height and each with half the original width."
636766a91a6d9265ec0175c1,enlarge,"private void enlarge(final int size){
  int doubleCapacity=2 * data.length;
  int minimalCapacity=length + size;
  byte[] newData=new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];
  System.arraycopy(data,0,newData,0,length);
  data=newData;
}
","/** 
 * Enlarges this byte vector so that it can receive 'size' more bytes.
 * @param size number of additional bytes that this byte vector should be able to receive.
 */
",Convert the original data array to a longer array.,"1. One-line summary: Dynamically resizes a byte array.
2. Function behavior: Enlarges the byte array to accommodate additional elements by creating a new larger array and copying existing data into it.
3. Function signature: 
   @param size int: additional number of elements to fit
4. Examples: size=5 with data.length=10, length=8 -> enlarges data (fits 13 elements) size=20 with data.length=15, length=12 -> enlarges data (fits 32 elements) size=0 with data.length=20, length=18 -> keeps data (no size change needed)
5. Preconditions & Postconditions: Precondition: data array has existing elements. Postcondition: data array is enlarged to fit additional size requirements."
6367674a1a6d9265ec017dab,compare,"@Override public int compare(Double o1,Double o2){
  if (Math.abs(o1 - o2) < epsilon) {
    return 0;
  }
 else {
    return Double.compare(o1,o2);
  }
}
","/** 
 * Compares two floating point values. Returns 0 if they are equal, -1 if  {@literal o1 < o2}, 1 otherwise
 * @param o1 the first value
 * @param o2 the second value
 * @return 0 if they are equal, -1 if {@literal o1 < o2}, 1 otherwise
 */
","Compares two values. If the difference between the two values is less than epsilon, 0 is returned. Otherwise, Double.compare is invoked.","1. One-line summary: Compares two Double objects with a tolerance level epsilon.
2. Function behavior: Returns 0 if the absolute difference between two doubles is less than epsilon, otherwise returns the result of Double.compare.
3. Function signature:
@param o1 Double: first double object
@param o2 Double: second double object
@return int: 0 if the doubles are approximately equal, otherwise standard comparison result
4. Examples: 
1.0, 1.0 -> 0 (Numbers are equal)
1.0, 1.1 -> -1 (1.0 is less than 1.1)
1.1, 1.0 -> 1 (1.1 is greater than 1.0)
5. Preconditions & Postconditions: The inputs are non-null Double objects; output is an integer indicating approximate equality or comparison result."
6367672d1a6d9265ec017c78,insert,"public boolean insert(int val){
  if (!map.containsKey(val)) {
    map.put(val,val);
    values.add(val);
    return true;
  }
 else {
    return false;
  }
}
","/** 
 * Inserts a value to the set. Returns true if the set did not already contain the specified element. 
 */
","If the key whose value is val does not exist in the map, add (val, val) to the map and return true. Otherwise, return false.","1. One-line summary: Inserts a value if it doesn't exist in the map.
2. Function behavior: The function checks if the value exists in the map. If not, it adds the value to the map and a list, returning true; otherwise, it returns false.
3. Function signature:
   @param val int: The value to be inserted
   @return boolean: True if the value was added, false if it already existed
4. Examples: 
   insert(5) -> true (inserts 5 successfully)
   insert(7) -> true (inserts 7 successfully)
   insert(5) -> false (5 already exists, no insertion)
5. Preconditions & Postconditions: Assumes `map` and `values` are initialized; after execution, `map` contains the value only if it wasn't already there."
636766821a6d9265ec0174bf,capitalize,"public static String capitalize(String name){
  if (name == null || name.length() == 0) {
    return name;
  }
  char chars[]=name.toCharArray();
  chars[0]=Character.toUpperCase(chars[0]);
  return new String(chars);
}
","/** 
 * Reverse of Introspector.decapitalize
 */
",Converts a name of the string type to a character array and converts the first letter to an uppercase letter.,"1. One-line summary: Capitalizes the first character of a non-empty string.
2. Function behavior: Converts the first character of a given string to uppercase. Returns the modified string without altering other characters.
3. Function signature: 
   @param name String: The input string to be capitalized
   @return String: The string with the first character capitalized
4. Examples: 
   ""hello"" -> ""Hello"" (capitalizes 'h')
   ""java"" -> ""Java"" (capitalizes 'j')
   """" -> """" (empty string remains unchanged)
   null -> null (returns null for null input)
5. Preconditions & Postconditions: Input is a string or null; output is the modified string with an uppercase first character or unchanged for empty/null input."
636766f21a6d9265ec017677,isNotTrue,"public static boolean isNotTrue(Boolean bool){
  return !isTrue(bool);
}
","/** 
 * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>true</code>, handling <code>null</code> by returning <code>true</code>.</p> <pre> BooleanUtils.isNotTrue(Boolean.TRUE)  = false BooleanUtils.isNotTrue(Boolean.FALSE) = true BooleanUtils.isNotTrue(null)          = true </pre>
 * @param bool  the boolean to check, null returns <code>true</code>
 * @return <code>true</code> if the input is null or false
 * @since 2.3
 */
",Check whether the parameter bool is not true.,"1. One-line summary: Checks if a Boolean is not true.
2. Function behavior: The function returns the opposite result of another function isTrue when given a Boolean input.
3. Function signature: 
   @param bool Boolean: Boolean value to check
   @return boolean: true if the input is not true, false otherwise
4. Examples: 
   true -> false (Assumes isTrue(true) returns true)
   false -> true (Assumes isTrue(false) returns false)
   null -> true (if isTrue(null) assumes false)
5. Preconditions & Postconditions: Input can be true, false, or null; output is the opposite of isTrue result for the input."
6367674f1a6d9265ec017e74,toString,"public String toString(){
  StringBuilder s=new StringBuilder();
  for (int j=i; j < n; j++)   s.append(vs[j]).append("" "");
  return s.toString();
}
","/** 
 * Returns a textual representation of the queue.
 * @return a textual representation of the queue.
 */
",Convert a value in a vs array to a string,"1. One-line summary: Converts a section of an array to a space-separated string.
2. Function behavior: The function iterates over an array from index `i` to `n`, appending each element followed by a space to a StringBuilder, and returns the resulting string.
3. Function signature:
@return String: The space-separated string formed by the array elements from index `i` to `n-1`.
4. Examples: 
{""a"", ""b"", ""c""}, i=0, n=3 -> ""a b c "" (entire array)
{""x"", ""y"", ""z""}, i=1, n=3 -> ""y z "" (partial array starting at index 1)
{""m"", ""n"", ""o"", ""p""}, i=2, n=4 -> ""o p "" (starts from index 2)
5. Preconditions & Postconditions: Preconditions: `i` and `n` are valid indices within the bounds of the array. Postconditions: Returns a string representing the desired section of the array."
6367675c1a6d9265ec018058,createStringSupplier,"@SuppressWarnings(""unchecked"") public static Supplier<String> createStringSupplier(int start){
  int[] container=new int[]{start};
  return (Supplier<String> & Serializable)() -> String.valueOf(container[0]++);
}
","/** 
 * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.
 * @param start where to start the sequence
 * @return a string supplier
 */
",Create a string supplier which returns unique integer strings starting from the given start.,"1. One-line summary: Creates a Supplier that generates a string from an incrementing integer.
2. Function behavior: Returns a supplier that provides the next integer in string form, starting from a given integer, and increments the value after each call.
3. Function signature:
@return Supplier<String>: A supplier that returns the current integer as a string and then increments the integer.
4. Examples: 
Supplier created with 5 -> ""5"" (first call)
Supplier created with 5 -> ""6"" (second call)
Supplier created with 0 -> ""0"" (first call)
5. Preconditions & Postconditions: Initial integer must be a valid int, generating strings from incrementing ints starting at given value."
6367677b1a6d9265ec0182bd,format,"public String format(final LoggingEvent event){
  StringBuffer buf=new StringBuffer();
  for (PatternConverter c=head; c != null; c=c.next) {
    c.format(buf,event);
  }
  return buf.toString();
}
","/** 
 * Formats a logging event to a writer.
 * @param event logging event to be formatted.
 */
",Formats LoggingEvent as a fixed-format string,"1. One-line summary: Formats a logging event into a string.
2. Function behavior: Iterates over a linked list of PatternConverter objects to format a LoggingEvent object, appending each result to a StringBuffer. Converts the StringBuffer to a String and returns it.
3. Function signature: @return String: the formatted string representation of the logging event.
4. Examples: event1 -> ""ERROR: NullPointerException at line 45"" (formats as error message) event2 -> ""INFO: User login successful"" (formats as info message) event3 -> ""DEBUG: Variable x set to 10"" (formats as debug message)
5. Preconditions & Postconditions: Preconditions: 'head' is not null, and each PatternConverter in the linked list can format the event. Postconditions: Returns a non-null string created from formatted logging event data."
636766ff1a6d9265ec017842,toPrimitive,"public static double[] toPrimitive(final Double[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_DOUBLE_ARRAY;
  }
  final double[] result=new double[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].doubleValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Doubles to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Double</code> array, may be <code>null</code>
 * @return a <code>double</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","If the length of the array is 0, return EMPTY_DOUBLE_ARAY. Otherwise, convert the array to an array of the double type.","1. One-line summary: Converts a Double array to a primitive double array.
2. Function behavior: Converts a non-null array of Double objects to an array of primitive doubles, handling null and empty cases specifically.
3. Function signature:
@param array Double[]: Input array of Double objects
@return double[]: Array of primitive doubles
4. Examples: 
null -> null (input null, output null)
[] -> [] (empty array to empty array)
[1.0, 2.2, 3.3] -> [1.0, 2.2, 3.3] (standard conversion)
5. Preconditions & Postconditions: Input must be a Double array or null; output is a corresponding double array or null if input is null."
636766fa1a6d9265ec0177a9,addInitializedType,"private void addInitializedType(final int abstractType){
  if (initializations == null) {
    initializations=new int[2];
  }
  int initializationsLength=initializations.length;
  if (initializationCount >= initializationsLength) {
    int[] newInitializations=new int[Math.max(initializationCount + 1,2 * initializationsLength)];
    System.arraycopy(initializations,0,newInitializations,0,initializationsLength);
    initializations=newInitializations;
  }
  initializations[initializationCount++]=abstractType;
}
","/** 
 * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.
 * @param abstractType an abstract type on a which a constructor is invoked.
 */
",Add abstractType to the initializations variable.,"1. One-line summary: Adds an initialized type to the internal array.
2. Function behavior: Checks and resizes the `initializations` array if needed, then adds the given `abstractType` at the next available index.
3. Function signature: 
   @param abstractType int: The type to be added to the array.
4. Examples: 
   abstractType=3 -> array resizes if needed and 3 is added
   abstractType=5 when full -> array extends and 5 is added
   abstractType=2 -> 2 is added at next available position
5. Preconditions & Postconditions: Assumes `initializations` can be null initially, enlarges array when full, ensures `abstractType` is appended."
6367670a1a6d9265ec0179dc,putAbstractTypes,"private void putAbstractTypes(final int start,final int end){
  for (int i=start; i < end; ++i) {
    Frame.putAbstractType(symbolTable,currentFrame[i],stackMapTableEntries);
  }
}
","/** 
 * Puts some abstract types of  {@link #currentFrame} in {@link #stackMapTableEntries} , using theJVMS verification_type_info format used in StackMapTable attributes.
 * @param start index of the first type in {@link #currentFrame} to write.
 * @param end index of last type in {@link #currentFrame} to write (exclusive).
 */
",Add the elements indexed from start to end in currentFrame to Frame.,"1. One-line summary: Updates a collection of abstract types within a specified range.
2. Function behavior: Iterates from `start` to `end` and updates each entry with an abstract type using `Frame.putAbstractType`.
3. Function signature:
   @param start int: Start index for the iteration.
   @param end int: End index for the iteration.
4. Examples:
   putAbstractTypes(0, 3) -> (updates entries at indices 0, 1, 2)
   putAbstractTypes(2, 5) -> (updates entries at indices 2, 3, 4)
   putAbstractTypes(1, 1) -> (does not update any entries)
5. Preconditions & Postconditions: Indices must be valid within the currentFrame; each valid index will have its abstract type updated."
6367670a1a6d9265ec0179d8,write,"@Override public void write(final byte[] b) throws IOException {
  if (this.encoding == null) {
    this.writer.write(new String(b));
  }
 else {
    this.writer.write(new String(b,this.encoding));
  }
}
","/** 
 * @see OutputStream#write(byte[]) 
 */
",Write the byte array b to the buffer based on the encoding.,"1. One-line summary: Writes byte data to a writer, optionally using a specified encoding.
2. Function behavior: Converts byte array to a String and writes to a writer. Uses default encoding if no encoding is specified.
3. Function signature: 
   @throws IOException: If an I/O error occurs during writing.
4. Examples: 
   byte[] data -> writes ""data"" using default encoding
   byte[] data, ""UTF-8"" -> writes ""data"" using UTF-8 encoding
5. Preconditions & Postconditions: Requires a writer and a non-null byte array; outputs a String representation of the byte array to the writer."
636767021a6d9265ec0178bf,convertToType,"@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {
  String string=value.toString();
  if (string.length() == 0) {
    return BeanUtils.getDefaultValue(type);
  }
 else {
    return string.charAt(0);
  }
}
","/** 
 * <p>Convert the input object into a java.lang.Character.</p>
 * @param type Data type to which this value should be converted.
 * @param value The input value to be converted.
 * @return The converted value.
 * @throws Exception if conversion cannot be performed successfully
 * @since 1.8.0
 */
","If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.","1. One-line summary: Converts an object to its default type or a character.
2. Function behavior: Converts a non-empty object to its first character, otherwise returns the default type value.
3. Function signature: 
   @param type Class<?>: Class type to convert the object to.
   @param value Object: Object to be converted.
   @return Object: The converted default value or first character.
   @throws Exception: If conversion fails.
4. Examples: 
   """" -> <default type value> (Empty string returns default type value)
   ""abc"" -> 'a' (Returns first character of non-empty string)
   null -> <default type value> (Null treated as empty)
5. Preconditions & Postconditions: Input object should be convertible to String; ensures a default or first character output."
6367670b1a6d9265ec017a0f,containsAnyIgnoreCase,"public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){
  if (StringUtils.isEmpty(str) || searchStrArray == null || searchStrArray.isEmpty()) {
    return false;
  }
  for (  String item : searchStrArray) {
    if (containsIgnoreCase(str,item)) {
      return true;
    }
  }
  return false;
}
","/** 
 * Case in-sensitive Checks if the String contains any character in the given set of string. 
 */
","Check whether str contains elements in searchStrArray. If yes, true is returned. If no, false is returned.","1. One-line summary: Checks if string contains any of the search strings, ignoring case.
2. Function behavior: Determines if any string in a list appears in a given string, case-insensitively. Returns true if any match is found.
3. Function signature: 
@param str String: The string to search within
@param searchStrArray List<String>: The list of strings to search for
@return boolean: True if any search string is found
4. Examples: 
""hello world"", [""Hello"", ""world""] -> true (matches ""hello"")
""abc"", [""def"", ""ghi""] -> false (no matches)
""My Test"", [""test"", ""another""] -> true (matches ""Test"")
5. Preconditions & Postconditions: Str and searchStrArray must be non-null for meaningful results; returns true if any search string is found in str, ignoring case."
636766a81a6d9265ec01758e,nextPrime,"public static int nextPrime(int desiredCapacity){
  if (desiredCapacity >= largestPrime) {
    return largestPrime;
  }
  int i=Arrays.binarySearch(primeCapacities,desiredCapacity);
  if (i < 0) {
    i=-i - 1;
  }
  return primeCapacities[i];
}
","/** 
 * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code> (within 11% if <code>desiredCapacity &gt;= 1000</code>).
 * @param desiredCapacity the capacity desired by the user.
 * @return the capacity which should be used for a hashtable.
 */
",Returns the element at the location specified by desiredCapacity in primeCapacities.,"1. One-line summary: Finds the smallest prime greater than or equal to a given number.
2. Function behavior: If the desired capacity is larger than or equal to the largest known prime, it returns the largest prime. Otherwise, it returns the next prime from a pre-sorted array.
3. Function signature:
   @param desiredCapacity int: capacity for which to find the next prime.
   @return int: the next prime capacity.
4. Examples: 
   10 -> 11 (10 < 11, next prime)
   17 -> 17 (exact match)
   100 -> 101 (next prime after 100)
5. Preconditions & Postconditions: Input is a non-negative integer; output is the smallest prime greater than or equal to the input."
6367670a1a6d9265ec0179cf,toChar,"public static char toChar(final Character ch,final char defaultValue){
  if (ch == null) {
    return defaultValue;
  }
  return ch.charValue();
}
","/** 
 * <p>Converts the Character to a char handling <code>null</code>.</p> <pre> CharUtils.toChar(null, 'X') = 'X' CharUtils.toChar(' ', 'X')  = ' ' CharUtils.toChar('A', 'X')  = 'A' </pre>
 * @param ch  the character to convert
 * @param defaultValue  the value to use if the  Character is null
 * @return the char value of the Character or the default if null
 */
","Obtains the character value of ch. If ch is null, defaultValue is returned.","1. One-line summary: Converts a nullable Character to a char using a default if null.
2. Function behavior: Returns the char value of a Character object or a specified default value if the Character is null.
3. Function signature:
   @param ch Character: Nullable Character object
   @param defaultValue char: Default character if ch is null
   @return char: Char value or default if null
4. Examples: 
   'A', 'X' -> 'A' (returns char value of Character)
   null, 'X' -> 'X' (returns default value when null)
5. Preconditions & Postconditions: Input Character may be null, output is always a non-null char."
6367676b1a6d9265ec0181e2,findFirstMatch,"public static Object findFirstMatch(Collection source,Collection candidates){
  if (isEmpty(source) || isEmpty(candidates)) {
    return null;
  }
  for (  Object candidate : candidates) {
    if (source.contains(candidate)) {
      return candidate;
    }
  }
  return null;
}
","/** 
 * Return the first element in '<code>candidates</code>' that is contained in '<code>source</code>'. If no element in '<code>candidates</code>' is present in '<code>source</code>' returns <code>null</code>. Iteration order is {@link Collection} implementation specific.
 * @param source the source Collection
 * @param candidates the candidates to search for
 * @return the first present object, or <code>null</code> if not found
 */
",Returns the first element in candidates that matches the source.,"1. One-line summary: Returns the first matching element from two collections.
2. Function behavior: It finds and returns the first object in the 'candidates' collection that is also present in the 'source' collection.
3. Function signature: 
   @param source Collection: Collection to check against.
   @param candidates Collection: Collection to find matches from.
   @return Object: The first matching element or null if no match.
4. Examples: 
   [1,2,3], [3,4,5] -> 3 (First match found in both)
   [""a"",""b""], [""c"",""d""] -> null (No matches present)
   [null], [null] -> null (null considered a non-match)
5. Preconditions & Postconditions: Collections are non-null, may contain nulls; function returns null if either collection is empty or no matches are found."
6367676b1a6d9265ec0181ee,trimTrailingWhitespace,"public static String trimTrailingWhitespace(String str){
  if (!hasLength(str)) {
    return str;
  }
  StringBuilder sb=new StringBuilder(str);
  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {
    sb.deleteCharAt(sb.length() - 1);
  }
  return sb.toString();
}
","/** 
 * Trim trailing whitespace from the given String.
 * @param str the String to check
 * @return the trimmed String
 * @see java.lang.Character#isWhitespace
 */
",Trim the end space of the str.,"1. One-line summary: Trims trailing whitespace from a string.
2. Function behavior: The function iteratively removes whitespace characters from the end of a given string until no whitespace remains.
3. Function signature: @return String: The input string without trailing whitespace.
4. Examples: ""hello "" -> ""hello"" (removes trailing space) "" world\t"" -> "" world"" (removes trailing tab) ""example"" -> ""example"" (no change)
5. Preconditions & Postconditions: Input string can be null, resulting string will have no trailing whitespace."
636767dc1a6d9265ec0186cb,init,"public void init(){
  File dist=new File(analyzeResultDist);
  if (!dist.exists()) {
    dist.mkdirs();
    return;
  }
  if (dist.isFile()) {
    throw new IllegalArgumentException(analyzeResultDist + "" must be a directory"");
  }
}
","/** 
 * initialize config, such as check dist path
 */
",Initializes a directory.,"1. One-line summary: Initializes a directory for analysis results.
2. Function behavior: Creates the directory if it doesn't exist; throws an exception if the path is a file.
3. Function signature: 
   @throws IllegalArgumentException: If analyzeResultDist is a file instead of a directory.
4. Examples: 
   nonexistent_path -> creates directory (creates directory)
   existent_directory_path -> does nothing (directory exists, no action)
   existent_file_path -> throws IllegalArgumentException (path is a file)
5. Preconditions & Postconditions: Path must either not exist or be a directory; postcondition is a ready-to-use directory or an exception if invalid."
636767a31a6d9265ec018552,readString,"@Override public String readString() throws IOException {
  final int size=readRawVarint32();
  if (size <= (bufferSize - bufferPos) && size > 0) {
    final String result=STRING.deser(buffer,bufferPos,size);
    bufferPos+=size;
    return result;
  }
 else {
    return STRING.deser(readRawBytes(size));
  }
}
","/** 
 * Read a  {@code string} field value from the stream.
 */
",Read string from a buffer.,"1. One-line summary: Utility to read and deserialize strings from a byte buffer.
2. Function behavior: Reads a variable-length integer to get the byte size of a string, then deserializes and returns the string using a buffer or reads raw bytes.
3. Function signature: 
@return String: The deserialized string from the byte buffer.
@throws IOException: If there's an issue reading bytes from the buffer.
4. Examples: 
input buffer with ""Hello"" -> ""Hello"" (buffer has string size)
input buffer with ""World!"" -> ""World!"" (buffer lacking fixed size)
5. Preconditions & Postconditions: Requires non-negative size that does not exceed buffer limits, returns a valid deserialized string."
636767a61a6d9265ec0185b7,digitValue,"private static int digitValue(final char c){
  if ('0' <= c && c <= '9') {
    return c - '0';
  }
 else   if ('a' <= c && c <= 'z') {
    return c - 'a' + 10;
  }
 else {
    return c - 'A' + 10;
  }
}
","/** 
 * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()} but we don't accept non-ASCII digits.
 */
",Obtains the number corresponding to the character c.,"1. One-line summary: Converts a char to its numeric value.
2. Function behavior: The function converts a digit or letter to a numeric value; digits '0'-'9' map to 0-9, lowercase 'a'-'z' and uppercase 'A'-'Z' map to 10-35.
3. Function signature: 
   @param c char: The character to convert
   @return int: The numeric value of the character
4. Examples: 
   '3' -> 3 (digit '3' to its numeric value)
   'b' -> 11 (lowercase 'b' to its numeric value)
   'G' -> 16 (uppercase 'G' to its numeric value)
5. Preconditions & Postconditions: Input is a single alphanumeric character; output is its corresponding numeric value."
636767e01a6d9265ec018755,buildContent,"private Map<String,Object> buildContent(JsonObject jsonObject){
  Map<String,Object> content=new HashMap<>();
  content.put(""msg_type"",jsonObject.get(""msg_type"").getAsString());
  if (jsonObject.get(""ats"") != null) {
    String ats=jsonObject.get(""ats"").getAsString();
    String text=jsonObject.get(""content"").getAsJsonObject().get(""text"").getAsString();
    List<String> collect=Arrays.stream(ats.split("","")).map(String::trim).collect(Collectors.toList());
    for (    String userId : collect) {
      text+=""<at user_id=\"""" + userId + ""\""></at>"";
    }
    jsonObject.get(""content"").getAsJsonObject().addProperty(""text"",text);
  }
  content.put(""content"",jsonObject.get(""content"").getAsJsonObject());
  return content;
}
","/** 
 * build content,if it has ats someone set the ats
 */
","Put the ""content"" from the  jsonObject to the content.","1. One-line summary: Constructs a content map from a JSON object.
2. Function behavior: The function extracts ""msg_type"" and a modified ""content"" from a JsonObject, adding <at> tags for user IDs found in the ""ats"" field.
3. Function signature: 
   @param jsonObject JsonObject: The input JSON object containing the required fields.
   @return Map<String,Object>: A map with keys ""msg_type"" and ""content"".
4. Examples: 
   {""msg_type"":""text"",""ats"":""1,2,3"",""content"":{""text"":""Hello""}} -> {""msg_type"":""text"",""content"":{""text"":""Hello<at user_id=\""1\""></at><at user_id=\""2\""></at><at user_id=\""3\""></at>""}}
   {""msg_type"":""text"",""ats"":null,""content"":{""text"":""Hello""}} -> {""msg_type"":""text"",""content"":{""text"":""Hello""}}
   {""msg_type"":""image"",""content"":{""url"":""image_url""}} -> {""msg_type"":""image"",""content"":{""url"":""image_url""}}
5. Preconditions & Postconditions: Assumes valid JsonObject input and modifies the ""content"" field with user ID mentions if ""ats"" is present."
636767a21a6d9265ec018517,toByteArray,"public final byte[] toByteArray(){
  LinkedBuffer node=head;
  int offset=0, len;
  final byte[] buf=new byte[size];
  do {
    if ((len=node.offset - node.start) > 0) {
      System.arraycopy(node.buffer,node.start,buf,offset,len);
      offset+=len;
    }
  }
 while ((node=node.next) != null);
  return buf;
}
","/** 
 * Returns a single byte array containg all the contents written to the buffer(s).
 */
",Copy bytes from LinkedBuffer and return.,"1. One-line summary: Converts linked buffers to a single byte array.
2. Function behavior: This function copies data from a sequence of linked buffers into a new byte array and returns it.
3. Function signature: 
@return byte[]: A byte array containing the concatenated data from all linked buffers.
4. Examples: 
LinkedBuffer with data [1, 2] and [3, 4] -> [1, 2, 3, 4] (Concatenated output)
Single LinkedBuffer with data [5, 6] -> [5, 6] (Direct copy)
Empty LinkedBuffer sequence -> [] (Empty array)
5. Preconditions & Postconditions: Linked buffers are non-null; returns a contiguous byte array representing all data."
6367667d1a6d9265ec017401,unescapeJava,"public static String unescapeJava(String str) throws Exception {
  if (str == null) {
    return null;
  }
  StringWriter writer=new StringWriter(str.length());
  unescapeJava(writer,str);
  return writer.toString();
}
","/** 
 * <p>Unescapes any Java literals found in the <code>String</code>. For example, it will turn a sequence of <code>'\'</code> and <code>'n'</code> into a newline character, unless the <code>'\'</code> is preceded by another <code>'\'</code>.</p>
 * @param str the <code>String</code> to unescape, may be null
 * @return a new unescaped <code>String</code>, <code>null</code> if null string input
 */
",Unescapes Java that found in the String.,"1. One-line summary: Convert Java escape sequences in a string to actual characters.
2. Function behavior: Transforms escape sequences (like \n, \t) in the input string to their respective characters, writing the result to a StringWriter.
3. Function signature: 
   @param str String: input string containing Java escape sequences
   @return String: string with escape sequences converted
   @throws Exception: if an error occurs during transformation
4. Examples: ""Hello\\nWorld"" -> ""Hello\nWorld"" (newline converted) ""Tab\\tSeparated"" -> ""Tab\tSeparated"" (tab converted) ""\\\\"" -> ""\\"" (backslash preserved)
5. Preconditions & Postconditions: Input string may have escape sequences and the output will have them converted to respective characters."
636766f01a6d9265ec01763e,javaCharset,"private static String javaCharset(String charset){
  if (charset == null) {
    return null;
  }
  String mappedCharset=MIME2JAVA.get(charset.toLowerCase(Locale.ENGLISH));
  if (mappedCharset == null) {
    return charset;
  }
  return mappedCharset;
}
","/** 
 * Translate a MIME standard character set name into the Java equivalent.
 * @param charset The MIME standard name.
 * @return The Java equivalent for this name.
 */
",Translate a MIME standard charset name into the Java equivalent.,"1. One-line summary: Map MIME charset names to Java charset names.
2. Function behavior: Transforms a given charset name into its Java equivalent using a predefined mapping; returns the original if no mapping exists.
3. Function signature:
@param charset String: The charset name to map.
@return String: The corresponding Java charset name or original.
4. Examples: 
""UTF-8"" -> ""UTF8"" (maps MIME to Java names)
""ISO-8859-1"" -> ""ISO8859_1"" (maps MIME to Java names)
""custom-charset"" -> ""custom-charset"" (no mapping exists)
5. Preconditions & Postconditions: Input charset may be null; mapped or original charset is returned, handle case insensitively."
6367676a1a6d9265ec0181bf,quoteIfString,"public static Object quoteIfString(Object obj){
  return (obj instanceof String ? quote((String)obj) : obj);
}
","/** 
 * Turn the given Object into a String with single quotes if it is a String; keeping the Object as-is else.
 * @param obj the input Object (e.g. ""myString"")
 * @return the quoted String (e.g. ""'myString'""),or the input object as-is if not a String
 */
",Check whether an obj variable is of the String type.,"1. One-line summary: Returns quoted string if input is a string.
2. Function behavior: Checks if the object is a String and returns the quoted string; otherwise, returns the object unchanged.
3. Function signature:
   @param obj Object: Input object to check.
   @return Object: Quoted string if input is a String; original object otherwise.
4. Examples: 
   ""hello"" -> ""\""hello\"""" (input is a string)
   5 -> 5 (input is an integer)
   null -> null (input is null)
5. Preconditions & Postconditions: Input can be any object type; if it's a String, it gets quoted, otherwise returned as is."
636767501a6d9265ec017e86,previousNode,"@Override public ListNode<E> previousNode(){
  checkForComodification();
  if (!hasPrevious()) {
    throw new NoSuchElementException();
  }
  last=next=next.prev;
  nextIndex--;
  return last;
}
","/** 
 * {@inheritDoc}
 */
",Returns the previous ListNode.,"1. One-line summary: Returns the previous node in a doubly linked list.
2. Function behavior: Checks for concurrent modifications, verifies availability of a previous node, then updates and returns the previous node.
3. Function signature: 
   @return ListNode<E>: The previous node in the list.
   @throws NoSuchElementException: If no previous node exists.
4. Examples: 
   current node -> previous node (navigates backwards)
   start of list -> NoSuchElementException (no previous node)
5. Preconditions & Postconditions: List must not be concurrently modified, cursor must not be at the list start; post-execution, cursor steps back one node."
636766f21a6d9265ec017667,readShort,"public short readShort(final int offset){
  byte[] classBuffer=classFileBuffer;
  return (short)(((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF));
}
","/** 
 * Reads a signed short value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
 * @param offset the start offset of the value to be read in this {@link ClassReader}.
 * @return the read value.
 */
",Read a short value from classFileBuffer,"1. One-line summary: Reads a 16-bit signed integer from a byte array at a specified offset.
2. Function behavior: This function extracts two bytes from a byte array starting at a given offset and converts them into a short value.
3. Function signature:
   @param offset int: Index in the byte array to start reading from
   @return short: The 16-bit signed integer value from the byte array
4. Examples: 
   offset=0, classBuffer={0x01, 0x02} -> 258 (reads bytes {0x01, 0x02})
   offset=1, classBuffer={0x00, 0x01, 0x02} -> 258 (reads bytes {0x01, 0x02})
   offset=0, classBuffer={0xFF, 0xFF} -> -1 (reads bytes {0xFF, 0xFF})
5. Preconditions & Postconditions: The byte array must have at least two bytes available starting at the offset; converts two bytes to a short integer."
636767031a6d9265ec0178ef,copyArrayGrow1,"private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){
  if (array != null) {
    int arrayLength=Array.getLength(array);
    Object newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength + 1);
    System.arraycopy(array,0,newArray,0,arrayLength);
    return newArray;
  }
  return Array.newInstance(newArrayComponentType,1);
}
","/** 
 * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.
 * @param array The array to copy, must not be <code>null</code>.
 * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.
 * @return A new copy of the array of size 1 greater than the input.
 */
",Copy the given array and add a default value at the end.,"1. One-line summary: Adds one element to the end of an array.
2. Function behavior: Creates a copy of the input array with an extra element added to its end; returns a new array of specified type if input is null.
3. Function signature: 
   @param array Object: The array to copy and grow.
   @param newArrayComponentType Class<?>: The component type for a new array if the input array is null.
   @return Object: The new array with one additional element.
4. Examples: 
   [1, 2, 3], Integer.class -> [1, 2, 3, null] (adds null to int array)
   null, Integer.class -> [null] (creates new int array with one null element)
   ['a', 'b'], Character.class -> ['a', 'b', null] (adds null to char array)
5. Preconditions & Postconditions: Input is an array or null; returns a new array with one more element, possibly null."
636767611a6d9265ec018116,intersection,"private Set<V> intersection(Set<V> set1,Set<V> set2){
  Set<V> a;
  Set<V> b;
  if (set1.size() <= set2.size()) {
    a=set1;
    b=set2;
  }
 else {
    a=set2;
    b=set1;
  }
  return a.stream().filter(b::contains).collect(Collectors.toSet());
}
","/** 
 * Efficient way to compute the intersection between two sets
 * @param set1 set $1$
 * @param set2 set $2$
 * @return intersection of set $1$ and $2$
 */
",Return the intersection between two sets.,"1. One-line summary: Finds the intersection of two sets.
2. Function behavior: Returns a set containing elements present in both input sets. Optimizes processing by iterating over the smaller set.
3. Function signature:
   @param set1 Set<V>: The first set of elements.
   @param set2 Set<V>: The second set of elements.
   @return Set<V>: A set containing the common elements of set1 and set2.
4. Examples: 
   {1, 2, 3}, {3, 4, 5} -> {3} (3 is common)
   {a, b}, {b, c, d} -> {b} (b is common)
   {}, {x, y} -> {} (no intersection)
5. Preconditions & Postconditions: Both input sets must be non-null, and the result set will have elements common to both input sets."
636766f71a6d9265ec017730,toNoNullStringArray,"static String[] toNoNullStringArray(Collection<?> collection){
  if (collection == null) {
    return ArrayUtils.EMPTY_STRING_ARRAY;
  }
  return toNoNullStringArray(collection.toArray());
}
","/** 
 * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element is <code>null</code>.
 * @param collection The collection to convert
 * @return A new array of Strings.
 */
","If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array. ???","1. One-line summary: Converts a collection to a string array excluding nulls.
2. Function behavior: Converts a Collection to a String array, removing null elements, or returns an empty array if the collection is null.
3. Function signature: @param collection Collection<?>: The collection to be converted @return String[]: A non-null string array after conversion
4. Examples: null -> [] (null input returns an empty array) [""a"", null, ""b""] -> [""a"", ""b""] (removes nulls) [] -> [] (empty collection returns empty array)
5. Preconditions & Postconditions: The input collection can be null or contain nulls; the output array contains only non-null strings or is empty."
636767081a6d9265ec0179a2,isAllZeros,"private static boolean isAllZeros(String s){
  if (s == null) {
    return true;
  }
  for (int i=s.length() - 1; i >= 0; i--) {
    if (s.charAt(i) != '0') {
      return false;
    }
  }
  return s.length() > 0;
}
","/** 
 * <p>Utility method for  {@link #createNumber(String)}.</p> <p>Returns <code>true</code> if s is <code>null</code>.</p>
 * @param s the String to check
 * @return if it is all zeros or <code>null</code>
 */
",Check whether a character string is all consist of zero. ,"1. One-line summary: Checks if a string consists entirely of zeros.

2. Function behavior: Returns true if the input string is null or contains only zero characters. Returns false if the string has any non-zero characters.

3. Function signature:
@param s String: Input string to check
@return boolean: True if the string is null or all zeros, false otherwise

4. Examples: 
null -> true (input is null)
""000"" -> true (all characters are zeros)
""100"" -> false (contains a non-zero character)

5. Preconditions & Postconditions: Input can be null; output is true if input is null or contains only zeros, otherwise false."
636767e01a6d9265ec018764,convertProperties,"private JsonObject convertProperties(List<KeyStringValuePair> properties){
  final JsonObject result=new JsonObject();
  for (  KeyStringValuePair kv : properties) {
    result.addProperty(kv.getKey(),kv.getValue());
  }
  return result;
}
","/** 
 * Convert process properties to source data
 */
",Convert process properties to the JsonObject.,"1. One-line summary: Converts a list of key-value pairs to a JsonObject.
2. Function behavior: The function iterates over a list of KeyStringValuePair objects and adds each key-value pair as a property in a new JsonObject. The resulting JsonObject contains all the key-value pairs from the input list.
3. Function signature:
   @param properties List<KeyStringValuePair>: List containing key-value pairs to be converted.
   @return JsonObject: JsonObject containing the converted properties.
4. Examples: 
   [{""key"":""name"",""value"":""John""}] -> {""name"":""John""} (single pair conversion)
   [{""key"":""age"",""value"":""25""}, {""key"":""country"",""value"":""USA""}] -> {""age"":""25"",""country"":""USA""} (multiple pairs conversion)
   [] -> {} (empty list to empty JsonObject)
5. Preconditions & Postconditions: Properties list should not contain null keys; result JsonObject will have all input key-value pairs."
636766ff1a6d9265ec017853,readLabel,"protected Label readLabel(final int bytecodeOffset,final Label[] labels){
  if (labels[bytecodeOffset] == null) {
    labels[bytecodeOffset]=new Label();
  }
  return labels[bytecodeOffset];
}
","/** 
 * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.
 * @param bytecodeOffset a bytecode offset in a method.
 * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.
 * @return a non null Label, which must be equal to labels[bytecodeOffset].
 */
","Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.","1. One-line summary: Ensures a non-null Label at a given index in an array.
2. Function behavior: Checks if the Label at the specified bytecode offset is null. If null, it initializes a new Label at that position and returns it.
3. @param bytecodeOffset int: The index in the labels array to check and potentially initialize.
   @param labels Label[]: An array of Label objects.
   @return Label: The Label at the specified index after ensuring it is non-null.
4. Examples: 
   [null, L1, L2], 0 -> L0 (initialized new Label at index 0)
   [L0, L1, L2], 1 -> L1 (returned existing Label at index 1)
   [L0, null, L2], 1 -> L1 (initialized new Label at index 1)
5. Preconditions & Postconditions: bytecodeOffset must be within labels' bounds; ensures Label at specified index is non-null."
6367677d1a6d9265ec0182fd,toBoolean,"public static boolean toBoolean(String value,boolean dEfault){
  if (value == null)   return dEfault;
  String trimmedVal=value.trim();
  if (""true"".equalsIgnoreCase(trimmedVal))   return true;
  if (""false"".equalsIgnoreCase(trimmedVal))   return false;
  return dEfault;
}
","/** 
 * If <code>value</code> is ""true"", then <code>true</code> is returned. If <code>value</code> is ""false"", then <code>true</code> is returned. Otherwise, <code>default</code> is returned. <p>Case of value is unimportant.  
 */
","Check whether a string is true or false after ignore cases and trim the whitespaces at both ends. If so, its boolean value is returned. Otherwise, dEfault is returned.","1. One-line summary: Converts a string to a boolean or returns a default if null or unrecognized.
2. Function behavior: The function checks if a string is ""true"" or ""false"" (case-insensitive) and returns corresponding boolean; if null or unrecognized, it returns a specified default value.
3. Function signature:
@param value String: Input string to convert.
@param dEfault boolean: Default return value if input is null or unrecognized.
@return boolean: Converted boolean value or the default.
4. Examples: 
""true"", false -> true (matches ""true"")
""TrUe"", true -> true (case insensitive match)
""no"", false -> false (unrecognized string, returns default)
null, true -> true (null input, returns default)
5. Preconditions & Postconditions: Input string can be null; returns a boolean true, false, or the default value if unrecognized."
6367676a1a6d9265ec0181cd,trimLeadingWhitespace,"public static String trimLeadingWhitespace(String str){
  if (!hasLength(str)) {
    return str;
  }
  StringBuilder sb=new StringBuilder(str);
  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {
    sb.deleteCharAt(0);
  }
  return sb.toString();
}
","/** 
 * Trim leading whitespace from the given String.
 * @param str the String to check
 * @return the trimmed String
 * @see java.lang.Character#isWhitespace
 */
",Trim the leading whitespaces in a string.,"1. One-line summary: Removals leading whitespace from a string.
2. Function behavior: Iterates through a string and removes spaces from the start until no leading space is left, returning the modified string.
3. Function signature: 
   @return String: The trimmed string with no leading whitespace.
4. Examples: 
   ""  hello"" -> ""hello"" (leading spaces removed)
   ""\thello"" -> ""hello"" (leading tab removed)
   ""hello"" -> ""hello"" (no leading whitespace present)
5. Preconditions & Postconditions: Input string is non-null, returns string without leading whitespace."
636766fe1a6d9265ec01782a,readUtf,"final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){
  String value=constantUtf8Values[constantPoolEntryIndex];
  if (value != null) {
    return value;
  }
  int cpInfoOffset=cpInfoOffsets[constantPoolEntryIndex];
  return constantUtf8Values[constantPoolEntryIndex]=readUtf(cpInfoOffset + 2,readUnsignedShort(cpInfoOffset),charBuffer);
}
","/** 
 * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}.
 * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pooltable.
 * @param charBuffer the buffer to be used to read the string. This buffer must be sufficientlylarge. It is not automatically resized.
 * @return the String corresponding to the specified CONSTANT_Utf8 entry.
 */
",Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.,"1. One-line summary: Reads a UTF-8 string from a constant pool.
2. Function behavior: Retrieves or computes a UTF-8 string from a constant pool using its index and stores it for future access.
3. Function signature:
@param constantPoolEntryIndex int: Index of the constant pool entry.
@param charBuffer char[]: Buffer used during string reading.
@return String: The UTF-8 string from the constant pool.
4. Examples: 
0, [] -> ""exampleString"" (returns stored or computed UTF-8 string)
1, ['a','b'] -> ""anotherString"" (returns stored or computed UTF-8 string)
5. Preconditions & Postconditions: Requires valid index within constant pool; returns a UTF-8 string or null if not found."
636766851a6d9265ec01751b,decodeHexNibble,"private static char decodeHexNibble(final char c){
  if ('0' <= c && c <= '9') {
    return (char)(c - '0');
  }
 else   if ('a' <= c && c <= 'f') {
    return (char)(c - 'a' + 10);
  }
 else   if ('A' <= c && c <= 'F') {
    return (char)(c - 'A' + 10);
  }
 else {
    return Character.MAX_VALUE;
  }
}
","/** 
 * Helper to decode half of a hexadecimal number from a string.
 * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}.
 * @return The hexadecimal value represented in the ASCII charactergiven, or  {@link Character#MAX_VALUE} if the character is invalid.
 */
",Convert a hexadecimal number to binary and return its character type.,"1. One-line summary: Converts a hex character to its decimal value or returns a max character.
2. Function behavior: Maps a hexadecimal character to its integer value or returns a max value character if invalid.
3. Function signature:
@return char: The corresponding decimal value of the hex character or Character.MAX_VALUE if invalid.
4. Examples: '0' -> 0, 'a' -> 10, 'F' -> 15, 'g' -> Character.MAX_VALUE (not a valid hex)
5. Preconditions & Postconditions: Input must be a single character; returns a character representing decimal or max value."
636766f21a6d9265ec01767d,toString,"public static String toString(Object object){
  return (object == null) ? null : object.toString();
}
","/** 
 * Object to String ,when null object then null else return toString(); 
 */
","Convert object to string  if the object is not null. Otherwise, null is returned.","1. One-line summary: Converts an object to a string representation.
2. Function behavior: Returns the string form of an object or null if the object is null.
3. Function signature:
@return String: A string representation of the object or null.
4. Examples: 
null -> null (Object is null)
""Hello"" -> ""Hello"" (String object)
123 -> ""123"" (Integer converted to string)
5. Preconditions & Postconditions: Input can be any object; output is string or null."
636767581a6d9265ec017fc4,factorial,"public static long factorial(int n){
  long multi=1;
  for (int i=1; i <= n; i++) {
    multi=multi * i;
  }
  return multi;
}
","/** 
 * Calculate the factorial of $n$.
 * @param n the input number
 * @return the factorial
 */
",Calculate the factorial of the given number.,"1. One-line summary: Computes the factorial of a given integer.
2. Function behavior: The function multiplies all integers from 1 to n to compute the factorial. The result is returned as a long integer.
3. Function signature: 
@param n int: The integer for which the factorial is calculated.
@return long: The factorial of the input integer.
4. Examples: 
5 -> 120 (factorial of 5)
1 -> 1 (factorial of 1)
0 -> 1 (factorial of 0)
5. Preconditions & Postconditions: The input must be a non-negative integer, and the output will be the factorial of the input."
636767511a6d9265ec017eb6,selectOnOuterFace,"private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){
  OuterFaceCirculator circulator=start.iterator(dir);
  Node current=circulator.next();
  while (current != stop && !predicate.test(current)) {
    current=circulator.next();
  }
  return circulator;
}
","/** 
 * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate} or returns a circulator to the {@code stop} node.
 * @param predicate the condition the desired node should satisfy
 * @param start the node to start the search from
 * @param stop the node to end the search with
 * @param dir the direction to start the traversal in
 * @return a circulator to the node satisfying the {@code predicate} or to the {@code stop} node
 */
",Find a circulator to the node that satisfies the Interface predicate.,"1. One-line summary: Iterates through nodes on an outer face in a specific direction until a condition is met or a stop node is reached.
2. Function behavior: Starts from a node and iterates in a given direction using a circulator, stopping when either a predicate is satisfied or the stop node is reached, returning the circulator.
3. Function signature:
   @param predicate Predicate<Node>: Condition to be satisfied.
   @param start Node: Starting node for iteration.
   @param stop Node: Node where iteration stops unconditionally.
   @param dir int: Direction of iteration.
   @return OuterFaceCirculator: Circulator positioned at the found node or stop node.
4. Examples: 
   predicate matches, start, end, 1 -> circulator (predicate matched)
   no match, start, end, 1 -> circulator (reached end)
   predicate matches, start, end, -1 -> circulator (predicate matched in reverse)
5. Preconditions & Postconditions: Preconditions include valid nodes and a direction; postconditions guarantee a circulator on the node satisfying the predicate or on the stop node."
636767841a6d9265ec0183e8,add,"public void add(LoggingEvent event){
  ea[last]=event;
  if (++last == maxSize)   last=0;
  if (numElems < maxSize)   numElems++;
 else   if (++first == maxSize)   first=0;
}
","/** 
 * Add an <code>event</code> as the last event in the buffer.
 */
",Add an event as the last event in the buffer.,"1. One-line summary: Add an event to a circular buffer.
2. Function behavior: Inserts a LoggingEvent into a circular array buffer, updating pointers for head and tail as needed, and maintaining size constraints.
3. Function signature: 
   @param event LoggingEvent: the event to add to the buffer
4. Examples: 
   input -> 1st event added (circular buffer initially empty)
   input -> 11th event wraps around (buffer size 10, overwriting the oldest)
   input -> 5th event added without wrapping (buffer not full yet)
5. Preconditions & Postconditions: Buffer size maximum is maxSize; elements overwrite older ones when full."
636767a41a6d9265ec01857e,compareSigned,"private static int compareSigned(long a,long b){
  return (a < b) ? -1 : ((a > b) ? 1 : 0);
}
","/** 
 * Compares the two specified  {@code long} values. The sign of the value returned is the same as that of{@code ((Long) a).compareTo(b)}. <p> <b>Note for Java 7 and later:</b> this method should be treated as deprecated; use the equivalent {@link Long#compare} method instead.
 * @param a the first  {@code long} to compare
 * @param b the second  {@code long} to compare
 * @return a negative value if {@code a} is less than {@code b}; a positive value if  {@code a} is greater than{@code b}; or zero if they are equal
 */
",Compare two numbers.,"1. One-line summary: Compares two long integers.
2. Function behavior: Determines if one long integer is less than, greater than, or equal to another. Returns -1, 1, or 0 based on comparison.
3. Function signature:
   @param a long: first integer to compare
   @param b long: second integer to compare
   @return int: -1 if a < b, 1 if a > b, 0 if equal
4. Examples: 
   5L, 10L -> -1 (5 is less than 10)
   10L, 5L -> 1 (10 is greater than 5)
   10L, 10L -> 0 (10 is equal to 10)
5. Preconditions & Postconditions: Inputs are long integers; outputs an integer indicating comparison result."
636766a91a6d9265ec0175ae,putByteArray,"public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){
  if (length + byteLength > data.length) {
    enlarge(byteLength);
  }
  if (byteArrayValue != null) {
    System.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);
  }
  length+=byteLength;
  return this;
}
","/** 
 * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.
 * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.
 * @param byteOffset     index of the first byte of byteArrayValue that must be copied.
 * @param byteLength     number of bytes of byteArrayValue that must be copied.
 * @return this byte vector.
 */
",Add a byte array into the byte vector.,"1. One-line summary: Appends a specified subarray to a ByteVector.
2. Function behavior: It copies a section of a byte array into a ByteVector, enlarging the storage if needed, and updates the length.
3. Function signature:
@param byteArrayValue byte[]: The source byte array to be copied.
@param byteOffset int: The starting position in the byte array to begin copying.
@param byteLength int: The number of bytes to copy.
@return ByteVector: Returns the updated ByteVector instance.
4. Examples: 
[1,2,3,4], 1, 2 -> ByteVector (Copies [2,3] to ByteVector)
null, 0, 3 -> ByteVector (Does nothing if source is null)
[1,2,3], 0, 3 -> ByteVector (Copies entire byte array)
5. Preconditions & Postconditions: byteArrayValue can be null; byteOffset and byteLength must define a valid range within the byte array; the ByteVector is enlarged as needed during appending."
636766f11a6d9265ec01764f,values,"public Collection<Object> values(){
  ArrayList<Object> answer=new ArrayList<>(readMethods.size());
  for (Iterator<Object> iter=valueIterator(); iter.hasNext(); ) {
    answer.add(iter.next());
  }
  return Collections.unmodifiableList(answer);
}
","/** 
 * Returns the values for the BeanMap.
 * @return values for the BeanMap. The returned collection is not modifiable.
 */
",Return an unmodifiable list that contains all methods in the BeanMap.,"1. One-line summary: Returns an unmodifiable list of object values.
2. Function behavior: The function iterates through a collection, collects object values, and returns them as an unmodifiable list.
3. Function signature: 
@return Collection<Object>: A list of object values that cannot be modified.
4. Examples: [] -> [] (empty collection returns an empty list), [1, 2, 3] -> [1, 2, 3] (returns a list with same elements), [null, ""text""] -> [null, ""text""] (includes nulls and strings)
5. Preconditions & Postconditions: The collection must be iterable; output is unmodifiable and reflects the exact content and order of the input collection."
636766f81a6d9265ec017758,hashCode,"@Override public int hashCode(){
  int hashCode=13 * (sort == INTERNAL ? OBJECT : sort);
  if (sort >= ARRAY) {
    for (int i=valueBegin, end=valueEnd; i < end; i++) {
      hashCode=17 * (hashCode + valueBuffer.charAt(i));
    }
  }
  return hashCode;
}
","/** 
 * Returns a hash code value for this type.
 * @return a hash code value for this type.
 */
",Compute a hash code according to the type.,"1. One-line summary: Computes hash code for an object based on its sort and value buffer.
2. Function behavior: Calculates a hash code by first considering a sort-based multiplier, then iterating over a character buffer to further modify the hash code if the sort type is ARRAY or higher.
3. Function signature: 
   @return int: The computed hash code for this object.
4. Examples: sort=INTERNAL, valueBegin=0, valueEnd=3, valueBuffer=""abc"" -> 552 (based on character values)
   sort=EXTERNAL, valueBegin=1, valueEnd=4, valueBuffer=""defgh"" -> varies (different character range)
   sort=ARRAY, valueBegin=0, valueEnd=2, valueBuffer=""xy"" -> varies (ARRAY sort affects calculation)
5. Preconditions & Postconditions: Preconditions: sort is a valid integer, valueBuffer is correctly initialized string. Postconditions: Returns an integer hash code for the object."
6367676c1a6d9265ec01820b,deleteAny,"public static String deleteAny(String inString,String charsToDelete){
  if (!hasLength(inString) || !hasLength(charsToDelete)) {
    return inString;
  }
  StringBuilder sb=new StringBuilder();
  for (int i=0; i < inString.length(); i++) {
    char c=inString.charAt(i);
    if (charsToDelete.indexOf(c) == -1) {
      sb.append(c);
    }
  }
  return sb.toString();
}
","/** 
 * Delete any character in a given String.
 * @param inString the original String
 * @param charsToDelete a set of characters to delete.E.g. ""az\n"" will delete 'a's, 'z's and new lines.
 * @return the resulting String
 */
",Delete characters that exists in the intersection between two character strings of the first character string and return the first character string that is modified.,"1. One-line summary: Remove specified characters from input string.
2. Function behavior: The function removes all characters in `charsToDelete` from `inString` and returns the result. It does nothing if either string is empty.
3. Function signature: 
@param inString String: Input string to process
@param charsToDelete String: Characters to remove from the input string
@return String: Resulting string after removals
4. Examples: 
""hello"", ""l"" -> ""heo"" (removes 'l' from ""hello"")
""abcdef"", ""xz"" -> ""abcdef"" (removes no characters)
""abcabc"", ""abc"" -> """" (removes all 'a', 'b', and 'c')
5. Preconditions & Postconditions: Input strings are non-null; output retains input order minus deletions."
636766861a6d9265ec01755a,match,"public final MatchResult match(CharSequence uri){
  if (uri == null || uri.length() == 0)   return (regexPattern == null) ? EMPTY_STRING_MATCH_RESULT : null;
 else   if (regexPattern == null)   return null;
  Matcher m=regexPattern.matcher(uri);
  if (!m.matches())   return null;
  return (groupIndexes.length > 0) ? new GroupIndexMatchResult(m) : m;
}
","/** 
 * Match a URI against the pattern.
 * @param uri the uri to match against the template.
 * @return the match result, otherwise null if no match occurs.
 */
","If the match between the url and the pattern occurs, return the match result. Otherwise, return null.","1. One-line summary: Matches a URI with a regex pattern.
2. Function behavior: Matches the given URI against a regex pattern and returns a match result or null if no match is found.
3. Function signature: 
   @param uri CharSequence: The URI to match.
   @return MatchResult: The match result or null if no match is found.
4. Examples: 
   ""http://example.com"" -> MatchResult (match successful)
   null -> null (null input)
   """" -> null (empty input)
5. Preconditions & Postconditions: URI may be null or empty, returns a match result if the pattern matches, otherwise null."
636766f91a6d9265ec01777d,convertHexDigit,"public static byte convertHexDigit(byte b){
  if ((b >= '0') && (b <= '9'))   return (byte)(b - '0');
  if ((b >= 'a') && (b <= 'f'))   return (byte)(b - 'a' + 10);
  if ((b >= 'A') && (b <= 'F'))   return (byte)(b - 'A' + 10);
  throw new IllegalArgumentException(""!hex:"" + Integer.toHexString(0xff & b));
}
","/** 
 * @param b An ASCII encoded character 0-9 a-f A-F
 * @return The byte value of the character 0-16.
 */
",Convert an ASCII encoded character to hex.,"1. One-line summary: Converts a hexadecimal digit byte to its decimal value.
2. Function behavior: Takes a byte representation of a hexadecimal digit and returns its decimal value. Throws an exception if the byte is not a valid hex digit.
3. Function signature:
@param b byte: hexadecimal digit as a byte
@return byte: decimal value of the hex digit
@throws IllegalArgumentException: if the input is not a valid hex digit
4. Examples: 
'0' -> 0
'a' -> 10
'F' -> 15
5. Preconditions & Postconditions: Input must represent a single hex digit. Output is a byte representing the decimal equivalent, exception on invalid input."
636767861a6d9265ec01844c,removeAppender,"public void removeAppender(String name){
  if (name == null || appenderList == null)   return;
  int size=appenderList.size();
  for (int i=0; i < size; i++) {
    if (name.equals(((Appender)appenderList.elementAt(i)).getName())) {
      appenderList.removeElementAt(i);
      break;
    }
  }
}
","/** 
 * Remove the appender with the name passed as parameter form the list of appenders.  
 */
",Remove the appender by the given name from the list of appenders.,"1. One-line summary: Remove an appender by name from a list.
2. Function behavior: This function removes the appender with the specified name from the appenderList if it exists. If the list or the name is null, the function does nothing.
3. Function signature: @param name String: The name of the appender to remove.
4. Examples: ""appender1"" -> removes appender1 (if present) ""appender2"" -> does nothing (if not present) null -> does nothing (null check)
5. Preconditions & Postconditions: The appenderList must be initialized; it will be modified by removing the specified appender if present."
6367670c1a6d9265ec017a2a,toPrimitive,"public static int[] toPrimitive(final Integer[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_INT_ARRAY;
  }
  final int[] result=new int[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].intValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Integers to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Integer</code> array, may be <code>null</code>
 * @return an <code>int</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Convert the given Integer array to primitives. Return ArrayUtils.EMPTY_INT_ARRAY for an empty array, return null for null array.","1. One-line summary: Converts Integer array to primitive int array.
2. Function behavior: The function converts an array of Integer objects to an array of primitive ints. It returns an empty array if the input array is empty.
3. Function signature: 
@param array Integer[]: The array of Integer objects to convert.
@return int[]: The resulting array of primitive int values.
4. Examples: 
null -> null (returns null for input null)
[] -> [] (returns empty array for empty input)
[1, 2, 3] -> [1, 2, 3] (converts Integer array to int array)
5. Preconditions & Postconditions: Input can be null or empty, output matches input length with Integer values converted to ints."
636767041a6d9265ec017911,register,"static void register(Object value){
  if (value != null) {
    Map m=getRegistry();
    if (m == null) {
      m=new WeakHashMap();
      REGISTRY.set(m);
    }
    m.put(value,null);
  }
}
","/** 
 * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>
 * @param value The object to register.
 */
",Register the value in REGISTRY if the value is not null.,"1. One-line summary: Registers a non-null object into a thread-local registry.

2. Function behavior: If the provided object is not null, it retrieves or initializes a WeakHashMap from thread-local storage and inserts the object as a key with a null value.

3. Function signature: 
@param value Object: The object to be registered.

4. Examples: 
register(null) -> no change (value is null)
register(""newValue"") -> ""newValue"" added (adds non-null value)

5. Preconditions & Postconditions: Preconditions: `value` is an object. Postconditions: If `value` is non-null, it's added as a key with null value to the registry map."
636767511a6d9265ec017eb0,nonZeros,"public int nonZeros(int row){
  assert row >= 0 && row < rowOffsets.length;
  return rowOffsets[row + 1] - rowOffsets[row];
}
","/** 
 * Get the number of non-zero entries of a row.
 * @param row the row
 * @return the number of non-zero entries of a row
 */
",Return the number of non-zero entries of a row.,"1. One-line summary: Calculates the number of non-zero elements in a specified row.
2. Function behavior: The function computes the difference between the values of consecutive row offsets to determine non-zero entries in a given row of a sparse matrix.
3. Function signature:
@param row int: Index of the matrix row for which non-zero elements are counted.
@return int: The count of non-zero elements in the specified row.
@throws AssertionError: If the row index is out of bounds.
4. Examples: 
row = 0 -> 5 (if rowOffsets[1] = 5, rowOffsets[0] = 0)
row = 1 -> 3 (if rowOffsets[2] = 8, rowOffsets[1] = 5)
row = 2 -> 2 (if rowOffsets[3] = 10, rowOffsets[2] = 8)
5. Preconditions & Postconditions: The row index must be within the valid range; on success, the function returns the number of non-zero elements in the specified row."
6367676c1a6d9265ec018223,containsInstance,"public static boolean containsInstance(Collection collection,Object element){
  if (collection != null) {
    for (    Object candidate : collection) {
      if (candidate == element) {
        return true;
      }
    }
  }
  return false;
}
","/** 
 * Check whether the given Collection contains the given element instance. <p>Enforces the given instance to be present, rather than returning <code>true</code> for an equal element as well.
 * @param collection the Collection to check
 * @param element the element to look for
 * @return <code>true</code> if found, <code>false</code> else
 */
",Check whether the element exists in the collection. ,"1. One-line summary: Checks if a collection contains a specific instance.

2. Function behavior: The function iterates over the collection to see if the specific object instance is present. Returns true if found, false otherwise.

3. Function signature:
@param collection Collection: the collection to be searched
@param element Object: the specific instance to look for
@return boolean: true if the instance is found, false otherwise

4. Examples: 
[1, 2, 3], 2 -> false (compares instance, not value equality)
[a, b, c], b -> true (same instance of 'b')
null, anyObject -> false (null collection)

5. Preconditions & Postconditions: Assumes a non-null collection iterates its elements, only considers instance reference, not value equality. Returns false if the collection is null."
636766fa1a6d9265ec01779d,isAsciiControl,"public static boolean isAsciiControl(final char ch){
  return ch < 32 || ch == 127;
}
","/** 
 * <p>Checks whether the character is ASCII 7 bit control.</p> <pre> CharUtils.isAsciiControl('a')  = false CharUtils.isAsciiControl('A')  = false CharUtils.isAsciiControl('3')  = false CharUtils.isAsciiControl('-')  = false CharUtils.isAsciiControl('\n') = true CharUtils.isAsciiControl('&copy;') = false </pre>
 * @param ch  the character to check
 * @return true if less than 32 or equals 127
 */
",Check whether the character is ASCII 7 bit control.,"1. One-line summary: Checks if a character is an ASCII control character.
2. Function behavior: Determines if a given character is a control character in the ASCII range by returning true if it is less than 32 or equals 127.
3. Function signature:
   @param ch char: Character to evaluate
   @return boolean: True if the character is an ASCII control character, otherwise false
4. Examples: 
   'A' -> false (Printable character)
   '\n' -> true (Newline is a control character)
   127 -> true (Delete is a control character)
5. Preconditions & Postconditions: Accepts a single character as input, returns a boolean indicating control character status within ASCII limits."
6367670b1a6d9265ec0179f2,containsKey,"@Override public boolean containsKey(final Object key){
  if (this.fast) {
    return this.map.containsKey(key);
  }
 else {
synchronized (this.map) {
      return this.map.containsKey(key);
    }
  }
}
","/** 
 * Return <code>true</code> if this map contains a mapping for the specified key.
 * @param key  the key to be searched for
 * @return true if the map contains the key
 */
",Check whether a map contains a mapping for the specified key.,"1. One-line summary: Check if a key exists in the map.
2. Function behavior: Returns true if the key is present in the map, utilizing synchronization if the map is not accessed fast.
3. Function signature: 
   @param key Object: Key to check for existence in the map.
   @return boolean: True if the key is present, false otherwise.
4. Examples: 
   ""key1"" -> true (key found)
   ""key2"" -> false (key not found)
5. Preconditions & Postconditions: Map must be initialized; result reflects key's presence without altering map state."
636766fa1a6d9265ec017796,toObject,"public static Boolean[] toObject(final boolean[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;
  }
  final Boolean[] result=new Boolean[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i] ? Boolean.TRUE : Boolean.FALSE;
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive booleans to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>boolean</code> array
 * @return a <code>Boolean</code> array, <code>null</code> if null array input
 */
",Convert an array of primitive booleans to objects.,"1. One-line summary: Converts a primitive boolean array to a Boolean object array.
2. Function behavior: Returns a Boolean array equivalent of the provided boolean array or null if the input is null. Returns an empty Boolean array if the input array is empty.
3. Function signature: 
@param array boolean[]: Input array of primitive booleans.
@return Boolean[]: Array of Boolean objects corresponding to input.
4. Examples: 
null -> null (null input)
[] -> [] (empty input array)
[true, false, true] -> [Boolean.TRUE, Boolean.FALSE, Boolean.TRUE] (conversion of non-empty array)
5. Preconditions & Postconditions: Input can be null or non-null, returns null, or a converted non-null Boolean array respectively."
636767aa1a6d9265ec01864a,toByteArray,"public byte[] toByteArray(){
  final int size=bytes.length;
  final byte[] copy=new byte[size];
  System.arraycopy(bytes,0,copy,0,size);
  return copy;
}
","/** 
 * Copies bytes to a  {@code byte[]}.
 */
",Copy bytes to a byte array.,"1. One-line summary: Returns a copy of the byte array.
2. Function behavior: Creates and returns a new byte array that is a copy of the 'bytes' array.
3. Function signature: 
@return byte[]: A copy of the internal byte array.
4. Examples: 
[1, 2, 3] -> [1, 2, 3] (returns a duplicate array)
[] -> [] (returns an empty array)
[10, 20, 30] -> [10, 20, 30] (returns a duplicate array)
5. Preconditions & Postconditions: Assumes 'bytes' is non-null, returns an identical array copy with the same content."
636767561a6d9265ec017f7c,edgeSetToTour,"protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){
  List<V> vertices=new ArrayList<>(tour.size() + 1);
  MaskSubgraph<V,E> tourGraph=new MaskSubgraph<>(graph,v -> false,e -> !tour.contains(e));
  new DepthFirstIterator<>(tourGraph).forEachRemaining(vertices::add);
  return vertexListToTour(vertices,graph);
}
","/** 
 * Transform from a Set representation to a graph path.
 * @param tour a set containing the edges of the tour
 * @param graph the graph
 * @return a graph path
 */
",Convert a set representation to a graph path.,"1. One-line summary: Converts a set of edges into a tour path on the graph.
2. Function behavior: Constructs a tour path from a given set of edges and returns it as a GraphPath. Uses a MaskSubgraph to filter out non-tour edges and performs a depth-first traversal.
3. Function signature: 
   @param tour Set<E>: Set of edges that form the tour.
   @param graph Graph<V,E>: The graph containing vertices and edges.
   @return GraphPath<V,E>: A path object representing the tour through the graph.
4. Examples: 
   Set of edges, complete graph -> a valid tour path (produces a tour using provided edges)
   Empty edge set, graph -> empty path (no edges, no tour)
5. Preconditions & Postconditions: Edges must form a continuous path; the graph must contain vertices and edges. The function outputs a valid graph path based on input edges."
6367670a1a6d9265ec0179f1,toObject,"public static Short[] toObject(final short[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;
  }
  final Short[] result=new Short[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=new Short(array[i]);
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive shorts to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>short</code> array
 * @return a <code>Short</code> array, <code>null</code> if null array input
 */
",Convert an array of primitive shorts to objects.,"1. One-line summary: Converts a primitive short array to a Short object array.
2. Function behavior: The toObject function converts a given array of primitive shorts into an array of Short objects, returning null or a predefined constant if the input is null or empty, respectively.
3. Function signature: 
@param array short[]: The array of primitive shorts to convert.
@return Short[]: The array of Short objects, or null/constant array if input is null/empty.
4. Examples: null -> null (null input returns null) [] -> ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY (empty input returns empty constant) [1, 2, 3] -> [1, 2, 3] (converts to Short objects)
5. Preconditions & Postconditions: Inputs must be an array of primitive shorts, output will be a corresponding array of Short objects or a specific constant if empty."
6367676c1a6d9265ec018204,concatenateStringArrays,"public static String[] concatenateStringArrays(String[] array1,String[] array2){
  if (Objects.isEmpty(array1)) {
    return array2;
  }
  if (Objects.isEmpty(array2)) {
    return array1;
  }
  String[] newArr=new String[array1.length + array2.length];
  System.arraycopy(array1,0,newArr,0,array1.length);
  System.arraycopy(array2,0,newArr,array1.length,array2.length);
  return newArr;
}
","/** 
 * Concatenate the given String arrays into one, with overlapping array elements included twice. <p>The order of elements in the original arrays is preserved.
 * @param array1 the first array (can be <code>null</code>)
 * @param array2 the second array (can be <code>null</code>)
 * @return the new array (<code>null</code> if both given arrays were <code>null</code>)
 */
",Concatenate two string arrays into one.,"1. One-line summary: Concatenates two string arrays.
2. Function behavior: This function merges two string arrays into one, returning the combined array. If either array is empty, it returns the non-empty array.
3. Function signature:
@param array1 String[]: First array of strings to concatenate
@param array2 String[]: Second array of strings to concatenate
@return String[]: New array containing all elements of both input arrays
4. Examples: [""a"", ""b""], [""c"", ""d""] -> [""a"", ""b"", ""c"", ""d""] (combines two non-empty arrays) [], [""x"", ""y""] -> [""x"", ""y""] (first array is empty) [""p"", ""q""], [] -> [""p"", ""q""] (second array is empty)
5. Preconditions & Postconditions: Arrays are non-null; returns a new array with combined elements, preserving order."
6367676a1a6d9265ec0181d4,addStringToArray,"public static String[] addStringToArray(String[] array,String str){
  if (Objects.isEmpty(array)) {
    return new String[]{str};
  }
  String[] newArr=new String[array.length + 1];
  System.arraycopy(array,0,newArr,0,array.length);
  newArr[array.length]=str;
  return newArr;
}
","/** 
 * Append the given String to the given String array, returning a new array consisting of the input array contents plus the given String.
 * @param array the array to append to (can be <code>null</code>)
 * @param str the String to append
 * @return the new array (never <code>null</code>)
 */
",Append a string to a string array.,"1. One-line summary: Adds a string to the end of an array.
2. Function behavior: The function checks if the given array is empty or null, creates a new array of the original size plus one, copies all elements, adds the given string to the end, and returns the new array.
3. Function signature:
   @param array String[]: The original array to which the string will be added
   @param str String: The string to add to the array
   @return String[]: The new array with the added string
4. Examples: 
   [""a"", ""b""], ""c"" -> [""a"", ""b"", ""c""] (adds ""c"" to array end)
   [], ""a"" -> [""a""] (adds ""a"" to new array)
   null, ""b"" -> [""b""] (handles null array)
5. Preconditions & Postconditions: The array can be null or empty; the returned array is always non-null and contains all original elements plus the new string at the end."
6367676b1a6d9265ec0181dd,countOccurrencesOf,"public static int countOccurrencesOf(String str,String sub){
  if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {
    return 0;
  }
  int count=0;
  int pos=0;
  int idx;
  while ((idx=str.indexOf(sub,pos)) != -1) {
    ++count;
    pos=idx + sub.length();
  }
  return count;
}
","/** 
 * Returns the number of occurrences the substring  {@code sub} appears in string {@code str}.
 * @param str string to search in. Return 0 if this is null.
 * @param sub string to search for. Return 0 if this is null.
 * @return the number of occurrences the substring {@code sub} appears in string {@code str}.
 */
",Return the frequencies that the substring appears in the string.,"1. One-line summary: Count occurrences of a substring within a string.
2. Function behavior: Iterates through the main string to count non-overlapping occurrences of the given substring.
3. Function signature: 
@param str String: The main string to search within
@param sub String: The substring to count
@return int: The count of non-overlapping occurrences
4. Examples: 
""hello"", ""l"" -> 2 (two 'l's in ""hello"")
""banana"", ""na"" -> 2 (""na"" appears twice)
""abc"", ""d"" -> 0 (""d"" is not in ""abc"")
5. Preconditions & Postconditions: The function assumes non-null input strings and returns a non-negative integer representing the count."
636766fe1a6d9265ec017821,appendDetail,"protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){
  buffer.append(arrayStart);
  for (int i=0; i < array.length; i++) {
    if (i > 0) {
      buffer.append(arraySeparator);
    }
    appendDetail(buffer,fieldName,array[i]);
  }
  buffer.append(arrayEnd);
}
","/** 
 * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>
 * @param buffer  the <code>StringBuffer</code> to populate
 * @param fieldName  the field name, typically not used as already appended
 * @param array  the array to add to the <code>toString</code>,not <code>null</code>
 */
",Append a byte array to a buffer.,"1. One-line summary: Appends array details to a StringBuffer.
2. Function behavior: Appends the start marker, each byte value separated by a defined separator, and the end marker of a byte array to a StringBuffer. Recursively calls itself for each byte element in the array.
3. Function signature: 
   @param buffer StringBuffer: The buffer to append details into
   @param fieldName String: The name of the field being processed
   @param array byte[]: The array whose details are to be appended
4. Examples: 
   byte[] {1, 2} -> StringBuffer containing ""[1,2]"" (basic example)
   byte[] {} -> StringBuffer containing ""[]"" (empty array)
   byte[] {4} -> StringBuffer containing ""[4]"" (single element)
5. Preconditions & Postconditions: Assumes arrayStart, arraySeparator, and arrayEnd are predefined strings; ensures fields are correctly appended to buffer."
636767561a6d9265ec017f63,hasNext,"@Override public boolean hasNext(){
  if (current != null) {
    return true;
  }
  current=advance();
  if (current != null && nListeners != 0) {
    fireVertexTraversed(createVertexTraversalEvent(current));
  }
  return current != null;
}
","/** 
 * Checks whether there exist unvisited vertices.
 * @return true if there exist unvisited vertices.
 */
","Check whether there are unvisited vertices. If so, return true. Otherwise, return false.","1. One-line summary: Checks if there is a next element in traversal.
2. Function behavior: The function checks if the 'current' element is not null, if so, it returns true. Otherwise, it advances to the next element, possibly triggering events, before checking again.
3. Function signature:
@return boolean: True if there is a non-null next element, otherwise false.
4. Examples: current != null -> true (as current already points to an element) current == null, advance() == null -> false (no next element after advancing) current == null, advance() != null -> true (found a next element after advancing)
5. Preconditions & Postconditions: The 'current' element starts either null or pointing to an element, and may trigger events when moving to the next element. The function returns whether a subsequent non-null element is available."
636766a81a6d9265ec017586,pop,"private void pop(final int elements){
  if (outputStackTop >= elements) {
    outputStackTop-=elements;
  }
 else {
    outputStackStart-=elements - outputStackTop;
    outputStackTop=0;
  }
}
","/** 
 * Pops the given number of abstract types from the output frame stack.
 * @param elements the number of abstract types that must be popped.
 */
",Pop the given number of elements from the stack.,"1. One-line summary: Reduces output stack size by a specified number of elements.
2. Function behavior: Decreases `outputStackTop` by `elements` if possible; adjusts `outputStackStart` otherwise.
3. Function signature: @param elements int: Number of elements to pop from the stack.
4. Examples: elements=5, outputStackTop=10 -> outputStackTop=5 (Reduced successfully) elements=5, outputStackTop=2 -> outputStackTop=0, outputStackStart-3 (Adjusted start)
5. Preconditions & Postconditions: Assumes `outputStackTop` and `outputStackStart` are initialized and valid, resulting in decreased stack size."
636767e11a6d9265ec018795,isCompatible,"public boolean isCompatible(DataTable dataset){
  final List<String> sortedKeys=dataset.sortedKeys(new HeatMap.KeyComparator(true));
  long[] existedBuckets=new long[sortedKeys.size()];
  for (int i=0; i < sortedKeys.size(); i++) {
    String key=sortedKeys.get(i);
    if (key.equals(Bucket.INFINITE_NEGATIVE)) {
      existedBuckets[i]=Long.MIN_VALUE;
    }
 else {
      if (key.contains("":"")) {
        key=StringUtils.substringAfterLast(key,"":"");
      }
      existedBuckets[i]=Long.parseLong(key);
    }
  }
  return Arrays.equals(buckets,existedBuckets);
}
","/** 
 * @return true if the bucket is same.
 */
",Check whether the existed buckets are the same as the buckets.,"1. One-line summary: Checks compatibility of dataset buckets with predefined buckets.
2. Function behavior: Compares sorted keys from the dataset to predefined bucket values after processing. Returns true if both arrays of buckets match.
3. Function signature: 
@return boolean: True if dataset buckets match predefined buckets, false otherwise.
4. Examples: dataset with sortedKeys [""INFINITE_NEGATIVE"", ""1""] and buckets [Long.MIN_VALUE, 1] -> true (buckets match) | dataset with sortedKeys [""INFINITE_NEGATIVE"", ""2""] and buckets [Long.MIN_VALUE, 1] -> false (buckets do not match) | dataset with sortedKeys [""0:1"", ""2""] and buckets [1, 2] -> true (buckets match)
5. Preconditions & Postconditions: Dataset keys must be parseable integers after last colon; output is false if arrays differ in length or content."
636767611a6d9265ec018112,provideNextVertex,"@Override protected V provideNextVertex(){
  V v=super.provideNextVertex();
  for (int i=path.size() - 1; i >= 0; --i) {
    if (graph.containsEdge(path.get(i),v)) {
      break;
    }
    path.remove(i);
  }
  path.add(v);
  return v;
}
","/** 
 * {@inheritDoc}
 */
",Get next vertext from a graph.,"1. One-line summary: Provides the next vertex for a path in a graph.
2. Function behavior: Removes vertices from the path that are not connected to the next vertex, then adds the next vertex to the path and returns it.
3. Function signature: 
   @return V: The next vertex added to the path.
4. Examples: 
   currentPath with edges -> updatedPath (updates path by adding vertex)
   path with vertices not connected to v -> pruned path (removes unconnected vertices)
   no path changes needed -> same path (path remains unchanged)
5. Preconditions & Postconditions: Assumes path is non-empty and modifications will maintain path connectivity, output path will have v appended if possible."
636767131a6d9265ec017b23,addLineNumber,"final void addLineNumber(final int lineNumber){
  if (this.lineNumber == 0) {
    this.lineNumber=(short)lineNumber;
  }
 else {
    if (otherLineNumbers == null) {
      otherLineNumbers=new int[LINE_NUMBERS_CAPACITY_INCREMENT];
    }
    int otherLineNumberIndex=++otherLineNumbers[0];
    if (otherLineNumberIndex >= otherLineNumbers.length) {
      int[] newLineNumbers=new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT];
      System.arraycopy(otherLineNumbers,0,newLineNumbers,0,otherLineNumbers.length);
      otherLineNumbers=newLineNumbers;
    }
    otherLineNumbers[otherLineNumberIndex]=lineNumber;
  }
}
","/** 
 * Adds a source line number corresponding to this label.
 * @param lineNumber a source line number (which should be strictly positive).
 */
",Add the number of lines. ,"1. One-line summary: Adds a line number to an internal list.
2. Function behavior: The method adds a new line number to a list, initializing or extending the list if necessary.
3. Function signature: @param lineNumber int: The line number to be added.
4. Examples: lineNumber=5, initial=0 -> sets this.lineNumber to 5 (empty initial line number) lineNumber=10, initial=5, list=null -> initializes otherLineNumbers list and adds 10 (non-zero initial line number) lineNumber=15, list full -> extends list and adds 15 (list capacity exceeded)
5. Preconditions & Postconditions: Preconditions: lineNumber is an integer; this.lineNumber and otherLineNumbers exist. Postconditions: The line number is added to the list or initializes the list."
636767dd1a6d9265ec0186f3,overrideName,"public void overrideName(String oldName,String newName){
  for (int i=0; i < columns.length; i++) {
    if (columns[i].equals(oldName)) {
      columns[i]=newName;
    }
  }
}
","/** 
 * Keep the same name replacement as  {@link ColumnName#overrideName(String,String)}
 * @param oldName to be replaced.
 * @param newName to use in the storage level.
 */
",Change the elements whose values are oldName to newName in column,"1. One-line summary: Replaces old column names with new ones in an array.
2. Function behavior: Iterates over the columns array, replacing occurrences of oldName with newName.
3. Function signature: 
   @param oldName String: Existing column name to be replaced
   @param newName String: New column name to set
4. Examples: 
   [""A"", ""B"", ""C""], ""B"", ""D"" -> [""A"", ""D"", ""C""] (B replaced with D)
   [""A"", ""A"", ""A""], ""A"", ""Z"" -> [""Z"", ""Z"", ""Z""] (All A's replaced with Z)
   [""X"", ""Y""], ""Z"", ""W"" -> [""X"", ""Y""] (No change as Z not found)
5. Preconditions & Postconditions: Assumes columns is a non-null array of strings. After execution, columns will have all instances of oldName replaced with newName."
636767631a6d9265ec018171,unlink,"private boolean unlink(ListNodeImpl<E> node){
  ListNodeImpl<E> prev=node.prev;
  ListNodeImpl<E> next=node.next;
  if (removeListNode(node)) {
    if (size == 0) {
      head=null;
    }
 else {
      link(prev,next);
      if (head == node) {
        head=next;
      }
    }
    return true;
  }
  return false;
}
","/** 
 * Remove the non null  {@code node} from the list. 
 */
","Remove the doubly circular linked list node.If success return true,otherwise return false.","1. One-line summary: Unlinks a node from a doubly linked list.
2. Function behavior: Removes the specified node from the list and adjusts links accordingly. If the node is successfully removed, it updates the head if necessary.
3. Function signature:
   @return boolean: True if the node was removed, false otherwise.
4. Examples: 
   node in middle -> true (node removed, links updated)
   node at head -> true (node removed, head updated)
   non-existent node -> false (no change)
5. Preconditions & Postconditions: The list must contain nodes; the list size decreases if a node is removed."
6367676c1a6d9265ec018220,stripFilenameExtension,"public static String stripFilenameExtension(String path){
  if (path == null) {
    return null;
  }
  int extIndex=path.lastIndexOf(EXTENSION_SEPARATOR);
  if (extIndex == -1) {
    return path;
  }
  int folderIndex=path.lastIndexOf(FOLDER_SEPARATOR);
  if (folderIndex > extIndex) {
    return path;
  }
  return path.substring(0,extIndex);
}
","/** 
 * Strip the filename extension from the given path, e.g. ""mypath/myfile.txt"" -&gt; ""mypath/myfile"".
 * @param path the file path (may be <code>null</code>)
 * @return the path with stripped filename extension,or <code>null</code> if none
 */
",Return the path without the extension.,"1. One-line summary: Removes the file extension from a file path string.
2. Function behavior: The function checks for the last occurrence of a file extension and removes it unless it's part of a folder name.
3. Function signature:
@param path String: The input file path.
@return String: The file path without an extension.
4. Examples: 
""file.txt"" -> ""file"" (removes extension)
""folder/file"" -> ""folder/file"" (no extension found)
""folder.ext/file"" -> ""folder.ext/file"" (extension part of folder)
5. Preconditions & Postconditions: Input can be null or a valid file path; the output is the path with the extension removed, if present and applicable."
636766fe1a6d9265ec017838,toPrimitive,"public static char[] toPrimitive(final Character[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_CHAR_ARRAY;
  }
  final char[] result=new char[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].charValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Characters to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Character</code> array, may be <code>null</code>
 * @return a <code>char</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Return a string which is consist of the values of elements in the given array.If array is equal to null,return null,or return ArrayUtils.EMPTY_CHAR_ARRAY if the size of array is equal to zero.","1. One-line summary: Convert an array of Character objects to a primitive char array.
2. Function behavior: Converts a given Character array to a char array, returning null if input is null and an empty array if input is empty.
3. Function signature: 
@param array Character[]: An array of Character objects to convert.
@return char[]: A primitive char array containing the converted characters.
4. Examples: 
new Character[]{'a', 'b', 'c'} -> new char[]{'a', 'b', 'c'} (conversion of Character array to char array)
new Character[]{} -> new char[]{} (empty Character array to empty char array)
null -> null (null input returns null)
5. Preconditions & Postconditions: Input array can be null or empty, output is either null, an empty char array, or a char array of the same length."
636766fa1a6d9265ec01779c,parseToken,"private String parseToken(final char[] terminators){
  char ch;
  i1=pos;
  i2=pos;
  while (hasChar()) {
    ch=chars[pos];
    if (isOneOf(ch,terminators)) {
      break;
    }
    i2++;
    pos++;
  }
  return getToken(false);
}
","/** 
 * Parses out a token until any of the given terminators is encountered.
 * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token
 * @return the token
 */
",Parses out a token until any of the given terminators is encountered and then return the token.,"1. One-line summary: Extracts a token from a character array until a terminator is found.
2. Function behavior: It scans the character array starting at the current position and stops at the first terminator. It then returns the extracted token.
3. Function signature: @param terminators char[]: Array of characters that signify the end of a token. @return String: The extracted token from the character array.
4. Examples: ""abc,"" with terminators ',' -> ""abc"" (comma is the terminator) ""hello;world"" with terminators ';' -> ""hello"" (semicolon is the terminator) ""test123"" with terminators ' ' -> ""test123"" (no terminator found, return whole string)
5. Preconditions & Postconditions: The function assumes the character array and terminators are properly defined. The current position updates after the function processes."
636767691a6d9265ec0181a7,trimLeadingCharacter,"public static String trimLeadingCharacter(String str,char leadingCharacter){
  if (!hasLength(str)) {
    return str;
  }
  StringBuilder sb=new StringBuilder(str);
  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {
    sb.deleteCharAt(0);
  }
  return sb.toString();
}
","/** 
 * Trim all occurrences of the supplied leading character from the given String.
 * @param str the String to check
 * @param leadingCharacter the leading character to be trimmed
 * @return the trimmed String
 */
","Trim all the characters which are equal to the given character and appear at the beginning of the given string,and return the trimmed string.","1. One-line summary: Removes leading specific characters from a string.
2. Function behavior: The function removes all occurrences of a specified leading character from the beginning of a given string until a different character is encountered.
3. Function signature: 
@param str String: The input string from which leading characters are to be removed.
@param leadingCharacter char: The character to remove from the start of the string.
@return String: The modified string with leading characters removed.
4. Examples: 
""00012345"", '0' -> ""12345"" (removes all '0' from start)
""abcabc"", 'a' -> ""bcabc"" (removes first 'a')
""111111"", '1' -> """" (removes all '1' leaving empty)
5. Preconditions & Postconditions: Input may be null or empty; if non-empty, only leading specified characters are removed. After execution, the returned string should have no leading specified characters unless not present initially."
636767041a6d9265ec01790f,toObject,"public static Integer[] toObject(final int[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;
  }
  final Integer[] result=new Integer[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=new Integer(array[i]);
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive ints to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  an <code>int</code> array
 * @return an <code>Integer</code> array, <code>null</code> if null array input
 */
",Return an array of Integer objects which are converted from an array of primitive ints.,"1. One-line summary: Converts a primitive int array to an Integer object array.
2. Function behavior: The function checks for null or empty arrays and returns an array of Integer objects, each representing an element in the input array.
3. Function signature: 
   @param array int[]: Array of primitive integers to be converted.
   @return Integer[]: Array of Integer objects equivalent to the input array.
4. Examples: 
   [1, 2, 3] -> [Integer(1), Integer(2), Integer(3)] (convert elements)
   [] -> [] (empty array conversion)
   null -> null (null input returns null)
5. Preconditions & Postconditions: Input can be null or an array of any length. Output will be an array of Integer objects or null if input is null."
636766fa1a6d9265ec0177a4,toObject,"public static Double[] toObject(final double[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;
  }
  final Double[] result=new Double[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=new Double(array[i]);
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive doubles to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>double</code> array
 * @return a <code>Double</code> array, <code>null</code> if null array input
 */
",Return an array of Double objects which are converted from an array of primitive doubles.,"1. One-line summary: Converts a primitive double array to a Double object array.
2. Function behavior: The function checks if the input array is null or empty, returning null or an empty Double array respectively. It converts each element to a Double object for non-empty arrays.
3. Function signature: 
@param array double[]: Input array of primitive doubles.
@return Double[]: Converted array of Double objects.
4. Examples: null -> null (Null input returns null) [] -> [] (Empty array to empty object array) [1.0, 2.0] -> [1.0, 2.0] (Primitive to object conversion)
5. Preconditions & Postconditions: Input array can be null or of any length, function outputs null, empty object array, or a fully converted object array."
636767461a6d9265ec017d0e,computeSuffixSum,"private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){
  List<Integer> suffixSum=new ArrayList<>(Collections.nCopies(bounds.size(),0));
  long sum=0;
  for (int i=bounds.size() - 1; i >= 0; i--) {
    suffixSum.set(i,(int)Math.min(Integer.MAX_VALUE,sum));
    sum+=bounds.get(i);
  }
  return Pair.of(suffixSum,sum);
}
","/** 
 * Computes a suffix sum of the  {@code bounds}. Returns computed suffix sum and the sum of all elements in the  {@code bounds list}.
 * @param bounds list of integers.
 * @return computed pair of suffix sum list and a sum of all elements.
 */
",Return a pair of the list of suffix sum and the sum of all elements of bounds.,"1. One-line summary: Calculate reverse cumulative sums for a list.
2. Function behavior: Computes a list of suffix sums from given bounds, constraining each to Integer.MAX_VALUE, and returns this list with the total sum.
3. Function signature:
@param bounds List<Integer>: List of integers to compute suffix sums.
@return Pair<List<Integer>, Long>: Suffix sums and total sum of integers in the input list.
4. Examples:
[1, 2, 3] -> ([0, 3, 2], 6) (Calculates suffix sums and total sum)
[1000000, 2000000] -> ([0, 1000000], 3000000) (Handles large numbers)
[] -> ([], 0) (Empty input produces empty output and sum 0)
5. Preconditions & Postconditions: Input list must be non-null, output list size matches input with total sum computed."
636767491a6d9265ec017d90,reverse,"public static final <V>void reverse(V[] arr,int from,int to){
  for (int i=from, j=to; i < j; ++i, --j) {
    swap(arr,i,j);
  }
}
","/** 
 * Reverses the order of the elements in the specified range within the given array.
 * @param < V > the type of elements in the array
 * @param arr the array
 * @param from the index of the first element (inclusive) inside the range to reverse
 * @param to the index of the last element (inclusive) inside the range to reverse
 */
",Reverse the order of the given elements in the specified range.,"1. One-line summary: Reverses array elements between specified indices.
2. Function behavior: The function reverses the order of elements in the array from index 'from' to 'to'. It swaps elements symmetrically until the middle of the specified range is reached.
3. Function signature: 
   @param arr V[]: Array whose elements are to be reversed.
   @param from int: Start index of the segment to reverse.
   @param to int: End index of the segment to reverse.
4. Examples: 
   [1, 2, 3, 4, 5], 1, 3 -> [1, 4, 3, 2, 5] (subarray [2, 3, 4] reversed)
   ['a', 'b', 'c', 'd'], 0, 2 -> ['c', 'b', 'a', 'd'] (subarray ['a', 'b', 'c'] reversed)
   [5, 4, 3], 0, 2 -> [3, 4, 5] (entire array reversed)
5. Preconditions & Postconditions: Indices must be within array bounds; 'from' <= 'to'. After execution, the array elements between 'from' and 'to' are reversed."
6367674a1a6d9265ec017da9,moveAllListNodes,"private void moveAllListNodes(DoublyLinkedList<E> list){
  for (ListNodeIteratorImpl it=list.new ListNodeIteratorImpl(0); it.hasNext(); ) {
    ListNodeImpl<E> node=it.nextNode();
    assert node.list == list;
    node.list=this;
  }
  size+=list.size;
  list.size=0;
  modCount++;
  list.modCount++;
}
","/** 
 * Atomically moves all  {@link ListNode ListNodes} from {@code list} to this list as if eachnode was removed with  {@link #removeListNode(ListNodeImpl)} from {@code list} andsubsequently added to this list by  {@link #addListNode(ListNodeImpl)}.
 */
",Move the nodes of the given doubly linked list to a new list sequentially.,"1. One-line summary: Moves nodes from one list to another.
2. Function behavior: Transfers all nodes from a given list to the current list, updating list size and modification counters.
3. Function signature: 
   @param <E> DoublyLinkedList<E>: List from which nodes are moved
4. Examples: list1, list2; list2 not empty -> list1 has all nodes (list2 is empty after operation)
   list1 empty, list2 -> all nodes in list1 (list2 becomes empty)
5. Preconditions & Postconditions: Both lists are non-null, nodes from one list are moved to another, source list is emptied."
636767151a6d9265ec017b6b,startsWith,"private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){
  if (str == null || prefix == null) {
    return str == null && prefix == null;
  }
  if (prefix.length() > str.length()) {
    return false;
  }
  return str.regionMatches(ignoreCase,0,prefix,0,prefix.length());
}
","/** 
 * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>
 * @see String#startsWith(String)
 * @param str  the String to check, may be null
 * @param prefix the prefix to find, may be null
 * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.
 * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>
 */
","Return true if the given string has the specified prefix with optional cases which can be ignored,or both string and prefix are null.Otherwise return false. ","1. One-line summary: Checks if a string starts with a specified prefix.
2. Function behavior: Determines if the given string begins with the specified prefix, optionally ignoring case.
3. Function signature:
   @param str String: The main string to check.
   @param prefix String: The prefix to compare against the start of the main string.
   @param ignoreCase boolean: Whether to ignore case during comparison.
   @return boolean: True if the main string starts with the prefix, considering case sensitivity based on the ignoreCase flag.
4. Examples: 
   ""hello"", ""he"", false -> true (Exact case match)
   ""hello"", ""HE"", true -> true (Case ignored)
   ""world"", ""wo"", false -> true (Exact case match)
   ""hello"", null, false -> false (Null prefix not matched)
5. Preconditions & Postconditions: Strings may be null; function returns false if prefix is longer than the main string."
636766fe1a6d9265ec01781c,toCharacterObject,"public static Character toCharacterObject(final char ch){
  if (ch < CharUtils.CHAR_ARRAY.length) {
    return CharUtils.CHAR_ARRAY[ch];
  }
  return new Character(ch);
}
","/** 
 * <p>Converts the character to a Character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same Character object each time.</p> <pre> CharUtils.toCharacterObject(' ')  = ' ' CharUtils.toCharacterObject('A')  = 'A' </pre>
 * @param ch  the character to convert
 * @return a Character of the specified character
 */
",Return the Character object converted from the given character.,"1. One-line summary: Converts a char to a Character object using an array cache.
2. Function behavior: Checks if the character can be returned from a predefined array; otherwise, creates a new Character object.
3. Function signature: 
   @param ch char: input character
   @return Character: Character object corresponding to the input
4. Examples: 'a' -> Character object (using the array) 256 -> Character object (created new) 65 -> Character object (using the array)
5. Preconditions & Postconditions: Input character is a valid char; returns a Character object."
636766fb1a6d9265ec0177c1,isAsciiAlphaUpper,"public static boolean isAsciiAlphaUpper(final char ch){
  return ch >= 'A' && ch <= 'Z';
}
","/** 
 * <p>Checks whether the character is ASCII 7 bit alphabetic upper case.</p> <pre> CharUtils.isAsciiAlphaUpper('a')  = false CharUtils.isAsciiAlphaUpper('A')  = true CharUtils.isAsciiAlphaUpper('3')  = false CharUtils.isAsciiAlphaUpper('-')  = false CharUtils.isAsciiAlphaUpper('\n') = false CharUtils.isAsciiAlphaUpper('&copy;') = false </pre>
 * @param ch  the character to check
 * @return true if between 65 and 90 inclusive
 */
",Return true if the character is ASCII alphabetic upper case.Otherwise return false.,"1. One-line summary: Checks if a character is an uppercase ASCII letter.
2. Function behavior: Determines if the input character is an uppercase English alphabetic character by comparing its value to ASCII ranges.
3. Function signature: 
   @param ch char: Character to be evaluated
   @return boolean: True if the character is an uppercase ASCII letter, false otherwise
4. Examples: 
   'A' -> true (A is uppercase)
   'Z' -> true (Z is uppercase)
   'a' -> false (a is lowercase)
   '1' -> false (1 is not a letter)
5. Preconditions & Postconditions: Input is a single character, output is true only if the input is between 'A' and 'Z' (inclusive)."
636767781a6d9265ec018250,decide,"public int decide(LoggingEvent event){
  String msg=event.getRenderedMessage();
  if (msg == null || stringToMatch == null)   return Filter.NEUTRAL;
  if (msg.indexOf(stringToMatch) == -1) {
    return Filter.NEUTRAL;
  }
 else {
    if (acceptOnMatch) {
      return Filter.ACCEPT;
    }
 else {
      return Filter.DENY;
    }
  }
}
","/** 
 * Returns  {@link Filter#NEUTRAL} is there is no string match.
 */
",Return a decision based on the message generated by the event and whether the given string is matched.,"1. One-line summary: Determines filter result based on message match.
2. Function behavior: Checks if a message contains a specific string and returns ACCEPT, DENY, or NEUTRAL based on match and settings.
3. Function signature: 
   @param event LoggingEvent: the event containing the message.
   @return int: the filter decision, either ACCEPT, DENY, or NEUTRAL.
4. Examples: 
   message containing ""error"", acceptOnMatch=true -> Filter.ACCEPT (matches and acceptOnMatch is true)
   message containing ""error"", acceptOnMatch=false -> Filter.DENY (matches but acceptOnMatch is false)
   message not containing ""error"" -> Filter.NEUTRAL (does not match)
5. Preconditions & Postconditions: String to match and message must be non-null for relevant comparison; returns a filter result."
636766861a6d9265ec017553,isTemplateVariablePresent,"public final boolean isTemplateVariablePresent(String name){
  for (  String s : templateVariables) {
    if (s.equals(name))     return true;
  }
  return false;
}
","/** 
 * Ascertain if a template variable is a member of this template.
 * @param name name The template variable.
 * @return true if the template variable is a member of the template, otherwisefalse.
 */
","Return true if the given name is a member variable of this template,otherwise return false.","1. One-line summary: Check if a string is present in a list.
2. Function behavior: The function iterates over a list of strings and returns true if the specified string is found; otherwise, it returns false.
3. Function signature:
@param name String: the string to search for in the list.
@return boolean: true if the string is present, false otherwise.
4. Examples: ""var1"" -> true (List contains ""var1"") ""unknown"" -> false (List does not contain ""unknown"") ""template"" -> true (List contains ""template"")
5. Preconditions & Postconditions: Input string is non-null. List of template variables is initialized and non-null."
6367670a1a6d9265ec0179d9,length,"public static int length(final String str){
  return str == null ? 0 : str.length();
}
","/** 
 * Gets a String's length or <code>0</code> if the String is <code>null</code>.
 * @param str a String or <code>null</code>
 * @return String length or <code>0</code> if the String is <code>null</code>.
 * @since 2.4
 */
","Return the given string's length.If the string is null,and zero will be returned.","1. One-line summary: Returns string length or zero if null.
2. Function behavior: Determines the length of the input string. Returns 0 if the input is null.
3. Function signature: 
   @param str String: Input string to measure
   @return int: The length of the string or 0 if null
4. Examples: 
   ""hello"" -> 5 (normal case)
   null -> 0 (null input)
   """" -> 0 (empty string)
5. Preconditions & Postconditions: Input can be a string or null. Returns the length of the string or 0 for null input."
636767ab1a6d9265ec018676,isHex,"private static boolean isHex(final char c){
  return ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F');
}
","/** 
 * Is this a hex digit?
 */
","Return true if the given character is a hex digit,otherwise return false.","1. One-line summary: Checks if a character is a hexadecimal digit.
2. Function behavior: Determines if the input character c is a valid hexadecimal character (0-9, a-f, A-F).
3. Function signature: @param c char: input character to be checked @return boolean: true if c is a hexadecimal character, false otherwise
4. Examples: '0' -> true ('0' is a hex digit) 'g' -> false ('g' is not a hex digit) 'F' -> true ('F' is a hex digit)
5. Preconditions & Postconditions: Input is a single character, output is a boolean indicating if it's a hexadecimal digit."
636766f11a6d9265ec017663,isSameLength,"public static boolean isSameLength(final double[] array1,final double[] array2){
  if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {
    return false;
  }
  return true;
}
","/** 
 * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array
 */
","Return true if the length of array1 is the same as the length of array2 or both them are null,otherwise return false.","1. One-line summary: Checks if two arrays have the same length.
2. Function behavior: Returns true if both arrays are null or have the same length. Returns false if any of the arrays is null and non-empty, or if their lengths differ.
3. @param array1 double[]: First array to compare lengths.
   @param array2 double[]: Second array to compare lengths.
   @return boolean: True if arrays have the same length or both are null, false otherwise.
4. Examples: 
   [1.2, 3.4], [5.6, 7.8] -> true (same length)
   [1.2], null -> false (one is non-null)
   null, [5.6] -> false (one is non-null)
   null, null -> true (both are null)
5. Preconditions & Postconditions: Arrays can be null or of any length. The result indicates whether they are both null or have equal lengths."
636767691a6d9265ec0181a6,split,"public static String[] split(String toSplit,String delimiter){
  if (!hasLength(toSplit) || !hasLength(delimiter)) {
    return null;
  }
  int offset=toSplit.indexOf(delimiter);
  if (offset < 0) {
    return null;
  }
  String beforeDelimiter=toSplit.substring(0,offset);
  String afterDelimiter=toSplit.substring(offset + delimiter.length());
  return new String[]{beforeDelimiter,afterDelimiter};
}
","/** 
 * Split a String at the first occurrence of the delimiter. Does not include the delimiter in the result.
 * @param toSplit the string to split
 * @param delimiter to split the string up with
 * @return a two element array with index 0 being before the delimiter, andindex 1 being after the delimiter (neither element includes the delimiter); or <code>null</code> if the delimiter wasn't found in the given input String
 */
","Split the given string toSplit at the first occurrence of the given delimiter,and return two substrings that don't include the delimiter.","1. One-line summary: Splits a string into two parts based on a delimiter.  
2. Function behavior: The function splits the input string into two substrings around the first occurrence of the delimiter, if both inputs are valid.  
3. Function signature:  
@param toSplit String: The string to be split.  
@param delimiter String: The string used as a delimiter for splitting.  
@return String[]: Array containing the two parts of the input string split by the delimiter.  
4. Examples:  
""hello,world"", "","" -> [""hello"", ""world""] (splits around comma)  
""key=value"", ""="" -> [""key"", ""value""] (splits around equal sign)  
""nosplit"", "","" -> null (delimiter not present)  
5. Preconditions & Postconditions: Input strings must not be null or empty. Returns null if delimiter not found in input string."
636767601a6d9265ec0180e2,computeGlobalSeparatorList,"private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){
  List<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<>();
  for (  E edge : graph.edgeSet()) {
    V source=graph.getEdgeSource(edge);
    V target=graph.getEdgeTarget(edge);
    if (source != target) {
      List<Set<V>> edgeSeparators=findSeparators(graph,edge);
      globalSeparatorList.addAll(reformatSeparatorList(edgeSeparators,edge));
    }
  }
  return globalSeparatorList;
}
","/** 
 * Computes the global separator list of the  {@code graph}. More precisely, for every edge $e$ in the $G = (V, E)$ computes list of minimal separators $S_e$ in the neighborhood of $e$ and then concatenates these lists. Note: the result may contain duplicates
 * @return the list of minimal separators of every edge $e$ in the inspected graph
 */
","Select an edge which isn't a circle in the graph,compute the list of the minimal separators in the neighborhood of the edge and put the pair of list and edge into the return list.Repeat for each edge in the graph and then return the final list.","1. One-line summary: Constructs a list of global edge separators for a graph.
2. Function behavior: Iterates over each edge of the graph to find and format separator sets, adding them to a global list.
3. Function signature: 
@return List<Pair<List<Pair<Integer,Integer>>,E>>: List of formatted edge separators with associated edges.
4. Examples: E1 with separators S1, S2 -> [(S1, E1), (S2, E1)] (Two separators for edge E1) E2 with separator S3 -> [(S3, E2)] (Single separator for edge E2) No separators -> [] (Edge source equals target)
5. Preconditions & Postconditions: Preconditions: The graph is non-null and populated with edges. Postconditions: Returns a list of edge-based separators formatted with their corresponding edges."
636766f31a6d9265ec01768f,clone,"public static char[] clone(final char[] array){
  if (array == null) {
    return null;
  }
  return array.clone();
}
","/** 
 * <p>Clones an array returning a typecast result and handling <code>null</code>.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */
",Return a clone of the given array.,"1. One-line summary: Clones an array of characters.
2. Function behavior: The function returns a clone of the input character array. If the input is null, it returns null.
3. Function signature: 
   @param array char[]: Input character array to clone
   @return char[]: Cloned array or null if input is null
4. Examples: 
   ['a', 'b', 'c'] -> ['a', 'b', 'c'] (Cloned array)
   null -> null (Input is null)
   ['x'] -> ['x'] (Single character array)
5. Preconditions & Postconditions: Input may be null; output is a new array or null if input is null."
636766831a6d9265ec0174eb,addReverse,"private void addReverse(final File[] files){
  if (files == null)   return;
  for (int i=files.length - 1; i >= 0; --i) {
    stack.add(files[i]);
  }
}
","/** 
 * Add the specified files in reverse order.
 */
",Put the given array of files into a stack in reverse order. ,"1. One-line summary: Iterates over an array of files in reverse order and pushes them onto a stack.
2. Function behavior: Checks if the input array is null. If not, iterates the array backward and adds each file to a stack.
3. Function signature:
@param files File[]: Array of files to be added in reverse.
4. Examples: 
files = {file1, file2, file3} -> stack: {file3, file2, file1} (adds files in reverse)
files = {} -> stack: {} (no files added)
files = null -> no change (null array, returns immediately)
5. Preconditions & Postconditions: Precondition: Input array may be null. Postcondition: Files are added to the stack in reverse order if the array is not null."
636766fd1a6d9265ec017814,arrayequals,"public static boolean arrayequals(byte[] a,byte[] b,int count){
  for (int i=0; i < count; i++) {
    if (a[i] != b[i]) {
      return false;
    }
  }
  return true;
}
","/** 
 * Compares <code>count</code> first bytes in the arrays <code>a</code> and <code>b</code>.
 * @param a     The first array to compare.
 * @param b     The second array to compare.
 * @param count How many bytes should be compared.
 * @return <code>true</code> if <code>count</code> first bytes in arrays<code>a</code> and <code>b</code> are equal.
 */
","Given two arrays with the given length count,return true if the array a is equal to array b,otherwise return false.","1. One-line summary: Compares two byte arrays for equality up to a given count.
2. Function behavior: The function iterates over the first 'count' elements of two byte arrays, returning false if any pair of elements differ; true otherwise.
3. Function signature:
@param a byte[]: The first byte array.
@param b byte[]: The second byte array.
@param count int: The number of elements to compare.
@return boolean: True if the first 'count' elements are equal, false otherwise.
@throws ArrayIndexOutOfBoundsException: If 'count' exceeds array bounds.
4. Examples:
[1, 2, 3], [1, 2, 3], 3 -> true (arrays are equal)
[1, 2, 3], [1, 2, 4], 3 -> false (last elements differ)
[1, 2, 3], [1, 2, 3], 2 -> true (first two elements equal)
5. Preconditions & Postconditions: Arrays must have at least 'count' elements; the function returns a boolean indicating equality of the specified portion of arrays."
636767861a6d9265ec018440,abbreviate,"public void abbreviate(final int nameStart,final StringBuffer buf){
  int i=count;
  for (int pos=buf.indexOf(""."",nameStart); pos != -1; pos=buf.indexOf(""."",pos + 1)) {
    if (--i == 0) {
      buf.delete(nameStart,pos + 1);
      break;
    }
  }
}
","/** 
 * Abbreviate name.
 * @param buf buffer to append abbreviation.
 * @param nameStart start of name to abbreviate.
 */
","The given name can be split into several substrings by ""."",and abbreviate the name in the buf by deleting the first count substrings. ","1. One-line summary: Deletes part of a string in StringBuffer based on a count of periods.
2. Function behavior: The function removes text from a starting position up to a specified nth occurrence of a period, exclusive of the period.
3. Function signature:
@param nameStart int: starting index for the search in the buffer
@param buf StringBuffer: input string buffer to be modified
4. Examples: 
""name.Start.Method"", 1, 2 -> ""name.Method"" (deletes after second period)
""com.example.ClassName"", 0, 1 -> ""example.ClassName"" (deletes after first period)
""root.branch.leaf"", 6, 1 -> ""root.branch.leaf"" (no deletion if count exceeds number of periods)
5. Preconditions & Postconditions: The buffer should not be empty, ensures text is removed only if specified period count is found."
6367667d1a6d9265ec01741d,resolveBound,"public static Type resolveBound(TypeVariable<?> typeVariable){
  Type[] bounds=typeVariable.getBounds();
  if (bounds.length == 0)   return Unknown.class;
  Type bound=bounds[0];
  if (bound instanceof TypeVariable)   bound=resolveBound((TypeVariable<?>)bound);
  return bound == Object.class ? Unknown.class : bound;
}
","/** 
 * Resolves the first bound for the  {@code typeVariable}, returning  {@code Unknown.class} if nonecan be resolved.
 */
","Resolve the class of the first bound for the typeVariable recursively,return Unknown.class if it can't be resolved.Otherwise return the bound.","1. One-line summary: Resolve type bounds for a TypeVariable.
2. Function behavior: This function resolves the first bound of a given type variable and recursively resolves it if it's another type variable. It returns Unknown.class if there are no bounds or if the bound is Object.class.
3. Function signature: 
   @param typeVariable TypeVariable<?>: the type variable to resolve the bound for
   @return Type: the resolved type bound
4. Examples: 
   unboundedTypeVar -> Unknown.class (no bounds)
   typeVarWithBound -> SomeClass.class (first non-object bound)
   circularBound -> SomeClass.class (resolves recursively)
5. Preconditions & Postconditions: TypeVariable must be non-null; returns a resolved bound or Unknown.class if unresolved."
6367675f1a6d9265ec0180cf,isClique,"private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){
  for (  V v1 : vertices) {
    for (    V v2 : vertices) {
      if (!v1.equals(v2) && (graph.getEdge(v1,v2) == null)) {
        return false;
      }
    }
  }
  return true;
}
","/** 
 * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.
 * @param graph the graph.
 * @param vertices the vertices to induce the subgraph from.
 * @return true if the induced subgraph is a clique.
 */
","Return true if the subgraph of the given graph induced by the given vertices is a clique,otherwise return false.","1. One-line summary: Checks if given vertices form a clique in a graph.
2. Function behavior: The function iterates through all pairs of vertices and returns false if any pair is not connected by an edge; otherwise, returns true.
3. Function signature:
@param graph Graph<V,E>: The graph containing vertices and edges.
@param vertices Set<V>: The set of vertices to check.
@return boolean: True if the vertices form a clique, false otherwise.
4. Examples: 
(vertices={A,B,C}, edges={AB, AC, BC}) -> true (All pairs are connected)
(vertices={A,B,C}, edges={AB}) -> false (C is not connected to A or B)
(vertices={A,B}, edges={AB}) -> true (A and B are connected)
5. Preconditions & Postconditions: Assumes no self-loops in the graph; returns true if all vertex pairs have edges."
636767431a6d9265ec017c88,computeLowerBounds,"private List<Integer> computeLowerBounds(List<K> keys){
  List<Integer> keyLowerBounds=new ArrayList<>(keys.size());
  for (  K key : keys) {
    int lowerBound=0;
    for (    Function<K,Integer> lowerBoundFunction : lowerBounds) {
      lowerBound=Math.max(lowerBound,lowerBoundFunction.apply(key));
    }
    keyLowerBounds.add(lowerBound);
  }
  return keyLowerBounds;
}
","/** 
 * Finds a maximum lower bound for every key.
 * @param keys list of keys.
 * @return the computed key lower bounds.
 */
","The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.","1. One-line summary: Calculates maximum lower bounds for a list of keys using specified functions.
2. Function behavior: Iterates over a list of keys and applies a set of functions to compute the maximum lower bound for each key. The results are collected into a list of integers.
3. Function signature: 
   @param keys List<K>: List of keys to process
   @return List<Integer>: List of maximum lower bounds for each key
4. Examples: 
   [key1, key2] -> [max1, max2] (lowerBounds are applied and maximum for each key is computed)
   [] -> [] (empty input results in empty output)
   [key1] -> [max1] (single key returns single lower bound)
5. Preconditions & Postconditions: Assumes the list of keys is not null and lowerBound functions are properly defined. Returns a list of non-negative integers representing maximum lower bounds per key."
636766a91a6d9265ec0175c4,pop,"private void pop(final String descriptor){
  char firstDescriptorChar=descriptor.charAt(0);
  if (firstDescriptorChar == '(') {
    pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);
  }
 else   if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {
    pop(2);
  }
 else {
    pop(1);
  }
}
","/** 
 * Pops as many abstract types from the output frame stack as described by the given descriptor.
 * @param descriptor a type or method descriptor (in which case its argument types are popped).
 */
",Pop different value of type based on the first character of the given descriptor.,"1. One-line summary: Pops stack based on type descriptor.
2. Function behavior: Determines the number of pops needed for a given type descriptor and calls a pop method with that number. Handles different descriptor types: method signatures, long/double, and others.
3. Function signature: 
   @param descriptor String: Type descriptor indicating the method signature or type.
4. Examples: ""(I)V"" -> pop((Type.getArgumentsAndReturnSizes(""(I)V"") >> 2) - 1) (method descriptor) ""J"" -> pop(2) (long type) ""L"" -> pop(1) (other types)
5. Preconditions & Postconditions: Preconditions: Valid Java type descriptor is provided. Postconditions: Stack is adjusted according to the descriptor's needs."
636766fb1a6d9265ec0177c3,isAscii,"public static boolean isAscii(final char ch){
  return ch < 128;
}
","/** 
 * <p>Checks whether the character is ASCII 7 bit.</p> <pre> CharUtils.isAscii('a')  = true CharUtils.isAscii('A')  = true CharUtils.isAscii('3')  = true CharUtils.isAscii('-')  = true CharUtils.isAscii('\n') = true CharUtils.isAscii('&copy;') = false </pre>
 * @param ch  the character to check
 * @return true if less than 128
 */
","Return true if the given character is a ASCII seven bit character,otherwise return false.","1. One-line summary: Checks if a character is an ASCII character.
2. Function behavior: Returns true if the character has an ASCII value less than 128, otherwise returns false.
3. Function signature: 
   @param ch char: the character to be checked
   @return boolean: true if the character is an ASCII character, false otherwise
4. Examples: 
   'A' -> true (ASCII character)
   'Â©' -> false (Non-ASCII character)
   'b' -> true (ASCII character)
5. Preconditions & Postconditions: The input is a single character; the function correctly identifies if it's within the ASCII range."
636767581a6d9265ec017fb4,computeUpperBounds,"private List<Integer> computeUpperBounds(List<K> keys){
  List<Integer> keyUpperBounds=new ArrayList<>(keys.size());
  for (  K key : keys) {
    int upperBound=Integer.MAX_VALUE;
    for (    Function<K,Integer> upperBoundFunction : upperBounds) {
      upperBound=Math.min(upperBound,upperBoundFunction.apply(key));
    }
    keyUpperBounds.add(upperBound);
  }
  return keyUpperBounds;
}
","/** 
 * Finds a minimum lower bound for every key.
 * @param keys a list of keys.
 * @return the computed key upper bound.
 */
","The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.","1. One-line summary: Computes the smallest integer upper bounds for each key using a list of functions.
2. Function behavior: The function iterates through a list of keys and applies a set of functions to find the smallest integer bound for each key, returning a list of these bounds.
3. Function signature:
@param keys List<K>: List of keys to process
@return List<Integer>: List of smallest upper bounds for each key
4. Examples: 
[key1, key2] -> [10, 15] (example with two keys producing distinct bounds)
[key1, key1] -> [10, 10] (same key yielding identical bounds)
[key1] -> [10] (single key results in a single bound)
5. Preconditions & Postconditions: The keys list must be non-null, and each function must accept a key and return a non-null integer, resulting in a list of calculated bounds."
636766801a6d9265ec017487,encodeTemplateNames,"public static String encodeTemplateNames(String s){
  int i=s.indexOf('{');
  if (i != -1)   s=s.replace(""{"",""%7B"");
  i=s.indexOf('}');
  if (i != -1)   s=s.replace(""}"",""%7D"");
  return s;
}
","/** 
 * Encodes a string with template parameters names present, specifically the characters '{' and '}' will be percent-encoded.
 * @param s the string with zero or more template parameters names
 * @return the string with encoded template parameters names.
 */
","Encoding the given string by changing '{' and '}' to the specified character for each,return the string after encoding.","1. One-line summary: Replaces curly braces in a string with URL-encoded versions.
2. Function behavior: The function searches for '{' and '}' in the input string and replaces each occurrence with the encoded strings ""%7B"" and ""%7D"" respectively.
3. Function signature: @return String: The modified string with encoded curly braces.
4. Examples: ""{hello}"" -> ""%7Bhello%7D"" (both braces replaced) ""text"" -> ""text"" (no braces so no change) ""a{b}c"" -> ""a%7Bb%7Dc"" (braces encoded)
5. Preconditions & Postconditions: The input is a non-null string. The output is the original string with encoded curly braces if any present."
636767691a6d9265ec0181ac,applyRelativePath,"public static String applyRelativePath(String path,String relativePath){
  int separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);
  if (separatorIndex != -1) {
    String newPath=path.substring(0,separatorIndex);
    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {
      newPath+=FOLDER_SEPARATOR;
    }
    return newPath + relativePath;
  }
 else {
    return relativePath;
  }
}
","/** 
 * Apply the given relative path to the given path, assuming standard Java folder separation (i.e. ""/"" separators).
 * @param path the path to start from (usually a full file path)
 * @param relativePath the relative path to apply(relative to the full file path above)
 * @return the full file path that results from applying the relative path
 */
","Combine the substring before FOLDER_SEPARATOR of the given path with the given relative path to construct a new full file path,and return the full file path.","1. One-line summary: Combines a base path with a relative path.
2. Function behavior: The function takes a base path and appends a relative path by replacing the last folder segment or returning the relative path if no separator is found.
3. Function signature:
@param path String: The base path with directories.
@param relativePath String: The path to be appended.
@return String: The combined path with the relative path.
4. Examples: 
""home/user/docs"",""reports/2023"" -> ""home/user/reports/2023"" (replaces last segment)
""home/user/docs"",""/2023"" -> ""home/user/docs/2023"" (appends separator)
""user"",""new"" -> ""new"" (no separator, return relative)
5. Preconditions & Postconditions: Paths are valid and separated by FOLDER_SEPARATOR; combined path ends with correct relative segment."
636767021a6d9265ec0178bc,indexOf,"public static int indexOf(String str,String searchStr){
  if (str == null || searchStr == null) {
    return StringUtils.INDEX_NOT_FOUND;
  }
  return str.indexOf(searchStr);
}
","/** 
 * Finds the first index within a String, handling <code>null</code>. This method uses  {@link String#indexOf(String)}. 
 */
",Return the first index of the searchStr in the given string.,"1. One-line summary: Find the index of a substring in a string.
2. Function behavior: Returns the index of the first occurrence of a search string within another string. Returns a constant for not found if either string is null.
3. Function signature:
@param str String: The string to be searched.
@param searchStr String: The substring to locate.
@return int: The index of the first occurrence or a not-found constant.
4. Examples: 
""hello"", ""e"" -> 1 (searchStr found at index 1)
""hello"", ""world"" -> StringUtils.INDEX_NOT_FOUND (not found)
null, ""test"" -> StringUtils.INDEX_NOT_FOUND (null input)
5. Preconditions & Postconditions: Strings may be null; a constant indicates not found. Returns index of the first match if both strings are non-null."
636766fc1a6d9265ec0177ef,toNoNullStringArray,"static String[] toNoNullStringArray(Object[] array){
  ArrayList<String> list=new ArrayList<String>(array.length);
  for (int i=0; i < array.length; i++) {
    Object e=array[i];
    if (e != null) {
      list.add(e.toString());
    }
  }
  return (String[])list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);
}
","/** 
 * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}if an array element is <code>null</code>.
 * @param array The array to check
 * @return The given array or a new array without null.
 */
","Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.","1. One-line summary: Converts non-null objects in an array to their string representation.
2. Function behavior: This function filters out non-null elements from the input array and returns their string representations as an array of strings.
3. Function signature:
@param array Object[]: An array of objects to be converted.
@return String[]: An array containing string representations of non-null objects.
4. Examples: 
[1, null, ""test""] -> [""1"", ""test""] (null is excluded)
[null, null, null] -> [] (all elements are null)
[""a"", ""b"", ""c""] -> [""a"", ""b"", ""c""] (no nulls)
5. Preconditions & Postconditions: Input array may contain null values; returns only non-null elements as strings."
636767061a6d9265ec01794a,indexOfExtension,"public static int indexOfExtension(String filename){
  if (filename == null) {
    return -1;
  }
  int extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);
  int lastSeparator=indexOfLastSeparator(filename);
  return lastSeparator > extensionPos ? -1 : extensionPos;
}
","/** 
 * Returns the index of the last extension separator character, which is a dot. <p> This method also checks that there is no directory separator after the last dot. To do this it uses  {@link #indexOfLastSeparator(String)} which willhandle a file in either Unix or Windows format. <p> The output will be the same irrespective of the machine that the code is running on.
 * @param filename  the filename to find the last path separator in, null returns -1
 * @return the index of the last separator character, or -1 if thereis no such character
 */
","Return the last index of the extension separator in the given filename,it will return -1 if the filename doesn't have the separator or there is a directory separator after it.","1. One-line summary: Finds the position of the file extension in a filename.
2. Function behavior: This function returns the index of the last extension separator in a filename or -1 if there's no valid extension position.
3. Function signature: 
   @param filename String: The filename to check for an extension.
   @return int: The index position of the extension or -1 if no valid extension exists.
4. Examples: ""file.txt"" -> 4 (extension at index 4) ""archive.tar.gz"" -> 11 (last extension at index 11) ""folder/file"" -> -1 (no extension) null -> -1 (null input)
5. Preconditions & Postconditions: The input may be null, and the output is -1 if there's no valid extension separator or the input is null."
636767dd1a6d9265ec0186de,isExpired,"public boolean isExpired(long timestamp,long expiredThreshold){
  return timestamp - lastUpdateTimestamp > expiredThreshold;
}
","/** 
 * @param timestamp        of current time
 * @param expiredThreshold represents the duration between last update time and the time point removing from cache.
 * @return true means this metrics should be removed from cache.
 */
","Return true if the timestamp minus the lastUpdateTimestamp is greater than expiredThreshold,otherwise return false.","1. One-line summary: Checks if a timestamp is beyond an expiration threshold.
2. Function behavior: Returns true if the difference between `timestamp` and `lastUpdateTimestamp` exceeds `expiredThreshold`.
3. Function signature:
@param timestamp long: current timestamp
@param expiredThreshold long: allowed period before expiration
@return boolean: true if expired, false otherwise
4. Examples: 
1000, 500 -> true (Expired)
1000, 600 -> false (Not expired)
1500, 400 -> true (Expired)
5. Preconditions & Postconditions: Assumes `lastUpdateTimestamp` is initialized; returns true if expired, false otherwise."
6367675d1a6d9265ec018082,edgeToNext,"Edge edgeToNext(){
  Edge edge=prev.embedded.getFirst();
  Node target=toExistingNode(current);
  Node source=toExistingNode(prev);
  if (edge.getOpposite(source) == target) {
    return edge;
  }
 else {
    return prev.embedded.getLast();
  }
}
","/** 
 * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.
 * @return an edge from the current node to the next node
 */
",Return the edge connecting the previously returned node with the current node.,"1. One-line summary: Retrieves the appropriate edge between two nodes.
2. Function behavior: This function checks if the first edge's opposite node matches a target node and returns the first edge; otherwise, it returns the last edge.
3. Function signature:
@return Edge: The edge either matching the destination node or the last edge in the list.
4. Examples: prev with first edge matching target -> first edge (first edge matches target) prev with mismatched first edge -> last edge (first edge does not match target)
5. Preconditions & Postconditions: Assumes 'prev.embedded' is non-empty and contains edges; outputs an edge from 'prev.embedded' list."
6367676b1a6d9265ec0181e9,substringMatch,"public static boolean substringMatch(CharSequence str,int index,CharSequence substring){
  for (int j=0; j < substring.length(); j++) {
    int i=index + j;
    if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {
      return false;
    }
  }
  return true;
}
","/** 
 * Returns  {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.
 * @param str the original string (or StringBuilder)
 * @param index the index in the original string to start matching against
 * @param substring the substring to match at the given index
 * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.
 */
","Return true if starting at the given index,the given string matches the given substring.Otherwise return false.","1. One-line summary: Checks if a substring matches a portion of a given string starting at a specified index.
2. Function behavior: The function iterates through the substring and checks each character against the main string starting from a specified index. It returns true if the substring matches; otherwise, it returns false.
3. Function signature: 
@param str CharSequence: main string to search within
@param index int: starting index in the main string
@param substring CharSequence: substring to match
@return boolean: true if substring matches main string from index, else false
4. Examples: 
""hello world"", 6, ""world"" -> true (substring matches)
""hello world"", 0, ""world"" -> false (substring doesn't match from index 0)
""abcd"", 2, ""cd"" -> true (substring matches)
5. Preconditions & Postconditions: Index must be non-negative; substring must fit within the remaining length of the main string. Returns true if the match is successful, otherwise false."
6367670b1a6d9265ec017a05,toString,"public static String toString(final char ch){
  if (ch < 128) {
    return CharUtils.CHAR_STRING_ARRAY[ch];
  }
  return new String(new char[]{ch});
}
","/** 
 * <p>Converts the character to a String that contains the one character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same String object each time.</p> <pre> CharUtils.toString(' ')  = "" "" CharUtils.toString('A')  = ""A"" </pre>
 * @param ch  the character to convert
 * @return a String containing the one specified character
 */
",Return the String object that contains the given character.,"1. One-line summary: Convert a character to its string representation.
2. Function behavior: Returns a string for ASCII characters using a predefined array or creates a new string for others.
3. Function signature: 
   @return String: String representation of the character.
4. Examples: 
   'a' -> ""a"" (ASCII character)
   'â‚¬' -> ""â‚¬"" (non-ASCII character)
   'Z' -> ""Z"" (ASCII character)
5. Preconditions & Postconditions: Character is assumed to be valid; returns a string encapsulating the character itself."
636767a31a6d9265ec01854f,checkIfPackedField,"private void checkIfPackedField() throws IOException {
  if (packedLimit == 0 && WireFormat.getTagWireType(lastTag) == WIRETYPE_LENGTH_DELIMITED) {
    final int length=readRawVarint32();
    if (length < 0)     throw ProtobufException.negativeSize();
    this.packedLimit=getTotalBytesRead() + length;
  }
}
","/** 
 * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that packed fields are being read.
 * @throws IOException
 */
","Check if the field should be packed,if so,read the field and update the internal state. It will throw an exception when the process of reading is wrong.","1. One-line summary: Sets packedLimit for length-delimited fields if not already set.
2. Function behavior: The function checks if current field is length-delimited and unprocessed, reads its length, updates packedLimit, and throws an exception for negative size.
3. Function signature: 
   @throws IOException: If an I/O error occurs.
4. Examples: 
   (initialized, WIRETYPE_LENGTH_DELIMITED) -> packedLimit updated (valid; updates packedLimit)
   (zero, WIRETYPE_LENGTH_DELIMITED) -> exception thrown (invalid; length is negative)
5. Preconditions & Postconditions: Precondition: packedLimit is zero, lastTag is length-delimited. Postcondition: packedLimit is updated or exception is thrown for negative size."
636767a81a6d9265ec0185fc,readTag,"public int readTag() throws IOException {
  if (!buffer.hasRemaining()) {
    lastTag=0;
    return 0;
  }
  final int tag=readRawVarint32();
  if (tag >>> TAG_TYPE_BITS == 0) {
    throw ProtobufException.invalidTag();
  }
  lastTag=tag;
  return tag;
}
","/** 
 * Attempt to read a field tag, returning zero if we have reached EOF. Protocol message parsers use this to read tags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.
 */
","Return a field tag, and if reach the EOF the tag will be zero.It will throw an exception when the tag is equal to zero after logical shift right  TAG_TYPE_BITS.","1. One-line summary: Reads a Protobuf tag from a buffer.
2. Function behavior: Reads and returns the next tag as an integer from a buffer, resetting or validating the tag as necessary.
3. Function signature:
@return int: The read tag or 0 if none.
@throws IOException: For I/O issues.
@throws ProtobufException: If the tag is invalid.
4. Examples: 
Buffer empty -> 0 (No tag read)
Valid buffer with tag -> tag value (Returns the tag)
Invalid tag -> Exception (Throws error)
5. Preconditions & Postconditions: Buffer must be set, returns a valid tag or resets to 0 if empty, throws exception on invalid tag."
636766a81a6d9265ec017595,put11,"final ByteVector put11(final int byteValue1,final int byteValue2){
  int currentLength=length;
  if (currentLength + 2 > data.length) {
    enlarge(2);
  }
  byte[] currentData=data;
  currentData[currentLength++]=(byte)byteValue1;
  currentData[currentLength++]=(byte)byteValue2;
  length=currentLength;
  return this;
}
","/** 
 * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.
 * @param byteValue1 a byte.
 * @param byteValue2 another byte.
 * @return this byte vector.
 */
",Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.,"1. One-line summary: Appends two byte values to a ByteVector.
2. Function behavior: The function checks if there is enough space in the data array, enlarges it if necessary, and appends two bytes to the current ByteVector.
3. Function signature: 
   @param byteValue1 int: First byte value to append.
   @param byteValue2 int: Second byte value to append.
   @return ByteVector: The updated ByteVector instance.
4. Examples: 
   put11(1, 2) -> ByteVector (appends bytes 1 and 2)
   put11(255, 0) -> ByteVector (appends bytes 255 and 0)
5. Preconditions & Postconditions: Preconditions: data is a non-null byte array. Postconditions: ByteVector length increases by 2 if there is space, otherwise data is enlarged."
636766ae1a6d9265ec0175d8,buildContentRange,"private String buildContentRange(){
  Integer limit=drc.getLimit() == null ? getDefaultNumberPagination() - 1 : drc.getLimit();
  Integer offset=drc.getOffset() == null ? 0 : drc.getOffset();
  Long count=drc.getCount() == null ? 0 : drc.getCount();
  return offset + ""-"" + (limit.equals(0) ? count - 1 : limit)+ ""/""+ count;
}
","/** 
 * Build the 'Content-Range' HTTP Header value.
 * @return 'Content-Range' value
 */
","Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.","1. One-line summary: Builds a content range string for pagination.
2. Function behavior: Constructs a string representing a range of data items being accessed, based on limit, offset, and total count values.
3. Function signature: 
@return String: A content range string formatted as ""offset-limit/count"".
4. Examples: 
limit=10, offset=5, count=50 -> ""5-9/50"" (normal range scenario)
limit=null, offset=null, count=null -> ""0-49/0"" (fall back to defaults)
limit=0, offset=10, count=15 -> ""10-14/15"" (limit is 0, output adjusted)
5. Preconditions & Postconditions: Limit, offset, and count may be null and, if so, are assigned default values, the string reflects range from offset to limit or count."
