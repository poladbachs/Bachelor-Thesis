{
  "RECORDS": [
    {
      "_id": "6367676d1a6d9265ec018229",
      "all_context": "{ \"class_level\" : \"import java.nio.charset.Charset;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nimport java.util.Enumeration;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Locale;\\nimport java.util.Properties;\\nimport java.util.Set;\\nimport java.util.StringTokenizer;\\nimport java.util.TreeSet;\\nString FOLDER_SEPARATOR;\\nString WINDOWS_FOLDER_SEPARATOR;\\nString TOP_PATH;\\nString CURRENT_PATH;\\nchar EXTENSION_SEPARATOR;\\nCharset UTF_8;\\nStrings();\\nhasLength(String str);\\nhasText(CharSequence str);\\nhasText(String str);\\ncontainsWhitespace(CharSequence str);\\ncontainsWhitespace(String str);\\ntrimWhitespace(String str);\\ntrimWhitespace(CharSequence str);\\nclean(String str);\\nclean(CharSequence str);\\ntrimAllWhitespace(String str);\\ntrimLeadingWhitespace(String str);\\ntrimTrailingWhitespace(String str);\\ntrimLeadingCharacter(String str,char leadingCharacter);\\ntrimTrailingCharacter(String str,char trailingCharacter);\\nstartsWithIgnoreCase(String str,String prefix);\\nendsWithIgnoreCase(String str,String suffix);\\nsubstringMatch(CharSequence str,int index,CharSequence substring);\\ncountOccurrencesOf(String str,String sub);\\nreplace(String inString,String oldPattern,String newPattern);\\ndelete(String inString,String pattern);\\ndeleteAny(String inString,String charsToDelete);\\nquote(String str);\\nquoteIfString(Object obj);\\nunqualify(String qualifiedName);\\nunqualify(String qualifiedName,char separator);\\ncapitalize(String str);\\nuncapitalize(String str);\\nchangeFirstCharacterCase(String str,boolean capitalize);\\ngetFilename(String path);\\ngetFilenameExtension(String path);\\nstripFilenameExtension(String path);\\napplyRelativePath(String path,String relativePath);\\ncleanPath(String path);\\npathEquals(String path1,String path2);\\nparseLocaleString(String localeString);\\nvalidateLocalePart(String localePart);\\ntoLanguageTag(Locale locale);\\naddStringToArray(String[] array,String str);\\nconcatenateStringArrays(String[] array1,String[] array2);\\nmergeStringArrays(String[] array1,String[] array2);\\nsortStringArray(String[] array);\\ntoStringArray(Collection collection);\\ntoStringArray(Enumeration enumeration);\\ntrimArrayElements(String[] array);\\nremoveDuplicateStrings(String[] array);\\nsplit(String toSplit,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter,String charsToDelete);\\ntokenizeToStringArray(String str,String delimiters);\\ntokenizeToStringArray(String str,String delimiters,boolean trimTokens,boolean ignoreEmptyTokens);\\ndelimitedListToStringArray(String str,String delimiter);\\ndelimitedListToStringArray(String str,String delimiter,String charsToDelete);\\ncommaDelimitedListToStringArray(String str);\\ncommaDelimitedListToSet(String str);\\ncollectionToDelimitedString(Collection coll,String delim,String prefix,String suffix);\\ncollectionToDelimitedString(Collection coll,String delim);\\ncollectionToCommaDelimitedString(Collection coll);\\narrayToDelimitedString(Object[] arr,String delim);\\narrayToCommaDelimitedString(Object[] arr);\\nhasLength(CharSequence str);\\n\", \"repo_level\" : \"\" }",
      "class_name": "Strings",
      "code": "public static String[] trimArrayElements(String[] array){\n  if (Objects.isEmpty(array)) {\n    return new String[0];\n  }\n  String[] result=new String[array.length];\n  for (int i=0; i < array.length; i++) {\n    String element=array[i];\n    result[i]=(element != null ? element.trim() : null);\n  }\n  return result;\n}\n",
      "docstring": "/** \n * Trim the elements of the given String array, calling <code>String.trim()</code> on each of them.\n * @param array the original String array\n * @return the resulting array (of the same size) with trimmed elements\n */\n",
      "end_lineno": "842",
      "file_content": "/*\n * Copyright (C) 2014 jsonwebtoken.io\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.jsonwebtoken.lang;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic final class Strings {\n\n    private static final String FOLDER_SEPARATOR = \"/\";\n\n    private static final String WINDOWS_FOLDER_SEPARATOR = \"\\\\\";\n\n    private static final String TOP_PATH = \"..\";\n\n    private static final String CURRENT_PATH = \".\";\n\n    private static final char EXTENSION_SEPARATOR = '.';\n\n    public static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    private Strings(){} //prevent instantiation\n\n    //---------------------------------------------------------------------\n    // General convenience methods for working with Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Check that the given CharSequence is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a CharSequence that purely consists of whitespace.\n     * <pre>\n     * Strings.hasLength(null) = false\n     * Strings.hasLength(\"\") = false\n     * Strings.hasLength(\" \") = true\n     * Strings.hasLength(\"Hello\") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(CharSequence str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasLength(CharSequence)\n     */\n    public static boolean hasLength(String str) {\n        return hasLength((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <pre>\n     * Strings.hasText(null) = false\n     * Strings.hasText(\"\") = false\n     * Strings.hasText(\" \") = false\n     * Strings.hasText(\"12345\") = true\n     * Strings.hasText(\" 12345 \") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not <code>null</code>,\n     * its length is greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     * greater than 0, and it does not contain whitespace only\n     * @see #hasText(CharSequence)\n     */\n    public static boolean hasText(String str) {\n        return hasText((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence contains any whitespace characters.\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not empty and\n     * contains at least 1 whitespace character\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean containsWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String contains any whitespace characters.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not empty and\n     * contains at least 1 whitespace character\n     * @see #containsWhitespace(CharSequence)\n     */\n    public static boolean containsWhitespace(String str) {\n        return containsWhitespace((CharSequence) str);\n    }\n\n    /**\n     * Trim leading and trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimWhitespace(String str) {\n        return (String) trimWhitespace((CharSequence)str);\n    }\n    \n    \n    private static CharSequence trimWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        final int length = str.length();\n\n        int start = 0;\n\t\twhile (start < length && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        \n\t\tint end = length;\n        while (start < length && Character.isWhitespace(str.charAt(end - 1))) {\n            end--;\n        }\n        \n        return ((start > 0) || (end < length)) ? str.subSequence(start, end) : str;\n    }\n\n    public static String clean(String str) {\n    \tCharSequence result = clean((CharSequence) str);\n        \n        return result!=null?result.toString():null;\n    }\n    \n    public static CharSequence clean(CharSequence str) {\n        str = trimWhitespace(str);\n        if (!hasLength(str)) {\n            return null;\n        }\n        return str;\n    }\n\n    /**\n     * Trim <i>all</i> whitespace from the given String:\n     * leading, trailing, and intermediate characters.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimAllWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        int index = 0;\n        while (sb.length() > index) {\n            if (Character.isWhitespace(sb.charAt(index))) {\n                sb.deleteCharAt(index);\n            }\n            else {\n                index++;\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim leading whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimLeadingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimTrailingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied leading character from the given String.\n     * @param str the String to check\n     * @param leadingCharacter the leading character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimLeadingCharacter(String str, char leadingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied trailing character from the given String.\n     * @param str the String to check\n     * @param trailingCharacter the trailing character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimTrailingCharacter(String str, char trailingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n\n    /**\n     * Returns {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @param str the String to check\n     * @param prefix the prefix to look for\n     * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @param str the String to check\n     * @param suffix the suffix to look for\n     * @return {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @see java.lang.String#endsWith\n     */\n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        if (str == null || suffix == null) {\n            return false;\n        }\n        if (str.endsWith(suffix)) {\n            return true;\n        }\n        if (str.length() < suffix.length()) {\n            return false;\n        }\n\n        String lcStr = str.substring(str.length() - suffix.length()).toLowerCase();\n        String lcSuffix = suffix.toLowerCase();\n        return lcStr.equals(lcSuffix);\n    }\n\n    /**\n     * Returns {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     * @param str the original string (or StringBuilder)\n     * @param index the index in the original string to start matching against\n     * @param substring the substring to match at the given index\n     * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     */\n    public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n        for (int j = 0; j < substring.length(); j++) {\n            int i = index + j;\n            if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the number of occurrences the substring {@code sub} appears in string {@code str}.\n     * @param str string to search in. Return 0 if this is null.\n     * @param sub string to search for. Return 0 if this is null.\n     * @return the number of occurrences the substring {@code sub} appears in string {@code str}.\n     */\n    public static int countOccurrencesOf(String str, String sub) {\n        if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n            return 0;\n        }\n        int count = 0;\n        int pos = 0;\n        int idx;\n        while ((idx = str.indexOf(sub, pos)) != -1) {\n            ++count;\n            pos = idx + sub.length();\n        }\n        return count;\n    }\n\n    /**\n     * Replace all occurrences of a substring within a string with\n     * another string.\n     * @param inString String to examine\n     * @param oldPattern String to replace\n     * @param newPattern String to insert\n     * @return a String with the replacements\n     */\n    public static String replace(String inString, String oldPattern, String newPattern) {\n        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        int pos = 0; // our position in the old string\n        int index = inString.indexOf(oldPattern);\n        // the index of an occurrence we've found, or -1\n        int patLen = oldPattern.length();\n        while (index >= 0) {\n            sb.append(inString.substring(pos, index));\n            sb.append(newPattern);\n            pos = index + patLen;\n            index = inString.indexOf(oldPattern, pos);\n        }\n        sb.append(inString.substring(pos));\n        // remember to append any characters to the right of a match\n        return sb.toString();\n    }\n\n    /**\n     * Delete all occurrences of the given substring.\n     * @param inString the original String\n     * @param pattern the pattern to delete all occurrences of\n     * @return the resulting String\n     */\n    public static String delete(String inString, String pattern) {\n        return replace(inString, pattern, \"\");\n    }\n\n    /**\n     * Delete any character in a given String.\n     * @param inString the original String\n     * @param charsToDelete a set of characters to delete.\n     * E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n     * @return the resulting String\n     */\n    public static String deleteAny(String inString, String charsToDelete) {\n        if (!hasLength(inString) || !hasLength(charsToDelete)) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < inString.length(); i++) {\n            char c = inString.charAt(i);\n            if (charsToDelete.indexOf(c) == -1) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with formatted Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Quote the given String with single quotes.\n     * @param str the input String (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or <code>null</code> if the input was <code>null</code>\n     */\n    public static String quote(String str) {\n        return (str != null ? \"'\" + str + \"'\" : null);\n    }\n\n    /**\n     * Turn the given Object into a String with single quotes\n     * if it is a String; keeping the Object as-is else.\n     * @param obj the input Object (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or the input object as-is if not a String\n     */\n    public static Object quoteIfString(Object obj) {\n        return (obj instanceof String ? quote((String) obj) : obj);\n    }\n\n    /**\n     * Unqualify a string qualified by a '.' dot character. For example,\n     * \"this.name.is.qualified\", returns \"qualified\".\n     * @param qualifiedName the qualified name\n     * @return an unqualified string by stripping all previous text before (and including) the last period character.\n     */\n    public static String unqualify(String qualifiedName) {\n        return unqualify(qualifiedName, '.');\n    }\n\n    /**\n     * Unqualify a string qualified by a separator character. For example,\n     * \"this:name:is:qualified\" returns \"qualified\" if using a ':' separator.\n     * @param qualifiedName the qualified name\n     * @param separator the separator\n     * @return an unqualified string by stripping all previous text before and including the last {@code separator} character.\n     */\n    public static String unqualify(String qualifiedName, char separator) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);\n    }\n\n    /**\n     * Capitalize a <code>String</code>, changing the first letter to\n     * upper case as per {@link Character#toUpperCase(char)}.\n     * No other letters are changed.\n     * @param str the String to capitalize, may be <code>null</code>\n     * @return the capitalized String, <code>null</code> if null\n     */\n    public static String capitalize(String str) {\n        return changeFirstCharacterCase(str, true);\n    }\n\n    /**\n     * Uncapitalize a <code>String</code>, changing the first letter to\n     * lower case as per {@link Character#toLowerCase(char)}.\n     * No other letters are changed.\n     * @param str the String to uncapitalize, may be <code>null</code>\n     * @return the uncapitalized String, <code>null</code> if null\n     */\n    public static String uncapitalize(String str) {\n        return changeFirstCharacterCase(str, false);\n    }\n\n    private static String changeFirstCharacterCase(String str, boolean capitalize) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str.length());\n        if (capitalize) {\n            sb.append(Character.toUpperCase(str.charAt(0)));\n        }\n        else {\n            sb.append(Character.toLowerCase(str.charAt(0)));\n        }\n        sb.append(str.substring(1));\n        return sb.toString();\n    }\n\n    /**\n     * Extract the filename from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"myfile.txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename, or <code>null</code> if none\n     */\n    public static String getFilename(String path) {\n        if (path == null) {\n            return null;\n        }\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);\n    }\n\n    /**\n     * Extract the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename extension, or <code>null</code> if none\n     */\n    public static String getFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return null;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return null;\n        }\n        return path.substring(extIndex + 1);\n    }\n\n    /**\n     * Strip the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"mypath/myfile\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the path with stripped filename extension,\n     * or <code>null</code> if none\n     */\n    public static String stripFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return path;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return path;\n        }\n        return path.substring(0, extIndex);\n    }\n\n    /**\n     * Apply the given relative path to the given path,\n     * assuming standard Java folder separation (i.e. \"/\" separators).\n     * @param path the path to start from (usually a full file path)\n     * @param relativePath the relative path to apply\n     * (relative to the full file path above)\n     * @return the full file path that results from applying the relative path\n     */\n    public static String applyRelativePath(String path, String relativePath) {\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (separatorIndex != -1) {\n            String newPath = path.substring(0, separatorIndex);\n            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n                newPath += FOLDER_SEPARATOR;\n            }\n            return newPath + relativePath;\n        }\n        else {\n            return relativePath;\n        }\n    }\n\n    /**\n     * Normalize the path by suppressing sequences like \"path/..\" and\n     * inner simple dots.\n     * <p>The result is convenient for path comparison. For other uses,\n     * notice that Windows separators (\"\\\") are replaced by simple slashes.\n     * @param path the original path\n     * @return the normalized path\n     */\n    public static String cleanPath(String path) {\n        if (path == null) {\n            return null;\n        }\n        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);\n\n        // Strip prefix from path to analyze, to not treat it as part of the\n        // first path element. This is necessary to correctly parse paths like\n        // \"file:core/../core/io/Resource.class\", where the \"..\" should just\n        // strip the first \"core\" directory while keeping the \"file:\" prefix.\n        int prefixIndex = pathToUse.indexOf(\":\");\n        String prefix = \"\";\n        if (prefixIndex != -1) {\n            prefix = pathToUse.substring(0, prefixIndex + 1);\n            pathToUse = pathToUse.substring(prefixIndex + 1);\n        }\n        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {\n            prefix = prefix + FOLDER_SEPARATOR;\n            pathToUse = pathToUse.substring(1);\n        }\n\n        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);\n        List<String> pathElements = new LinkedList<String>();\n        int tops = 0;\n\n        for (int i = pathArray.length - 1; i >= 0; i--) {\n            String element = pathArray[i];\n            if (CURRENT_PATH.equals(element)) {\n                // Points to current directory - drop it.\n            }\n            else if (TOP_PATH.equals(element)) {\n                // Registering top path found.\n                tops++;\n            }\n            else {\n                if (tops > 0) {\n                    // Merging path element with element corresponding to top path.\n                    tops--;\n                }\n                else {\n                    // Normal path element found.\n                    pathElements.add(0, element);\n                }\n            }\n        }\n\n        // Remaining top paths need to be retained.\n        for (int i = 0; i < tops; i++) {\n            pathElements.add(0, TOP_PATH);\n        }\n\n        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);\n    }\n\n    /**\n     * Compare two paths after normalization of them.\n     * @param path1 first path for comparison\n     * @param path2 second path for comparison\n     * @return whether the two paths are equivalent after normalization\n     */\n    public static boolean pathEquals(String path1, String path2) {\n        return cleanPath(path1).equals(cleanPath(path2));\n    }\n\n    /**\n     * Parse the given <code>localeString</code> value into a {@link java.util.Locale}.\n     * <p>This is the inverse operation of {@link java.util.Locale#toString Locale's toString}.\n     * @param localeString the locale string, following <code>Locale's</code>\n     * <code>toString()</code> format (\"en\", \"en_UK\", etc);\n     * also accepts spaces as separators, as an alternative to underscores\n     * @return a corresponding <code>Locale</code> instance\n     */\n    public static Locale parseLocaleString(String localeString) {\n        String[] parts = tokenizeToStringArray(localeString, \"_ \", false, false);\n        String language = (parts.length > 0 ? parts[0] : \"\");\n        String country = (parts.length > 1 ? parts[1] : \"\");\n        validateLocalePart(language);\n        validateLocalePart(country);\n        String variant = \"\";\n        if (parts.length >= 2) {\n            // There is definitely a variant, and it is everything after the country\n            // code sans the separator between the country code and the variant.\n            int endIndexOfCountryCode = localeString.indexOf(country) + country.length();\n            // Strip off any leading '_' and whitespace, what's left is the variant.\n            variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));\n            if (variant.startsWith(\"_\")) {\n                variant = trimLeadingCharacter(variant, '_');\n            }\n        }\n        return (language.length() > 0 ? new Locale(language, country, variant) : null);\n    }\n\n    private static void validateLocalePart(String localePart) {\n        for (int i = 0; i < localePart.length(); i++) {\n            char ch = localePart.charAt(i);\n            if (ch != '_' && ch != ' ' && !Character.isLetterOrDigit(ch)) {\n                throw new IllegalArgumentException(\n                    \"Locale part \\\"\" + localePart + \"\\\" contains invalid characters\");\n            }\n        }\n    }\n\n    /**\n     * Determine the RFC 3066 compliant language tag,\n     * as used for the HTTP \"Accept-Language\" header.\n     * @param locale the Locale to transform to a language tag\n     * @return the RFC 3066 compliant language tag as String\n     */\n    public static String toLanguageTag(Locale locale) {\n        return locale.getLanguage() + (hasText(locale.getCountry()) ? \"-\" + locale.getCountry() : \"\");\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with String arrays\n    //---------------------------------------------------------------------\n\n    /**\n     * Append the given String to the given String array, returning a new array\n     * consisting of the input array contents plus the given String.\n     * @param array the array to append to (can be <code>null</code>)\n     * @param str the String to append\n     * @return the new array (never <code>null</code>)\n     */\n    public static String[] addStringToArray(String[] array, String str) {\n        if (Objects.isEmpty(array)) {\n            return new String[] {str};\n        }\n        String[] newArr = new String[array.length + 1];\n        System.arraycopy(array, 0, newArr, 0, array.length);\n        newArr[array.length] = str;\n        return newArr;\n    }\n\n    /**\n     * Concatenate the given String arrays into one,\n     * with overlapping array elements included twice.\n     * <p>The order of elements in the original arrays is preserved.\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        String[] newArr = new String[array1.length + array2.length];\n        System.arraycopy(array1, 0, newArr, 0, array1.length);\n        System.arraycopy(array2, 0, newArr, array1.length, array2.length);\n        return newArr;\n    }\n\n    /**\n     * Merge the given String arrays into one, with overlapping\n     * array elements only included once.\n     * <p>The order of elements in the original arrays is preserved\n     * (with the exception of overlapping elements, which are only\n     * included on their first occurrence).\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] mergeStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        List<String> result = new ArrayList<String>();\n        result.addAll(Arrays.asList(array1));\n        for (String str : array2) {\n            if (!result.contains(str)) {\n                result.add(str);\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Turn given source String array into sorted array.\n     * @param array the source array\n     * @return the sorted array (never <code>null</code>)\n     */\n    public static String[] sortStringArray(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        Arrays.sort(array);\n        return array;\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Collection was <code>null</code>)\n     */\n    public static String[] toStringArray(Collection<String> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new String[collection.size()]);\n    }\n\n    /**\n     * Copy the given Enumeration into a String array.\n     * The Enumeration must contain String elements only.\n     * @param enumeration the Enumeration to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Enumeration was <code>null</code>)\n     */\n    public static String[] toStringArray(Enumeration<String> enumeration) {\n        if (enumeration == null) {\n            return null;\n        }\n        List<String> list = java.util.Collections.list(enumeration);\n        return list.toArray(new String[list.size()]);\n    }\n\n    /**\n     * Trim the elements of the given String array,\n     * calling <code>String.trim()</code> on each of them.\n     * @param array the original String array\n     * @return the resulting array (of the same size) with trimmed elements\n     */\n    public static String[] trimArrayElements(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        String[] result = new String[array.length];\n        for (int i = 0; i < array.length; i++) {\n            String element = array[i];\n            result[i] = (element != null ? element.trim() : null);\n        }\n        return result;\n    }\n\n    /**\n     * Remove duplicate Strings from the given array.\n     * Also sorts the array, as it uses a TreeSet.\n     * @param array the String array\n     * @return an array without duplicates, in natural sort order\n     */\n    public static String[] removeDuplicateStrings(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return array;\n        }\n        Set<String> set = new TreeSet<String>();\n        for (String element : array) {\n            set.add(element);\n        }\n        return toStringArray(set);\n    }\n\n    /**\n     * Split a String at the first occurrence of the delimiter.\n     * Does not include the delimiter in the result.\n     * @param toSplit the string to split\n     * @param delimiter to split the string up with\n     * @return a two element array with index 0 being before the delimiter, and\n     * index 1 being after the delimiter (neither element includes the delimiter);\n     * or <code>null</code> if the delimiter wasn't found in the given input String\n     */\n    public static String[] split(String toSplit, String delimiter) {\n        if (!hasLength(toSplit) || !hasLength(delimiter)) {\n            return null;\n        }\n        int offset = toSplit.indexOf(delimiter);\n        if (offset < 0) {\n            return null;\n        }\n        String beforeDelimiter = toSplit.substring(0, offset);\n        String afterDelimiter = toSplit.substring(offset + delimiter.length());\n        return new String[] {beforeDelimiter, afterDelimiter};\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was null or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {\n        return splitArrayElementsIntoProperties(array, delimiter, null);\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @param charsToDelete one or more characters to remove from each element\n     * prior to attempting the split operation (typically the quotation mark\n     * symbol), or <code>null</code> if no removal should occur\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was <code>null</code> or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(\n        String[] array, String delimiter, String charsToDelete) {\n\n        if (Objects.isEmpty(array)) {\n            return null;\n        }\n        Properties result = new Properties();\n        for (String element : array) {\n            if (charsToDelete != null) {\n                element = deleteAny(element, charsToDelete);\n            }\n            String[] splittedElement = split(element, delimiter);\n            if (splittedElement == null) {\n                continue;\n            }\n            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n        }\n        return result;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter)\n     * @param trimTokens trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     * (only applies to tokens that are empty after trimming; StringTokenizer\n     * will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     * was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(\n        String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List<String> tokens = new ArrayList<String>();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter) {\n        return delimitedListToStringArray(str, delimiter, null);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @param charsToDelete a set of characters to delete. Useful for deleting unwanted\n     * line breaks: e.g. \"\\r\\n\\f\" will delete all new lines and line feeds in a String.\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {\n        if (str == null) {\n            return new String[0];\n        }\n        if (delimiter == null) {\n            return new String[] {str};\n        }\n        List<String> result = new ArrayList<String>();\n        if (\"\".equals(delimiter)) {\n            for (int i = 0; i < str.length(); i++) {\n                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));\n            }\n        }\n        else {\n            int pos = 0;\n            int delPos;\n            while ((delPos = str.indexOf(delimiter, pos)) != -1) {\n                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));\n                pos = delPos + delimiter.length();\n            }\n            if (str.length() > 0 && pos <= str.length()) {\n                // Add rest of String, but not in case of empty input.\n                result.add(deleteAny(str.substring(pos), charsToDelete));\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Convert a CSV list into an array of Strings.\n     * @param str the input String\n     * @return an array of Strings, or the empty array in case of empty input\n     */\n    public static String[] commaDelimitedListToStringArray(String str) {\n        return delimitedListToStringArray(str, \",\");\n    }\n\n    /**\n     * Convenience method to convert a CSV string list to a set.\n     * Note that this will suppress duplicates.\n     * @param str the input String\n     * @return a Set of String entries in the list\n     */\n    public static Set<String> commaDelimitedListToSet(String str) {\n        Set<String> set = new TreeSet<String>();\n        String[] tokens = commaDelimitedListToStringArray(str);\n        for (String token : tokens) {\n            set.add(token);\n        }\n        return set;\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @param prefix the String to start each element with\n     * @param suffix the String to end each element with\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {\n        if (Collections.isEmpty(coll)) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        Iterator<?> it = coll.iterator();\n        while (it.hasNext()) {\n            sb.append(prefix).append(it.next()).append(suffix);\n            if (it.hasNext()) {\n                sb.append(delim);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim) {\n        return collectionToDelimitedString(coll, delim, \"\", \"\");\n    }\n\n    /**\n     * Convenience method to return a Collection as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @return the delimited String\n     */\n    public static String collectionToCommaDelimitedString(Collection<?> coll) {\n        return collectionToDelimitedString(coll, \",\");\n    }\n\n    /**\n     * Convenience method to return a String array as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String arrayToDelimitedString(Object[] arr, String delim) {\n        if (Objects.isEmpty(arr)) {\n            return \"\";\n        }\n        if (arr.length == 1) {\n            return Objects.nullSafeToString(arr[0]);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < arr.length; i++) {\n            if (i > 0) {\n                sb.append(delim);\n            }\n            sb.append(arr[i]);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a String array as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @return the delimited String\n     */\n    public static String arrayToCommaDelimitedString(Object[] arr) {\n        return arrayToDelimitedString(arr, \",\");\n    }\n\n}\n\n",
      "file_name": "Strings.java",
      "human_label": "Trim each element in the given string array and return the resulting array.",
      "level": "self_contained",
      "lineno": "826",
      "name": "trimArrayElements",
      "oracle_context": "{ \"apis\" : \"[isEmpty, trim]\", \"classes\" : \"[String[], String]\", \"vars\" : \"[length]\" }",
      "package": "io.jsonwebtoken.lang",
      "project": "jjwt-master"
    },
    {
      "_id": "6367670b1a6d9265ec017a00",
      "all_context": "{ \"class_level\" : \"import java.lang.reflect.Array;\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.Map.Entry;\\nObject[] EMPTY_OBJECT_ARRAY;\\nClass<?>[] EMPTY_CLASS_ARRAY;\\nString[] EMPTY_STRING_ARRAY;\\nlong[] EMPTY_LONG_ARRAY;\\nLong[] EMPTY_LONG_OBJECT_ARRAY;\\nint[] EMPTY_INT_ARRAY;\\nInteger[] EMPTY_INTEGER_OBJECT_ARRAY;\\nshort[] EMPTY_SHORT_ARRAY;\\nShort[] EMPTY_SHORT_OBJECT_ARRAY;\\nbyte[] EMPTY_BYTE_ARRAY;\\nByte[] EMPTY_BYTE_OBJECT_ARRAY;\\ndouble[] EMPTY_DOUBLE_ARRAY;\\nDouble[] EMPTY_DOUBLE_OBJECT_ARRAY;\\nfloat[] EMPTY_FLOAT_ARRAY;\\nFloat[] EMPTY_FLOAT_OBJECT_ARRAY;\\nboolean[] EMPTY_BOOLEAN_ARRAY;\\nBoolean[] EMPTY_BOOLEAN_OBJECT_ARRAY;\\nchar[] EMPTY_CHAR_ARRAY;\\nCharacter[] EMPTY_CHARACTER_OBJECT_ARRAY;\\nint INDEX_NOT_FOUND;\\nArrayUtils();\\nclone(Object[] array);\\nclone(long[] array);\\nclone(int[] array);\\nclone(short[] array);\\nclone(char[] array);\\nclone(byte[] array);\\nclone(double[] array);\\nclone(float[] array);\\nclone(boolean[] array);\\nclone(String[] array);\\nnullToEmpty(Object[] array);\\nnullToEmpty(String[] array);\\nnullToEmpty(long[] array);\\nnullToEmpty(int[] array);\\nnullToEmpty(short[] array);\\nnullToEmpty(char[] array);\\nnullToEmpty(byte[] array);\\nnullToEmpty(double[] array);\\nnullToEmpty(float[] array);\\nnullToEmpty(boolean[] array);\\nnullToEmpty(Long[] array);\\nnullToEmpty(Integer[] array);\\nnullToEmpty(Short[] array);\\nnullToEmpty(Character[] array);\\nnullToEmpty(Byte[] array);\\nnullToEmpty(Double[] array);\\nnullToEmpty(Float[] array);\\nnullToEmpty(Boolean[] array);\\nsubarray(Object[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(long[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(int[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(short[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(char[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(byte[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(double[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(float[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(boolean[] array,int startIndexInclusive,int endIndexExclusive);\\nisSameLength(Object[] array1,Object[] array2);\\nisSameLength(long[] array1,long[] array2);\\nisSameLength(int[] array1,int[] array2);\\nisSameLength(short[] array1,short[] array2);\\nisSameLength(char[] array1,char[] array2);\\nisSameLength(byte[] array1,byte[] array2);\\nisSameLength(double[] array1,double[] array2);\\nisSameLength(float[] array1,float[] array2);\\nisSameLength(boolean[] array1,boolean[] array2);\\ngetLength(Object array);\\nisSameType(Object array1,Object array2);\\nreverse(Object[] array);\\nreverse(long[] array);\\nreverse(int[] array);\\nreverse(short[] array);\\nreverse(char[] array);\\nreverse(byte[] array);\\nreverse(double[] array);\\nreverse(float[] array);\\nreverse(boolean[] array);\\nindexOf(Object[] array,Object objectToFind);\\nindexOf(Object[] array,Object objectToFind,int startIndex);\\nlastIndexOf(Object[] array,Object objectToFind);\\nlastIndexOf(Object[] array,Object objectToFind,int startIndex);\\ncontains(Object[] array,Object objectToFind);\\nindexOf(long[] array,long valueToFind);\\nindexOf(long[] array,long valueToFind,int startIndex);\\nlastIndexOf(long[] array,long valueToFind);\\nlastIndexOf(long[] array,long valueToFind,int startIndex);\\ncontains(long[] array,long valueToFind);\\nindexOf(int[] array,int valueToFind);\\nindexOf(int[] array,int valueToFind,int startIndex);\\nlastIndexOf(int[] array,int valueToFind);\\nlastIndexOf(int[] array,int valueToFind,int startIndex);\\ncontains(int[] array,int valueToFind);\\nindexOf(short[] array,short valueToFind);\\nindexOf(short[] array,short valueToFind,int startIndex);\\nlastIndexOf(short[] array,short valueToFind);\\nlastIndexOf(short[] array,short valueToFind,int startIndex);\\ncontains(short[] array,short valueToFind);\\nindexOf(char[] array,char valueToFind);\\nindexOf(char[] array,char valueToFind,int startIndex);\\nlastIndexOf(char[] array,char valueToFind);\\nlastIndexOf(char[] array,char valueToFind,int startIndex);\\ncontains(char[] array,char valueToFind);\\nindexOf(byte[] array,byte valueToFind);\\nindexOf(byte[] array,byte valueToFind,int startIndex);\\nlastIndexOf(byte[] array,byte valueToFind);\\nlastIndexOf(byte[] array,byte valueToFind,int startIndex);\\ncontains(byte[] array,byte valueToFind);\\nindexOf(double[] array,double valueToFind);\\nindexOf(double[] array,double valueToFind,double tolerance);\\nindexOf(double[] array,double valueToFind,int startIndex);\\nindexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\nlastIndexOf(double[] array,double valueToFind);\\nlastIndexOf(double[] array,double valueToFind,double tolerance);\\nlastIndexOf(double[] array,double valueToFind,int startIndex);\\nlastIndexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\ncontains(double[] array,double valueToFind);\\ncontains(double[] array,double valueToFind,double tolerance);\\nindexOf(float[] array,float valueToFind);\\nindexOf(float[] array,float valueToFind,int startIndex);\\nlastIndexOf(float[] array,float valueToFind);\\nlastIndexOf(float[] array,float valueToFind,int startIndex);\\ncontains(float[] array,float valueToFind);\\nindexOf(boolean[] array,boolean valueToFind);\\nindexOf(boolean[] array,boolean valueToFind,int startIndex);\\nlastIndexOf(boolean[] array,boolean valueToFind);\\nlastIndexOf(boolean[] array,boolean valueToFind,int startIndex);\\ncontains(boolean[] array,boolean valueToFind);\\ntoPrimitive(Character[] array);\\ntoPrimitive(Character[] array,char valueForNull);\\ntoObject(char[] array);\\ntoPrimitive(Long[] array);\\ntoPrimitive(Long[] array,long valueForNull);\\ntoObject(long[] array);\\ntoPrimitive(Integer[] array);\\ntoPrimitive(Integer[] array,int valueForNull);\\ntoObject(int[] array);\\ntoPrimitive(Short[] array);\\ntoPrimitive(Short[] array,short valueForNull);\\ntoObject(short[] array);\\ntoPrimitive(Byte[] array);\\ntoPrimitive(Byte[] array,byte valueForNull);\\ntoObject(byte[] array);\\ntoPrimitive(Double[] array);\\ntoPrimitive(Double[] array,double valueForNull);\\ntoObject(double[] array);\\ntoPrimitive(Float[] array);\\ntoPrimitive(Float[] array,float valueForNull);\\ntoObject(float[] array);\\ntoPrimitive(Boolean[] array);\\ntoPrimitive(Boolean[] array,boolean valueForNull);\\ntoObject(boolean[] array);\\nisEmpty(Object[] array);\\nisEmpty(long[] array);\\nisEmpty(int[] array);\\nisEmpty(short[] array);\\nisEmpty(char[] array);\\nisEmpty(byte[] array);\\nisEmpty(double[] array);\\nisEmpty(float[] array);\\nisEmpty(boolean[] array);\\nisNotEmpty(Object[] array);\\nisNotEmpty(long[] array);\\nisNotEmpty(int[] array);\\nisNotEmpty(short[] array);\\nisNotEmpty(char[] array);\\nisNotEmpty(byte[] array);\\nisNotEmpty(double[] array);\\nisNotEmpty(float[] array);\\nisNotEmpty(boolean[] array);\\naddAll(Object[] array1,Object[] array2);\\naddAll(boolean[] array1,boolean[] array2);\\naddAll(char[] array1,char[] array2);\\naddAll(byte[] array1,byte[] array2);\\naddAll(short[] array1,short[] array2);\\naddAll(int[] array1,int[] array2);\\naddAll(long[] array1,long[] array2);\\naddAll(float[] array1,float[] array2);\\naddAll(double[] array1,double[] array2);\\naddAll(String[] array1,String[] array2);\\nadd(T[] array,T element);\\nadd(boolean[] array,boolean element);\\nadd(byte[] array,byte element);\\nadd(char[] array,char element);\\nadd(double[] array,double element);\\nadd(float[] array,float element);\\nadd(int[] array,int element);\\nadd(long[] array,long element);\\nadd(short[] array,short element);\\ncopyArrayGrow1(Object array,Class newArrayComponentType);\\nadd(Object[] array,int index,Object element);\\nadd(boolean[] array,int index,boolean element);\\nadd(char[] array,int index,char element);\\nadd(byte[] array,int index,byte element);\\nadd(short[] array,int index,short element);\\nadd(int[] array,int index,int element);\\nadd(long[] array,int index,long element);\\nadd(float[] array,int index,float element);\\nadd(double[] array,int index,double element);\\nadd(Object array,int index,Object element,Class clss);\\nremove(Object[] array,int index);\\nremoveElement(Object[] array,Object element);\\nremove(boolean[] array,int index);\\nremoveElement(boolean[] array,boolean element);\\nremove(byte[] array,int index);\\nremoveElement(byte[] array,byte element);\\nremove(char[] array,int index);\\nremoveElement(char[] array,char element);\\nremove(double[] array,int index);\\nremoveElement(double[] array,double element);\\nremove(float[] array,int index);\\nremoveElement(float[] array,float element);\\nremove(int[] array,int index);\\nremoveElement(int[] array,int element);\\nremove(long[] array,int index);\\nremoveElement(long[] array,long element);\\nremove(short[] array,int index);\\nremoveElement(short[] array,short element);\\nremove(Object array,int index);\\nclearNull(Object[] arr);\\ntoMap(Object[] array);\\n\", \"repo_level\" : \"\" }",
      "class_name": "ArrayUtils",
      "code": "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n  if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n    return false;\n  }\n  return true;\n}\n",
      "docstring": "/** \n * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>\n * @param array1 the first array, may be <code>null</code>\n * @param array2 the second array, may be <code>null</code>\n * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array\n */\n",
      "end_lineno": "1130",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils;\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * <p>Operations on arrays, primitive arrays (like <code>int[]</code>) and\n * primitive wrapper arrays (like <code>Integer[]</code>).</p>\n *\n * <p>This class tries to handle <code>null</code> input gracefully.\n * An exception will not be thrown for a <code>null</code>\n * array input. However, an Object array that contains a <code>null</code>\n * element may throw an exception. Each method documents its behaviour.</p>\n *\n * <p>#ThreadSafe#</p>\n * @author Apache Software Foundation\n * @author Moritz Petersen\n * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n * @author Nikolay Metchev\n * @author Matthew Hawthorne\n * @author Tim O'Brien\n * @author Pete Gieser\n * @author Gary Gregory\n * @author <a href=\"mailto:equinus100@hotmail.com\">Ashwin S</a>\n * @author Maarten Coene\n * @since 2.0\n * @version $Id: ArrayUtils.java 1056988 2011-01-09 17:58:53Z niallp $\n */\npublic class ArrayUtils {\n    /** An empty immutable <code>Object</code> array. */\n    public static final Object[]    EMPTY_OBJECT_ARRAY           = new Object[0];\n    /** An empty immutable <code>Class</code> array. */\n    public static final Class<?>[]  EMPTY_CLASS_ARRAY            = new Class[0];\n    /** An empty immutable <code>String</code> array. */\n    public static final String[]    EMPTY_STRING_ARRAY           = new String[0];\n    /** An empty immutable <code>long</code> array. */\n    public static final long[]      EMPTY_LONG_ARRAY             = new long[0];\n    /** An empty immutable <code>Long</code> array. */\n    public static final Long[]      EMPTY_LONG_OBJECT_ARRAY      = new Long[0];\n    /** An empty immutable <code>int</code> array. */\n    public static final int[]       EMPTY_INT_ARRAY              = new int[0];\n    /** An empty immutable <code>Integer</code> array. */\n    public static final Integer[]   EMPTY_INTEGER_OBJECT_ARRAY   = new Integer[0];\n    /** An empty immutable <code>short</code> array. */\n    public static final short[]     EMPTY_SHORT_ARRAY            = new short[0];\n    /** An empty immutable <code>Short</code> array. */\n    public static final Short[]     EMPTY_SHORT_OBJECT_ARRAY     = new Short[0];\n    /** An empty immutable <code>byte</code> array. */\n    public static final byte[]      EMPTY_BYTE_ARRAY             = new byte[0];\n    /** An empty immutable <code>Byte</code> array. */\n    public static final Byte[]      EMPTY_BYTE_OBJECT_ARRAY      = new Byte[0];\n    /** An empty immutable <code>double</code> array. */\n    public static final double[]    EMPTY_DOUBLE_ARRAY           = new double[0];\n    /** An empty immutable <code>Double</code> array. */\n    public static final Double[]    EMPTY_DOUBLE_OBJECT_ARRAY    = new Double[0];\n    /** An empty immutable <code>float</code> array. */\n    public static final float[]     EMPTY_FLOAT_ARRAY            = new float[0];\n    /** An empty immutable <code>Float</code> array. */\n    public static final Float[]     EMPTY_FLOAT_OBJECT_ARRAY     = new Float[0];\n    /** An empty immutable <code>boolean</code> array. */\n    public static final boolean[]   EMPTY_BOOLEAN_ARRAY          = new boolean[0];\n    /** An empty immutable <code>Boolean</code> array. */\n    public static final Boolean[]   EMPTY_BOOLEAN_OBJECT_ARRAY   = new Boolean[0];\n    /** An empty immutable <code>char</code> array. */\n    public static final char[]      EMPTY_CHAR_ARRAY             = new char[0];\n    /** An empty immutable <code>Character</code> array. */\n    public static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n    /**\n     * The index value when an element is not found in a list or array: <code>-1</code>.\n     * This value is returned by methods in this class and can also be used in comparisons with values returned by\n     * various method from {@link java.util.List}.\n     */\n    public static final int         INDEX_NOT_FOUND              = -1;\n\n    /**\n     * <p>ArrayUtils instances should NOT be constructed in standard programming.\n     * Instead, the class should be used as <code>ArrayUtils.clone(new int[] {2})</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     */\n    public ArrayUtils() {\n        super();\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts the given array into a {@link Map}. Each element of the array\n     * must be either a {@link Entry} or an Array, containing at least two\n     * elements, where the first element is used as key and the second as\n     * value.</p>\n     *\n     * <p>This method can be used to initialize:</p>\n     * <pre>\n     * // Create a Map mapping colors.\n     * Map colorMap = ArrayUtils.toMap(new String[][] {{\n     *     {\"RED\", \"#FF0000\"},\n     *     {\"GREEN\", \"#00FF00\"},\n     *     {\"BLUE\", \"#0000FF\"}});\n     * </pre>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  an array whose elements are either a {@link Entry} or\n     *  an Array containing at least two elements, may be <code>null</code>\n     * @return a <code>Map</code> that was created from the array\n     * @throws IllegalArgumentException  if one element of this Array is\n     *  itself an Array containing less then two elements\n     * @throws IllegalArgumentException  if the array contains elements other\n     *  than {@link Entry} and an Array\n     */\n    public static Map toMap(final Object[] array) {\n        if (array == null) {\n            return null;\n        }\n        final Map map = new HashMap((int) (array.length * 1.5));\n        for (int i = 0; i < array.length; i++) {\n            Object object = array[i];\n            if (object instanceof Entry) {\n                Entry entry = (Entry) object;\n                map.put(entry.getKey(), entry.getValue());\n            } else if (object instanceof Object[]) {\n                Object[] entry = (Object[]) object;\n                if (entry.length < 2) {\n                    throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', has a length less than 2\");\n                }\n                map.put(entry[0], entry[1]);\n            } else {\n                throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', is neither of type Map.Entry nor an Array\");\n            }\n        }\n        return map;\n    }\n    // Clone\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Shallow clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>The objects in the array are not cloned, thus there is no special\n     * handling for multi-dimensional arrays.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to shallow clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static Object[] clone(final Object[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static long[] clone(final long[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static int[] clone(final int[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static short[] clone(final short[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static char[] clone(final char[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static byte[] clone(final byte[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static double[] clone(final double[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static float[] clone(final float[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static boolean[] clone(final boolean[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static String[] clone(final String[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n    // nullToEmpty\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Object[] nullToEmpty(final Object[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static String[] nullToEmpty(final String[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static long[] nullToEmpty(final long[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static int[] nullToEmpty(final int[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static short[] nullToEmpty(final short[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static char[] nullToEmpty(final char[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static byte[] nullToEmpty(final byte[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static double[] nullToEmpty(final double[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static float[] nullToEmpty(final float[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static boolean[] nullToEmpty(final boolean[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Long[] nullToEmpty(final Long[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Integer[] nullToEmpty(final Integer[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Short[] nullToEmpty(final Short[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Character[] nullToEmpty(final Character[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Byte[] nullToEmpty(final Byte[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Double[] nullToEmpty(final Double[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Float[] nullToEmpty(final Float[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Boolean[] nullToEmpty(final Boolean[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;\n        }\n        return array;\n    }\n    // Subarrays\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Produces a new array containing the elements between\n     * the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * <p>The component type of the subarray is always the same as\n     * that of the input array. Thus, if the input is an array of type\n     * <code>Date</code>, the following usage is envisaged:</p>\n     *\n     * <pre>\n     * Date[] someDates = (Date[])ArrayUtils.subarray(allDates, 2, 5);\n     * </pre>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static Object[] subarray(final Object[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        Class<?> type = array.getClass().getComponentType();\n        if (newSize <= 0) {\n            return (Object[]) Array.newInstance(type, 0);\n        }\n        Object[] subarray = (Object[]) Array.newInstance(type, newSize);\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>long</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        long[] subarray = new long[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>int</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        int[] subarray = new int[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>short</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        short[] subarray = new short[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>char</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        char[] subarray = new char[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>byte</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        byte[] subarray = new byte[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>double</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] subarray = new double[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>float</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        float[] subarray = new float[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>boolean</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        boolean[] subarray = new boolean[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n    // Is same length\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.\n     *\n     * <p>Any multi-dimensional aspects of the arrays are ignored.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final Object[] array1, final Object[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final long[] array1, final long[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final int[] array1, final int[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final short[] array1, final short[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final char[] array1, final char[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final double[] array1, final double[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final float[] array1, final float[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Returns the length of the specified array.\n     * This method can deal with <code>Object</code> arrays and with primitive arrays.</p>\n     *\n     * <p>If the input array is <code>null</code>, <code>0</code> is returned.</p>\n     *\n     * <pre>\n     * ArrayUtils.getLength(null)            = 0\n     * ArrayUtils.getLength([])              = 0\n     * ArrayUtils.getLength([null])          = 1\n     * ArrayUtils.getLength([true, false])   = 2\n     * ArrayUtils.getLength([1, 2, 3])       = 3\n     * ArrayUtils.getLength([\"a\", \"b\", \"c\"]) = 3\n     * </pre>\n     *\n     * @param array  the array to retrieve the length from, may be null\n     * @return The length of the array, or <code>0</code> if the array is <code>null</code>\n     * @throws IllegalArgumentException if the object arguement is not an array.\n     * @since 2.1\n     */\n    public static int getLength(final Object array) {\n        if (array == null) {\n            return 0;\n        }\n        return Array.getLength(array);\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same type taking into account\n     * multi-dimensional arrays.</p>\n     *\n     * @param array1 the first array, must not be <code>null</code>\n     * @param array2 the second array, must not be <code>null</code>\n     * @return <code>true</code> if type of arrays matches\n     * @throws IllegalArgumentException if either array is <code>null</code>\n     */\n    public static boolean isSameType(final Object array1, final Object array2) {\n        if (array1 == null || array2 == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        return array1.getClass().getName().equals(array2.getClass().getName());\n    }\n    // Reverse\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>There is no special handling for multi-dimensional arrays.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final Object[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        Object tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final long[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        long tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final int[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        int tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final short[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        short tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final char[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        char tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final byte[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        byte tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final double[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        double tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final float[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        float tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final boolean[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        boolean tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n    // IndexOf search\n    // ----------------------------------------------------------------------\n    // Object IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given object in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @return the index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final Object[] array, final Object objectToFind) {\n        return ArrayUtils.indexOf(array, objectToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given object in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @param startIndex  the index to start searching at\n     * @return the index of the object within the array starting at the index,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given object within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @return the last index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final Object[] array, final Object objectToFind) {\n        return ArrayUtils.lastIndexOf(array, objectToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given object in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n     * the array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i >= 0; i--) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n            for (int i = startIndex; i >= 0; i--) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the object is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param objectToFind  the object to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final Object[] array, final Object objectToFind) {\n        return ArrayUtils.indexOf(array, objectToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // long IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final long[] array, final long valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final long[] array, final long valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final long[] array, final long valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final long[] array, final long valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // int IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final int[] array, final int valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final int[] array, final int valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final int[] array, final int valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final int[] array, final int valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // short IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final short[] array, final short valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final short[] array, final short valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final short[] array, final short valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final short[] array, final short valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final short[] array, final short valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // char IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int indexOf(final char[] array, final char valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int indexOf(final char[] array, final char valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int lastIndexOf(final char[] array, final char valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int lastIndexOf(final char[] array, final char valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     * @since 2.1\n     */\n    public static boolean contains(final char[] array, final char valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // byte IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final byte[] array, final byte valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final byte[] array, final byte valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final byte[] array, final byte valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // double IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value within a given tolerance in the array.\n     * This method will return the index of the first value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind, final double tolerance) {\n        return ArrayUtils.indexOf(array, valueToFind, 0, tolerance);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.\n     * This method will return the index of the first value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        double min = valueToFind - tolerance;\n        double max = valueToFind + tolerance;\n        for (int i = startIndex; i < array.length; i++) {\n            if (array[i] >= min && array[i] <= max) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value within a given tolerance in the array.\n     * This method will return the index of the last value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.\n     * This method will return the index of the last value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @param tolerance  search for value within plus/minus this amount\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        double min = valueToFind - tolerance;\n        double max = valueToFind + tolerance;\n        for (int i = startIndex; i >= 0; i--) {\n            if (array[i] >= min && array[i] <= max) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final double[] array, final double valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if a value falling within the given tolerance is in the\n     * given array.  If the array contains a value within the inclusive range\n     * defined by (value - tolerance) to (value + tolerance).</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array\n     * is passed in.</p>\n     *\n     * @param array  the array to search\n     * @param valueToFind  the value to find\n     * @param tolerance  the array contains the tolerance of the search\n     * @return true if value falling within tolerance is in array\n     */\n    public static boolean contains(final double[] array, final double valueToFind, final double tolerance) {\n        return ArrayUtils.indexOf(array, valueToFind, 0, tolerance) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // float IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final float[] array, final float valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final float[] array, final float valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final float[] array, final float valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final float[] array, final float valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // boolean IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final boolean[] array, final boolean valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code>\n     *  array input\n     */\n    public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) if\n     * <code>null</code> array input.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final boolean[] array, final boolean valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n     * the array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final boolean[] array, final boolean valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // Primitive/Object array converters\n    // ----------------------------------------------------------------------\n    // Character array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Characters to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Character</code> array, may be <code>null</code>\n     * @return a <code>char</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static char[] toPrimitive(final Character[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].charValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Character to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Character</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>char</code> array, <code>null</code> if null array input\n     */\n    public static char[] toPrimitive(final Character[] array, final char valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Character b = array[i];\n            result[i] = b == null ? valueForNull : b.charValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive chars to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array a <code>char</code> array\n     * @return a <code>Character</code> array, <code>null</code> if null array input\n     */\n    public static Character[] toObject(final char[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY;\n        }\n        final Character[] result = new Character[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Character(array[i]);\n        }\n        return result;\n    }\n    // Long array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Longs to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Long</code> array, may be <code>null</code>\n     * @return a <code>long</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static long[] toPrimitive(final Long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].longValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Long to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Long</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>long</code> array, <code>null</code> if null array input\n     */\n    public static long[] toPrimitive(final Long[] array, final long valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Long b = array[i];\n            result[i] = b == null ? valueForNull : b.longValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive longs to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>long</code> array\n     * @return a <code>Long</code> array, <code>null</code> if null array input\n     */\n    public static Long[] toObject(final long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_OBJECT_ARRAY;\n        }\n        final Long[] result = new Long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Long(array[i]);\n        }\n        return result;\n    }\n    // Int array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Integers to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Integer</code> array, may be <code>null</code>\n     * @return an <code>int</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static int[] toPrimitive(final Integer[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].intValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Integer to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Integer</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return an <code>int</code> array, <code>null</code> if null array input\n     */\n    public static int[] toPrimitive(final Integer[] array, final int valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Integer b = array[i];\n            result[i] = b == null ? valueForNull : b.intValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive ints to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  an <code>int</code> array\n     * @return an <code>Integer</code> array, <code>null</code> if null array input\n     */\n    public static Integer[] toObject(final int[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        final Integer[] result = new Integer[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Integer(array[i]);\n        }\n        return result;\n    }\n    // Short array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Shorts to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Short</code> array, may be <code>null</code>\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static short[] toPrimitive(final Short[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        final short[] result = new short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].shortValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Short to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Short</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     */\n    public static short[] toPrimitive(final Short[] array, final short valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        final short[] result = new short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Short b = array[i];\n            result[i] = b == null ? valueForNull : b.shortValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive shorts to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>short</code> array\n     * @return a <code>Short</code> array, <code>null</code> if null array input\n     */\n    public static Short[] toObject(final short[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;\n        }\n        final Short[] result = new Short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Short(array[i]);\n        }\n        return result;\n    }\n    // Byte array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Bytes to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Byte</code> array, may be <code>null</code>\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static byte[] toPrimitive(final Byte[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        final byte[] result = new byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].byteValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Bytes to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Byte</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     */\n    public static byte[] toPrimitive(final Byte[] array, final byte valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        final byte[] result = new byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Byte b = array[i];\n            result[i] = b == null ? valueForNull : b.byteValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive bytes to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>byte</code> array\n     * @return a <code>Byte</code> array, <code>null</code> if null array input\n     */\n    public static Byte[] toObject(final byte[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;\n        }\n        final Byte[] result = new Byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Byte(array[i]);\n        }\n        return result;\n    }\n    // Double array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Doubles to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Double</code> array, may be <code>null</code>\n     * @return a <code>double</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static double[] toPrimitive(final Double[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        final double[] result = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].doubleValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Doubles to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Double</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>double</code> array, <code>null</code> if null array input\n     */\n    public static double[] toPrimitive(final Double[] array, final double valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        final double[] result = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Double b = array[i];\n            result[i] = b == null ? valueForNull : b.doubleValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive doubles to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>double</code> array\n     * @return a <code>Double</code> array, <code>null</code> if null array input\n     */\n    public static Double[] toObject(final double[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;\n        }\n        final Double[] result = new Double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Double(array[i]);\n        }\n        return result;\n    }\n    //   Float array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Floats to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Float</code> array, may be <code>null</code>\n     * @return a <code>float</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static float[] toPrimitive(final Float[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        final float[] result = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].floatValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Floats to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Float</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>float</code> array, <code>null</code> if null array input\n     */\n    public static float[] toPrimitive(final Float[] array, final float valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        final float[] result = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Float b = array[i];\n            result[i] = b == null ? valueForNull : b.floatValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive floats to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>float</code> array\n     * @return a <code>Float</code> array, <code>null</code> if null array input\n     */\n    public static Float[] toObject(final float[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY;\n        }\n        final Float[] result = new Float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Float(array[i]);\n        }\n        return result;\n    }\n    // Boolean array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Booleans to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n     * @return a <code>boolean</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static boolean[] toPrimitive(final Boolean[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        final boolean[] result = new boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].booleanValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Booleans to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>boolean</code> array, <code>null</code> if null array input\n     */\n    public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        final boolean[] result = new boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Boolean b = array[i];\n            result[i] = b == null ? valueForNull : b.booleanValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive booleans to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>boolean</code> array\n     * @return a <code>Boolean</code> array, <code>null</code> if null array input\n     */\n    public static Boolean[] toObject(final boolean[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;\n        }\n        final Boolean[] result = new Boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE;\n        }\n        return result;\n    }\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if an array of Objects is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final Object[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive longs is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final long[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive ints is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final int[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive shorts is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final short[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive chars is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final char[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive bytes is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final byte[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final double[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive floats is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final float[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive booleans is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final boolean[] array) {\n        return array == null || array.length == 0;\n    }\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if an array of Objects is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final Object[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive longs is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final long[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive ints is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final int[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive shorts is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final short[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive chars is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final char[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive bytes is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final byte[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive doubles is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final double[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive floats is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final float[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive booleans is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final boolean[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(null, null)     = null\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * ArrayUtils.addAll([null], [null]) = [null, null]\n     * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array, may be <code>null</code>\n     * @param array2  the second array whose elements are added to the new array, may be <code>null</code>\n     * @return The new array, <code>null</code> if both arrays are <code>null</code>.\n     *      The type of the new array is the type of the first array,\n     *      unless the first array is null, in which case the type is the same as the second array.\n     * @since 2.1\n     * @throws IllegalArgumentException if the array types are incompatible\n     */\n    public static Object[] addAll(final Object[] array1, final Object[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        Object[] joinedArray = (Object[]) Array.newInstance(array1.getClass().getComponentType(), array1.length + array2.length);\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        try {\n            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        } catch (ArrayStoreException ase) {\n            // Check if problem was due to incompatible types\n            /*\n             * We do this here, rather than before the copy because:\n             * - it would be a wasted check most of the time\n             * - safer, in case check turns out to be too strict\n             */\n            final Class<?> type1 = array1.getClass().getComponentType();\n            final Class<?> type2 = array2.getClass().getComponentType();\n            if (!type1.isAssignableFrom(type2)) {\n                throw new IllegalArgumentException(\"Cannot store \" + type2.getName() + \" in an array of \" + type1.getName());\n            }\n            throw ase; // No, so rethrow original\n        }\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new boolean[] array.\n     * @since 2.1\n     */\n    public static boolean[] addAll(final boolean[] array1, final boolean[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        boolean[] joinedArray = new boolean[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new char[] array.\n     * @since 2.1\n     */\n    public static char[] addAll(final char[] array1, final char[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        char[] joinedArray = new char[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new byte[] array.\n     * @since 2.1\n     */\n    public static byte[] addAll(final byte[] array1, final byte[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        byte[] joinedArray = new byte[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new short[] array.\n     * @since 2.1\n     */\n    public static short[] addAll(final short[] array1, final short[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        short[] joinedArray = new short[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new int[] array.\n     * @since 2.1\n     */\n    public static int[] addAll(final int[] array1, final int[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        int[] joinedArray = new int[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new long[] array.\n     * @since 2.1\n     */\n    public static long[] addAll(final long[] array1, final long[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        long[] joinedArray = new long[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new float[] array.\n     * @since 2.1\n     */\n    public static float[] addAll(final float[] array1, final float[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        float[] joinedArray = new float[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new double[] array.\n     * @since 2.1\n     */\n    public static double[] addAll(final double[] array1, final double[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        double[] joinedArray = new double[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new String[] array.\n     * @since 2.1\n     */\n    public static String[] addAll(final String[] array1, final String[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        String[] joinedArray = new String[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element, unless the element itself is null,\n     *  in which case the return type is Object[]</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, null)      = [null]\n     * ArrayUtils.add(null, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to \"add\" the element to, may be <code>null</code>\n     * @param element  the object to add, may be <code>null</code>\n     * @return A new array containing the existing elements plus the new element\n     * The returned array type will be that of the input array (unless null),\n     * in which case it will have the same type as the element.\n     * @since 2.1\n     */\n    public static <T> T[] add(final T[] array, final T element) {\n        Class<?> type;\n        if (array != null) {\n            type = array.getClass();\n        } else if (element != null) {\n            type = element.getClass();\n        } else {\n            type = Object.class;\n        }\n        T[] newArray = (T[]) ArrayUtils.copyArrayGrow1(array, type);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, true)          = [true]\n     * ArrayUtils.add([true], false)       = [true, false]\n     * ArrayUtils.add([true, false], true) = [true, false, true]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static boolean[] add(final boolean[] array, final boolean element) {\n        boolean[] newArray = (boolean[]) ArrayUtils.copyArrayGrow1(array, Boolean.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static byte[] add(final byte[] array, final byte element) {\n        byte[] newArray = (byte[]) ArrayUtils.copyArrayGrow1(array, Byte.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, '0')       = ['0']\n     * ArrayUtils.add(['1'], '0')      = ['1', '0']\n     * ArrayUtils.add(['1', '0'], '1') = ['1', '0', '1']\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static char[] add(final char[] array, final char element) {\n        char[] newArray = (char[]) ArrayUtils.copyArrayGrow1(array, Character.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static double[] add(final double[] array, final double element) {\n        double[] newArray = (double[]) ArrayUtils.copyArrayGrow1(array, Double.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static float[] add(final float[] array, final float element) {\n        float[] newArray = (float[]) ArrayUtils.copyArrayGrow1(array, Float.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static int[] add(final int[] array, final int element) {\n        int[] newArray = (int[]) ArrayUtils.copyArrayGrow1(array, Integer.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static long[] add(final long[] array, final long element) {\n        long[] newArray = (long[]) ArrayUtils.copyArrayGrow1(array, Long.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static short[] add(final short[] array, final short element) {\n        short[] newArray = (short[]) ArrayUtils.copyArrayGrow1(array, Short.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * Returns a copy of the given array of size 1 greater than the argument.\n     * The last value of the array is left to the default value.\n     *\n     * @param array The array to copy, must not be <code>null</code>.\n     * @param newArrayComponentType If <code>array</code> is <code>null</code>, create a\n     * size 1 array of this type.\n     * @return A new copy of the array of size 1 greater than the input.\n     */\n    private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n        if (array != null) {\n            int arrayLength = Array.getLength(array);\n            Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n            System.arraycopy(array, 0, newArray, 0, arrayLength);\n            return newArray;\n        }\n        return Array.newInstance(newArrayComponentType, 1);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, null)      = [null]\n     * ArrayUtils.add(null, 0, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], 1, null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], 1, \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], 3, \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > array.length).\n     */\n    public static Object[] add(final Object[] array, final int index, final Object element) {\n        Class<?> clss = null;\n        if (array != null) {\n            clss = array.getClass().getComponentType();\n        } else if (element != null) {\n            clss = element.getClass();\n        } else {\n            return new Object[] { null };\n        }\n        return (Object[]) ArrayUtils.add(array, index, element, clss);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, true)          = [true]\n     * ArrayUtils.add([true], 0, false)       = [false, true]\n     * ArrayUtils.add([false], 1, true)       = [false, true]\n     * ArrayUtils.add([true, false], 1, true) = [true, true, false]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static boolean[] add(final boolean[] array, final int index, final boolean element) {\n        Boolean booElement = element ? Boolean.TRUE : Boolean.FALSE;\n        return (boolean[]) ArrayUtils.add(array, index, booElement, Boolean.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, 'a')            = ['a']\n     * ArrayUtils.add(['a'], 0, 'b')           = ['b', 'a']\n     * ArrayUtils.add(['a', 'b'], 0, 'c')      = ['c', 'a', 'b']\n     * ArrayUtils.add(['a', 'b'], 1, 'k')      = ['a', 'k', 'b']\n     * ArrayUtils.add(['a', 'b', 'c'], 1, 't') = ['a', 't', 'b', 'c']\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static char[] add(final char[] array, final int index, final char element) {\n        return (char[]) ArrayUtils.add(array, index, new Character(element), Character.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 3)      = [2, 6, 3]\n     * ArrayUtils.add([2, 6], 0, 1)      = [1, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static byte[] add(final byte[] array, final int index, final byte element) {\n        return (byte[]) ArrayUtils.add(array, index, new Byte(element), Byte.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static short[] add(final short[] array, final int index, final short element) {\n        return (short[]) ArrayUtils.add(array, index, new Short(element), Short.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static int[] add(final int[] array, final int index, final int element) {\n        return (int[]) ArrayUtils.add(array, index, new Integer(element), Integer.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1L], 0, 2L)           = [2L, 1L]\n     * ArrayUtils.add([2L, 6L], 2, 10L)      = [2L, 6L, 10L]\n     * ArrayUtils.add([2L, 6L], 0, -4L)      = [-4L, 2L, 6L]\n     * ArrayUtils.add([2L, 6L, 3L], 2, 1L)   = [2L, 6L, 1L, 3L]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static long[] add(final long[] array, final int index, final long element) {\n        return (long[]) ArrayUtils.add(array, index, new Long(element), Long.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1.1f], 0, 2.2f)               = [2.2f, 1.1f]\n     * ArrayUtils.add([2.3f, 6.4f], 2, 10.5f)        = [2.3f, 6.4f, 10.5f]\n     * ArrayUtils.add([2.6f, 6.7f], 0, -4.8f)        = [-4.8f, 2.6f, 6.7f]\n     * ArrayUtils.add([2.9f, 6.0f, 0.3f], 2, 1.0f)   = [2.9f, 6.0f, 1.0f, 0.3f]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static float[] add(final float[] array, final int index, final float element) {\n        return (float[]) ArrayUtils.add(array, index, new Float(element), Float.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1.1], 0, 2.2)              = [2.2, 1.1]\n     * ArrayUtils.add([2.3, 6.4], 2, 10.5)        = [2.3, 6.4, 10.5]\n     * ArrayUtils.add([2.6, 6.7], 0, -4.8)        = [-4.8, 2.6, 6.7]\n     * ArrayUtils.add([2.9, 6.0, 0.3], 2, 1.0)    = [2.9, 6.0, 1.0, 0.3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static double[] add(final double[] array, final int index, final double element) {\n        return (double[]) ArrayUtils.add(array, index, new Double(element), Double.TYPE);\n    }\n\n    /**\n     * Underlying implementation of add(array, index, element) methods.\n     * The last parameter is the class, which may not equal element.getClass\n     * for primitives.\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @param clss the type of the element being added\n     * @return A new array containing the existing elements and the new element\n     */\n    private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {\n        if (array == null) {\n            if (index != 0) {\n                throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n            }\n            Object joinedArray = Array.newInstance(clss, 1);\n            Array.set(joinedArray, 0, element);\n            return joinedArray;\n        }\n        int length = Array.getLength(array);\n        if (index > length || index < 0) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n        }\n        Object result = Array.newInstance(clss, length + 1);\n        System.arraycopy(array, 0, result, 0, index);\n        Array.set(result, index, element);\n        if (index < length) {\n            System.arraycopy(array, index, result, index + 1, length - index);\n        }\n        return result;\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([\"a\"], 0)           = []\n     * ArrayUtils.remove([\"a\", \"b\"], 0)      = [\"b\"]\n     * ArrayUtils.remove([\"a\", \"b\"], 1)      = [\"a\"]\n     * ArrayUtils.remove([\"a\", \"b\", \"c\"], 1) = [\"a\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static Object[] remove(final Object[] array, final int index) {\n        return (Object[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, \"a\")            = null\n     * ArrayUtils.removeElement([], \"a\")              = []\n     * ArrayUtils.removeElement([\"a\"], \"b\")           = [\"a\"]\n     * ArrayUtils.removeElement([\"a\", \"b\"], \"a\")      = [\"b\"]\n     * ArrayUtils.removeElement([\"a\", \"b\", \"a\"], \"a\") = [\"b\", \"a\"]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static Object[] removeElement(final Object[] array, final Object element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([true], 0)              = []\n     * ArrayUtils.remove([true, false], 0)       = [false]\n     * ArrayUtils.remove([true, false], 1)       = [true]\n     * ArrayUtils.remove([true, true, false], 1) = [true, false]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static boolean[] remove(final boolean[] array, final int index) {\n        return (boolean[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, true)                = null\n     * ArrayUtils.removeElement([], true)                  = []\n     * ArrayUtils.removeElement([true], false)             = [true]\n     * ArrayUtils.removeElement([true, false], false)      = [true]\n     * ArrayUtils.removeElement([true, false, true], true) = [false, true]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static boolean[] removeElement(final boolean[] array, final boolean element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)          = []\n     * ArrayUtils.remove([1, 0], 0)       = [0]\n     * ArrayUtils.remove([1, 0], 1)       = [1]\n     * ArrayUtils.remove([1, 0, 1], 1)    = [1, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static byte[] remove(final byte[] array, final int index) {\n        return (byte[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)        = null\n     * ArrayUtils.removeElement([], 1)          = []\n     * ArrayUtils.removeElement([1], 0)         = [1]\n     * ArrayUtils.removeElement([1, 0], 0)      = [1]\n     * ArrayUtils.removeElement([1, 0, 1], 1)   = [0, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static byte[] removeElement(final byte[] array, final byte element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove(['a'], 0)           = []\n     * ArrayUtils.remove(['a', 'b'], 0)      = ['b']\n     * ArrayUtils.remove(['a', 'b'], 1)      = ['a']\n     * ArrayUtils.remove(['a', 'b', 'c'], 1) = ['a', 'c']\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static char[] remove(final char[] array, final int index) {\n        return (char[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 'a')            = null\n     * ArrayUtils.removeElement([], 'a')              = []\n     * ArrayUtils.removeElement(['a'], 'b')           = ['a']\n     * ArrayUtils.removeElement(['a', 'b'], 'a')      = ['b']\n     * ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static char[] removeElement(final char[] array, final char element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1.1], 0)           = []\n     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static double[] remove(final double[] array, final int index) {\n        return (double[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1.1)            = null\n     * ArrayUtils.removeElement([], 1.1)              = []\n     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static double[] removeElement(final double[] array, final double element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1.1], 0)           = []\n     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static float[] remove(final float[] array, final int index) {\n        return (float[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1.1)            = null\n     * ArrayUtils.removeElement([], 1.1)              = []\n     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static float[] removeElement(final float[] array, final float element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static int[] remove(final int[] array, final int index) {\n        return (int[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static int[] removeElement(final int[] array, final int element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static long[] remove(final long[] array, final int index) {\n        return (long[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static long[] removeElement(final long[] array, final long element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static short[] remove(final short[] array, final int index) {\n        return (short[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static short[] removeElement(final short[] array, final short element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    private static Object remove(final Object array, final int index) {\n        int length = ArrayUtils.getLength(array);\n        if (index < 0 || index >= length) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n        }\n        Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);\n        System.arraycopy(array, 0, result, 0, index);\n        if (index < length - 1) {\n            System.arraycopy(array, index + 1, result, index, length - index - 1);\n        }\n        return result;\n    }\n\n    /**删除数组中空元素*/\n    public static Object[] clearNull(final Object[] arr) {\n        ArrayList<Object> list = new ArrayList<Object>();\n        if (arr != null) {\n            for (Object item : arr) {\n                if (item != null) {\n                    list.add(item);\n                }\n            }\n        }\n        return list.toArray();\n    }\n}\n",
      "file_name": "ArrayUtils.java",
      "human_label": "Check whether the length of the given two byte arrays is the same.",
      "level": "self_contained",
      "lineno": "1116",
      "name": "isSameLength",
      "oracle_context": "{ \"apis\" : \"[]\", \"classes\" : \"[]\", \"vars\" : \"[length]\" }",
      "package": "net.hasor.utils",
      "project": "hasor-master"
    },
    {
      "_id": "636766a91a6d9265ec0175c2",
      "all_context": "{ \"class_level\" : \"int SAME_FRAME;\\nint SAME_LOCALS_1_STACK_ITEM_FRAME;\\nint SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\\nint CHOP_FRAME;\\nint SAME_FRAME_EXTENDED;\\nint APPEND_FRAME;\\nint FULL_FRAME;\\nint ITEM_TOP;\\nint ITEM_INTEGER;\\nint ITEM_FLOAT;\\nint ITEM_DOUBLE;\\nint ITEM_LONG;\\nint ITEM_NULL;\\nint ITEM_UNINITIALIZED_THIS;\\nint ITEM_OBJECT;\\nint ITEM_UNINITIALIZED;\\nint ITEM_ASM_BOOLEAN;\\nint ITEM_ASM_BYTE;\\nint ITEM_ASM_CHAR;\\nint ITEM_ASM_SHORT;\\nint DIM_SIZE;\\nint KIND_SIZE;\\nint FLAGS_SIZE;\\nint VALUE_SIZE;\\nint DIM_SHIFT;\\nint KIND_SHIFT;\\nint FLAGS_SHIFT;\\nint DIM_MASK;\\nint KIND_MASK;\\nint VALUE_MASK;\\nint ARRAY_OF;\\nint ELEMENT_OF;\\nint CONSTANT_KIND;\\nint REFERENCE_KIND;\\nint UNINITIALIZED_KIND;\\nint LOCAL_KIND;\\nint STACK_KIND;\\nint TOP_IF_LONG_OR_DOUBLE_FLAG;\\nint TOP;\\nint BOOLEAN;\\nint BYTE;\\nint CHAR;\\nint SHORT;\\nint INTEGER;\\nint FLOAT;\\nint LONG;\\nint DOUBLE;\\nint NULL;\\nint UNINITIALIZED_THIS;\\nLabel owner;\\nint[] inputLocals;\\nint[] inputStack;\\nint[] outputLocals;\\nint[] outputStack;\\nshort outputStackStart;\\nshort outputStackTop;\\nint initializationCount;\\nint[] initializations;\\nFrame(Label owner);\\ngetAbstractTypeFromDescriptor(SymbolTable symbolTable,String buffer,int offset);\\nsetInputFrameFromDescriptor(SymbolTable symbolTable,int access,String descriptor,int maxLocals);\\ngetLocal(int localIndex);\\nsetLocal(int localIndex,int abstractType);\\npush(SymbolTable symbolTable,String descriptor);\\npop();\\npop(int elements);\\npop(String descriptor);\\naddInitializedType(int abstractType);\\ngetInitializedType(SymbolTable symbolTable,int abstractType);\\nexecute(int opcode,int arg,Symbol argSymbol,SymbolTable symbolTable);\\ngetConcreteOutputType(int abstractOutputType,int numStack);\\nmerge(SymbolTable symbolTable,Frame dstFrame);\\nmerge(SymbolTable symbolTable,int sourceType,int[] dstTypes,int dstIndex);\\naccept(MethodWriter methodWriter);\\npush(int abstractType);\\n\", \"repo_level\" : \"\" }",
      "class_name": "Frame",
      "code": "private int pop(){\n  if (outputStackTop > 0) {\n    return outputStack[--outputStackTop];\n  }\n else {\n    return STACK_KIND | -(--outputStackStart);\n  }\n}\n",
      "docstring": "/** \n * Pops an abstract type from the output frame stack and returns its value.\n * @return the abstract type that has been popped from the output frame stack.\n */\n",
      "end_lineno": "629",
      "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage com.alibaba.fastjson2.internal.asm;\n\n/**\n * @author Eric Bruneton\n */\nclass Frame {\n    // Constants used in the StackMapTable attribute.\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4.\n\n    static final int SAME_FRAME = 0;\n    static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n//    static final int RESERVED = 128;\n    static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n    static final int CHOP_FRAME = 248;\n    static final int SAME_FRAME_EXTENDED = 251;\n    static final int APPEND_FRAME = 252;\n    static final int FULL_FRAME = 255;\n\n    static final int ITEM_TOP = 0;\n    static final int ITEM_INTEGER = 1;\n    static final int ITEM_FLOAT = 2;\n    static final int ITEM_DOUBLE = 3;\n    static final int ITEM_LONG = 4;\n    static final int ITEM_NULL = 5;\n    static final int ITEM_UNINITIALIZED_THIS = 6;\n    static final int ITEM_OBJECT = 7;\n    static final int ITEM_UNINITIALIZED = 8;\n    // Additional, ASM specific constants used in abstract types below.\n    static final int ITEM_ASM_BOOLEAN = 9;\n    static final int ITEM_ASM_BYTE = 10;\n    static final int ITEM_ASM_CHAR = 11;\n    static final int ITEM_ASM_SHORT = 12;\n\n    // The size and offset in bits of each field of an abstract type.\n\n    static final int DIM_SIZE = 6;\n    static final int KIND_SIZE = 4;\n    static final int FLAGS_SIZE = 2;\n    static final int VALUE_SIZE = 32 - DIM_SIZE - KIND_SIZE - FLAGS_SIZE;\n\n    static final int DIM_SHIFT = KIND_SIZE + FLAGS_SIZE + VALUE_SIZE;\n    static final int KIND_SHIFT = FLAGS_SIZE + VALUE_SIZE;\n    static final int FLAGS_SHIFT = VALUE_SIZE;\n\n    // Bitmasks to get each field of an abstract type.\n\n    static final int DIM_MASK = ((1 << DIM_SIZE) - 1) << DIM_SHIFT;\n    static final int KIND_MASK = ((1 << KIND_SIZE) - 1) << KIND_SHIFT;\n    static final int VALUE_MASK = (1 << VALUE_SIZE) - 1;\n\n    // Constants to manipulate the DIM field of an abstract type.\n\n    /**\n     * The constant to be added to an abstract type to get one with one more array dimension.\n     */\n    static final int ARRAY_OF = +1 << DIM_SHIFT;\n\n    /**\n     * The constant to be added to an abstract type to get one with one less array dimension.\n     */\n    static final int ELEMENT_OF = -1 << DIM_SHIFT;\n\n    // Possible values for the KIND field of an abstract type.\n\n    static final int CONSTANT_KIND = 1 << KIND_SHIFT;\n    static final int REFERENCE_KIND = 2 << KIND_SHIFT;\n    static final int UNINITIALIZED_KIND = 3 << KIND_SHIFT;\n    static final int LOCAL_KIND = 4 << KIND_SHIFT;\n    static final int STACK_KIND = 5 << KIND_SHIFT;\n\n    // Possible flags for the FLAGS field of an abstract type.\n\n    /**\n     * A flag used for LOCAL_KIND and STACK_KIND abstract types, indicating that if the resolved,\n     * concrete type is LONG or DOUBLE, TOP should be used instead (because the value has been\n     * partially overridden with an xSTORE instruction).\n     */\n    private static final int TOP_IF_LONG_OR_DOUBLE_FLAG = 1 << FLAGS_SHIFT;\n\n    // Useful predefined abstract types (all the possible CONSTANT_KIND types).\n\n    private static final int TOP = CONSTANT_KIND | ITEM_TOP;\n    private static final int BOOLEAN = CONSTANT_KIND | ITEM_ASM_BOOLEAN;\n    private static final int BYTE = CONSTANT_KIND | ITEM_ASM_BYTE;\n    private static final int CHAR = CONSTANT_KIND | ITEM_ASM_CHAR;\n    private static final int SHORT = CONSTANT_KIND | ITEM_ASM_SHORT;\n    private static final int INTEGER = CONSTANT_KIND | ITEM_INTEGER;\n    private static final int FLOAT = CONSTANT_KIND | ITEM_FLOAT;\n    private static final int LONG = CONSTANT_KIND | ITEM_LONG;\n    private static final int DOUBLE = CONSTANT_KIND | ITEM_DOUBLE;\n    private static final int NULL = CONSTANT_KIND | ITEM_NULL;\n    private static final int UNINITIALIZED_THIS = CONSTANT_KIND | ITEM_UNINITIALIZED_THIS;\n\n    // -----------------------------------------------------------------------------------------------\n    // Instance fields\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * The basic block to which these input and output stack map frames correspond.\n     */\n    Label owner;\n\n    /**\n     * The input stack map frame locals. This is an array of abstract types.\n     */\n    private int[] inputLocals;\n\n    /**\n     * The input stack map frame stack. This is an array of abstract types.\n     */\n    int[] inputStack;\n\n    /**\n     * The output stack map frame locals. This is an array of abstract types.\n     */\n    private int[] outputLocals;\n\n    /**\n     * The output stack map frame stack. This is an array of abstract types.\n     */\n    private int[] outputStack;\n\n    /**\n     * The start of the output stack, relatively to the input stack. This offset is always negative or\n     * null. A null offset means that the output stack must be appended to the input stack. A -n\n     * offset means that the first n output stack elements must replace the top n input stack\n     * elements, and that the other elements must be appended to the input stack.\n     */\n    private short outputStackStart;\n\n    /**\n     * The index of the top stack element in {@link #outputStack}.\n     */\n    private short outputStackTop;\n\n    /**\n     * The number of types that are initialized in the basic block. See {@link #initializations}.\n     */\n    private int initializationCount;\n\n    /**\n     * The abstract types that are initialized in the basic block. A constructor invocation on an\n     * UNINITIALIZED or UNINITIALIZED_THIS abstract type must replace <i>every occurrence</i> of this\n     * type in the local variables and in the operand stack. This cannot be done during the first step\n     * of the algorithm since, during this step, the local variables and the operand stack types are\n     * still abstract. It is therefore necessary to store the abstract types of the constructors which\n     * are invoked in the basic block, in order to do this replacement during the second step of the\n     * algorithm, where the frames are fully computed. Note that this array can contain abstract types\n     * that are relative to the input locals or to the input stack.\n     */\n    private int[] initializations;\n\n    // -----------------------------------------------------------------------------------------------\n    // Constructor\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Constructs a new Frame.\n     *\n     * @param owner the basic block to which these input and output stack map frames correspond.\n     */\n    Frame(final Label owner) {\n        this.owner = owner;\n    }\n//\n//    /**\n//     * Returns the abstract type corresponding to the internal name of a class.\n//     *\n//     * @param symbolTable  the type table to use to lookup and store type {@link Symbol}.\n//     * @param internalName the internal name of a class. This must <i>not</i> be an array type\n//     *                     descriptor.\n//     * @return the abstract type value corresponding to the given internal name.\n//     */\n//    static int getAbstractTypeFromInternalName(\n//            final SymbolTable symbolTable, final String internalName) {\n//        return REFERENCE_KIND | symbolTable.addType(internalName);\n//    }\n\n    /**\n     * Returns the abstract type corresponding to the given type descriptor.\n     *\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     * @param buffer      a string ending with a type descriptor.\n     * @param offset      the start offset of the type descriptor in buffer.\n     * @return the abstract type corresponding to the given type descriptor.\n     */\n    private static int getAbstractTypeFromDescriptor(\n            final SymbolTable symbolTable, final String buffer, final int offset) {\n        String internalName = null;\n        switch (buffer.charAt(offset)) {\n            case 'V':\n                return 0;\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                return INTEGER;\n            case 'F':\n                return FLOAT;\n            case 'J':\n                return LONG;\n            case 'D':\n                return DOUBLE;\n            case 'L':\n                if (offset == 0) {\n                    switch (buffer) {\n                        case \"Ljava/lang/Object;\":\n                            internalName = \"java/lang/Object\";\n                            break;\n                        case \"Ljava/lang/Class;\":\n                            internalName = \"java/lang/Class\";\n                            break;\n                        case \"Ljava/lang/String;\":\n                            internalName = \"java/lang/String\";\n                            break;\n                        case \"Ljava/util/List;\":\n                            internalName = \"java/util/List\";\n                            break;\n                        case \"Ljava/lang/reflect/Type;\":\n                            internalName = \"java/lang/reflect/Type\";\n                            break;\n                        case \"Ljava/util/function/Supplier;\":\n                            internalName = \"java/util/function/Supplier\";\n                            break;\n                        case \"Lsun/misc/Unsafe;\":\n                            internalName = \"sun/misc/Unsafe\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/JSONReader;\":\n                            internalName = \"com/alibaba/fastjson2/JSONReader\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/reader/FieldReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/FieldReader\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/reader/ObjectReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/ObjectReader\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/JSONWriter;\":\n                            internalName = \"com/alibaba/fastjson2/JSONWriter\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/writer/FieldWriter;\":\n                            internalName = \"com/alibaba/fastjson2/writer/FieldWriter\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else if (offset == 2) {\n                    switch (buffer) {\n                        case \"()Ljava/lang/Class;\":\n                            internalName = \"java/lang/Class\";\n                            break;\n                        case \"()Ljava/lang/String;\":\n                            internalName = \"java/lang/String\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else if (offset == 3) {\n                    switch (buffer) {\n                        case \"(J)Lcom/alibaba/fastjson2/reader/FieldReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/FieldReader\";\n                            break;\n                        case \"(I)Ljava/lang/Object;\":\n                            internalName = \"java/lang/Object\";\n                            break;\n                        case \"(I)Ljava/lang/Integer;\":\n                            internalName = \"java/lang/Integer\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else if (offset == 36) {\n                    switch (buffer) {\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;)Lcom/alibaba/fastjson2/reader/ObjectReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/ObjectReader\";\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;)Ljava/lang/Object;\":\n                            internalName = \"java/lang/Object\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else if (offset == 54) {\n                    switch (buffer) {\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;Ljava/lang/Class;J)Lcom/alibaba/fastjson2/reader/ObjectReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/ObjectReader\";\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;Ljava/lang/Class;J)Ljava/lang/Object;\":\n                            internalName = \"java/lang/Object\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else {\n                    switch (buffer) {\n                        case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/Class;)Lcom/alibaba/fastjson2/writer/ObjectWriter;\":\n                            if (offset == 53) {\n                                internalName = \"com/alibaba/fastjson2/writer/ObjectWriter\";\n                            }\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/reflect/Type;)Lcom/alibaba/fastjson2/writer/ObjectWriter;\":\n                            if (offset == 60) {\n                                internalName = \"com/alibaba/fastjson2/writer/ObjectWriter\";\n                            }\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/writer/FieldWriter;Ljava/lang/Object;)Ljava/lang/String;\":\n                            if (offset == 62) {\n                                internalName = \"java/lang/String\";\n                            }\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;Ljava/lang/reflect/Type;Ljava/lang/Object;J)Ljava/lang/Object;\":\n                            if (offset == 79) {\n                                internalName = \"java/lang/Object\";\n                            }\n                            break;\n                        default:\n                            break;\n                    }\n                }\n\n                if (internalName == null) {\n                    internalName = buffer.substring(offset + 1, buffer.length() - 1);\n                }\n                return REFERENCE_KIND | symbolTable.addType(internalName);\n            case '[':\n                int elementDescriptorOffset = offset + 1;\n                while (buffer.charAt(elementDescriptorOffset) == '[') {\n                    ++elementDescriptorOffset;\n                }\n                int typeValue;\n                switch (buffer.charAt(elementDescriptorOffset)) {\n                    case 'Z':\n                        typeValue = BOOLEAN;\n                        break;\n                    case 'C':\n                        typeValue = CHAR;\n                        break;\n                    case 'B':\n                        typeValue = BYTE;\n                        break;\n                    case 'S':\n                        typeValue = SHORT;\n                        break;\n                    case 'I':\n                        typeValue = INTEGER;\n                        break;\n                    case 'F':\n                        typeValue = FLOAT;\n                        break;\n                    case 'J':\n                        typeValue = LONG;\n                        break;\n                    case 'D':\n                        typeValue = DOUBLE;\n                        break;\n                    case 'L':\n                        if (offset == 0) {\n                            switch (buffer) {\n                                case \"[Lcom/alibaba/fastjson2/writer/FieldWriter;\":\n                                    internalName = \"com/alibaba/fastjson2/reader/FieldReader\";\n                                    break;\n                                case \"[Lcom/alibaba/fastjson2/reader/FieldReader;\":\n                                    internalName = \"Lcom/alibaba/fastjson2/reader/FieldReader\";\n                                    break;\n                                default:\n                                    break;\n                            }\n                        }\n                        if (internalName == null) {\n                            internalName = buffer.substring(elementDescriptorOffset + 1, buffer.length() - 1);\n                        }\n                        typeValue = REFERENCE_KIND | symbolTable.addType(internalName);\n                        break;\n                    default:\n                        throw new IllegalArgumentException();\n                }\n                return ((elementDescriptorOffset - offset) << DIM_SHIFT) | typeValue;\n            default:\n                throw new IllegalArgumentException();\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Methods related to the input frame\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Sets the input frame from the given method description. This method is used to initialize the\n     * first frame of a method, which is implicit (i.e. not stored explicitly in the StackMapTable\n     * attribute).\n     *\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     * @param access      the method's access flags.\n     * @param descriptor  the method descriptor.\n     * @param maxLocals   the maximum number of local variables of the method.\n     */\n    final void setInputFrameFromDescriptor(\n            final SymbolTable symbolTable,\n            final int access,\n            final String descriptor,\n            final int maxLocals) {\n        inputLocals = new int[maxLocals];\n        inputStack = new int[0];\n        int inputLocalIndex = 0;\n        if ((access & Opcodes.ACC_STATIC) == 0) {\n            if ((access & Constants.ACC_CONSTRUCTOR) == 0) {\n                inputLocals[inputLocalIndex++] =\n                        REFERENCE_KIND | symbolTable.addType(symbolTable.className);\n            } else {\n                inputLocals[inputLocalIndex++] = UNINITIALIZED_THIS;\n            }\n        }\n        for (Type argumentType : Type.getArgumentTypes(descriptor)) {\n            int abstractType =\n                    getAbstractTypeFromDescriptor(symbolTable, argumentType.getDescriptor(), 0);\n            inputLocals[inputLocalIndex++] = abstractType;\n            if (abstractType == LONG || abstractType == DOUBLE) {\n                inputLocals[inputLocalIndex++] = TOP;\n            }\n        }\n        while (inputLocalIndex < maxLocals) {\n            inputLocals[inputLocalIndex++] = TOP;\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Methods related to the output frame\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the abstract type stored at the given local variable index in the output frame.\n     *\n     * @param localIndex the index of the local variable whose value must be returned.\n     * @return the abstract type stored at the given local variable index in the output frame.\n     */\n    private int getLocal(final int localIndex) {\n        if (outputLocals == null || localIndex >= outputLocals.length) {\n            // If this local has never been assigned in this basic block, it is still equal to its value\n            // in the input frame.\n            return LOCAL_KIND | localIndex;\n        } else {\n            int abstractType = outputLocals[localIndex];\n            if (abstractType == 0) {\n                // If this local has never been assigned in this basic block, so it is still equal to its\n                // value in the input frame.\n                abstractType = outputLocals[localIndex] = LOCAL_KIND | localIndex;\n            }\n            return abstractType;\n        }\n    }\n\n    /**\n     * Replaces the abstract type stored at the given local variable index in the output frame.\n     *\n     * @param localIndex   the index of the output frame local variable that must be set.\n     * @param abstractType the value that must be set.\n     */\n    private void setLocal(final int localIndex, final int abstractType) {\n        // Create and/or resize the output local variables array if necessary.\n        if (outputLocals == null) {\n            outputLocals = new int[10];\n        }\n        int outputLocalsLength = outputLocals.length;\n        if (localIndex >= outputLocalsLength) {\n            int[] newOutputLocals = new int[Math.max(localIndex + 1, 2 * outputLocalsLength)];\n            System.arraycopy(outputLocals, 0, newOutputLocals, 0, outputLocalsLength);\n            outputLocals = newOutputLocals;\n        }\n        // Set the local variable.\n        outputLocals[localIndex] = abstractType;\n    }\n\n    /**\n     * Pushes the given abstract type on the output frame stack.\n     *\n     * @param abstractType an abstract type.\n     */\n    private void push(final int abstractType) {\n        // Create and/or resize the output stack array if necessary.\n        if (outputStack == null) {\n            outputStack = new int[10];\n        }\n        int outputStackLength = outputStack.length;\n        if (outputStackTop >= outputStackLength) {\n            int[] newOutputStack = new int[Math.max(outputStackTop + 1, 2 * outputStackLength)];\n            System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength);\n            outputStack = newOutputStack;\n        }\n        // Pushes the abstract type on the output stack.\n        outputStack[outputStackTop++] = abstractType;\n        // Updates the maximum size reached by the output stack, if needed (note that this size is\n        // relative to the input stack size, which is not known yet).\n        short outputStackSize = (short) (outputStackStart + outputStackTop);\n        if (outputStackSize > owner.outputStackMax) {\n            owner.outputStackMax = outputStackSize;\n        }\n    }\n\n    /**\n     * Pushes the abstract type corresponding to the given descriptor on the output frame stack.\n     *\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     * @param descriptor  a type or method descriptor (in which case its return type is pushed).\n     */\n    private void push(final SymbolTable symbolTable, final String descriptor) {\n        final int typeDescriptorOffset;\n        switch (descriptor) {\n            case \"()J\":\n            case \"()V\":\n            case \"()Z\":\n            case \"()I\":\n            case \"()Ljava/lang/Class;\":\n                typeDescriptorOffset = 2;\n                break;\n            case \"(I)V\":\n            case \"(J)V\":\n            case \"(J)Z\":\n            case \"(I)Ljava/lang/Object;\":\n            case \"(I)Ljava/lang/Integer;\":\n                typeDescriptorOffset = 3;\n                break;\n            case \"(Ljava/lang/Enum;)V\":\n                typeDescriptorOffset = 18;\n                break;\n            case \"(Ljava/lang/Object;)Z\":\n            case \"(Ljava/lang/String;)V\":\n            case \"(Ljava/lang/Object;)V\":\n                typeDescriptorOffset = 20;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;)V\":\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;)Z\":\n                typeDescriptorOffset = 36;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;I)V\":\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;J)V\":\n                typeDescriptorOffset = 37;\n                break;\n            case \"(Ljava/lang/Object;Ljava/lang/reflect/Type;)Z\":\n                typeDescriptorOffset = 44;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/Enum;)V\":\n                typeDescriptorOffset = 52;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/Class;)Lcom/alibaba/fastjson2/writer/ObjectWriter;\":\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;ZLjava/util/List;)V\":\n                typeDescriptorOffset = 53;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/reflect/Type;)Lcom/alibaba/fastjson2/writer/ObjectWriter;\":\n                typeDescriptorOffset = 60;\n                break;\n            case \"(Lcom/alibaba/fastjson2/writer/FieldWriter;Ljava/lang/Object;)Ljava/lang/String;\":\n                typeDescriptorOffset = 62;\n                break;\n            case \"(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;JLjava/util/List;)V\":\n                typeDescriptorOffset = 72;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/reflect/Type;J)V\":\n                typeDescriptorOffset = 97;\n                break;\n            default:\n                if (descriptor.charAt(0) == '(') {\n                    int currentOffset = 1;\n                    // Skip the argument types, one at a each loop iteration.\n                    while (descriptor.charAt(currentOffset) != ')') {\n                        while (descriptor.charAt(currentOffset) == '[') {\n                            currentOffset++;\n                        }\n                        if (descriptor.charAt(currentOffset++) == 'L') {\n                            // Skip the argument descriptor content.\n                            int semiColumnOffset = descriptor.indexOf(';', currentOffset);\n                            currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\n                        }\n                    }\n                    typeDescriptorOffset = currentOffset + 1;\n                } else {\n                    typeDescriptorOffset = 0;\n                }\n                break;\n        }\n\n        int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset);\n        if (abstractType != 0) {\n            push(abstractType);\n            if (abstractType == LONG || abstractType == DOUBLE) {\n                push(TOP);\n            }\n        }\n    }\n\n    /**\n     * Pops an abstract type from the output frame stack and returns its value.\n     *\n     * @return the abstract type that has been popped from the output frame stack.\n     */\n    private int pop() {\n        if (outputStackTop > 0) {\n            return outputStack[--outputStackTop];\n        } else {\n            // If the output frame stack is empty, pop from the input stack.\n            return STACK_KIND | -(--outputStackStart);\n        }\n    }\n\n    /**\n     * Pops the given number of abstract types from the output frame stack.\n     *\n     * @param elements the number of abstract types that must be popped.\n     */\n    private void pop(final int elements) {\n        if (outputStackTop >= elements) {\n            outputStackTop -= elements;\n        } else {\n            // If the number of elements to be popped is greater than the number of elements in the output\n            // stack, clear it, and pop the remaining elements from the input stack.\n            outputStackStart -= elements - outputStackTop;\n            outputStackTop = 0;\n        }\n    }\n\n    /**\n     * Pops as many abstract types from the output frame stack as described by the given descriptor.\n     *\n     * @param descriptor a type or method descriptor (in which case its argument types are popped).\n     */\n    private void pop(final String descriptor) {\n        char firstDescriptorChar = descriptor.charAt(0);\n        if (firstDescriptorChar == '(') {\n            pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);\n        } else if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {\n            pop(2);\n        } else {\n            pop(1);\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Methods to handle uninitialized types\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Adds an abstract type to the list of types on which a constructor is invoked in the basic\n     * block.\n     *\n     * @param abstractType an abstract type on a which a constructor is invoked.\n     */\n    private void addInitializedType(final int abstractType) {\n        // Create and/or resize the initializations array if necessary.\n        if (initializations == null) {\n            initializations = new int[2];\n        }\n        int initializationsLength = initializations.length;\n        if (initializationCount >= initializationsLength) {\n            int[] newInitializations =\n                    new int[Math.max(initializationCount + 1, 2 * initializationsLength)];\n            System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength);\n            initializations = newInitializations;\n        }\n        // Store the abstract type.\n        initializations[initializationCount++] = abstractType;\n    }\n\n    /**\n     * Returns the \"initialized\" abstract type corresponding to the given abstract type.\n     *\n     * @param symbolTable  the type table to use to lookup and store type {@link Symbol}.\n     * @param abstractType an abstract type.\n     * @return the REFERENCE_KIND abstract type corresponding to abstractType if it is\n     * UNINITIALIZED_THIS or an UNINITIALIZED_KIND abstract type for one of the types on which a\n     * constructor is invoked in the basic block. Otherwise returns abstractType.\n     */\n    private int getInitializedType(final SymbolTable symbolTable, final int abstractType) {\n        if (abstractType == UNINITIALIZED_THIS\n                || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND) {\n            for (int i = 0; i < initializationCount; ++i) {\n                int initializedType = initializations[i];\n                int dim = initializedType & DIM_MASK;\n                int kind = initializedType & KIND_MASK;\n                int value = initializedType & VALUE_MASK;\n                if (kind == LOCAL_KIND) {\n                    initializedType = dim + inputLocals[value];\n                } else if (kind == STACK_KIND) {\n                    initializedType = dim + inputStack[inputStack.length - value];\n                }\n                if (abstractType == initializedType) {\n                    if (abstractType == UNINITIALIZED_THIS) {\n                        return REFERENCE_KIND | symbolTable.addType(symbolTable.className);\n                    } else {\n                        return REFERENCE_KIND\n                                | symbolTable.addType(symbolTable.typeTable[abstractType & VALUE_MASK].value);\n                    }\n                }\n            }\n        }\n        return abstractType;\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Main method, to simulate the execution of each instruction on the output frame\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Simulates the action of the given instruction on the output stack frame.\n     *\n     * @param opcode      the opcode of the instruction.\n     * @param arg         the numeric operand of the instruction, if any.\n     * @param argSymbol   the Symbol operand of the instruction, if any.\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     */\n    void execute(\n            final int opcode, final int arg, final Symbol argSymbol, final SymbolTable symbolTable) {\n        final int CONSTANT_INTEGER_TAG = 3;\n        final int CONSTANT_FLOAT_TAG = 4;\n        final int CONSTANT_LONG_TAG = 5;\n        final int CONSTANT_DOUBLE_TAG = 6;\n        final int CONSTANT_CLASS_TAG = 7;\n        final int CONSTANT_STRING_TAG = 8;\n        final int CONSTANT_METHOD_HANDLE_TAG = 15;\n        final int CONSTANT_METHOD_TYPE_TAG = 16;\n        final int CONSTANT_DYNAMIC_TAG = 17;\n\n        // Abstract types popped from the stack or read from local variables.\n        int abstractType1;\n        int abstractType2;\n        int abstractType3;\n        int abstractType4;\n        switch (opcode) {\n            case Opcodes.NOP:\n            case Opcodes.INEG:\n            case Opcodes.LNEG:\n            case Opcodes.FNEG:\n            case Opcodes.DNEG:\n            case Opcodes.I2B:\n            case Opcodes.I2C:\n            case Opcodes.I2S:\n            case Opcodes.GOTO:\n            case Opcodes.RETURN:\n                break;\n            case Opcodes.ACONST_NULL:\n                push(NULL);\n                break;\n            case Opcodes.ICONST_M1:\n            case Opcodes.ICONST_0:\n            case Opcodes.ICONST_1:\n            case Opcodes.ICONST_2:\n            case Opcodes.ICONST_3:\n            case Opcodes.ICONST_4:\n            case Opcodes.ICONST_5:\n            case Opcodes.BIPUSH:\n            case Opcodes.SIPUSH:\n            case Opcodes.ILOAD:\n                push(INTEGER);\n                break;\n            case Opcodes.LCONST_0:\n            case Opcodes.LCONST_1:\n            case Opcodes.LLOAD:\n                push(LONG);\n                push(TOP);\n                break;\n            case Opcodes.FCONST_0:\n            case Opcodes.FCONST_1:\n            case Opcodes.FCONST_2:\n            case Opcodes.FLOAD:\n                push(FLOAT);\n                break;\n            case Opcodes.DCONST_0:\n            case Opcodes.DCONST_1:\n            case Opcodes.DLOAD:\n                push(DOUBLE);\n                push(TOP);\n                break;\n            case Opcodes.LDC:\n                switch (argSymbol.tag) {\n                    case CONSTANT_INTEGER_TAG:\n                        push(INTEGER);\n                        break;\n                    case CONSTANT_LONG_TAG:\n                        push(LONG);\n                        push(TOP);\n                        break;\n                    case CONSTANT_FLOAT_TAG:\n                        push(FLOAT);\n                        break;\n                    case CONSTANT_DOUBLE_TAG:\n                        push(DOUBLE);\n                        push(TOP);\n                        break;\n                    case CONSTANT_CLASS_TAG:\n                        push(REFERENCE_KIND | symbolTable.addType(\"java/lang/Class\"));\n                        break;\n                    case CONSTANT_STRING_TAG:\n                        push(REFERENCE_KIND | symbolTable.addType(\"java/lang/String\"));\n                        break;\n                    case CONSTANT_METHOD_TYPE_TAG:\n                        push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodType\"));\n                        break;\n                    case CONSTANT_METHOD_HANDLE_TAG:\n                        push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodHandle\"));\n                        break;\n                    case CONSTANT_DYNAMIC_TAG:\n                        push(symbolTable, argSymbol.value);\n                        break;\n                    default:\n                        throw new AssertionError();\n                }\n                break;\n            case Opcodes.ALOAD:\n                push(getLocal(arg));\n                break;\n            case Opcodes.LALOAD:\n            case Opcodes.D2L:\n                pop(2);\n                push(LONG);\n                push(TOP);\n                break;\n            case Opcodes.AALOAD:\n                pop(1);\n                abstractType1 = pop();\n                push(abstractType1 == NULL ? abstractType1 : ELEMENT_OF + abstractType1);\n                break;\n            case Opcodes.ISTORE:\n            case Opcodes.FSTORE:\n            case Opcodes.ASTORE:\n                abstractType1 = pop();\n                setLocal(arg, abstractType1);\n                if (arg > 0) {\n                    int previousLocalType = getLocal(arg - 1);\n                    if (previousLocalType == LONG || previousLocalType == DOUBLE) {\n                        setLocal(arg - 1, TOP);\n                    } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND\n                            || (previousLocalType & KIND_MASK) == STACK_KIND) {\n                        // The type of the previous local variable is not known yet, but if it later appears\n                        // to be LONG or DOUBLE, we should then use TOP instead.\n                        setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\n                    }\n                }\n                break;\n            case Opcodes.LSTORE:\n            case Opcodes.DSTORE:\n                pop(1);\n                abstractType1 = pop();\n                setLocal(arg, abstractType1);\n                setLocal(arg + 1, TOP);\n                if (arg > 0) {\n                    int previousLocalType = getLocal(arg - 1);\n                    if (previousLocalType == LONG || previousLocalType == DOUBLE) {\n                        setLocal(arg - 1, TOP);\n                    } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND\n                            || (previousLocalType & KIND_MASK) == STACK_KIND) {\n                        // The type of the previous local variable is not known yet, but if it later appears\n                        // to be LONG or DOUBLE, we should then use TOP instead.\n                        setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\n                    }\n                }\n                break;\n            case Opcodes.POP:\n            case Opcodes.IFEQ:\n            case Opcodes.IFNE:\n            case Opcodes.IFLT:\n            case Opcodes.IFGE:\n            case Opcodes.IFGT:\n            case Opcodes.IFLE:\n            case Opcodes.IRETURN:\n            case Opcodes.FRETURN:\n            case Opcodes.ARETURN:\n            case Opcodes.TABLESWITCH:\n            case Opcodes.LOOKUPSWITCH:\n            case Opcodes.ATHROW:\n            case Opcodes.MONITORENTER:\n            case Opcodes.MONITOREXIT:\n            case Opcodes.IFNULL:\n            case Opcodes.IFNONNULL:\n                pop(1);\n                break;\n            case Opcodes.POP2:\n            case Opcodes.IF_ICMPEQ:\n            case Opcodes.IF_ICMPNE:\n            case Opcodes.IF_ICMPLT:\n            case Opcodes.IF_ICMPGE:\n            case Opcodes.IF_ICMPGT:\n            case Opcodes.IF_ICMPLE:\n            case Opcodes.IF_ACMPEQ:\n            case Opcodes.IF_ACMPNE:\n            case Opcodes.LRETURN:\n            case Opcodes.DRETURN:\n                pop(2);\n                break;\n            case Opcodes.DUP:\n                abstractType1 = pop();\n                push(abstractType1);\n                push(abstractType1);\n                break;\n            case Opcodes.DUP2:\n                abstractType1 = pop();\n                abstractType2 = pop();\n                push(abstractType2);\n                push(abstractType1);\n                push(abstractType2);\n                push(abstractType1);\n                break;\n            case Opcodes.SWAP:\n                abstractType1 = pop();\n                abstractType2 = pop();\n                push(abstractType1);\n                push(abstractType2);\n                break;\n            case Opcodes.IALOAD:\n            case Opcodes.BALOAD:\n            case Opcodes.CALOAD:\n            case Opcodes.SALOAD:\n            case Opcodes.IADD:\n            case Opcodes.ISUB:\n            case Opcodes.IMUL:\n            case Opcodes.IDIV:\n            case Opcodes.IREM:\n            case Opcodes.IAND:\n            case Opcodes.IOR:\n            case Opcodes.IXOR:\n            case Opcodes.ISHL:\n            case Opcodes.ISHR:\n            case Opcodes.IUSHR:\n            case Opcodes.L2I:\n            case Opcodes.D2I:\n            case Opcodes.FCMPL:\n            case Opcodes.FCMPG:\n                pop(2);\n                push(INTEGER);\n                break;\n            case Opcodes.LADD:\n            case Opcodes.LSUB:\n            case Opcodes.LMUL:\n            case Opcodes.LDIV:\n            case Opcodes.LREM:\n            case Opcodes.LAND:\n            case Opcodes.LOR:\n            case Opcodes.LXOR:\n                pop(4);\n                push(LONG);\n                push(TOP);\n                break;\n            case Opcodes.LSHL:\n            case Opcodes.LSHR:\n            case Opcodes.LUSHR:\n                pop(3);\n                push(LONG);\n                push(TOP);\n                break;\n            case Opcodes.IINC:\n                setLocal(arg, INTEGER);\n                break;\n            case Opcodes.F2I:\n            case Opcodes.ARRAYLENGTH:\n            case Opcodes.INSTANCEOF:\n                pop(1);\n                push(INTEGER);\n                break;\n            case Opcodes.LCMP:\n            case Opcodes.DCMPL:\n            case Opcodes.DCMPG:\n                pop(4);\n                push(INTEGER);\n                break;\n            case Opcodes.GETSTATIC:\n                push(symbolTable, argSymbol.value);\n                break;\n            case Opcodes.PUTSTATIC:\n                pop(argSymbol.value);\n                break;\n            case Opcodes.GETFIELD:\n                pop(1);\n                push(symbolTable, argSymbol.value);\n                break;\n            case Opcodes.PUTFIELD:\n                pop(argSymbol.value);\n                pop();\n                break;\n            case Opcodes.INVOKEVIRTUAL:\n            case Opcodes.INVOKESPECIAL:\n            case Opcodes.INVOKESTATIC:\n            case Opcodes.INVOKEINTERFACE:\n                pop(argSymbol.value);\n                if (opcode != Opcodes.INVOKESTATIC) {\n                    abstractType1 = pop();\n                    if (opcode == Opcodes.INVOKESPECIAL && argSymbol.name.charAt(0) == '<') {\n                        addInitializedType(abstractType1);\n                    }\n                }\n                push(symbolTable, argSymbol.value);\n                break;\n            case Opcodes.NEW:\n                push(UNINITIALIZED_KIND | symbolTable.addUninitializedType(argSymbol.value, arg));\n                break;\n            case Opcodes.CHECKCAST:\n                String castType = argSymbol.value;\n                pop();\n                if (castType.charAt(0) == '[') {\n                    push(symbolTable, castType);\n                } else {\n                    push(REFERENCE_KIND | symbolTable.addType(castType));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException();\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Frame merging methods, used in the second step of the stack map frame computation algorithm\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Computes the concrete output type corresponding to a given abstract output type.\n     *\n     * @param abstractOutputType an abstract output type.\n     * @param numStack           the size of the input stack, used to resolve abstract output types of\n     *                           STACK_KIND kind.\n     * @return the concrete output type corresponding to 'abstractOutputType'.\n     */\n    private int getConcreteOutputType(final int abstractOutputType, final int numStack) {\n        int dim = abstractOutputType & DIM_MASK;\n        int kind = abstractOutputType & KIND_MASK;\n        if (kind == LOCAL_KIND) {\n            // By definition, a LOCAL_KIND type designates the concrete type of a local variable at\n            // the beginning of the basic block corresponding to this frame (which is known when\n            // this method is called, but was not when the abstract type was computed).\n            int concreteOutputType = dim + inputLocals[abstractOutputType & VALUE_MASK];\n            if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0\n                    && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {\n                concreteOutputType = TOP;\n            }\n            return concreteOutputType;\n        } else if (kind == STACK_KIND) {\n            // By definition, a STACK_KIND type designates the concrete type of a local variable at\n            // the beginning of the basic block corresponding to this frame (which is known when\n            // this method is called, but was not when the abstract type was computed).\n            int concreteOutputType = dim + inputStack[numStack - (abstractOutputType & VALUE_MASK)];\n            if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0\n                    && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {\n                concreteOutputType = TOP;\n            }\n            return concreteOutputType;\n        } else {\n            return abstractOutputType;\n        }\n    }\n\n    final boolean merge(\n            final SymbolTable symbolTable, final Frame dstFrame) {\n        boolean frameChanged = false;\n\n        // Compute the concrete types of the local variables at the end of the basic block corresponding\n        // to this frame, by resolving its abstract output types, and merge these concrete types with\n        // those of the local variables in the input frame of dstFrame.\n        int numLocal = inputLocals.length;\n        int numStack = inputStack.length;\n        if (dstFrame.inputLocals == null) {\n            dstFrame.inputLocals = new int[numLocal];\n            frameChanged = true;\n        }\n        for (int i = 0; i < numLocal; ++i) {\n            int concreteOutputType;\n            if (outputLocals != null && i < outputLocals.length) {\n                int abstractOutputType = outputLocals[i];\n                if (abstractOutputType == 0) {\n                    // If the local variable has never been assigned in this basic block, it is equal to its\n                    // value at the beginning of the block.\n                    concreteOutputType = inputLocals[i];\n                } else {\n                    concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);\n                }\n            } else {\n                // If the local variable has never been assigned in this basic block, it is equal to its\n                // value at the beginning of the block.\n                concreteOutputType = inputLocals[i];\n            }\n            // concreteOutputType might be an uninitialized type from the input locals or from the input\n            // stack. However, if a constructor has been called for this class type in the basic block,\n            // then this type is no longer uninitialized at the end of basic block.\n            if (initializations != null) {\n                concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\n            }\n            frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputLocals, i);\n        }\n\n        // Compute the concrete types of the stack operands at the end of the basic block corresponding\n        // to this frame, by resolving its abstract output types, and merge these concrete types with\n        // those of the stack operands in the input frame of dstFrame.\n        int numInputStack = inputStack.length + outputStackStart;\n        if (dstFrame.inputStack == null) {\n            dstFrame.inputStack = new int[numInputStack + outputStackTop];\n            frameChanged = true;\n        }\n        // First, do this for the stack operands that have not been popped in the basic block\n        // corresponding to this frame, and which are therefore equal to their value in the input\n        // frame (except for uninitialized types, which may have been initialized).\n        for (int i = 0; i < numInputStack; ++i) {\n            int concreteOutputType = inputStack[i];\n            if (initializations != null) {\n                concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\n            }\n            frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, i);\n        }\n        // Then, do this for the stack operands that have pushed in the basic block (this code is the\n        // same as the one above for local variables).\n        for (int i = 0; i < outputStackTop; ++i) {\n            int abstractOutputType = outputStack[i];\n            int concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);\n            if (initializations != null) {\n                concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\n            }\n            frameChanged |=\n                    merge(symbolTable, concreteOutputType, dstFrame.inputStack, numInputStack + i);\n        }\n        return frameChanged;\n    }\n\n    /**\n     * Merges the type at the given index in the given abstract type array with the given type.\n     * Returns {@literal true} if the type array has been modified by this operation.\n     *\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     * @param sourceType  the abstract type with which the abstract type array element must be merged.\n     *                    This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND} or {@link\n     *                    #UNINITIALIZED_KIND} kind, with positive or {@literal null} array dimensions.\n     * @param dstTypes    an array of abstract types. These types should be of {@link #CONSTANT_KIND},\n     *                    {@link #REFERENCE_KIND} or {@link #UNINITIALIZED_KIND} kind, with positive or {@literal\n     *                    null} array dimensions.\n     * @param dstIndex    the index of the type that must be merged in dstTypes.\n     * @return {@literal true} if the type array has been modified by this operation.\n     */\n    private static boolean merge(\n            final SymbolTable symbolTable,\n            final int sourceType,\n            final int[] dstTypes,\n            final int dstIndex) {\n        int dstType = dstTypes[dstIndex];\n        if (dstType == sourceType) {\n            // If the types are equal, merge(sourceType, dstType) = dstType, so there is no change.\n            return false;\n        }\n        int srcType = sourceType;\n        if ((sourceType & ~DIM_MASK) == NULL) {\n            if (dstType == NULL) {\n                return false;\n            }\n            srcType = NULL;\n        }\n        if (dstType == 0) {\n            // If dstTypes[dstIndex] has never been assigned, merge(srcType, dstType) = srcType.\n            dstTypes[dstIndex] = srcType;\n            return true;\n        }\n        int mergedType;\n        if ((dstType & DIM_MASK) != 0 || (dstType & KIND_MASK) == REFERENCE_KIND) {\n            // If dstType is a reference type of any array dimension.\n            if (srcType == NULL) {\n                // If srcType is the NULL type, merge(srcType, dstType) = dstType, so there is no change.\n                return false;\n            } else if ((srcType & (DIM_MASK | KIND_MASK)) == (dstType & (DIM_MASK | KIND_MASK))) {\n                // If srcType has the same array dimension and the same kind as dstType.\n                if ((dstType & KIND_MASK) == REFERENCE_KIND) {\n                    // If srcType and dstType are reference types with the same array dimension,\n                    // merge(srcType, dstType) = dim(srcType) | common super class of srcType and dstType.\n                    mergedType =\n                            (srcType & DIM_MASK)\n                                    | REFERENCE_KIND\n                                    | symbolTable.addMergedType(srcType & VALUE_MASK, dstType & VALUE_MASK);\n                } else {\n                    // If srcType and dstType are array types of equal dimension but different element types,\n                    // merge(srcType, dstType) = dim(srcType) - 1 | java/lang/Object.\n                    int mergedDim = ELEMENT_OF + (srcType & DIM_MASK);\n                    mergedType = mergedDim | REFERENCE_KIND | symbolTable.addType(\"java/lang/Object\");\n                }\n            } else if ((srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND) {\n                // If srcType is any other reference or array type,\n                // merge(srcType, dstType) = min(srcDdim, dstDim) | java/lang/Object\n                // where srcDim is the array dimension of srcType, minus 1 if srcType is an array type\n                // with a non reference element type (and similarly for dstDim).\n                int srcDim = srcType & DIM_MASK;\n                if (srcDim != 0 && (srcType & KIND_MASK) != REFERENCE_KIND) {\n                    srcDim = ELEMENT_OF + srcDim;\n                }\n                int dstDim = dstType & DIM_MASK;\n                if (dstDim != 0 && (dstType & KIND_MASK) != REFERENCE_KIND) {\n                    dstDim = ELEMENT_OF + dstDim;\n                }\n                mergedType =\n                        Math.min(srcDim, dstDim) | REFERENCE_KIND | symbolTable.addType(\"java/lang/Object\");\n            } else {\n                // If srcType is any other type, merge(srcType, dstType) = TOP.\n                mergedType = TOP;\n            }\n        } else if (dstType == NULL) {\n            // If dstType is the NULL type, merge(srcType, dstType) = srcType, or TOP if srcType is not a\n            // an array type or a reference type.\n            mergedType =\n                    (srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND ? srcType : TOP;\n        } else {\n            // If dstType is any other type, merge(srcType, dstType) = TOP whatever srcType.\n            mergedType = TOP;\n        }\n        if (mergedType != dstType) {\n            dstTypes[dstIndex] = mergedType;\n            return true;\n        }\n        return false;\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Frame output methods, to generate StackMapFrame attributes\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Makes the given {@link MethodWriter} visit the input frame of this {@link Frame}. The visit is\n     * done with the {@link MethodWriter#visitFrameStart}, {@link MethodWriter#visitAbstractType} and\n     * {@link MethodWriter#visitFrameEnd} methods.\n     *\n     * @param methodWriter the {@link MethodWriter} that should visit the input frame of this {@link\n     *                     Frame}.\n     */\n    final void accept(final MethodWriter methodWriter) {\n        // Compute the number of locals, ignoring TOP types that are just after a LONG or a DOUBLE, and\n        // all trailing TOP types.\n        int[] localTypes = inputLocals;\n        int numLocal = 0;\n        int numTrailingTop = 0;\n        int i = 0;\n        while (i < localTypes.length) {\n            int localType = localTypes[i];\n            i += (localType == LONG || localType == DOUBLE) ? 2 : 1;\n            if (localType == TOP) {\n                numTrailingTop++;\n            } else {\n                numLocal += numTrailingTop + 1;\n                numTrailingTop = 0;\n            }\n        }\n        // Compute the stack size, ignoring TOP types that are just after a LONG or a DOUBLE.\n        int[] stackTypes = inputStack;\n        int numStack = 0;\n        i = 0;\n        while (i < stackTypes.length) {\n            int stackType = stackTypes[i];\n            i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;\n            numStack++;\n        }\n        // Visit the frame and its content.\n        int frameIndex = methodWriter.visitFrameStart(owner.bytecodeOffset, numLocal, numStack);\n        i = 0;\n        while (numLocal-- > 0) {\n            int localType = localTypes[i];\n            i += (localType == LONG || localType == DOUBLE) ? 2 : 1;\n            methodWriter.visitAbstractType(frameIndex++, localType);\n        }\n        i = 0;\n        while (numStack-- > 0) {\n            int stackType = stackTypes[i];\n            i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;\n            methodWriter.visitAbstractType(frameIndex++, stackType);\n        }\n        methodWriter.visitFrameEnd();\n    }\n//\n//    /**\n//     * Put the given abstract type in the given ByteVector, using the JVMS verification_type_info\n//     * format used in StackMapTable attributes.\n//     *\n//     * @param symbolTable  the type table to use to lookup and store type {@link Symbol}.\n//     * @param abstractType an abstract type, restricted to {@link Frame#CONSTANT_KIND}, {@link\n//     *                     Frame#REFERENCE_KIND} or {@link Frame#UNINITIALIZED_KIND} types.\n//     * @param output       where the abstract type must be put.\n//     * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4\">JVMS\n//     * 4.7.4</a>\n//     */\n//    static void putAbstractType(\n//            final SymbolTable symbolTable, final int abstractType, final ByteVector output) {\n//        int arrayDimensions = (abstractType & Frame.DIM_MASK) >> DIM_SHIFT;\n//        if (arrayDimensions == 0) {\n//            int typeValue = abstractType & VALUE_MASK;\n//            switch (abstractType & KIND_MASK) {\n//                case CONSTANT_KIND:\n//                    output.putByte(typeValue);\n//                    break;\n//                case REFERENCE_KIND:\n//                    output\n//                            .putByte(ITEM_OBJECT)\n//                            .putShort(symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, symbolTable.typeTable[typeValue].value).index);\n//                    break;\n//                case UNINITIALIZED_KIND:\n//                    output.putByte(ITEM_UNINITIALIZED).putShort((int) symbolTable.typeTable[typeValue].data);\n//                    break;\n//                default:\n//                    throw new AssertionError();\n//            }\n//        } else {\n//            // Case of an array type, we need to build its descriptor first.\n//            StringBuilder typeDescriptor = new StringBuilder();\n//            while (arrayDimensions-- > 0) {\n//                typeDescriptor.append('[');\n//            }\n//            if ((abstractType & KIND_MASK) == REFERENCE_KIND) {\n//                typeDescriptor\n//                        .append('L')\n//                        .append(symbolTable.typeTable[abstractType & VALUE_MASK].value)\n//                        .append(';');\n//            } else {\n//                switch (abstractType & VALUE_MASK) {\n//                    case Frame.ITEM_ASM_BOOLEAN:\n//                        typeDescriptor.append('Z');\n//                        break;\n//                    case Frame.ITEM_ASM_BYTE:\n//                        typeDescriptor.append('B');\n//                        break;\n//                    case Frame.ITEM_ASM_CHAR:\n//                        typeDescriptor.append('C');\n//                        break;\n//                    case Frame.ITEM_ASM_SHORT:\n//                        typeDescriptor.append('S');\n//                        break;\n//                    case Frame.ITEM_INTEGER:\n//                        typeDescriptor.append('I');\n//                        break;\n//                    case Frame.ITEM_FLOAT:\n//                        typeDescriptor.append('F');\n//                        break;\n//                    case Frame.ITEM_LONG:\n//                        typeDescriptor.append('J');\n//                        break;\n//                    case Frame.ITEM_DOUBLE:\n//                        typeDescriptor.append('D');\n//                        break;\n//                    default:\n//                        throw new AssertionError();\n//                }\n//            }\n//            output\n//                    .putByte(ITEM_OBJECT)\n//                    .putShort(symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, typeDescriptor.toString()).index);\n//        }\n//    }\n}\n",
      "file_name": "Frame.java",
      "human_label": "Pop an abstract type from the output frame stack and return its value.",
      "level": "self_contained",
      "lineno": "617",
      "name": "pop",
      "oracle_context": "{ \"apis\" : \"[]\", \"classes\" : \"[]\", \"vars\" : \"[outputStackTop, outputStack, STACK_KIND, outputStackStart]\" }",
      "package": "com.alibaba.fastjson2.internal.asm",
      "project": "fastjson2-main"
    },
    {
      "_id": "636767081a6d9265ec017989",
      "all_context": "{ \"class_level\" : \"import java.lang.reflect.Array;\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.Map.Entry;\\nObject[] EMPTY_OBJECT_ARRAY;\\nClass<?>[] EMPTY_CLASS_ARRAY;\\nString[] EMPTY_STRING_ARRAY;\\nlong[] EMPTY_LONG_ARRAY;\\nLong[] EMPTY_LONG_OBJECT_ARRAY;\\nint[] EMPTY_INT_ARRAY;\\nInteger[] EMPTY_INTEGER_OBJECT_ARRAY;\\nshort[] EMPTY_SHORT_ARRAY;\\nShort[] EMPTY_SHORT_OBJECT_ARRAY;\\nbyte[] EMPTY_BYTE_ARRAY;\\nByte[] EMPTY_BYTE_OBJECT_ARRAY;\\ndouble[] EMPTY_DOUBLE_ARRAY;\\nDouble[] EMPTY_DOUBLE_OBJECT_ARRAY;\\nfloat[] EMPTY_FLOAT_ARRAY;\\nFloat[] EMPTY_FLOAT_OBJECT_ARRAY;\\nboolean[] EMPTY_BOOLEAN_ARRAY;\\nBoolean[] EMPTY_BOOLEAN_OBJECT_ARRAY;\\nchar[] EMPTY_CHAR_ARRAY;\\nCharacter[] EMPTY_CHARACTER_OBJECT_ARRAY;\\nint INDEX_NOT_FOUND;\\nArrayUtils();\\nclone(Object[] array);\\nclone(long[] array);\\nclone(int[] array);\\nclone(short[] array);\\nclone(char[] array);\\nclone(byte[] array);\\nclone(double[] array);\\nclone(float[] array);\\nclone(boolean[] array);\\nclone(String[] array);\\nnullToEmpty(Object[] array);\\nnullToEmpty(String[] array);\\nnullToEmpty(long[] array);\\nnullToEmpty(int[] array);\\nnullToEmpty(short[] array);\\nnullToEmpty(char[] array);\\nnullToEmpty(byte[] array);\\nnullToEmpty(double[] array);\\nnullToEmpty(float[] array);\\nnullToEmpty(boolean[] array);\\nnullToEmpty(Long[] array);\\nnullToEmpty(Integer[] array);\\nnullToEmpty(Short[] array);\\nnullToEmpty(Character[] array);\\nnullToEmpty(Byte[] array);\\nnullToEmpty(Double[] array);\\nnullToEmpty(Float[] array);\\nnullToEmpty(Boolean[] array);\\nsubarray(Object[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(long[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(int[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(short[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(char[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(byte[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(double[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(float[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(boolean[] array,int startIndexInclusive,int endIndexExclusive);\\nisSameLength(Object[] array1,Object[] array2);\\nisSameLength(long[] array1,long[] array2);\\nisSameLength(int[] array1,int[] array2);\\nisSameLength(short[] array1,short[] array2);\\nisSameLength(char[] array1,char[] array2);\\nisSameLength(byte[] array1,byte[] array2);\\nisSameLength(double[] array1,double[] array2);\\nisSameLength(float[] array1,float[] array2);\\nisSameLength(boolean[] array1,boolean[] array2);\\ngetLength(Object array);\\nisSameType(Object array1,Object array2);\\nreverse(Object[] array);\\nreverse(long[] array);\\nreverse(int[] array);\\nreverse(short[] array);\\nreverse(char[] array);\\nreverse(byte[] array);\\nreverse(double[] array);\\nreverse(float[] array);\\nreverse(boolean[] array);\\nindexOf(Object[] array,Object objectToFind);\\nindexOf(Object[] array,Object objectToFind,int startIndex);\\nlastIndexOf(Object[] array,Object objectToFind);\\nlastIndexOf(Object[] array,Object objectToFind,int startIndex);\\ncontains(Object[] array,Object objectToFind);\\nindexOf(long[] array,long valueToFind);\\nindexOf(long[] array,long valueToFind,int startIndex);\\nlastIndexOf(long[] array,long valueToFind);\\nlastIndexOf(long[] array,long valueToFind,int startIndex);\\ncontains(long[] array,long valueToFind);\\nindexOf(int[] array,int valueToFind);\\nindexOf(int[] array,int valueToFind,int startIndex);\\nlastIndexOf(int[] array,int valueToFind);\\nlastIndexOf(int[] array,int valueToFind,int startIndex);\\ncontains(int[] array,int valueToFind);\\nindexOf(short[] array,short valueToFind);\\nindexOf(short[] array,short valueToFind,int startIndex);\\nlastIndexOf(short[] array,short valueToFind);\\nlastIndexOf(short[] array,short valueToFind,int startIndex);\\ncontains(short[] array,short valueToFind);\\nindexOf(char[] array,char valueToFind);\\nindexOf(char[] array,char valueToFind,int startIndex);\\nlastIndexOf(char[] array,char valueToFind);\\nlastIndexOf(char[] array,char valueToFind,int startIndex);\\ncontains(char[] array,char valueToFind);\\nindexOf(byte[] array,byte valueToFind);\\nindexOf(byte[] array,byte valueToFind,int startIndex);\\nlastIndexOf(byte[] array,byte valueToFind);\\nlastIndexOf(byte[] array,byte valueToFind,int startIndex);\\ncontains(byte[] array,byte valueToFind);\\nindexOf(double[] array,double valueToFind);\\nindexOf(double[] array,double valueToFind,double tolerance);\\nindexOf(double[] array,double valueToFind,int startIndex);\\nindexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\nlastIndexOf(double[] array,double valueToFind);\\nlastIndexOf(double[] array,double valueToFind,double tolerance);\\nlastIndexOf(double[] array,double valueToFind,int startIndex);\\nlastIndexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\ncontains(double[] array,double valueToFind);\\ncontains(double[] array,double valueToFind,double tolerance);\\nindexOf(float[] array,float valueToFind);\\nindexOf(float[] array,float valueToFind,int startIndex);\\nlastIndexOf(float[] array,float valueToFind);\\nlastIndexOf(float[] array,float valueToFind,int startIndex);\\ncontains(float[] array,float valueToFind);\\nindexOf(boolean[] array,boolean valueToFind);\\nindexOf(boolean[] array,boolean valueToFind,int startIndex);\\nlastIndexOf(boolean[] array,boolean valueToFind);\\nlastIndexOf(boolean[] array,boolean valueToFind,int startIndex);\\ncontains(boolean[] array,boolean valueToFind);\\ntoPrimitive(Character[] array);\\ntoPrimitive(Character[] array,char valueForNull);\\ntoObject(char[] array);\\ntoPrimitive(Long[] array);\\ntoPrimitive(Long[] array,long valueForNull);\\ntoObject(long[] array);\\ntoPrimitive(Integer[] array);\\ntoPrimitive(Integer[] array,int valueForNull);\\ntoObject(int[] array);\\ntoPrimitive(Short[] array);\\ntoPrimitive(Short[] array,short valueForNull);\\ntoObject(short[] array);\\ntoPrimitive(Byte[] array);\\ntoPrimitive(Byte[] array,byte valueForNull);\\ntoObject(byte[] array);\\ntoPrimitive(Double[] array);\\ntoPrimitive(Double[] array,double valueForNull);\\ntoObject(double[] array);\\ntoPrimitive(Float[] array);\\ntoPrimitive(Float[] array,float valueForNull);\\ntoObject(float[] array);\\ntoPrimitive(Boolean[] array);\\ntoPrimitive(Boolean[] array,boolean valueForNull);\\ntoObject(boolean[] array);\\nisEmpty(Object[] array);\\nisEmpty(long[] array);\\nisEmpty(int[] array);\\nisEmpty(short[] array);\\nisEmpty(char[] array);\\nisEmpty(byte[] array);\\nisEmpty(double[] array);\\nisEmpty(float[] array);\\nisEmpty(boolean[] array);\\nisNotEmpty(Object[] array);\\nisNotEmpty(long[] array);\\nisNotEmpty(int[] array);\\nisNotEmpty(short[] array);\\nisNotEmpty(char[] array);\\nisNotEmpty(byte[] array);\\nisNotEmpty(double[] array);\\nisNotEmpty(float[] array);\\nisNotEmpty(boolean[] array);\\naddAll(Object[] array1,Object[] array2);\\naddAll(boolean[] array1,boolean[] array2);\\naddAll(char[] array1,char[] array2);\\naddAll(byte[] array1,byte[] array2);\\naddAll(short[] array1,short[] array2);\\naddAll(int[] array1,int[] array2);\\naddAll(long[] array1,long[] array2);\\naddAll(float[] array1,float[] array2);\\naddAll(double[] array1,double[] array2);\\naddAll(String[] array1,String[] array2);\\nadd(T[] array,T element);\\nadd(boolean[] array,boolean element);\\nadd(byte[] array,byte element);\\nadd(char[] array,char element);\\nadd(double[] array,double element);\\nadd(float[] array,float element);\\nadd(int[] array,int element);\\nadd(long[] array,long element);\\nadd(short[] array,short element);\\ncopyArrayGrow1(Object array,Class newArrayComponentType);\\nadd(Object[] array,int index,Object element);\\nadd(boolean[] array,int index,boolean element);\\nadd(char[] array,int index,char element);\\nadd(byte[] array,int index,byte element);\\nadd(short[] array,int index,short element);\\nadd(int[] array,int index,int element);\\nadd(long[] array,int index,long element);\\nadd(float[] array,int index,float element);\\nadd(double[] array,int index,double element);\\nadd(Object array,int index,Object element,Class clss);\\nremove(Object[] array,int index);\\nremoveElement(Object[] array,Object element);\\nremove(boolean[] array,int index);\\nremoveElement(boolean[] array,boolean element);\\nremove(byte[] array,int index);\\nremoveElement(byte[] array,byte element);\\nremove(char[] array,int index);\\nremoveElement(char[] array,char element);\\nremove(double[] array,int index);\\nremoveElement(double[] array,double element);\\nremove(float[] array,int index);\\nremoveElement(float[] array,float element);\\nremove(int[] array,int index);\\nremoveElement(int[] array,int element);\\nremove(long[] array,int index);\\nremoveElement(long[] array,long element);\\nremove(short[] array,int index);\\nremoveElement(short[] array,short element);\\nremove(Object array,int index);\\nclearNull(Object[] arr);\\ntoMap(Object[] array);\\n\", \"repo_level\" : \"\" }",
      "class_name": "ArrayUtils",
      "code": "public static boolean[] toPrimitive(final Boolean[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result=new boolean[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=array[i].booleanValue();\n  }\n  return result;\n}\n",
      "docstring": "/** \n * <p>Converts an array of object Booleans to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Boolean</code> array, may be <code>null</code>\n * @return a <code>boolean</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n",
      "end_lineno": "3008",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils;\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * <p>Operations on arrays, primitive arrays (like <code>int[]</code>) and\n * primitive wrapper arrays (like <code>Integer[]</code>).</p>\n *\n * <p>This class tries to handle <code>null</code> input gracefully.\n * An exception will not be thrown for a <code>null</code>\n * array input. However, an Object array that contains a <code>null</code>\n * element may throw an exception. Each method documents its behaviour.</p>\n *\n * <p>#ThreadSafe#</p>\n * @author Apache Software Foundation\n * @author Moritz Petersen\n * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n * @author Nikolay Metchev\n * @author Matthew Hawthorne\n * @author Tim O'Brien\n * @author Pete Gieser\n * @author Gary Gregory\n * @author <a href=\"mailto:equinus100@hotmail.com\">Ashwin S</a>\n * @author Maarten Coene\n * @since 2.0\n * @version $Id: ArrayUtils.java 1056988 2011-01-09 17:58:53Z niallp $\n */\npublic class ArrayUtils {\n    /** An empty immutable <code>Object</code> array. */\n    public static final Object[]    EMPTY_OBJECT_ARRAY           = new Object[0];\n    /** An empty immutable <code>Class</code> array. */\n    public static final Class<?>[]  EMPTY_CLASS_ARRAY            = new Class[0];\n    /** An empty immutable <code>String</code> array. */\n    public static final String[]    EMPTY_STRING_ARRAY           = new String[0];\n    /** An empty immutable <code>long</code> array. */\n    public static final long[]      EMPTY_LONG_ARRAY             = new long[0];\n    /** An empty immutable <code>Long</code> array. */\n    public static final Long[]      EMPTY_LONG_OBJECT_ARRAY      = new Long[0];\n    /** An empty immutable <code>int</code> array. */\n    public static final int[]       EMPTY_INT_ARRAY              = new int[0];\n    /** An empty immutable <code>Integer</code> array. */\n    public static final Integer[]   EMPTY_INTEGER_OBJECT_ARRAY   = new Integer[0];\n    /** An empty immutable <code>short</code> array. */\n    public static final short[]     EMPTY_SHORT_ARRAY            = new short[0];\n    /** An empty immutable <code>Short</code> array. */\n    public static final Short[]     EMPTY_SHORT_OBJECT_ARRAY     = new Short[0];\n    /** An empty immutable <code>byte</code> array. */\n    public static final byte[]      EMPTY_BYTE_ARRAY             = new byte[0];\n    /** An empty immutable <code>Byte</code> array. */\n    public static final Byte[]      EMPTY_BYTE_OBJECT_ARRAY      = new Byte[0];\n    /** An empty immutable <code>double</code> array. */\n    public static final double[]    EMPTY_DOUBLE_ARRAY           = new double[0];\n    /** An empty immutable <code>Double</code> array. */\n    public static final Double[]    EMPTY_DOUBLE_OBJECT_ARRAY    = new Double[0];\n    /** An empty immutable <code>float</code> array. */\n    public static final float[]     EMPTY_FLOAT_ARRAY            = new float[0];\n    /** An empty immutable <code>Float</code> array. */\n    public static final Float[]     EMPTY_FLOAT_OBJECT_ARRAY     = new Float[0];\n    /** An empty immutable <code>boolean</code> array. */\n    public static final boolean[]   EMPTY_BOOLEAN_ARRAY          = new boolean[0];\n    /** An empty immutable <code>Boolean</code> array. */\n    public static final Boolean[]   EMPTY_BOOLEAN_OBJECT_ARRAY   = new Boolean[0];\n    /** An empty immutable <code>char</code> array. */\n    public static final char[]      EMPTY_CHAR_ARRAY             = new char[0];\n    /** An empty immutable <code>Character</code> array. */\n    public static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n    /**\n     * The index value when an element is not found in a list or array: <code>-1</code>.\n     * This value is returned by methods in this class and can also be used in comparisons with values returned by\n     * various method from {@link java.util.List}.\n     */\n    public static final int         INDEX_NOT_FOUND              = -1;\n\n    /**\n     * <p>ArrayUtils instances should NOT be constructed in standard programming.\n     * Instead, the class should be used as <code>ArrayUtils.clone(new int[] {2})</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     */\n    public ArrayUtils() {\n        super();\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts the given array into a {@link Map}. Each element of the array\n     * must be either a {@link Entry} or an Array, containing at least two\n     * elements, where the first element is used as key and the second as\n     * value.</p>\n     *\n     * <p>This method can be used to initialize:</p>\n     * <pre>\n     * // Create a Map mapping colors.\n     * Map colorMap = ArrayUtils.toMap(new String[][] {{\n     *     {\"RED\", \"#FF0000\"},\n     *     {\"GREEN\", \"#00FF00\"},\n     *     {\"BLUE\", \"#0000FF\"}});\n     * </pre>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  an array whose elements are either a {@link Entry} or\n     *  an Array containing at least two elements, may be <code>null</code>\n     * @return a <code>Map</code> that was created from the array\n     * @throws IllegalArgumentException  if one element of this Array is\n     *  itself an Array containing less then two elements\n     * @throws IllegalArgumentException  if the array contains elements other\n     *  than {@link Entry} and an Array\n     */\n    public static Map toMap(final Object[] array) {\n        if (array == null) {\n            return null;\n        }\n        final Map map = new HashMap((int) (array.length * 1.5));\n        for (int i = 0; i < array.length; i++) {\n            Object object = array[i];\n            if (object instanceof Entry) {\n                Entry entry = (Entry) object;\n                map.put(entry.getKey(), entry.getValue());\n            } else if (object instanceof Object[]) {\n                Object[] entry = (Object[]) object;\n                if (entry.length < 2) {\n                    throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', has a length less than 2\");\n                }\n                map.put(entry[0], entry[1]);\n            } else {\n                throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', is neither of type Map.Entry nor an Array\");\n            }\n        }\n        return map;\n    }\n    // Clone\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Shallow clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>The objects in the array are not cloned, thus there is no special\n     * handling for multi-dimensional arrays.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to shallow clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static Object[] clone(final Object[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static long[] clone(final long[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static int[] clone(final int[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static short[] clone(final short[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static char[] clone(final char[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static byte[] clone(final byte[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static double[] clone(final double[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static float[] clone(final float[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static boolean[] clone(final boolean[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static String[] clone(final String[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n    // nullToEmpty\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Object[] nullToEmpty(final Object[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static String[] nullToEmpty(final String[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static long[] nullToEmpty(final long[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static int[] nullToEmpty(final int[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static short[] nullToEmpty(final short[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static char[] nullToEmpty(final char[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static byte[] nullToEmpty(final byte[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static double[] nullToEmpty(final double[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static float[] nullToEmpty(final float[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static boolean[] nullToEmpty(final boolean[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Long[] nullToEmpty(final Long[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Integer[] nullToEmpty(final Integer[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Short[] nullToEmpty(final Short[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Character[] nullToEmpty(final Character[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Byte[] nullToEmpty(final Byte[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Double[] nullToEmpty(final Double[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Float[] nullToEmpty(final Float[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Boolean[] nullToEmpty(final Boolean[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;\n        }\n        return array;\n    }\n    // Subarrays\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Produces a new array containing the elements between\n     * the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * <p>The component type of the subarray is always the same as\n     * that of the input array. Thus, if the input is an array of type\n     * <code>Date</code>, the following usage is envisaged:</p>\n     *\n     * <pre>\n     * Date[] someDates = (Date[])ArrayUtils.subarray(allDates, 2, 5);\n     * </pre>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static Object[] subarray(final Object[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        Class<?> type = array.getClass().getComponentType();\n        if (newSize <= 0) {\n            return (Object[]) Array.newInstance(type, 0);\n        }\n        Object[] subarray = (Object[]) Array.newInstance(type, newSize);\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>long</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        long[] subarray = new long[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>int</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        int[] subarray = new int[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>short</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        short[] subarray = new short[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>char</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        char[] subarray = new char[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>byte</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        byte[] subarray = new byte[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>double</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] subarray = new double[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>float</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        float[] subarray = new float[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>boolean</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        boolean[] subarray = new boolean[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n    // Is same length\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.\n     *\n     * <p>Any multi-dimensional aspects of the arrays are ignored.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final Object[] array1, final Object[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final long[] array1, final long[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final int[] array1, final int[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final short[] array1, final short[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final char[] array1, final char[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final double[] array1, final double[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final float[] array1, final float[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Returns the length of the specified array.\n     * This method can deal with <code>Object</code> arrays and with primitive arrays.</p>\n     *\n     * <p>If the input array is <code>null</code>, <code>0</code> is returned.</p>\n     *\n     * <pre>\n     * ArrayUtils.getLength(null)            = 0\n     * ArrayUtils.getLength([])              = 0\n     * ArrayUtils.getLength([null])          = 1\n     * ArrayUtils.getLength([true, false])   = 2\n     * ArrayUtils.getLength([1, 2, 3])       = 3\n     * ArrayUtils.getLength([\"a\", \"b\", \"c\"]) = 3\n     * </pre>\n     *\n     * @param array  the array to retrieve the length from, may be null\n     * @return The length of the array, or <code>0</code> if the array is <code>null</code>\n     * @throws IllegalArgumentException if the object arguement is not an array.\n     * @since 2.1\n     */\n    public static int getLength(final Object array) {\n        if (array == null) {\n            return 0;\n        }\n        return Array.getLength(array);\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same type taking into account\n     * multi-dimensional arrays.</p>\n     *\n     * @param array1 the first array, must not be <code>null</code>\n     * @param array2 the second array, must not be <code>null</code>\n     * @return <code>true</code> if type of arrays matches\n     * @throws IllegalArgumentException if either array is <code>null</code>\n     */\n    public static boolean isSameType(final Object array1, final Object array2) {\n        if (array1 == null || array2 == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        return array1.getClass().getName().equals(array2.getClass().getName());\n    }\n    // Reverse\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>There is no special handling for multi-dimensional arrays.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final Object[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        Object tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final long[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        long tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final int[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        int tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final short[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        short tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final char[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        char tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final byte[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        byte tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final double[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        double tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final float[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        float tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final boolean[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        boolean tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n    // IndexOf search\n    // ----------------------------------------------------------------------\n    // Object IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given object in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @return the index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final Object[] array, final Object objectToFind) {\n        return ArrayUtils.indexOf(array, objectToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given object in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @param startIndex  the index to start searching at\n     * @return the index of the object within the array starting at the index,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given object within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @return the last index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final Object[] array, final Object objectToFind) {\n        return ArrayUtils.lastIndexOf(array, objectToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given object in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n     * the array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i >= 0; i--) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n            for (int i = startIndex; i >= 0; i--) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the object is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param objectToFind  the object to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final Object[] array, final Object objectToFind) {\n        return ArrayUtils.indexOf(array, objectToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // long IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final long[] array, final long valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final long[] array, final long valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final long[] array, final long valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final long[] array, final long valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // int IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final int[] array, final int valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final int[] array, final int valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final int[] array, final int valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final int[] array, final int valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // short IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final short[] array, final short valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final short[] array, final short valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final short[] array, final short valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final short[] array, final short valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final short[] array, final short valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // char IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int indexOf(final char[] array, final char valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int indexOf(final char[] array, final char valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int lastIndexOf(final char[] array, final char valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int lastIndexOf(final char[] array, final char valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     * @since 2.1\n     */\n    public static boolean contains(final char[] array, final char valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // byte IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final byte[] array, final byte valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final byte[] array, final byte valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final byte[] array, final byte valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // double IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value within a given tolerance in the array.\n     * This method will return the index of the first value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind, final double tolerance) {\n        return ArrayUtils.indexOf(array, valueToFind, 0, tolerance);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.\n     * This method will return the index of the first value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        double min = valueToFind - tolerance;\n        double max = valueToFind + tolerance;\n        for (int i = startIndex; i < array.length; i++) {\n            if (array[i] >= min && array[i] <= max) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value within a given tolerance in the array.\n     * This method will return the index of the last value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.\n     * This method will return the index of the last value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @param tolerance  search for value within plus/minus this amount\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        double min = valueToFind - tolerance;\n        double max = valueToFind + tolerance;\n        for (int i = startIndex; i >= 0; i--) {\n            if (array[i] >= min && array[i] <= max) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final double[] array, final double valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if a value falling within the given tolerance is in the\n     * given array.  If the array contains a value within the inclusive range\n     * defined by (value - tolerance) to (value + tolerance).</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array\n     * is passed in.</p>\n     *\n     * @param array  the array to search\n     * @param valueToFind  the value to find\n     * @param tolerance  the array contains the tolerance of the search\n     * @return true if value falling within tolerance is in array\n     */\n    public static boolean contains(final double[] array, final double valueToFind, final double tolerance) {\n        return ArrayUtils.indexOf(array, valueToFind, 0, tolerance) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // float IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final float[] array, final float valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final float[] array, final float valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final float[] array, final float valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final float[] array, final float valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // boolean IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final boolean[] array, final boolean valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code>\n     *  array input\n     */\n    public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) if\n     * <code>null</code> array input.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final boolean[] array, final boolean valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n     * the array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final boolean[] array, final boolean valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // Primitive/Object array converters\n    // ----------------------------------------------------------------------\n    // Character array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Characters to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Character</code> array, may be <code>null</code>\n     * @return a <code>char</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static char[] toPrimitive(final Character[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].charValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Character to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Character</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>char</code> array, <code>null</code> if null array input\n     */\n    public static char[] toPrimitive(final Character[] array, final char valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Character b = array[i];\n            result[i] = b == null ? valueForNull : b.charValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive chars to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array a <code>char</code> array\n     * @return a <code>Character</code> array, <code>null</code> if null array input\n     */\n    public static Character[] toObject(final char[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY;\n        }\n        final Character[] result = new Character[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Character(array[i]);\n        }\n        return result;\n    }\n    // Long array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Longs to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Long</code> array, may be <code>null</code>\n     * @return a <code>long</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static long[] toPrimitive(final Long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].longValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Long to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Long</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>long</code> array, <code>null</code> if null array input\n     */\n    public static long[] toPrimitive(final Long[] array, final long valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Long b = array[i];\n            result[i] = b == null ? valueForNull : b.longValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive longs to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>long</code> array\n     * @return a <code>Long</code> array, <code>null</code> if null array input\n     */\n    public static Long[] toObject(final long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_OBJECT_ARRAY;\n        }\n        final Long[] result = new Long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Long(array[i]);\n        }\n        return result;\n    }\n    // Int array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Integers to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Integer</code> array, may be <code>null</code>\n     * @return an <code>int</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static int[] toPrimitive(final Integer[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].intValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Integer to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Integer</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return an <code>int</code> array, <code>null</code> if null array input\n     */\n    public static int[] toPrimitive(final Integer[] array, final int valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Integer b = array[i];\n            result[i] = b == null ? valueForNull : b.intValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive ints to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  an <code>int</code> array\n     * @return an <code>Integer</code> array, <code>null</code> if null array input\n     */\n    public static Integer[] toObject(final int[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        final Integer[] result = new Integer[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Integer(array[i]);\n        }\n        return result;\n    }\n    // Short array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Shorts to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Short</code> array, may be <code>null</code>\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static short[] toPrimitive(final Short[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        final short[] result = new short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].shortValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Short to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Short</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     */\n    public static short[] toPrimitive(final Short[] array, final short valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        final short[] result = new short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Short b = array[i];\n            result[i] = b == null ? valueForNull : b.shortValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive shorts to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>short</code> array\n     * @return a <code>Short</code> array, <code>null</code> if null array input\n     */\n    public static Short[] toObject(final short[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;\n        }\n        final Short[] result = new Short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Short(array[i]);\n        }\n        return result;\n    }\n    // Byte array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Bytes to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Byte</code> array, may be <code>null</code>\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static byte[] toPrimitive(final Byte[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        final byte[] result = new byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].byteValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Bytes to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Byte</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     */\n    public static byte[] toPrimitive(final Byte[] array, final byte valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        final byte[] result = new byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Byte b = array[i];\n            result[i] = b == null ? valueForNull : b.byteValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive bytes to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>byte</code> array\n     * @return a <code>Byte</code> array, <code>null</code> if null array input\n     */\n    public static Byte[] toObject(final byte[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;\n        }\n        final Byte[] result = new Byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Byte(array[i]);\n        }\n        return result;\n    }\n    // Double array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Doubles to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Double</code> array, may be <code>null</code>\n     * @return a <code>double</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static double[] toPrimitive(final Double[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        final double[] result = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].doubleValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Doubles to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Double</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>double</code> array, <code>null</code> if null array input\n     */\n    public static double[] toPrimitive(final Double[] array, final double valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        final double[] result = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Double b = array[i];\n            result[i] = b == null ? valueForNull : b.doubleValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive doubles to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>double</code> array\n     * @return a <code>Double</code> array, <code>null</code> if null array input\n     */\n    public static Double[] toObject(final double[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;\n        }\n        final Double[] result = new Double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Double(array[i]);\n        }\n        return result;\n    }\n    //   Float array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Floats to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Float</code> array, may be <code>null</code>\n     * @return a <code>float</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static float[] toPrimitive(final Float[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        final float[] result = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].floatValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Floats to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Float</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>float</code> array, <code>null</code> if null array input\n     */\n    public static float[] toPrimitive(final Float[] array, final float valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        final float[] result = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Float b = array[i];\n            result[i] = b == null ? valueForNull : b.floatValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive floats to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>float</code> array\n     * @return a <code>Float</code> array, <code>null</code> if null array input\n     */\n    public static Float[] toObject(final float[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY;\n        }\n        final Float[] result = new Float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Float(array[i]);\n        }\n        return result;\n    }\n    // Boolean array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Booleans to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n     * @return a <code>boolean</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static boolean[] toPrimitive(final Boolean[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        final boolean[] result = new boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].booleanValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Booleans to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>boolean</code> array, <code>null</code> if null array input\n     */\n    public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        final boolean[] result = new boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Boolean b = array[i];\n            result[i] = b == null ? valueForNull : b.booleanValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive booleans to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>boolean</code> array\n     * @return a <code>Boolean</code> array, <code>null</code> if null array input\n     */\n    public static Boolean[] toObject(final boolean[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;\n        }\n        final Boolean[] result = new Boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE;\n        }\n        return result;\n    }\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if an array of Objects is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final Object[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive longs is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final long[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive ints is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final int[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive shorts is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final short[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive chars is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final char[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive bytes is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final byte[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final double[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive floats is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final float[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive booleans is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final boolean[] array) {\n        return array == null || array.length == 0;\n    }\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if an array of Objects is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final Object[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive longs is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final long[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive ints is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final int[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive shorts is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final short[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive chars is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final char[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive bytes is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final byte[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive doubles is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final double[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive floats is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final float[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive booleans is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final boolean[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(null, null)     = null\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * ArrayUtils.addAll([null], [null]) = [null, null]\n     * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array, may be <code>null</code>\n     * @param array2  the second array whose elements are added to the new array, may be <code>null</code>\n     * @return The new array, <code>null</code> if both arrays are <code>null</code>.\n     *      The type of the new array is the type of the first array,\n     *      unless the first array is null, in which case the type is the same as the second array.\n     * @since 2.1\n     * @throws IllegalArgumentException if the array types are incompatible\n     */\n    public static Object[] addAll(final Object[] array1, final Object[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        Object[] joinedArray = (Object[]) Array.newInstance(array1.getClass().getComponentType(), array1.length + array2.length);\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        try {\n            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        } catch (ArrayStoreException ase) {\n            // Check if problem was due to incompatible types\n            /*\n             * We do this here, rather than before the copy because:\n             * - it would be a wasted check most of the time\n             * - safer, in case check turns out to be too strict\n             */\n            final Class<?> type1 = array1.getClass().getComponentType();\n            final Class<?> type2 = array2.getClass().getComponentType();\n            if (!type1.isAssignableFrom(type2)) {\n                throw new IllegalArgumentException(\"Cannot store \" + type2.getName() + \" in an array of \" + type1.getName());\n            }\n            throw ase; // No, so rethrow original\n        }\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new boolean[] array.\n     * @since 2.1\n     */\n    public static boolean[] addAll(final boolean[] array1, final boolean[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        boolean[] joinedArray = new boolean[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new char[] array.\n     * @since 2.1\n     */\n    public static char[] addAll(final char[] array1, final char[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        char[] joinedArray = new char[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new byte[] array.\n     * @since 2.1\n     */\n    public static byte[] addAll(final byte[] array1, final byte[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        byte[] joinedArray = new byte[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new short[] array.\n     * @since 2.1\n     */\n    public static short[] addAll(final short[] array1, final short[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        short[] joinedArray = new short[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new int[] array.\n     * @since 2.1\n     */\n    public static int[] addAll(final int[] array1, final int[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        int[] joinedArray = new int[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new long[] array.\n     * @since 2.1\n     */\n    public static long[] addAll(final long[] array1, final long[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        long[] joinedArray = new long[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new float[] array.\n     * @since 2.1\n     */\n    public static float[] addAll(final float[] array1, final float[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        float[] joinedArray = new float[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new double[] array.\n     * @since 2.1\n     */\n    public static double[] addAll(final double[] array1, final double[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        double[] joinedArray = new double[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new String[] array.\n     * @since 2.1\n     */\n    public static String[] addAll(final String[] array1, final String[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        String[] joinedArray = new String[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element, unless the element itself is null,\n     *  in which case the return type is Object[]</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, null)      = [null]\n     * ArrayUtils.add(null, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to \"add\" the element to, may be <code>null</code>\n     * @param element  the object to add, may be <code>null</code>\n     * @return A new array containing the existing elements plus the new element\n     * The returned array type will be that of the input array (unless null),\n     * in which case it will have the same type as the element.\n     * @since 2.1\n     */\n    public static <T> T[] add(final T[] array, final T element) {\n        Class<?> type;\n        if (array != null) {\n            type = array.getClass();\n        } else if (element != null) {\n            type = element.getClass();\n        } else {\n            type = Object.class;\n        }\n        T[] newArray = (T[]) ArrayUtils.copyArrayGrow1(array, type);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, true)          = [true]\n     * ArrayUtils.add([true], false)       = [true, false]\n     * ArrayUtils.add([true, false], true) = [true, false, true]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static boolean[] add(final boolean[] array, final boolean element) {\n        boolean[] newArray = (boolean[]) ArrayUtils.copyArrayGrow1(array, Boolean.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static byte[] add(final byte[] array, final byte element) {\n        byte[] newArray = (byte[]) ArrayUtils.copyArrayGrow1(array, Byte.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, '0')       = ['0']\n     * ArrayUtils.add(['1'], '0')      = ['1', '0']\n     * ArrayUtils.add(['1', '0'], '1') = ['1', '0', '1']\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static char[] add(final char[] array, final char element) {\n        char[] newArray = (char[]) ArrayUtils.copyArrayGrow1(array, Character.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static double[] add(final double[] array, final double element) {\n        double[] newArray = (double[]) ArrayUtils.copyArrayGrow1(array, Double.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static float[] add(final float[] array, final float element) {\n        float[] newArray = (float[]) ArrayUtils.copyArrayGrow1(array, Float.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static int[] add(final int[] array, final int element) {\n        int[] newArray = (int[]) ArrayUtils.copyArrayGrow1(array, Integer.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static long[] add(final long[] array, final long element) {\n        long[] newArray = (long[]) ArrayUtils.copyArrayGrow1(array, Long.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static short[] add(final short[] array, final short element) {\n        short[] newArray = (short[]) ArrayUtils.copyArrayGrow1(array, Short.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * Returns a copy of the given array of size 1 greater than the argument.\n     * The last value of the array is left to the default value.\n     *\n     * @param array The array to copy, must not be <code>null</code>.\n     * @param newArrayComponentType If <code>array</code> is <code>null</code>, create a\n     * size 1 array of this type.\n     * @return A new copy of the array of size 1 greater than the input.\n     */\n    private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n        if (array != null) {\n            int arrayLength = Array.getLength(array);\n            Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n            System.arraycopy(array, 0, newArray, 0, arrayLength);\n            return newArray;\n        }\n        return Array.newInstance(newArrayComponentType, 1);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, null)      = [null]\n     * ArrayUtils.add(null, 0, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], 1, null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], 1, \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], 3, \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > array.length).\n     */\n    public static Object[] add(final Object[] array, final int index, final Object element) {\n        Class<?> clss = null;\n        if (array != null) {\n            clss = array.getClass().getComponentType();\n        } else if (element != null) {\n            clss = element.getClass();\n        } else {\n            return new Object[] { null };\n        }\n        return (Object[]) ArrayUtils.add(array, index, element, clss);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, true)          = [true]\n     * ArrayUtils.add([true], 0, false)       = [false, true]\n     * ArrayUtils.add([false], 1, true)       = [false, true]\n     * ArrayUtils.add([true, false], 1, true) = [true, true, false]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static boolean[] add(final boolean[] array, final int index, final boolean element) {\n        Boolean booElement = element ? Boolean.TRUE : Boolean.FALSE;\n        return (boolean[]) ArrayUtils.add(array, index, booElement, Boolean.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, 'a')            = ['a']\n     * ArrayUtils.add(['a'], 0, 'b')           = ['b', 'a']\n     * ArrayUtils.add(['a', 'b'], 0, 'c')      = ['c', 'a', 'b']\n     * ArrayUtils.add(['a', 'b'], 1, 'k')      = ['a', 'k', 'b']\n     * ArrayUtils.add(['a', 'b', 'c'], 1, 't') = ['a', 't', 'b', 'c']\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static char[] add(final char[] array, final int index, final char element) {\n        return (char[]) ArrayUtils.add(array, index, new Character(element), Character.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 3)      = [2, 6, 3]\n     * ArrayUtils.add([2, 6], 0, 1)      = [1, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static byte[] add(final byte[] array, final int index, final byte element) {\n        return (byte[]) ArrayUtils.add(array, index, new Byte(element), Byte.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static short[] add(final short[] array, final int index, final short element) {\n        return (short[]) ArrayUtils.add(array, index, new Short(element), Short.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static int[] add(final int[] array, final int index, final int element) {\n        return (int[]) ArrayUtils.add(array, index, new Integer(element), Integer.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1L], 0, 2L)           = [2L, 1L]\n     * ArrayUtils.add([2L, 6L], 2, 10L)      = [2L, 6L, 10L]\n     * ArrayUtils.add([2L, 6L], 0, -4L)      = [-4L, 2L, 6L]\n     * ArrayUtils.add([2L, 6L, 3L], 2, 1L)   = [2L, 6L, 1L, 3L]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static long[] add(final long[] array, final int index, final long element) {\n        return (long[]) ArrayUtils.add(array, index, new Long(element), Long.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1.1f], 0, 2.2f)               = [2.2f, 1.1f]\n     * ArrayUtils.add([2.3f, 6.4f], 2, 10.5f)        = [2.3f, 6.4f, 10.5f]\n     * ArrayUtils.add([2.6f, 6.7f], 0, -4.8f)        = [-4.8f, 2.6f, 6.7f]\n     * ArrayUtils.add([2.9f, 6.0f, 0.3f], 2, 1.0f)   = [2.9f, 6.0f, 1.0f, 0.3f]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static float[] add(final float[] array, final int index, final float element) {\n        return (float[]) ArrayUtils.add(array, index, new Float(element), Float.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1.1], 0, 2.2)              = [2.2, 1.1]\n     * ArrayUtils.add([2.3, 6.4], 2, 10.5)        = [2.3, 6.4, 10.5]\n     * ArrayUtils.add([2.6, 6.7], 0, -4.8)        = [-4.8, 2.6, 6.7]\n     * ArrayUtils.add([2.9, 6.0, 0.3], 2, 1.0)    = [2.9, 6.0, 1.0, 0.3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static double[] add(final double[] array, final int index, final double element) {\n        return (double[]) ArrayUtils.add(array, index, new Double(element), Double.TYPE);\n    }\n\n    /**\n     * Underlying implementation of add(array, index, element) methods.\n     * The last parameter is the class, which may not equal element.getClass\n     * for primitives.\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @param clss the type of the element being added\n     * @return A new array containing the existing elements and the new element\n     */\n    private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {\n        if (array == null) {\n            if (index != 0) {\n                throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n            }\n            Object joinedArray = Array.newInstance(clss, 1);\n            Array.set(joinedArray, 0, element);\n            return joinedArray;\n        }\n        int length = Array.getLength(array);\n        if (index > length || index < 0) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n        }\n        Object result = Array.newInstance(clss, length + 1);\n        System.arraycopy(array, 0, result, 0, index);\n        Array.set(result, index, element);\n        if (index < length) {\n            System.arraycopy(array, index, result, index + 1, length - index);\n        }\n        return result;\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([\"a\"], 0)           = []\n     * ArrayUtils.remove([\"a\", \"b\"], 0)      = [\"b\"]\n     * ArrayUtils.remove([\"a\", \"b\"], 1)      = [\"a\"]\n     * ArrayUtils.remove([\"a\", \"b\", \"c\"], 1) = [\"a\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static Object[] remove(final Object[] array, final int index) {\n        return (Object[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, \"a\")            = null\n     * ArrayUtils.removeElement([], \"a\")              = []\n     * ArrayUtils.removeElement([\"a\"], \"b\")           = [\"a\"]\n     * ArrayUtils.removeElement([\"a\", \"b\"], \"a\")      = [\"b\"]\n     * ArrayUtils.removeElement([\"a\", \"b\", \"a\"], \"a\") = [\"b\", \"a\"]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static Object[] removeElement(final Object[] array, final Object element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([true], 0)              = []\n     * ArrayUtils.remove([true, false], 0)       = [false]\n     * ArrayUtils.remove([true, false], 1)       = [true]\n     * ArrayUtils.remove([true, true, false], 1) = [true, false]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static boolean[] remove(final boolean[] array, final int index) {\n        return (boolean[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, true)                = null\n     * ArrayUtils.removeElement([], true)                  = []\n     * ArrayUtils.removeElement([true], false)             = [true]\n     * ArrayUtils.removeElement([true, false], false)      = [true]\n     * ArrayUtils.removeElement([true, false, true], true) = [false, true]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static boolean[] removeElement(final boolean[] array, final boolean element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)          = []\n     * ArrayUtils.remove([1, 0], 0)       = [0]\n     * ArrayUtils.remove([1, 0], 1)       = [1]\n     * ArrayUtils.remove([1, 0, 1], 1)    = [1, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static byte[] remove(final byte[] array, final int index) {\n        return (byte[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)        = null\n     * ArrayUtils.removeElement([], 1)          = []\n     * ArrayUtils.removeElement([1], 0)         = [1]\n     * ArrayUtils.removeElement([1, 0], 0)      = [1]\n     * ArrayUtils.removeElement([1, 0, 1], 1)   = [0, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static byte[] removeElement(final byte[] array, final byte element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove(['a'], 0)           = []\n     * ArrayUtils.remove(['a', 'b'], 0)      = ['b']\n     * ArrayUtils.remove(['a', 'b'], 1)      = ['a']\n     * ArrayUtils.remove(['a', 'b', 'c'], 1) = ['a', 'c']\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static char[] remove(final char[] array, final int index) {\n        return (char[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 'a')            = null\n     * ArrayUtils.removeElement([], 'a')              = []\n     * ArrayUtils.removeElement(['a'], 'b')           = ['a']\n     * ArrayUtils.removeElement(['a', 'b'], 'a')      = ['b']\n     * ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static char[] removeElement(final char[] array, final char element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1.1], 0)           = []\n     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static double[] remove(final double[] array, final int index) {\n        return (double[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1.1)            = null\n     * ArrayUtils.removeElement([], 1.1)              = []\n     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static double[] removeElement(final double[] array, final double element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1.1], 0)           = []\n     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static float[] remove(final float[] array, final int index) {\n        return (float[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1.1)            = null\n     * ArrayUtils.removeElement([], 1.1)              = []\n     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static float[] removeElement(final float[] array, final float element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static int[] remove(final int[] array, final int index) {\n        return (int[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static int[] removeElement(final int[] array, final int element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static long[] remove(final long[] array, final int index) {\n        return (long[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static long[] removeElement(final long[] array, final long element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static short[] remove(final short[] array, final int index) {\n        return (short[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static short[] removeElement(final short[] array, final short element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    private static Object remove(final Object array, final int index) {\n        int length = ArrayUtils.getLength(array);\n        if (index < 0 || index >= length) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n        }\n        Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);\n        System.arraycopy(array, 0, result, 0, index);\n        if (index < length - 1) {\n            System.arraycopy(array, index + 1, result, index, length - index - 1);\n        }\n        return result;\n    }\n\n    /**删除数组中空元素*/\n    public static Object[] clearNull(final Object[] arr) {\n        ArrayList<Object> list = new ArrayList<Object>();\n        if (arr != null) {\n            for (Object item : arr) {\n                if (item != null) {\n                    list.add(item);\n                }\n            }\n        }\n        return list.toArray();\n    }\n}\n",
      "file_name": "ArrayUtils.java",
      "human_label": "Convert the given Boolean array to primitives. Return ArrayUtils.EMPTY_BOOLEAN_ARRAY for an empty array, return null for null array.",
      "level": "self_contained",
      "lineno": "2988",
      "name": "toPrimitive",
      "oracle_context": "{ \"apis\" : \"[booleanValue, ArrayUtils]\", \"classes\" : \"[boolean[], ArrayUtils]\", \"vars\" : \"[length, EMPTY_BOOLEAN_ARRAY]\" }",
      "package": "net.hasor.utils",
      "project": "hasor-master"
    },
    {
      "_id": "6367672d1a6d9265ec017c73",
      "all_context": "{ \"class_level\" : \"HashMap<String,Integer> messages;\\nshouldPrintMessage(int timestamp,String message);\\nLogger();\\n\", \"repo_level\" : \"\" }",
      "class_name": "LoggerRateLimiter",
      "code": "public boolean shouldPrintMessage(int timestamp,String message){\n  if (messages.containsKey(message)) {\n    if (timestamp - messages.get(message) >= 10) {\n      messages.put(message,timestamp);\n      return true;\n    }\n else {\n      return false;\n    }\n  }\n else {\n    messages.put(message,timestamp);\n    return true;\n  }\n}\n",
      "docstring": "/** \n * Returns true if the message should be printed in the given timestamp, otherwise returns false. If this method returns false, the message will not be printed. The timestamp is in seconds granularity. \n */\n",
      "end_lineno": "52",
      "file_content": "// Design a logger system that receive stream of messages along with its timestamps, each message should be printed if and only if it is not printed in the last 10 seconds.\n\n// Given a message and a timestamp (in seconds granularity), return true if the message should be printed in the given timestamp, otherwise returns false.\n\n// It is possible that several messages arrive roughly at the same time.\n\n// Example:\n\n// Logger logger = new Logger();\n\n// // logging string \"foo\" at timestamp 1\n// logger.shouldPrintMessage(1, \"foo\"); returns true; \n\n// // logging string \"bar\" at timestamp 2\n// logger.shouldPrintMessage(2,\"bar\"); returns true;\n\n// // logging string \"foo\" at timestamp 3\n// logger.shouldPrintMessage(3,\"foo\"); returns false;\n\n// // logging string \"bar\" at timestamp 8\n// logger.shouldPrintMessage(8,\"bar\"); returns false;\n\n// // logging string \"foo\" at timestamp 10\n// logger.shouldPrintMessage(10,\"foo\"); returns false;\n\n// // logging string \"foo\" at timestamp 11\n// logger.shouldPrintMessage(11,\"foo\"); returns true;\n\npublic class LoggerRateLimiter {\n    HashMap<String, Integer> messages;\n\n    /** Initialize your data structure here. */\n    public Logger() {\n       this.messages = new HashMap<String, Integer>(); \n    }\n    \n    /** Returns true if the message should be printed in the given timestamp, otherwise returns false.\n        If this method returns false, the message will not be printed.\n        The timestamp is in seconds granularity. */\n    public boolean shouldPrintMessage(int timestamp, String message) {\n        if(messages.containsKey(message)) {\n            if(timestamp - messages.get(message) >= 10) {\n                messages.put(message, timestamp);\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            messages.put(message, timestamp);\n            return true;\n        }\n    }\n}\n\n/**\n * Your Logger object will be instantiated and called as such:\n * Logger obj = new Logger();\n * boolean param_1 = obj.shouldPrintMessage(timestamp,message);\n */\n",
      "file_name": "LoggerRateLimiter.java",
      "human_label": " If the message does not exist in the dict messages, or it exists but the timestamp (seconds) difference is bigger than 10, put the message and timestamp into messages and return true, otherwise return false.",
      "level": "self_contained",
      "lineno": "37",
      "name": "shouldPrintMessage",
      "oracle_context": "{ \"apis\" : \"[containsKey, get, put]\", \"classes\" : \"[]\", \"vars\" : \"[messages]\" }",
      "package": "",
      "project": "interviews-master"
    },
    {
      "_id": "636766f81a6d9265ec01775c",
      "all_context": "{ \"class_level\" : \"import java.io.Serializable;\\nNull NULL;\\nlong serialVersionUID;\\nObjectUtils();\\nequals(Object object1,Object object2);\\nnotEqual(Object object1,Object object2);\\nhashCode(Object obj);\\nidentityToString(Object object);\\nidentityToString(StringBuffer buffer,Object object);\\ntoString(Object obj);\\ntoString(Object obj,String nullStr);\\nmin(Comparable c1,Comparable c2);\\nmax(Comparable c1,Comparable c2);\\ncompare(Comparable c1,Comparable c2);\\ncompare(Comparable c1,Comparable c2,boolean nullGreater);\\nNull();\\nreadResolve();\\ndefaultIfNull(Object object,Object defaultValue);\\n\", \"repo_level\" : \"\" }",
      "class_name": "ObjectUtils",
      "code": "public static String toString(Object obj){\n  return obj == null ? \"\" : obj.toString();\n}\n",
      "docstring": "/** \n * <p>Gets the <code>toString</code> of an <code>Object</code> returning an empty string (\"\") if <code>null</code> input.</p> <pre> ObjectUtils.toString(null)         = \"\" ObjectUtils.toString(\"\")           = \"\" ObjectUtils.toString(\"bat\")        = \"bat\" ObjectUtils.toString(Boolean.TRUE) = \"true\" </pre>\n * @see StringUtils#defaultString(String)\n * @see String#valueOf(Object)\n * @param obj  the Object to <code>toString</code>, may be null\n * @return the passed in Object's toString, or nullStr if <code>null</code> input\n * @since 2.0\n */\n",
      "end_lineno": "231",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils;\nimport java.io.Serializable;\n\n/**\n * <p>Operations on <code>Object</code>.</p>\n *\n * <p>This class tries to handle <code>null</code> input gracefully.\n * An exception will generally not be thrown for a <code>null</code> input.\n * Each method documents its behaviour in more detail.</p>\n *\n * <p>#ThreadSafe#</p>\n * @author Apache Software Foundation\n * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n * @author <a href=\"mailto:janekdb@yahoo.co.uk\">Janek Bogucki</a>\n * @author Daniel L. Rall\n * @author Gary Gregory\n * @author Mario Winterer\n * @author <a href=\"mailto:david@davidkarlsen.com\">David J. M. Karlsen</a>\n * @since 1.0\n * @version $Id: ObjectUtils.java 1057434 2011-01-11 01:27:37Z niallp $\n */\npublic class ObjectUtils {\n    /**\n     * <p>Singleton used as a <code>null</code> placeholder where\n     * <code>null</code> has another meaning.</p>\n     *\n     * <p>For example, in a <code>HashMap</code> the\n     * {@link java.util.HashMap#get(Object)} method returns\n     * <code>null</code> if the <code>Map</code> contains\n     * <code>null</code> or if there is no matching key. The\n     * <code>Null</code> placeholder can be used to distinguish between\n     * these two cases.</p>\n     *\n     * <p>Another example is <code>Hashtable</code>, where <code>null</code>\n     * cannot be stored.</p>\n     *\n     * <p>This instance is Serializable.</p>\n     */\n    public static final Null NULL = new Null();\n\n    /**\n     * <p><code>ObjectUtils</code> instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * <code>ObjectUtils.defaultIfNull(\"a\",\"b\");</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     */\n    public ObjectUtils() {\n        super();\n    }\n    // Defaulting\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Returns a default value if the object passed is\n     * <code>null</code>.</p>\n     *\n     * <pre>\n     * ObjectUtils.defaultIfNull(null, null)      = null\n     * ObjectUtils.defaultIfNull(null, \"\")        = \"\"\n     * ObjectUtils.defaultIfNull(null, \"zz\")      = \"zz\"\n     * ObjectUtils.defaultIfNull(\"abc\", *)        = \"abc\"\n     * ObjectUtils.defaultIfNull(Boolean.TRUE, *) = Boolean.TRUE\n     * </pre>\n     *\n     * @param object  the <code>Object</code> to test, may be <code>null</code>\n     * @param defaultValue  the default value to return, may be <code>null</code>\n     * @return <code>object</code> if it is not <code>null</code>, defaultValue otherwise\n     */\n    public static Object defaultIfNull(Object object, Object defaultValue) {\n        return object != null ? object : defaultValue;\n    }\n\n    /**\n     * <p>Compares two objects for equality, where either one or both\n     * objects may be <code>null</code>.</p>\n     *\n     * <pre>\n     * ObjectUtils.equals(null, null)                  = true\n     * ObjectUtils.equals(null, \"\")                    = false\n     * ObjectUtils.equals(\"\", null)                    = false\n     * ObjectUtils.equals(\"\", \"\")                      = true\n     * ObjectUtils.equals(Boolean.TRUE, null)          = false\n     * ObjectUtils.equals(Boolean.TRUE, \"true\")        = false\n     * ObjectUtils.equals(Boolean.TRUE, Boolean.TRUE)  = true\n     * ObjectUtils.equals(Boolean.TRUE, Boolean.FALSE) = false\n     * </pre>\n     *\n     * @param object1  the first object, may be <code>null</code>\n     * @param object2  the second object, may be <code>null</code>\n     * @return <code>true</code> if the values of both objects are the same\n     */\n    public static boolean equals(Object object1, Object object2) {\n        if (object1 == object2) {\n            return true;\n        }\n        if ((object1 == null) || (object2 == null)) {\n            return false;\n        }\n        return object1.equals(object2);\n    }\n\n    /**\n     * <p>Compares two objects for inequality, where either one or both\n     * objects may be <code>null</code>.</p>\n     *\n     * <pre>\n     * ObjectUtils.notEqual(null, null)                  = false\n     * ObjectUtils.notEqual(null, \"\")                    = true\n     * ObjectUtils.notEqual(\"\", null)                    = true\n     * ObjectUtils.notEqual(\"\", \"\")                      = false\n     * ObjectUtils.notEqual(Boolean.TRUE, null)          = true\n     * ObjectUtils.notEqual(Boolean.TRUE, \"true\")        = true\n     * ObjectUtils.notEqual(Boolean.TRUE, Boolean.TRUE)  = false\n     * ObjectUtils.notEqual(Boolean.TRUE, Boolean.FALSE) = true\n     * </pre>\n     *\n     * @param object1  the first object, may be <code>null</code>\n     * @param object2  the second object, may be <code>null</code>\n     * @return <code>false</code> if the values of both objects are the same\n     * @since 2.6\n     */\n    public static boolean notEqual(Object object1, Object object2) {\n        return ObjectUtils.equals(object1, object2) == false;\n    }\n\n    /**\n     * <p>Gets the hash code of an object returning zero when the\n     * object is <code>null</code>.</p>\n     *\n     * <pre>\n     * ObjectUtils.hashCode(null)   = 0\n     * ObjectUtils.hashCode(obj)    = obj.hashCode()\n     * </pre>\n     *\n     * @param obj  the object to obtain the hash code of, may be <code>null</code>\n     * @return the hash code of the object, or zero if null\n     * @since 2.1\n     */\n    public static int hashCode(Object obj) {\n        return (obj == null) ? 0 : obj.hashCode();\n    }\n    // Identity ToString\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Gets the toString that would be produced by <code>Object</code>\n     * if a class did not override toString itself. <code>null</code>\n     * will return <code>null</code>.</p>\n     *\n     * <pre>\n     * ObjectUtils.identityToString(null)         = null\n     * ObjectUtils.identityToString(\"\")           = \"java.lang.String@1e23\"\n     * ObjectUtils.identityToString(Boolean.TRUE) = \"java.lang.Boolean@7fa\"\n     * </pre>\n     *\n     * @param object  the object to create a toString for, may be\n     *  <code>null</code>\n     * @return the default toString text, or <code>null</code> if\n     *  <code>null</code> passed in\n     */\n    public static String identityToString(Object object) {\n        if (object == null) {\n            return null;\n        }\n        StringBuffer buffer = new StringBuffer();\n        identityToString(buffer, object);\n        return buffer.toString();\n    }\n\n    /**\n     * <p>Appends the toString that would be produced by <code>Object</code>\n     * if a class did not override toString itself. <code>null</code>\n     * will throw a NullPointerException for either of the two parameters. </p>\n     *\n     * <pre>\n     * ObjectUtils.identityToString(buf, \"\")            = buf.append(\"java.lang.String@1e23\"\n     * ObjectUtils.identityToString(buf, Boolean.TRUE)  = buf.append(\"java.lang.Boolean@7fa\"\n     * ObjectUtils.identityToString(buf, Boolean.TRUE)  = buf.append(\"java.lang.Boolean@7fa\")\n     * </pre>\n     *\n     * @param buffer  the buffer to append to\n     * @param object  the object to create a toString for\n     * @since 2.4\n     */\n    public static void identityToString(StringBuffer buffer, Object object) {\n        if (object == null) {\n            throw new NullPointerException(\"Cannot get the toString of a null identity\");\n        }\n        buffer.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object)));\n    }\n    // ToString\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Gets the <code>toString</code> of an <code>Object</code> returning\n     * an empty string (\"\") if <code>null</code> input.</p>\n     *\n     * <pre>\n     * ObjectUtils.toString(null)         = \"\"\n     * ObjectUtils.toString(\"\")           = \"\"\n     * ObjectUtils.toString(\"bat\")        = \"bat\"\n     * ObjectUtils.toString(Boolean.TRUE) = \"true\"\n     * </pre>\n     *\n     * @see StringUtils#defaultString(String)\n     * @see String#valueOf(Object)\n     * @param obj  the Object to <code>toString</code>, may be null\n     * @return the passed in Object's toString, or nullStr if <code>null</code> input\n     * @since 2.0\n     */\n    public static String toString(Object obj) {\n        return obj == null ? \"\" : obj.toString();\n    }\n\n    /**\n     * <p>Gets the <code>toString</code> of an <code>Object</code> returning\n     * a specified text if <code>null</code> input.</p>\n     *\n     * <pre>\n     * ObjectUtils.toString(null, null)           = null\n     * ObjectUtils.toString(null, \"null\")         = \"null\"\n     * ObjectUtils.toString(\"\", \"null\")           = \"\"\n     * ObjectUtils.toString(\"bat\", \"null\")        = \"bat\"\n     * ObjectUtils.toString(Boolean.TRUE, \"null\") = \"true\"\n     * </pre>\n     *\n     * @see StringUtils#defaultString(String, String)\n     * @see String#valueOf(Object)\n     * @param obj  the Object to <code>toString</code>, may be null\n     * @param nullStr  the String to return if <code>null</code> input, may be null\n     * @return the passed in Object's toString, or nullStr if <code>null</code> input\n     * @since 2.0\n     */\n    public static String toString(Object obj, String nullStr) {\n        return obj == null ? nullStr : obj.toString();\n    }\n    // Min/Max\n    //-----------------------------------------------------------------------\n\n    /**\n     * Null safe comparison of Comparables.\n     *\n     * @param c1  the first comparable, may be null\n     * @param c2  the second comparable, may be null\n     * @return\n     *  <ul>\n     *   <li>If both objects are non-null and unequal, the lesser object.\n     *   <li>If both objects are non-null and equal, c1.\n     *   <li>If one of the comparables is null, the non-null object.\n     *   <li>If both the comparables are null, null is returned.\n     *  </ul>\n     */\n    public static Object min(Comparable c1, Comparable c2) {\n        return (compare(c1, c2, true) <= 0 ? c1 : c2);\n    }\n\n    /**\n     * Null safe comparison of Comparables.\n     *\n     * @param c1  the first comparable, may be null\n     * @param c2  the second comparable, may be null\n     * @return\n     *  <ul>\n     *   <li>If both objects are non-null and unequal, the greater object.\n     *   <li>If both objects are non-null and equal, c1.\n     *   <li>If one of the comparables is null, the non-null object.\n     *   <li>If both the comparables are null, null is returned.\n     *  </ul>\n     */\n    public static Object max(Comparable c1, Comparable c2) {\n        return (compare(c1, c2, false) >= 0 ? c1 : c2);\n    }\n\n    /**\n     * Null safe comparison of Comparables.\n     * {@code null} is assumed to be less than a non-{@code null} value.\n     *\n     * @param c1  the first comparable, may be null\n     * @param c2  the second comparable, may be null\n     * @return a negative value if c1 < c2, zero if c1 = c2\n     * and a positive value if c1 > c2\n     * @since 2.6\n     */\n    public static int compare(Comparable c1, Comparable c2) {\n        return compare(c1, c2, false);\n    }\n\n    /**\n     * Null safe comparison of Comparables.\n     *\n     * @param c1  the first comparable, may be null\n     * @param c2  the second comparable, may be null\n     * @param nullGreater if true <code>null</code> is considered greater\n     * than a Non-<code>null</code> value or if false <code>null</code> is\n     * considered less than a Non-<code>null</code> value\n     * @return a negative value if c1 < c2, zero if c1 = c2\n     * and a positive value if c1 > c2\n     * @see java.util.Comparator#compare(Object, Object)\n     * @since 2.6\n     */\n    public static int compare(Comparable c1, Comparable c2, boolean nullGreater) {\n        if (c1 == c2) {\n            return 0;\n        } else if (c1 == null) {\n            return (nullGreater ? 1 : -1);\n        } else if (c2 == null) {\n            return (nullGreater ? -1 : 1);\n        }\n        return c1.compareTo(c2);\n    }\n    // Null\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Class used as a null placeholder where <code>null</code>\n     * has another meaning.</p>\n     *\n     * <p>For example, in a <code>HashMap</code> the\n     * {@link java.util.HashMap#get(Object)} method returns\n     * <code>null</code> if the <code>Map</code> contains\n     * <code>null</code> or if there is no matching key. The\n     * <code>Null</code> placeholder can be used to distinguish between\n     * these two cases.</p>\n     *\n     * <p>Another example is <code>Hashtable</code>, where <code>null</code>\n     * cannot be stored.</p>\n     */\n    public static class Null implements Serializable {\n        /**\n         * Required for serialization support. Declare serialization compatibility with Commons Lang 1.0\n         *\n         * @see Serializable\n         */\n        private static final long serialVersionUID = 7092611880189329093L;\n\n        /**\n         * Restricted constructor - singleton.\n         */\n        Null() {\n            super();\n        }\n\n        /**\n         * <p>Ensure singleton.</p>\n         *\n         * @return the singleton value\n         */\n        private Object readResolve() {\n            return ObjectUtils.NULL;\n        }\n    }\n}\n",
      "file_name": "ObjectUtils.java",
      "human_label": "Return the string representation of the given object, return an empty string if the object is null.",
      "level": "self_contained",
      "lineno": "212",
      "name": "toString",
      "oracle_context": "{ \"apis\" : \"[]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
      "package": "net.hasor.utils",
      "project": "hasor-master"
    },
    {
      "_id": "6367667f1a6d9265ec017457",
      "all_context": "{ \"class_level\" : \"import java.io.UnsupportedEncodingException;\\nimport java.net.URI;\\nimport java.net.URLDecoder;\\nimport java.nio.Buffer;\\nimport java.nio.ByteBuffer;\\nimport java.nio.CharBuffer;\\nimport java.nio.charset.Charset;\\nimport java.nio.charset.StandardCharsets;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collections;\\nimport java.util.HashMap;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Map;\\nchar[] HEX_DIGITS;\\nString[] SCHEME;\\nString[] UNRESERVED;\\nString[] SUB_DELIMS;\\nboolean[][] ENCODING_TABLES;\\nCharset UTF_8_CHARSET;\\nPathSegmentImpl EMPTY_PATH_SEGMENT;\\nString path;\\nMap<String,String> matrixParameters;\\nint[] HEX_TABLE;\\nUriComponent();\\nvalidate(String s,Type t,boolean template);\\nvalid(String s,Type t);\\nvalid(String s,Type t,boolean template);\\n_valid(String s,Type t,boolean template);\\ncontextualEncode(String s,Type t);\\ncontextualEncode(String s,Type t,boolean template);\\nencode(String s,Type t);\\nencode(String s,Type t,boolean template);\\nencodeTemplateNames(String s);\\n_encode(String s,Type t,boolean template,boolean contextualEncode);\\nappendPercentEncodedOctet(StringBuilder sb,int b);\\nappendUTF8EncodedCharacter(StringBuilder sb,char c);\\ncreatingEncodingTables();\\ncreatingEncodingTable(List allowed);\\ndecode(String s,Type t);\\ndecodeQuery(URI u,boolean decode);\\ndecodeQuery(String q,boolean decode);\\ndecodeQueryParam(Map params,String param,boolean decode);\\nPathSegmentImpl(String path,boolean decode);\\nPathSegmentImpl(String path,boolean decode,Map matrixParameters);\\ngetPath();\\ngetMatrixParameters();\\ndecodePath(URI u,boolean decode);\\ndecodePath(String path,boolean decode);\\ndecodePathSegment(List segments,String segment,boolean decode);\\ndecodeMatrix(String pathSegment,boolean decode);\\ndecodeMatrixParam(Map params,String param,boolean decode);\\ndecode(String s,int n);\\ndecodeQueryParam(String s,int n);\\ndecodeHost(String s,int n);\\ndecodePercentEncodedOctets(String s,int i,ByteBuffer bb);\\ndecodeOctets(int i,ByteBuffer bb,StringBuilder sb);\\ndecodeHex(String s,int i);\\ncreateHexTable();\\ndecodeHex(char c);\\nisHexCharacter(char c);\\nvalidate(String s,Type t);\\n\", \"repo_level\" : \"\" }",
      "class_name": "UriComponent",
      "code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n  if (bb.limit() == 1 && (bb.get(0) & 0xFF) < 0x80) {\n    sb.append((char)bb.get(0));\n    return i + 2;\n  }\n else {\n    CharBuffer cb=UTF_8_CHARSET.decode(bb);\n    sb.append(cb);\n    return i + bb.limit() * 3 - 1;\n  }\n}\n",
      "docstring": "/** \n * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.\n * @return the index to the next unchecked character in the string to decode\n */\n",
      "end_lineno": "816",
      "file_content": "/*\n * Copyright 2008-2022 Async-IO.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n *\n * Copyright (c) 2010-2018 Oracle and/or its affiliates. All rights reserved.\n *\n * The contents of this file are subject to the terms of either the GNU\n * General Public License Version 2 only (\"GPL\") or the Common Development\n * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n * may not use this file except in compliance with the License.  You can\n * obtain a copy of the License at\n * http://glassfish.java.net/public/CDDL+GPL_1_1.html\n * or packager/legal/LICENSE.txt.  See the License for the specific\n * language governing permissions and limitations under the License.\n *\n * When distributing the software, include this License Header Notice in each\n * file and include the License file at packager/legal/LICENSE.txt.\n *\n * GPL Classpath Exception:\n * Oracle designates this particular file as subject to the \"Classpath\"\n * exception as provided by Oracle in the GPL Version 2 section of the License\n * file that accompanied this code.\n *\n * Modifications:\n * If applicable, add the following below the License Header, with the fields\n * enclosed by brackets [] replaced by your own identifying information:\n * \"Portions Copyright [year] [name of copyright owner]\"\n *\n * Contributor(s):\n * If you wish your version of this file to be governed by only the CDDL or\n * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n * elects to include this software in this distribution under the [CDDL or GPL\n * Version 2] license.\"  If you don't indicate a single choice of license, a\n * recipient has the option to distribute your version of this file under\n * either the CDDL, the GPL Version 2 or to extend the choice of license to\n * its licensees as provided above.  However, if you add GPL Version 2 code\n * and therefore, elected the GPL Version 2 license, then the option applies\n * only if the new code is made subject to such option by the copyright\n * holder.\n */\npackage org.atmosphere.util.uri;\n\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLDecoder;\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Utility class for validating, encoding and decoding components\n * of a URI.\n *\n * @author Paul.Sandoz@Sun.Com\n */\npublic class UriComponent {\n\n    // TODO rewrite to use masks and not lookup tables\n    /**\n     * The URI component type.\n     */\n    public enum Type {\n\n        /**\n         * ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\" characters\n         */\n        UNRESERVED,\n        /**\n         * The URI scheme component type.\n         */\n        SCHEME,\n        /**\n         * The URI authority component type.\n         */\n        AUTHORITY,\n        /**\n         * The URI user info component type.\n         */\n        USER_INFO,\n        /**\n         * The URI host component type.\n         */\n        HOST,\n        /**\n         * The URI port component type.\n         */\n        PORT,\n        /**\n         * The URI path component type.\n         */\n        PATH,\n        /**\n         * The URI path component type that is a path segment.\n         */\n        PATH_SEGMENT,\n        /**\n         * The URI path component type that is a matrix parameter.\n         */\n        MATRIX_PARAM,\n        /**\n         * The URI query component type.\n         */\n        QUERY,\n        /**\n         * The URI query component type that is a query parameter.\n         */\n        QUERY_PARAM,\n        /**\n         * The URI fragment component type.\n         */\n        FRAGMENT,\n    }\n\n    private UriComponent() {\n    }\n\n    /**\n     * Validates the legal characters of a percent-encoded string that \n     * represents a URI component type.\n     *\n     * @param s the encoded string.\n     * @param t the URI compontent type identifying the legal characters.\n     * @throws IllegalArgumentException if the encoded string contains illegal\n     *         characters.\n     */\n    public static void validate(String s, Type t) {\n        validate(s, t, false);\n    }\n\n    /**\n     * Validates the legal characters of a percent-encoded string that \n     * represents a URI component type.\n     *\n     * @param s the encoded string.\n     * @param t the URI compontent type identifying the legal characters.\n     * @param template true if the encoded string contains URI template variables\n     * @throws IllegalArgumentException if the encoded string contains illegal\n     *         characters.\n     */\n    public static void validate(String s, Type t, boolean template) {\n        int i = _valid(s, t, template);\n        if (i > -1) // TODO localize\n        {\n            throw new IllegalArgumentException(\"The string '\" + s +\n                    \"' for the URI component \" + t +\n                    \" contains an invalid character, '\" + s.charAt(i) + \"', at index \" + i);\n        }\n    }\n\n    /**\n     * Validates the legal characters of a percent-encoded string that \n     * represents a URI component type.\n     *\n     * @param s the encoded string.\n     * @param t the URI compontent type identifying the legal characters.\n     * @return true if the encoded string is valid, otherwise false.\n     */\n    public static boolean valid(String s, Type t) {\n        return valid(s, t, false);\n    }\n\n    /**\n     * Validates the legal characters of a percent-encoded string that \n     * represents a URI component type.\n     *\n     * @param s the encoded string.\n     * @param t the URI compontent type identifying the legal characters.\n     * @param template true if the encoded string contains URI template variables\n     * @return true if the encoded string is valid, otherwise false.\n     */\n    public static boolean valid(String s, Type t, boolean template) {\n        return _valid(s, t, template) == -1;\n    }\n\n    private static int _valid(String s, Type t, boolean template) {\n        boolean[] table = ENCODING_TABLES[t.ordinal()];\n\n        for (int i = 0; i < s.length(); i++) {\n            final char c = s.charAt(i);\n            if (c >= 0x80 || (c != '%' && !table[c])) {\n                if (!template || (c != '{' && c != '}')) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Contextually encodes the characters of string that are either non-ASCII\n     * characters or are ASCII characters that must be percent-encoded using the\n     * UTF-8 encoding. Percent-encoded characters will be recognized and not\n     * double encoded.\n     *\n     * @param s the string to be encoded.\n     * @param t the URI compontent type identifying the ASCII characters that \n     *          must be percent-encoded.\n     * @return the encoded string.\n     */\n    public static String contextualEncode(String s, Type t) {\n        return _encode(s, t, false, true);\n    }\n\n    /**\n     * Contextually encodes the characters of string that are either non-ASCII\n     * characters or are ASCII characters that must be percent-encoded using the\n     * UTF-8 encoding. Percent-encoded characters will be recognized and not\n     * double encoded.\n     *\n     * @param s the string to be encoded.\n     * @param t the URI compontent type identifying the ASCII characters that \n     *          must be percent-encoded.\n     * @param template true if the encoded string contains URI template variables\n     * @return the encoded string.\n     */\n    public static String contextualEncode(String s, Type t, boolean template) {\n        return _encode(s, t, template, true);\n    }\n\n    /**\n     * Encodes the characters of string that are either non-ASCII characters \n     * or are ASCII characters that must be percent-encoded using the \n     * UTF-8 encoding.\n     *\n     * @param s the string to be encoded.\n     * @param t the URI compontent type identifying the ASCII characters that \n     *          must be percent-encoded.\n     * @return the encoded string.\n     */\n    public static String encode(String s, Type t) {\n        return _encode(s, t, false, false);\n    }\n\n    /**\n     * Encodes the characters of string that are either non-ASCII characters \n     * or are ASCII characters that must be percent-encoded using the \n     * UTF-8 encoding.\n     *\n     * @param s the string to be encoded.\n     * @param t the URI compontent type identifying the ASCII characters that \n     *          must be percent-encoded.\n     * @param template true if the encoded string contains URI template variables\n     * @return the encoded string.\n     */\n    public static String encode(String s, Type t, boolean template) {\n        return _encode(s, t, template, false);\n    }\n\n    /**\n     * Encodes a string with template parameters names present, specifically the\n     * characters '{' and '}' will be percent-encoded.\n     * \n     * @param s the string with zero or more template parameters names\n     * @return the string with encoded template parameters names.\n     */\n    public static String encodeTemplateNames(String s) {\n        int i = s.indexOf('{');\n        if (i != -1)\n            s = s.replace(\"{\", \"%7B\");\n        i = s.indexOf('}');\n        if (i != -1)\n            s = s.replace(\"}\", \"%7D\");\n\n        return s;\n    }\n\n    private static String _encode(String s, Type t, boolean template, boolean contextualEncode) {\n        final boolean[] table = ENCODING_TABLES[t.ordinal()];\n\n        StringBuilder sb = null;\n        for (int i = 0; i < s.length(); i++) {\n            final char c = s.charAt(i);\n            if (c < 0x80 && table[c]) {\n                if (sb != null) sb.append(c);\n            } else {\n                if (template && (c == '{' || c == '}')) {\n                    if (sb != null) sb.append(c);\n                    continue;\n                } else if (contextualEncode) {\n                    if (c == '%' && i + 2 < s.length()) {\n                        if (isHexCharacter(s.charAt(i + 1)) &&\n                                isHexCharacter(s.charAt(i + 2))) {\n                            if (sb != null)\n                                sb.append('%').append(s.charAt(i + 1)).append(s.charAt(i + 2));\n                            i += 2;\n                            continue;\n                        }\n                    }\n                }\n\n                if (sb == null) {\n                    sb = new StringBuilder();\n                    sb.append(s, 0, i);\n                }\n\n                if (c < 0x80) {\n                    if (c == ' ' && (t == Type.QUERY_PARAM)) {\n                        sb.append('+');\n                    } else {\n                        appendPercentEncodedOctet(sb, c);\n                    }\n                } else {\n                    appendUTF8EncodedCharacter(sb, c);\n                }\n            }\n        }\n\n        return (sb == null) ? s : sb.toString();\n    }\n    private final static char[] HEX_DIGITS = {\n        '0', '1', '2', '3', '4', '5', '6', '7',\n        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n    };\n\n    private static void appendPercentEncodedOctet(StringBuilder sb, int b) {\n        sb.append('%');\n        sb.append(HEX_DIGITS[b >> 4]);\n        sb.append(HEX_DIGITS[b & 0x0F]);\n    }\n\n    private static void appendUTF8EncodedCharacter(StringBuilder sb, char c) {\n        final ByteBuffer bb = UTF_8_CHARSET.encode(\"\" + c);\n\n        while (bb.hasRemaining()) {\n            appendPercentEncodedOctet(sb, bb.get() & 0xFF);\n        }\n    }\n    private static final String[] SCHEME = {\"0-9\", \"A-Z\", \"a-z\", \"+\", \"-\", \".\"};\n    private static final String[] UNRESERVED = {\"0-9\", \"A-Z\", \"a-z\", \"-\", \".\", \"_\", \"~\"};\n    private static final String[] SUB_DELIMS = {\"!\", \"$\", \"&\", \"'\", \"(\", \")\", \"*\", \"+\", \",\", \";\", \"=\"};\n    private static final boolean[][] ENCODING_TABLES = creatingEncodingTables();\n\n    private static boolean[][] creatingEncodingTables() {\n        boolean[][] tables = new boolean[Type.values().length][];\n\n        List<String> l = new ArrayList<>(Arrays.asList(SCHEME));\n        tables[Type.SCHEME.ordinal()] = creatingEncodingTable(l);\n\n        l.clear();\n\n        l.addAll(Arrays.asList(UNRESERVED));\n        tables[Type.UNRESERVED.ordinal()] = creatingEncodingTable(l);\n\n        l.addAll(Arrays.asList(SUB_DELIMS));\n\n        tables[Type.HOST.ordinal()] = creatingEncodingTable(l);\n\n        tables[Type.PORT.ordinal()] = creatingEncodingTable(Collections.singletonList(\"0-9\"));\n\n        l.add(\":\");\n\n        tables[Type.USER_INFO.ordinal()] = creatingEncodingTable(l);\n\n        l.add(\"@\");\n\n        tables[Type.AUTHORITY.ordinal()] = creatingEncodingTable(l);\n\n        tables[Type.PATH_SEGMENT.ordinal()] = creatingEncodingTable(l);\n        tables[Type.PATH_SEGMENT.ordinal()][';'] = false;\n\n        tables[Type.MATRIX_PARAM.ordinal()] = tables[Type.PATH_SEGMENT.ordinal()].clone();\n        tables[Type.MATRIX_PARAM.ordinal()]['='] = false;\n\n        l.add(\"/\");\n\n        tables[Type.PATH.ordinal()] = creatingEncodingTable(l);\n\n        l.add(\"?\");\n\n        tables[Type.QUERY.ordinal()] = creatingEncodingTable(l);\n\n        tables[Type.FRAGMENT.ordinal()] = tables[Type.QUERY.ordinal()];\n\n        tables[Type.QUERY_PARAM.ordinal()] = creatingEncodingTable(l);\n        tables[Type.QUERY_PARAM.ordinal()]['='] = false;\n        tables[Type.QUERY_PARAM.ordinal()]['+'] = false;\n        tables[Type.QUERY_PARAM.ordinal()]['&'] = false;\n\n        return tables;\n    }\n\n    private static boolean[] creatingEncodingTable(List<String> allowed) {\n        boolean[] table = new boolean[0x80];\n        for (String range : allowed) {\n            if (range.length() == 1) {\n                table[range.charAt(0)] = true;\n            } else if (range.length() == 3 && range.charAt(1) == '-') {\n                for (int i = range.charAt(0); i <= range.charAt(2); i++) {\n                    table[i] = true;\n                }\n            }\n        }\n\n        return table;\n    }\n    private static final Charset UTF_8_CHARSET = StandardCharsets.UTF_8;\n\n    /**\n     * Decodes characters of a string that are percent-encoded octets using \n     * UTF-8 decoding (if needed).\n     * <p>\n     * It is assumed that the string is valid according to an (unspecified) URI \n     * component type. If a sequence of contiguous percent-encoded octets is \n     * not a valid UTF-8 character then the octets are replaced with '\\uFFFD'.\n     * <p>\n     * If the URI component is of type HOST then any \"%\" found between \"[]\" is \n     * left alone. It is an IPv6 literal with a scope_id.\n     * <p>\n     * If the URI component is of type QUERY_PARAM then any \"+\" is decoded as\n     * as ' '.\n     * <p>\n     * @param s the string to be decoded.\n     * @param t the URI component type, may be null.\n     * @return the decoded string.\n     * @throws IllegalArgumentException if a malformed percent-encoded octet is\n     *         detected\n     */\n    public static String decode(String s, Type t) {\n        if (s == null) {\n            throw new IllegalArgumentException();\n        }\n\n        final int n = s.length();\n        if (n == 0) {\n            return s;\n        }\n\n        // If there are no percent-escaped octets\n        if (s.indexOf('%') < 0) {\n            // If there are no '+' characters for query param\n            if (t == Type.QUERY_PARAM) {\n                if (s.indexOf('+') < 0) {\n                    return s;\n                }\n            } else {\n                return s;\n            }\n        } else {\n            // Malformed percent-escaped octet at the end\n            if (n < 2) // TODO localize\n            {\n                throw new IllegalArgumentException(\"Malformed percent-encoded octet at index 1\");\n            }\n\n            // Malformed percent-escaped octet at the end\n            if (s.charAt(n - 2) == '%') // TODO localize\n            {\n                throw new IllegalArgumentException(\"Malformed percent-encoded octet at index \" + (n - 2));\n            }\n        }\n\n        if (t == null)\n            return decode(s, n);\n        \n        switch (t) {\n            case HOST :\n                return decodeHost(s, n);\n            case QUERY_PARAM :\n                return decodeQueryParam(s, n);\n            default :\n                return decode(s, n);\n        }\n    }\n\n    /**\n     * Decode the query component of a URI.\n     * \n     * @param u the URI.\n     * @param decode true if the query parameters of the query component\n     *        should be in decoded form.\n     * @return the multivalued map of query parameters.\n     */\n    public static Map<String, String> decodeQuery(URI u, boolean decode) {\n        return decodeQuery(u.getRawQuery(), decode);\n    }\n\n    /**\n     * Decode the query component of a URI.\n     * \n     * @param q the query component in encoded form.\n     * @param decode true of the query parameters of the query component\n     *        should be in decoded form.\n     * @return the multivalued map of query parameters.\n     */\n    public static Map<String, String> decodeQuery(String q, boolean decode) {\n        Map<String, String> queryParameters = new HashMap<>();\n\n        if (q == null || q.length() == 0) {\n            return queryParameters;\n        }\n\n        int s = 0, e;\n        do {\n            e = q.indexOf('&', s);\n\n            if (e == -1) {\n                decodeQueryParam(queryParameters, q.substring(s), decode);\n            } else if (e > s) {\n                decodeQueryParam(queryParameters, q.substring(s, e), decode);\n            }\n            s = e + 1;\n        } while (s > 0 && s < q.length());\n\n        return queryParameters;\n    }\n\n    private static void decodeQueryParam(Map<String, String> params,\n            String param, boolean decode) {\n        try {\n            int equals = param.indexOf('=');\n            if (equals > 0) {\n                params.put(\n                        URLDecoder.decode(param.substring(0, equals), \"UTF-8\"),\n                        (decode) ? URLDecoder.decode(param.substring(equals + 1), \"UTF-8\") : param.substring(equals + 1));\n            } else if (equals == 0) {\n                // no key declared, ignore\n            } else if (param.length() > 0) {\n                params.put(\n                        URLDecoder.decode(param, \"UTF-8\"),\n                        \"\");\n            }\n        } catch (UnsupportedEncodingException ex) {\n            // This should never occur\n            throw new IllegalArgumentException(ex);\n        }\n    }\n\n    private static final class PathSegmentImpl  {\n\n        private static final PathSegmentImpl EMPTY_PATH_SEGMENT = new PathSegmentImpl(\"\", false);\n        private final String path;\n        private final Map<String, String> matrixParameters;\n\n        PathSegmentImpl(String path, boolean decode) {\n            this(path, decode, new HashMap<String, String> ());\n        }\n\n        PathSegmentImpl(String path, boolean decode, Map<String, String> matrixParameters) {\n            this.path = (decode) ? UriComponent.decode(path, UriComponent.Type.PATH_SEGMENT) : path;\n            this.matrixParameters = matrixParameters;\n        }\n\n        public String getPath() {\n            return path;\n        }\n\n        public Map<String, String> getMatrixParameters() {\n            return matrixParameters;\n        }\n    }\n\n    /**\n     * Decode the path component of a URI as path segments.\n     *\n     * @param u the URI. If the path component is an absolute path component\n     *        then the leading '/' is ignored and is not considered a delimiator\n     *        of a path segment.\n     * @param decode true if the path segments of the path component\n     *        should be in decoded form.\n     * @return the list of path segments.\n     */\n    public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n        String rawPath = u.getRawPath();\n        if (rawPath != null && rawPath.length() > 0 && rawPath.charAt(0) == '/') {\n            rawPath = rawPath.substring(1);\n        }\n        return decodePath(rawPath, decode);\n    }\n\n    /**\n     * Decode the path component of a URI as path segments.\n     * <p>\n     * Any '/' character in the path is considered to be a deliminator\n     * between two path segments. Thus if the path is '/' then the path segment\n     * list will contain two empty path segments. If the path is \"//\" then\n     * the path segment list will contain three empty path segments. If the path\n     * is \"/a/\" the path segment list will consist of the following path\n     * segments in order: \"\", \"a\" and \"\".\n     *\n     * @param path the path component in encoded form.\n     * @param decode true if the path segments of the path component\n     *        should be in decoded form.\n     * @return the list of path segments.\n     */\n    public static List<PathSegmentImpl> decodePath(String path, boolean decode) {\n        List<PathSegmentImpl> segments = new LinkedList<>();\n\n        if (path == null) {\n            return segments;\n        }\n\n        int s;\n        int e = -1;\n        do {\n            s = e + 1;\n            e = path.indexOf('/', s);\n\n            if (e > s) {\n                decodePathSegment(segments, path.substring(s, e), decode);\n            } else if (e == s) {\n                segments.add(PathSegmentImpl.EMPTY_PATH_SEGMENT);\n            }\n        } while (e != -1);\n        if (s < path.length()) {\n            decodePathSegment(segments, path.substring(s), decode);\n        } else {\n            segments.add(PathSegmentImpl.EMPTY_PATH_SEGMENT);\n        }\n        return segments;\n    }\n\n    public static void decodePathSegment(List<PathSegmentImpl> segments, String segment, boolean decode) {\n        int colon = segment.indexOf(';');\n        if (colon != -1) {\n            segments.add(new PathSegmentImpl(\n                    (colon == 0) ? \"\" : segment.substring(0, colon),\n                    decode,\n                    decodeMatrix(segment, decode)));\n        } else {\n            segments.add(new PathSegmentImpl(\n                    segment,\n                    decode));\n        }\n    }\n\n    /**\n     * Decode the matrix component of a URI path segment.\n     *\n     * @param pathSegment the path segment component in encoded form.\n     * @param decode true if the matrix parameters of the path segment component\n     *        should be in decoded form.\n     * @return the multivalued map of matrix parameters.\n     */\n    public static Map<String, String> decodeMatrix(String pathSegment, boolean decode) {\n        Map<String, String> matrixMap = new HashMap<>();\n\n        // Skip over path segment\n        int s = pathSegment.indexOf(';') + 1;\n        if (s == 0 || s == pathSegment.length()) {\n            return matrixMap;\n        }\n\n        int e;\n        do {\n            e = pathSegment.indexOf(';', s);\n\n            if (e == -1) {\n                decodeMatrixParam(matrixMap, pathSegment.substring(s), decode);\n            } else if (e > s) {\n                decodeMatrixParam(matrixMap, pathSegment.substring(s, e), decode);\n            }\n            s = e + 1;\n        } while (s > 0 && s < pathSegment.length());\n\n        return matrixMap;\n    }\n\n    private static void decodeMatrixParam(Map<String, String> params,\n            String param, boolean decode) {\n        int equals = param.indexOf('=');\n        if (equals > 0) {\n            params.put(\n                    UriComponent.decode(param.substring(0, equals), UriComponent.Type.MATRIX_PARAM),\n                    (decode) ? UriComponent.decode(param.substring(equals + 1), UriComponent.Type.MATRIX_PARAM) : param.substring(equals + 1));\n        } else if (equals == 0) {\n            // no key declared, ignore\n        } else if (param.length() > 0) {\n            params.put(\n                    UriComponent.decode(param, UriComponent.Type.MATRIX_PARAM),\n                    \"\");\n        }\n    }\n\n    private static String decode(String s, int n) {\n        final StringBuilder sb = new StringBuilder(n);\n        ByteBuffer bb = null;\n\n        for (int i = 0; i < n;) {\n            final char c = s.charAt(i++);\n            if (c != '%') {\n                sb.append(c);\n            } else {\n                bb = decodePercentEncodedOctets(s, i, bb);\n                i = decodeOctets(i, bb, sb);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    private static String decodeQueryParam(String s, int n) {\n        final StringBuilder sb = new StringBuilder(n);\n        ByteBuffer bb = null;\n\n        for (int i = 0; i < n;) {\n            final char c = s.charAt(i++);\n            if (c != '%') {\n                if (c != '+')\n                    sb.append(c);\n                else\n                    sb.append(' ');\n            } else {\n                bb = decodePercentEncodedOctets(s, i, bb);\n                i = decodeOctets(i, bb, sb);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    private static String decodeHost(String s, int n) {\n        final StringBuilder sb = new StringBuilder(n);\n        ByteBuffer bb = null;\n\n        boolean betweenBrackets = false;\n        for (int i = 0; i < n;) {\n            final char c = s.charAt(i++);\n            if (c == '[') {\n                betweenBrackets = true;\n            } else if (betweenBrackets && c == ']') {\n                betweenBrackets = false;\n            }\n\n            if (c != '%' || betweenBrackets) {\n                sb.append(c);\n            } else {\n                bb = decodePercentEncodedOctets(s, i, bb);\n                i = decodeOctets(i, bb, sb);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * Decode a contigious sequence of percent encoded octets.\n     * <p>\n     * Assumes the index, i, starts that the first hex digit of the first\n     * percent-encoded octet.\n     */\n    private static ByteBuffer decodePercentEncodedOctets(String s, int i, ByteBuffer bb) {\n        if (bb == null)\n            bb = ByteBuffer.allocate(1);\n        else\n            ((Buffer)bb).clear();\n\n        while (true) {\n            // Decode the hex digits\n            bb.put((byte) (decodeHex(s, i++) << 4 | decodeHex(s, i++)));\n\n            // Finish if at the end of the string\n            if (i == s.length()) {\n                break;\n            }\n\n            // Finish if no more percent-encoded octets follow\n            if (s.charAt(i++) != '%') {\n                break;\n            }\n\n            // Check if the byte buffer needs to be increased in size\n            if (bb.position() == bb.capacity()) {\n                ((Buffer)bb).flip();\n                // Create a new byte buffer with the maximum number of possible\n                // octets, hence resize should only occur once\n                ByteBuffer bb_new = ByteBuffer.allocate(s.length() / 3);\n                bb_new.put(bb);\n                bb = bb_new;\n            }\n        }\n\n        ((Buffer)bb).flip();\n        return bb;\n    }\n\n    /**\n     * Decodes octets to characters using the UTF-8 decoding and appends\n     * the characters to a StringBuffer.\n     * @return the index to the next unchecked character in the string to decode\n     */\n    private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n        // If there is only one octet and is an ASCII character\n        if (bb.limit() == 1 && (bb.get(0) & 0xFF) < 0x80) {\n            // Octet can be appended directly\n            sb.append((char) bb.get(0));\n            return i + 2;\n        } else {\n            // \n            CharBuffer cb = UTF_8_CHARSET.decode(bb);\n            sb.append(cb);\n            return i + bb.limit() * 3 - 1;\n        }\n    }\n\n    private static int decodeHex(String s, int i) {\n        final int v = decodeHex(s.charAt(i));\n        if (v == -1) // TODO localize\n        {\n            throw new IllegalArgumentException(\"Malformed percent-encoded octet at index \" + i +\n                    \", invalid hexadecimal digit '\" + s.charAt(i) + \"'\");\n        }\n        return v;\n    }\n    private static final int[] HEX_TABLE = createHexTable();\n\n    private static int[] createHexTable() {\n        int[] table = new int[0x80];\n        Arrays.fill(table, -1);\n\n        for (char c = '0'; c <= '9'; c++) {\n            table[c] = c - '0';\n        }\n        for (char c = 'A'; c <= 'F'; c++) {\n            table[c] = c - 'A' + 10;\n        }\n        for (char c = 'a'; c <= 'f'; c++) {\n            table[c] = c - 'a' + 10;\n        }\n        return table;\n    }\n\n    private static int decodeHex(char c) {\n        return (c < 128) ? HEX_TABLE[c] : -1;\n    }\n\n    private static boolean isHexCharacter(char c) {\n        return c < 128 && HEX_TABLE[c] != -1;\n    }\n}",
      "file_name": "UriComponent.java",
      "human_label": "Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.",
      "level": "class_runnable",
      "lineno": "799",
      "name": "decodeOctets",
      "oracle_context": "{ \"apis\" : \"[limit, get, append, decode]\", \"classes\" : \"[CharBuffer]\", \"vars\" : \"[UTF_8_CHARSET]\" }",
      "package": "org.atmosphere.util.uri",
      "project": "atmosphere-atmosphere-2.7.x"
    },
    {
      "_id": "636766aa1a6d9265ec0175ce",
      "all_context": "{ \"class_level\" : \"import com.alibaba.fastjson2.JSONException;\\nMethodWriter mv;\\nSymbolTable symbolTable;\\nint accessFlags;\\nint nameIndex;\\nString name;\\nint descriptorIndex;\\nString descriptor;\\nint maxStack;\\nint maxLocals;\\nByteVector code;\\nint stackMapTableNumberOfEntries;\\nByteVector stackMapTableEntries;\\nLabel firstBasicBlock;\\nLabel lastBasicBlock;\\nLabel currentBasicBlock;\\nint[] previousFrame;\\nint[] currentFrame;\\nboolean hasAsmInstructions;\\nint lastBytecodeOffset;\\nMethodWriter(SymbolTable symbolTable,int access,String name,String descriptor,int codeInitCapacity);\\nvisitInsn(int opcode);\\nvisitIntInsn(int opcode,int operand);\\nvisitVarInsn(int opcode,int var);\\nvisitTypeInsn(int opcode,String type);\\nvisitFieldInsn(int opcode,String owner,String name,String descriptor);\\nvisitMethodInsn(int opcode,String owner,String name,String descriptor,boolean isInterface);\\nvisitJumpInsn(int opcode,Label label);\\nvisitLabel(Label label);\\nvisitLdcInsn(String value);\\nvisitLdcInsn(Class value);\\nvisitLdcInsn(int value);\\nvisitLdcInsn(long value);\\nvisitIincInsn(int var,int increment);\\nvisitLookupSwitchInsn(Label dflt,int[] keys,Label[] labels);\\nvisitSwitchInsn(Label dflt,Label[] labels);\\nvisitMaxs(int maxStack,int maxLocals);\\nendCurrentBasicBlockWithNoSuccessor();\\nvisitFrameStart(int offset,int numLocal,int numStack);\\nvisitAbstractType(int frameIndex,int abstractType);\\nvisitFrameEnd();\\nputFrame();\\nputAbstractTypes(int start,int end);\\ncomputeMethodInfoSize();\\nputMethodInfo(ByteVector output);\\naddSuccessorToCurrentBasicBlock(Label successor);\\n\", \"repo_level\" : \"public interface JSONException { }\\n\" }",
      "class_name": "MethodWriter",
      "code": "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n  int frameLength=3 + numLocal + numStack;\n  if (currentFrame == null || currentFrame.length < frameLength) {\n    currentFrame=new int[frameLength];\n  }\n  currentFrame[0]=offset;\n  currentFrame[1]=numLocal;\n  currentFrame[2]=numStack;\n  return 3;\n}\n",
      "docstring": "/** \n * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}.\n * @param offset   the bytecode offset of the instruction to which the frame corresponds.\n * @param numLocal the number of local variables in the frame.\n * @param numStack the number of stack elements in the frame.\n * @return the index of the next element to be written in this frame.\n */\n",
      "end_lineno": "651",
      "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage com.alibaba.fastjson2.internal.asm;\n\nimport com.alibaba.fastjson2.JSONException;\n\n/**\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic final class MethodWriter {\n    protected MethodWriter mv;\n\n    /**\n     * Where the constants used in this MethodWriter must be stored.\n     */\n    private final SymbolTable symbolTable;\n\n    private final int accessFlags;\n\n    /**\n     * The name_index field of the method_info JVMS structure.\n     */\n    private final int nameIndex;\n\n    /**\n     * The name of this method.\n     */\n    private final String name;\n\n    /**\n     * The descriptor_index field of the method_info JVMS structure.\n     */\n    private final int descriptorIndex;\n\n    /**\n     * The descriptor of this method.\n     */\n    private final String descriptor;\n\n    // Code attribute fields and sub attributes:\n\n    /**\n     * The max_stack field of the Code attribute.\n     */\n    private int maxStack;\n\n    /**\n     * The max_locals field of the Code attribute.\n     */\n    private int maxLocals;\n\n    /**\n     * The 'code' field of the Code attribute.\n     */\n    private final ByteVector code;\n\n    /**\n     * The number_of_entries field of the StackMapTable code attribute.\n     */\n    int stackMapTableNumberOfEntries;\n\n    /**\n     * The 'entries' array of the StackMapTable code attribute.\n     */\n    private ByteVector stackMapTableEntries;\n    /**\n     * The first basic block of the method. The next ones (in bytecode offset order) can be accessed\n     * with the {@link Label#nextBasicBlock} field.\n     */\n    private Label firstBasicBlock;\n\n    /**\n     * The last basic block of the method (in bytecode offset order). This field is updated each time\n     * a basic block is encountered, and is used to append it at the end of the basic block list.\n     */\n    private Label lastBasicBlock;\n\n    private Label currentBasicBlock;\n\n    /**\n     * The last frame that was written in {@link #stackMapTableEntries}. This field has the same\n     * format as {@link #currentFrame}.\n     */\n    private int[] previousFrame;\n    private int[] currentFrame;\n\n    boolean hasAsmInstructions;\n\n    /**\n     * The start offset of the last visited instruction. Used to set the offset field of type\n     * annotations of type 'offset_target' (see <a\n     * href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.1\">JVMS\n     * 4.7.20.1</a>).\n     */\n    private int lastBytecodeOffset;\n\n    // -----------------------------------------------------------------------------------------------\n    // Constructor and accessors\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Constructs a new {@link MethodWriter}.\n     *\n     * @param symbolTable where the constants used in this AnnotationWriter must be stored.\n     * @param access      the method's access flags (see {@link Opcodes}).\n     * @param name        the method's name.\n     * @param descriptor  the method's descriptor (see {@link Type}).\n     */\n    MethodWriter(\n            SymbolTable symbolTable,\n            int access,\n            String name,\n            String descriptor,\n            int codeInitCapacity\n    ) {\n        this.symbolTable = symbolTable;\n        this.accessFlags = \"<init>\".equals(name) ? access | Constants.ACC_CONSTRUCTOR : access;\n        this.nameIndex = symbolTable.addConstantUtf8(name);\n        this.name = name;\n        this.descriptorIndex = symbolTable.addConstantUtf8(descriptor);\n        this.descriptor = descriptor;\n        this.code = new ByteVector(codeInitCapacity);\n\n        // Update maxLocals and currentLocals.\n        int argumentsSize = Type.getArgumentsAndReturnSizes(descriptor) >> 2;\n        if ((access & Opcodes.ACC_STATIC) != 0) {\n            --argumentsSize;\n        }\n        maxLocals = argumentsSize;\n        // Create and visit the label for the first basic block.\n        firstBasicBlock = new Label();\n        visitLabel(firstBasicBlock);\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Implementation of the MethodVisitor abstract class\n    // -----------------------------------------------------------------------------------------------\n\n    public void visitInsn(final int opcode) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        code.putByte(opcode);\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(opcode, 0, null, null);\n            if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN) || opcode == Opcodes.ATHROW) {\n                endCurrentBasicBlockWithNoSuccessor();\n            }\n        }\n    }\n\n    public void visitIntInsn(final int opcode, final int operand) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        if (opcode == Opcodes.SIPUSH) {\n            code.put12(opcode, operand);\n        } else { // BIPUSH or NEWARRAY\n            code.put11(opcode, operand);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(opcode, operand, null, null);\n        }\n    }\n\n    public void visitVarInsn(final int opcode, final int var) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        if (var < 4 && opcode != Opcodes.RET) {\n            int optimizedOpcode;\n            if (opcode < Opcodes.ISTORE) {\n                optimizedOpcode = Constants.ILOAD_0 + ((opcode - Opcodes.ILOAD) << 2) + var;\n            } else {\n                optimizedOpcode = Constants.ISTORE_0 + ((opcode - Opcodes.ISTORE) << 2) + var;\n            }\n            code.putByte(optimizedOpcode);\n        } else if (var >= 256) {\n            code.putByte(Constants.WIDE).put12(opcode, var);\n        } else {\n            code.put11(opcode, var);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(opcode, var, null, null);\n        }\n\n        int currentMaxLocals;\n        if (opcode == Opcodes.LLOAD\n                || opcode == Opcodes.DLOAD\n                || opcode == Opcodes.LSTORE\n                || opcode == Opcodes.DSTORE) {\n            currentMaxLocals = var + 2;\n        } else {\n            currentMaxLocals = var + 1;\n        }\n        if (currentMaxLocals > maxLocals) {\n            maxLocals = currentMaxLocals;\n        }\n    }\n\n    public void visitTypeInsn(final int opcode, final String type) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol typeSymbol = symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, type);\n        code.put12(opcode, typeSymbol.index);\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(opcode, lastBytecodeOffset, typeSymbol, symbolTable);\n        }\n    }\n\n    public void visitFieldInsn(\n            final int opcode, final String owner, final String name, final String descriptor) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol fieldrefSymbol = symbolTable.addConstantMemberReference(/*CONSTANT_FIELDREF_TAG*/ 9, owner, name, descriptor);\n        code.put12(opcode, fieldrefSymbol.index);\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(opcode, 0, fieldrefSymbol, symbolTable);\n        }\n    }\n\n    public void visitMethodInsn(\n            final int opcode,\n            final String owner,\n            final String name,\n            final String descriptor,\n            final boolean isInterface) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol methodrefSymbol = symbolTable.addConstantMemberReference(\n                isInterface ? /*CONSTANT_INTERFACE_METHODREF_TAG*/ 11 : /*CONSTANT_METHODREF_TAG*/ 10,\n                owner,\n                name,\n                descriptor\n        );\n        if (opcode == Opcodes.INVOKEINTERFACE) {\n            code.put12(Opcodes.INVOKEINTERFACE, methodrefSymbol.index)\n                    .put11(methodrefSymbol.getArgumentsAndReturnSizes() >> 2, 0);\n        } else {\n            code.put12(opcode, methodrefSymbol.index);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(opcode, 0, methodrefSymbol, symbolTable);\n        }\n    }\n\n    public void visitJumpInsn(final int opcode, final Label label) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        // Compute the 'base' opcode, i.e. GOTO or JSR if opcode is GOTO_W or JSR_W, otherwise opcode.\n        int baseOpcode =\n                opcode >= Constants.GOTO_W ? opcode - Constants.WIDE_JUMP_OPCODE_DELTA : opcode;\n        boolean nextInsnIsJumpTarget = false;\n        if ((label.flags & Label.FLAG_RESOLVED) != 0\n                && label.bytecodeOffset - code.length < Short.MIN_VALUE) {\n            throw new JSONException(\"not supported\");\n        } else if (baseOpcode != opcode) {\n            // Case of a GOTO_W or JSR_W specified by the user (normally ClassReader when used to remove\n            // ASM specific instructions). In this case we keep the original instruction.\n            code.putByte(opcode);\n            label.put(code, code.length - 1, true);\n        } else {\n            // Case of a jump with an offset >= -32768, or of a jump with an unknown offset. In these\n            // cases we store the offset in 2 bytes (which will be increased via a ClassReader ->\n            // ClassWriter round trip if it turns out that 2 bytes are not sufficient).\n            code.putByte(baseOpcode);\n            label.put(code, code.length - 1, false);\n        }\n\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            Label nextBasicBlock = null;\n            currentBasicBlock.frame.execute(baseOpcode, 0, null, null);\n            // Record the fact that 'label' is the target of a jump instruction.\n            label.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\n            // Add 'label' as a successor of the current basic block.\n            addSuccessorToCurrentBasicBlock(label);\n            if (baseOpcode != Opcodes.GOTO) {\n                // The next instruction starts a new basic block (except for GOTO: by default the code\n                // following a goto is unreachable - unless there is an explicit label for it - and we\n                // should not compute stack frame types for its instructions).\n                nextBasicBlock = new Label();\n            }\n\n            // If the next instruction starts a new basic block, call visitLabel to add the label of this\n            // instruction as a successor of the current block, and to start a new basic block.\n            if (nextBasicBlock != null) {\n                if (nextInsnIsJumpTarget) {\n                    nextBasicBlock.flags |= Label.FLAG_JUMP_TARGET;\n                }\n                visitLabel(nextBasicBlock);\n            }\n            if (baseOpcode == Opcodes.GOTO) {\n                endCurrentBasicBlockWithNoSuccessor();\n            }\n        }\n    }\n\n    public void visitLabel(final Label label) {\n        // Resolve the forward references to this label, if any.\n        hasAsmInstructions |= label.resolve(code.data, code.length);\n        // visitLabel starts a new basic block (except for debug only labels), so we need to update the\n        // previous and current block references and list of successors.\n        if ((label.flags & Label.FLAG_DEBUG_ONLY) != 0) {\n            return;\n        }\n\n        if (currentBasicBlock != null) {\n            if (label.bytecodeOffset == currentBasicBlock.bytecodeOffset) {\n                // We use {@link Label#getCanonicalInstance} to store the state of a basic block in only\n                // one place, but this does not work for labels which have not been visited yet.\n                // Therefore, when we detect here two labels having the same bytecode offset, we need to\n                // - consolidate the state scattered in these two instances into the canonical instance:\n                currentBasicBlock.flags |= (label.flags & Label.FLAG_JUMP_TARGET);\n                // - make sure the two instances share the same Frame instance (the implementation of\n                // {@link Label#getCanonicalInstance} relies on this property; here label.frame should be\n                // null):\n                label.frame = currentBasicBlock.frame;\n                // - and make sure to NOT assign 'label' into 'currentBasicBlock' or 'lastBasicBlock', so\n                // that they still refer to the canonical instance for this bytecode offset.\n                return;\n            }\n            // End the current basic block (with one new successor).\n            addSuccessorToCurrentBasicBlock(label);\n        }\n        // Append 'label' at the end of the basic block list.\n        if (lastBasicBlock != null) {\n            if (label.bytecodeOffset == lastBasicBlock.bytecodeOffset) {\n                // Same comment as above.\n                lastBasicBlock.flags |= (label.flags & Label.FLAG_JUMP_TARGET);\n                // Here label.frame should be null.\n                label.frame = lastBasicBlock.frame;\n                currentBasicBlock = lastBasicBlock;\n                return;\n            }\n            lastBasicBlock.nextBasicBlock = label;\n        }\n        lastBasicBlock = label;\n        // Make it the new current basic block.\n        currentBasicBlock = label;\n        // Here label.frame should be null.\n        label.frame = new Frame(label);\n    }\n//\n//  public void visitLdcInsn(final Object value) {\n//    lastBytecodeOffset = code.length;\n//    // Add the instruction to the bytecode of the method.\n//    Symbol constantSymbol = symbolTable.addConstant(value);\n//    int constantIndex = constantSymbol.index;\n//    char firstDescriptorChar;\n//    boolean isLongOrDouble =\n//            constantSymbol.tag == Symbol.CONSTANT_LONG_TAG\n//                    || constantSymbol.tag == Symbol.CONSTANT_DOUBLE_TAG\n//                    || (constantSymbol.tag == Symbol.CONSTANT_DYNAMIC_TAG\n//                    && ((firstDescriptorChar = constantSymbol.value.charAt(0)) == 'J'\n//                    || firstDescriptorChar == 'D'));\n//    if (isLongOrDouble) {\n//      code.put12(Constants.LDC2_W, constantIndex);\n//    } else if (constantIndex >= 256) {\n//      code.put12(Constants.LDC_W, constantIndex);\n//    } else {\n//      code.put11(Opcodes.LDC, constantIndex);\n//    }\n//    // If needed, update the maximum stack size and number of locals, and stack map frames.\n//    if (currentBasicBlock != null) {\n//      currentBasicBlock.frame.execute(Opcodes.LDC, 0, constantSymbol, symbolTable);\n//    }\n//  }\n\n    public void visitLdcInsn(final String value) {\n        final int CONSTANT_STRING_TAG = 8;\n\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol constantSymbol = symbolTable.addConstantUtf8Reference(CONSTANT_STRING_TAG, value);\n        int constantIndex = constantSymbol.index;\n        if (constantIndex >= 256) {\n            code.put12(Constants.LDC_W, constantIndex);\n        } else {\n            code.put11(Opcodes.LDC, constantIndex);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(Opcodes.LDC, 0, constantSymbol, symbolTable);\n        }\n    }\n\n    public void visitLdcInsn(Class value) {\n        // getTypeInternal(typeDescriptor, 0, typeDescriptor.length())\n        String desc = ASMUtils.desc(value);\n        Type type = Type.getTypeInternal(desc, 0, desc.length());\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol constantSymbol;\n//        int typeSort = type.getSort();\n        int typeSort = type.sort == Type.INTERNAL ? Type.OBJECT : type.sort;\n        if (typeSort == Type.OBJECT) {\n            // type.valueBuffer.substring(type.valueBegin, type.valueEnd)\n            constantSymbol = symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, type.valueBuffer.substring(type.valueBegin, type.valueEnd));\n        } else { // type is a primitive or array type.\n            constantSymbol = symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, type.getDescriptor());\n        }\n        int constantIndex = constantSymbol.index;\n        if (constantIndex >= 256) {\n            code.put12(Constants.LDC_W, constantIndex);\n        } else {\n            code.put11(Opcodes.LDC, constantIndex);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(Opcodes.LDC, 0, constantSymbol, symbolTable);\n        }\n    }\n\n    public void visitLdcInsn(final int value) {\n        final int CONSTANT_INTEGER_TAG = 3;\n\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol constantSymbol = symbolTable.addConstantIntegerOrFloat(CONSTANT_INTEGER_TAG, value);\n        int constantIndex = constantSymbol.index;\n        if (constantIndex >= 256) {\n            code.put12(Constants.LDC_W, constantIndex);\n        } else {\n            code.put11(Opcodes.LDC, constantIndex);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(Opcodes.LDC, 0, constantSymbol, symbolTable);\n        }\n    }\n\n    public void visitLdcInsn(final long value) {\n        final int CONSTANT_LONG_TAG = 5;\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol constantSymbol = symbolTable.addConstantLongOrDouble(CONSTANT_LONG_TAG, value);\n        int constantIndex = constantSymbol.index;\n        code.put12(Constants.LDC2_W, constantIndex);\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(Opcodes.LDC, 0, constantSymbol, symbolTable);\n        }\n    }\n\n    public void visitIincInsn(final int var, final int increment) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        if ((var > 255) || (increment > 127) || (increment < -128)) {\n            code.putByte(Constants.WIDE).put12(Opcodes.IINC, var).putShort(increment);\n        } else {\n            code.putByte(Opcodes.IINC).put11(var, increment);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(Opcodes.IINC, var, null, null);\n        }\n    }\n\n    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        code.putByte(Opcodes.LOOKUPSWITCH).putByteArray(null, 0, (4 - code.length % 4) % 4);\n        dflt.put(code, lastBytecodeOffset, true);\n        code.putInt(labels.length);\n        for (int i = 0; i < labels.length; ++i) {\n            code.putInt(keys[i]);\n            labels[i].put(code, lastBytecodeOffset, true);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        visitSwitchInsn(dflt, labels);\n    }\n\n    private void visitSwitchInsn(final Label dflt, final Label[] labels) {\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);\n            // Add all the labels as successors of the current basic block.\n            addSuccessorToCurrentBasicBlock(dflt);\n            dflt.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\n            for (Label label : labels) {\n                addSuccessorToCurrentBasicBlock(label);\n                label.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\n            }\n            // End the current basic block.\n            endCurrentBasicBlockWithNoSuccessor();\n        }\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n        /**\n         * Computes all the stack map frames of the method, from scratch.\n         */\n        // computeAllFrames();\n        // Create and visit the first (implicit) frame.\n        Frame firstFrame = firstBasicBlock.frame;\n        firstFrame.setInputFrameFromDescriptor(symbolTable, accessFlags, descriptor, this.maxLocals);\n        firstFrame.accept(this);\n\n        // Fix point algorithm: add the first basic block to a list of blocks to process (i.e. blocks\n        // whose stack map frame has changed) and, while there are blocks to process, remove one from\n        // the list and update the stack map frames of its successor blocks in the control flow graph\n        // (which might change them, in which case these blocks must be processed too, and are thus\n        // added to the list of blocks to process). Also compute the maximum stack size of the method,\n        // as a by-product.\n        Label listOfBlocksToProcess = firstBasicBlock;\n        listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;\n        int maxStackSize = 0;\n        while (listOfBlocksToProcess != Label.EMPTY_LIST) {\n            // Remove a basic block from the list of blocks to process.\n            Label basicBlock = listOfBlocksToProcess;\n            listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;\n            basicBlock.nextListElement = null;\n            // By definition, basicBlock is reachable.\n            basicBlock.flags |= Label.FLAG_REACHABLE;\n            // Update the (absolute) maximum stack size.\n            int maxBlockStackSize = basicBlock.frame.inputStack.length + basicBlock.outputStackMax;\n            if (maxBlockStackSize > maxStackSize) {\n                maxStackSize = maxBlockStackSize;\n            }\n            // Update the successor blocks of basicBlock in the control flow graph.\n            Edge outgoingEdge = basicBlock.outgoingEdges;\n            while (outgoingEdge != null) {\n                Label successorBlock = outgoingEdge.successor.getCanonicalInstance();\n                boolean successorBlockChanged =\n                        basicBlock.frame.merge(symbolTable, successorBlock.frame);\n                if (successorBlockChanged && successorBlock.nextListElement == null) {\n                    // If successorBlock has changed it must be processed. Thus, if it is not already in the\n                    // list of blocks to process, add it to this list.\n                    successorBlock.nextListElement = listOfBlocksToProcess;\n                    listOfBlocksToProcess = successorBlock;\n                }\n                outgoingEdge = outgoingEdge.nextEdge;\n            }\n        }\n\n        // Loop over all the basic blocks and visit the stack map frames that must be stored in the\n        // StackMapTable attribute. Also replace unreachable code with NOP* ATHROW, and remove it from\n        // exception handler ranges.\n        Label basicBlock = firstBasicBlock;\n        while (basicBlock != null) {\n            if ((basicBlock.flags & (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE))\n                    == (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE)) {\n                basicBlock.frame.accept(this);\n            }\n            if ((basicBlock.flags & Label.FLAG_REACHABLE) == 0) {\n                // Find the start and end bytecode offsets of this unreachable block.\n                Label nextBasicBlock = basicBlock.nextBasicBlock;\n                int startOffset = basicBlock.bytecodeOffset;\n                int endOffset = (nextBasicBlock == null ? code.length : nextBasicBlock.bytecodeOffset) - 1;\n                if (endOffset >= startOffset) {\n                    // Replace its instructions with NOP ... NOP ATHROW.\n                    for (int i = startOffset; i < endOffset; ++i) {\n                        code.data[i] = Opcodes.NOP;\n                    }\n                    code.data[endOffset] = (byte) Opcodes.ATHROW;\n                    // Emit a frame for this unreachable block, with no local and a Throwable on the stack\n                    // (so that the ATHROW could consume this Throwable if it were reachable).\n                    int frameIndex = visitFrameStart(startOffset, /* numLocal = */ 0, /* numStack = */ 1);\n                    currentFrame[frameIndex] = Frame.REFERENCE_KIND | symbolTable.addType(\"java/lang/Throwable\");\n                    visitFrameEnd();\n                    // The maximum stack size is now at least one, because of the Throwable declared above.\n                    maxStackSize = Math.max(maxStackSize, 1);\n                }\n            }\n            basicBlock = basicBlock.nextBasicBlock;\n        }\n\n        this.maxStack = maxStackSize;\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Utility methods: control flow analysis algorithm\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Adds a successor to {@link #currentBasicBlock} in the control flow graph.\n     *\n     * @param successor the successor block to be added to the current basic block.\n     */\n    private void addSuccessorToCurrentBasicBlock(final Label successor) {\n        currentBasicBlock.outgoingEdges = new Edge(successor, currentBasicBlock.outgoingEdges);\n    }\n\n    /**\n     * Ends the current basic block. This method must be used in the case where the current basic\n     * block does not have any successor.\n     *\n     * <p>WARNING: this method must be called after the currently visited instruction has been put in\n     * {@link #code} (if frames are computed, this method inserts a new Label to start a new basic\n     * block after the current instruction).\n     */\n    private void endCurrentBasicBlockWithNoSuccessor() {\n        Label nextBasicBlock = new Label();\n        nextBasicBlock.frame = new Frame(nextBasicBlock);\n        nextBasicBlock.resolve(code.data, code.length);\n        lastBasicBlock.nextBasicBlock = nextBasicBlock;\n        lastBasicBlock = nextBasicBlock;\n        currentBasicBlock = null;\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Utility methods: stack map frames\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Starts the visit of a new stack map frame, stored in {@link #currentFrame}.\n     *\n     * @param offset   the bytecode offset of the instruction to which the frame corresponds.\n     * @param numLocal the number of local variables in the frame.\n     * @param numStack the number of stack elements in the frame.\n     * @return the index of the next element to be written in this frame.\n     */\n    int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n        int frameLength = 3 + numLocal + numStack;\n        if (currentFrame == null || currentFrame.length < frameLength) {\n            currentFrame = new int[frameLength];\n        }\n        currentFrame[0] = offset;\n        currentFrame[1] = numLocal;\n        currentFrame[2] = numStack;\n        return 3;\n    }\n\n    /**\n     * Sets an abstract type in {@link #currentFrame}.\n     *\n     * @param frameIndex   the index of the element to be set in {@link #currentFrame}.\n     * @param abstractType an abstract type.\n     */\n    void visitAbstractType(final int frameIndex, final int abstractType) {\n        currentFrame[frameIndex] = abstractType;\n    }\n\n    /**\n     * Ends the visit of {@link #currentFrame} by writing it in the StackMapTable entries and by\n     * updating the StackMapTable number_of_entries (except if the current frame is the first one,\n     * which is implicit in StackMapTable). Then resets {@link #currentFrame} to {@literal null}.\n     */\n    void visitFrameEnd() {\n        if (previousFrame != null) {\n            if (stackMapTableEntries == null) {\n                stackMapTableEntries = new ByteVector(2048);\n            }\n            putFrame();\n            ++stackMapTableNumberOfEntries;\n        }\n        previousFrame = currentFrame;\n        currentFrame = null;\n    }\n\n    /**\n     * Compresses and writes {@link #currentFrame} in a new StackMapTable entry.\n     */\n    private void putFrame() {\n        final int numLocal = currentFrame[1];\n        final int numStack = currentFrame[2];\n        final int offsetDelta =\n                stackMapTableNumberOfEntries == 0\n                        ? currentFrame[0]\n                        : currentFrame[0] - previousFrame[0] - 1;\n        final int previousNumlocal = previousFrame[1];\n        final int numLocalDelta = numLocal - previousNumlocal;\n        int type = Frame.FULL_FRAME;\n        if (numStack == 0) {\n            switch (numLocalDelta) {\n                case -3:\n                case -2:\n                case -1:\n                    type = Frame.CHOP_FRAME;\n                    break;\n                case 0:\n                    type = offsetDelta < 64 ? Frame.SAME_FRAME : Frame.SAME_FRAME_EXTENDED;\n                    break;\n                case 1:\n                case 2:\n                case 3:\n                    type = Frame.APPEND_FRAME;\n                    break;\n                default:\n                    // Keep the FULL_FRAME type.\n                    break;\n            }\n        } else if (numLocalDelta == 0 && numStack == 1) {\n            type =\n                    offsetDelta < 63\n                            ? Frame.SAME_LOCALS_1_STACK_ITEM_FRAME\n                            : Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\n        }\n        if (type != Frame.FULL_FRAME) {\n            // Verify if locals are the same as in the previous frame.\n            int frameIndex = 3;\n            for (int i = 0; i < previousNumlocal && i < numLocal; i++) {\n                if (currentFrame[frameIndex] != previousFrame[frameIndex]) {\n                    type = Frame.FULL_FRAME;\n                    break;\n                }\n                frameIndex++;\n            }\n        }\n        switch (type) {\n            case Frame.SAME_FRAME:\n                stackMapTableEntries.putByte(offsetDelta);\n                break;\n            case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME:\n                stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);\n                putAbstractTypes(3 + numLocal, 4 + numLocal);\n                break;\n            case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:\n                stackMapTableEntries\n                        .putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)\n                        .putShort(offsetDelta);\n                putAbstractTypes(3 + numLocal, 4 + numLocal);\n                break;\n            case Frame.SAME_FRAME_EXTENDED:\n                stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);\n                break;\n            case Frame.CHOP_FRAME:\n                stackMapTableEntries\n                        .putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta)\n                        .putShort(offsetDelta);\n                break;\n            case Frame.APPEND_FRAME:\n                stackMapTableEntries\n                        .putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta)\n                        .putShort(offsetDelta);\n                putAbstractTypes(3 + previousNumlocal, 3 + numLocal);\n                break;\n            case Frame.FULL_FRAME:\n            default:\n                stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(numLocal);\n                putAbstractTypes(3, 3 + numLocal);\n                stackMapTableEntries.putShort(numStack);\n                putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);\n                break;\n        }\n    }\n\n    /**\n     * Puts some abstract types of {@link #currentFrame} in {@link #stackMapTableEntries} , using the\n     * JVMS verification_type_info format used in StackMapTable attributes.\n     *\n     * @param start index of the first type in {@link #currentFrame} to write.\n     * @param end   index of last type in {@link #currentFrame} to write (exclusive).\n     */\n    private void putAbstractTypes(final int start, final int end) {\n        for (int i = start; i < end; ++i) {\n            final int abstractType = currentFrame[i];\n            final ByteVector output = stackMapTableEntries;\n\n            int arrayDimensions = (abstractType & Frame.DIM_MASK) >> Frame.DIM_SHIFT;\n            if (arrayDimensions == 0) {\n                int typeValue = abstractType & Frame.VALUE_MASK;\n                switch (abstractType & Frame.KIND_MASK) {\n                    case Frame.CONSTANT_KIND:\n                        output.putByte(typeValue);\n                        break;\n                    case Frame.REFERENCE_KIND:\n                        output\n                                .putByte(Frame.ITEM_OBJECT)\n                                .putShort(symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, symbolTable.typeTable[typeValue].value).index);\n                        break;\n                    case Frame.UNINITIALIZED_KIND:\n                        output.putByte(Frame.ITEM_UNINITIALIZED).putShort((int) symbolTable.typeTable[typeValue].data);\n                        break;\n                    default:\n                        throw new AssertionError();\n                }\n            } else {\n                // Case of an array type, we need to build its descriptor first.\n                StringBuilder typeDescriptor = new StringBuilder();\n                while (arrayDimensions-- > 0) {\n                    typeDescriptor.append('[');\n                }\n                if ((abstractType & Frame.KIND_MASK) == Frame.REFERENCE_KIND) {\n                    typeDescriptor\n                            .append('L')\n                            .append(symbolTable.typeTable[abstractType & Frame.VALUE_MASK].value)\n                            .append(';');\n                } else {\n                    switch (abstractType & Frame.VALUE_MASK) {\n                        case Frame.ITEM_ASM_BOOLEAN:\n                            typeDescriptor.append('Z');\n                            break;\n                        case Frame.ITEM_ASM_BYTE:\n                            typeDescriptor.append('B');\n                            break;\n                        case Frame.ITEM_ASM_CHAR:\n                            typeDescriptor.append('C');\n                            break;\n                        case Frame.ITEM_ASM_SHORT:\n                            typeDescriptor.append('S');\n                            break;\n                        case Frame.ITEM_INTEGER:\n                            typeDescriptor.append('I');\n                            break;\n                        case Frame.ITEM_FLOAT:\n                            typeDescriptor.append('F');\n                            break;\n                        case Frame.ITEM_LONG:\n                            typeDescriptor.append('J');\n                            break;\n                        case Frame.ITEM_DOUBLE:\n                            typeDescriptor.append('D');\n                            break;\n                        default:\n                            throw new AssertionError();\n                    }\n                }\n                output\n                        .putByte(Frame.ITEM_OBJECT)\n                        .putShort(symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, typeDescriptor.toString()).index);\n            }\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Utility methods\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the size of the method_info JVMS structure generated by this MethodWriter. Also add the\n     * names of the attributes of this method in the constant pool.\n     *\n     * @return the size in bytes of the method_info JVMS structure.\n     */\n    int computeMethodInfoSize() {\n        // 2 bytes each for access_flags, name_index, descriptor_index and attributes_count.\n        int size = 8;\n        // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\n        if (code.length > 0) {\n            if (code.length > 65535) {\n                throw new JSONException(\"Method too large: \" + symbolTable.className + \".\" + name + \" \" + descriptor + \", length \" + code.length);\n            }\n            symbolTable.addConstantUtf8(Constants.CODE);\n            // The Code attribute has 6 header bytes, plus 2, 2, 4 and 2 bytes respectively for max_stack,\n            // max_locals, code_length and attributes_count, plus the bytecode and the exception table.\n            size += 16 + code.length + 2;\n            if (stackMapTableEntries != null) {\n                boolean useStackMapTable = true;\n                symbolTable.addConstantUtf8(useStackMapTable ? Constants.STACK_MAP_TABLE : \"StackMap\");\n                // 6 header bytes and 2 bytes for number_of_entries.\n                size += 8 + stackMapTableEntries.length;\n            }\n        }\n        return size;\n    }\n\n    /**\n     * Puts the content of the method_info JVMS structure generated by this MethodWriter into the\n     * given ByteVector.\n     *\n     * @param output where the method_info structure must be put.\n     */\n    void putMethodInfo(final ByteVector output) {\n        int mask = 0;\n        output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex);\n        // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\n        int attributeCount = 0;\n        if (code.length > 0) {\n            ++attributeCount;\n        }\n        // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\n        output.putShort(attributeCount);\n        if (code.length > 0) {\n            // 2, 2, 4 and 2 bytes respectively for max_stack, max_locals, code_length and\n            // attributes_count, plus the bytecode and the exception table.\n            int size = 10 + code.length + 2;\n            int codeAttributeCount = 0;\n            if (stackMapTableEntries != null) {\n                // 6 header bytes and 2 bytes for number_of_entries.\n                size += 8 + stackMapTableEntries.length;\n                ++codeAttributeCount;\n            }\n            output\n                    .putShort(symbolTable.addConstantUtf8(Constants.CODE))\n                    .putInt(size)\n                    .putShort(maxStack)\n                    .putShort(maxLocals)\n                    .putInt(code.length)\n                    .putByteArray(code.data, 0, code.length);\n            output.putShort(0); // putExceptionTable\n            output.putShort(codeAttributeCount);\n            if (stackMapTableEntries != null) {\n                boolean useStackMapTable = true;\n                output\n                        .putShort(\n                                symbolTable.addConstantUtf8(\n                                        useStackMapTable ? Constants.STACK_MAP_TABLE : \"StackMap\"))\n                        .putInt(2 + stackMapTableEntries.length)\n                        .putShort(stackMapTableNumberOfEntries)\n                        .putByteArray(stackMapTableEntries.data, 0, stackMapTableEntries.length);\n            }\n        }\n    }\n}\n",
      "file_name": "MethodWriter.java",
      "human_label": "Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.",
      "level": "self_contained",
      "lineno": "634",
      "name": "visitFrameStart",
      "oracle_context": "{ \"apis\" : \"[]\", \"classes\" : \"[currentFrame]\", \"vars\" : \"[length, currentFrame]\" }",
      "package": "com.alibaba.fastjson2.internal.asm",
      "project": "fastjson2-main"
    },
    {
      "_id": "636767191a6d9265ec017c0f",
      "all_context": "{ \"class_level\" : \"byte[] data;\\nint length;\\nByteVector();\\nByteVector(int initialCapacity);\\nByteVector(byte[] data);\\nput11(int byteValue1,int byteValue2);\\nputShort(int shortValue);\\nput12(int byteValue,int shortValue);\\nput112(int byteValue1,int byteValue2,int shortValue);\\nputInt(int intValue);\\nput122(int byteValue,int shortValue1,int shortValue2);\\nputLong(long longValue);\\nputUTF8(String stringValue);\\nencodeUtf8(String stringValue,int offset,int maxByteLength);\\nputByteArray(byte[] byteArrayValue,int byteOffset,int byteLength);\\nenlarge(int size);\\nputByte(int byteValue);\\n\", \"repo_level\" : \"\" }",
      "class_name": "ByteVector",
      "code": "private void enlarge(final int size){\n  int doubleCapacity=2 * data.length;\n  int minimalCapacity=length + size;\n  byte[] newData=new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\n  System.arraycopy(data,0,newData,0,length);\n  data=newData;\n}\n",
      "docstring": "/** \n * Enlarges this byte vector so that it can receive 'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n",
      "end_lineno": "356",
      "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage net.hasor.utils.asm;\n/**\n * A dynamically extensible vector of bytes. This class is roughly equivalent to a DataOutputStream\n * on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n */\npublic class ByteVector {\n    /** The content of this vector. Only the first {@link #length} bytes contain real data. */\n    byte[] data;\n    /** The actual number of bytes in this vector. */\n    int    length;\n\n    /** Constructs a new {@link ByteVector} with a default initial capacity. */\n    public ByteVector() {\n        data = new byte[64];\n    }\n\n    /**\n     * Constructs a new {@link ByteVector} with the given initial capacity.\n     *\n     * @param initialCapacity the initial capacity of the byte vector to be constructed.\n     */\n    public ByteVector(final int initialCapacity) {\n        data = new byte[initialCapacity];\n    }\n\n    /**\n     * Constructs a new {@link ByteVector} from the given initial data.\n     *\n     * @param data the initial data of the new byte vector.\n     */\n    ByteVector(final byte[] data) {\n        this.data = data;\n        this.length = data.length;\n    }\n\n    /**\n     * Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue a byte.\n     * @return this byte vector.\n     */\n    public ByteVector putByte(final int byteValue) {\n        int currentLength = length;\n        if (currentLength + 1 > data.length) {\n            enlarge(1);\n        }\n        data[currentLength++] = (byte) byteValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue1 a byte.\n     * @param byteValue2 another byte.\n     * @return this byte vector.\n     */\n    final ByteVector put11(final int byteValue1, final int byteValue2) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue1;\n        currentData[currentLength++] = (byte) byteValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    public ByteVector putShort(final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteValue a byte.\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    final ByteVector put12(final int byteValue, final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 3 > data.length) {\n            enlarge(3);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts two bytes and a short into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteValue1 a byte.\n     * @param byteValue2 another byte.\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    final ByteVector put112(final int byteValue1, final int byteValue2, final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue1;\n        currentData[currentLength++] = (byte) byteValue2;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param intValue an int.\n     * @return this byte vector.\n     */\n    public ByteVector putInt(final int intValue) {\n        int currentLength = length;\n        if (currentLength + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\n     * if necessary.\n     *\n     * @param byteValue a byte.\n     * @param shortValue1 a short.\n     * @param shortValue2 another short.\n     * @return this byte vector.\n     */\n    final ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) {\n        int currentLength = length;\n        if (currentLength + 5 > data.length) {\n            enlarge(5);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue1 >>> 8);\n        currentData[currentLength++] = (byte) shortValue1;\n        currentData[currentLength++] = (byte) (shortValue2 >>> 8);\n        currentData[currentLength++] = (byte) shortValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param longValue a long.\n     * @return this byte vector.\n     */\n    public ByteVector putLong(final long longValue) {\n        int currentLength = length;\n        if (currentLength + 8 > data.length) {\n            enlarge(8);\n        }\n        byte[] currentData = data;\n        int intValue = (int) (longValue >>> 32);\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        intValue = (int) longValue;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param stringValue a String whose UTF8 encoded length must be less than 65536.\n     * @return this byte vector.\n     */\n    // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\n    public ByteVector putUTF8(final String stringValue) {\n        int charLength = stringValue.length();\n        if (charLength > 65535) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        int currentLength = length;\n        if (currentLength + 2 + charLength > data.length) {\n            enlarge(2 + charLength);\n        }\n        byte[] currentData = data;\n        // Optimistic algorithm: instead of computing the byte length and then serializing the string\n        // (which requires two loops), we assume the byte length is equal to char length (which is the\n        // most frequent case), and we start serializing the string right away. During the\n        // serialization, if we find that this assumption is wrong, we continue with the general method.\n        currentData[currentLength++] = (byte) (charLength >>> 8);\n        currentData[currentLength++] = (byte) charLength;\n        for (int i = 0; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= '\\u0001' && charValue <= '\\u007F') {\n                currentData[currentLength++] = (byte) charValue;\n            } else {\n                length = currentLength;\n                return encodeUtf8(stringValue, i, 65535);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary. The string length is encoded in two bytes before the encoded characters, if there is\n     * space for that (i.e. if this.length - offset - 2 &gt;= 0).\n     *\n     * @param stringValue the String to encode.\n     * @param offset the index of the first character to encode. The previous characters are supposed\n     *     to have already been encoded, using only one byte per character.\n     * @param maxByteLength the maximum byte length of the encoded string, including the already\n     *     encoded characters.\n     * @return this byte vector.\n     */\n    final ByteVector encodeUtf8(final String stringValue, final int offset, final int maxByteLength) {\n        int charLength = stringValue.length();\n        int byteLength = offset;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                byteLength++;\n            } else if (charValue <= 0x07FF) {\n                byteLength += 2;\n            } else {\n                byteLength += 3;\n            }\n        }\n        if (byteLength > maxByteLength) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        // Compute where 'byteLength' must be stored in 'data', and store it at this location.\n        int byteLengthOffset = length - offset - 2;\n        if (byteLengthOffset >= 0) {\n            data[byteLengthOffset] = (byte) (byteLength >>> 8);\n            data[byteLengthOffset + 1] = (byte) byteLength;\n        }\n        if (length + byteLength - offset > data.length) {\n            enlarge(byteLength - offset);\n        }\n        int currentLength = length;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                data[currentLength++] = (byte) charValue;\n            } else if (charValue <= 0x07FF) {\n                data[currentLength++] = (byte) (0xC0 | charValue >> 6 & 0x1F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            } else {\n                data[currentLength++] = (byte) (0xE0 | charValue >> 12 & 0xF);\n                data[currentLength++] = (byte) (0x80 | charValue >> 6 & 0x3F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\n     *     bytes into this byte vector.\n     * @param byteOffset index of the first byte of byteArrayValue that must be copied.\n     * @param byteLength number of bytes of byteArrayValue that must be copied.\n     * @return this byte vector.\n     */\n    public ByteVector putByteArray(final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n        if (length + byteLength > data.length) {\n            enlarge(byteLength);\n        }\n        if (byteArrayValue != null) {\n            System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength);\n        }\n        length += byteLength;\n        return this;\n    }\n\n    /**\n     * Enlarges this byte vector so that it can receive 'size' more bytes.\n     *\n     * @param size number of additional bytes that this byte vector should be able to receive.\n     */\n    private void enlarge(final int size) {\n        int doubleCapacity = 2 * data.length;\n        int minimalCapacity = length + size;\n        byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\n        System.arraycopy(data, 0, newData, 0, length);\n        data = newData;\n    }\n}\n",
      "file_name": "ByteVector.java",
      "human_label": "Enlarge the byte vector data, by increasing it by the given size.",
      "level": "class_runnable",
      "lineno": "345",
      "name": "enlarge",
      "oracle_context": "{ \"apis\" : \"[arraycopy]\", \"classes\" : \"[byte[], data]\", \"vars\" : \"[length, data]\" }",
      "package": "net.hasor.utils.asm",
      "project": "hasor-master"
    },
    {
      "_id": "636767821a6d9265ec0183a0",
      "all_context": "{ \"class_level\" : \"import org.apache.log4j.RollingCalendar;\\nimport org.apache.log4j.helpers.OptionConverter;\\nimport org.apache.log4j.helpers.QuietWriter;\\nimport org.apache.log4j.helpers.CountingQuietWriter;\\nimport org.apache.log4j.helpers.LogLog;\\nimport org.apache.log4j.spi.LoggingEvent;\\nimport java.util.Date;\\nimport java.io.IOException;\\nimport java.io.Writer;\\nimport java.text.SimpleDateFormat;\\nimport java.io.File;\\nimport java.io.FilenameFilter;\\nint TOP_OF_TROUBLE;\\nint TOP_OF_MINUTE;\\nint TOP_OF_HOUR;\\nint HALF_DAY;\\nint TOP_OF_DAY;\\nint TOP_OF_WEEK;\\nint TOP_OF_MONTH;\\nint BY_SIZE;\\nint BY_DATE;\\nint BY_COMPOSITE;\\nString S_BY_SIZE;\\nString S_BY_DATE;\\nString S_BY_COMPOSITE;\\nString datePattern;\\nString scheduledFilename;\\nlong nextCheck;\\nDate now;\\nSimpleDateFormat sdf;\\nRollingCalendar rc;\\nint checkPeriod;\\nlong maxFileSize;\\nint maxSizeRollBackups;\\nint curSizeRollBackups;\\nint maxTimeRollBackups;\\nint curTimeRollBackups;\\nint countDirection;\\nint rollingStyle;\\nboolean rollDate;\\nboolean rollSize;\\nboolean staticLogFileName;\\nString baseFileName;\\nCompositeRollingAppender();\\nCompositeRollingAppender(Layout layout,String filename,String datePattern);\\nCompositeRollingAppender(Layout layout,String filename,boolean append);\\nCompositeRollingAppender(Layout layout,String filename,String datePattern,boolean append);\\nCompositeRollingAppender(Layout layout,String filename);\\nsetDatePattern(String pattern);\\ngetDatePattern();\\ngetMaxSizeRollBackups();\\ngetMaximumFileSize();\\nsetMaxSizeRollBackups(int maxBackups);\\nsetMaxFileSize(long maxFileSize);\\nsetMaximumFileSize(long maxFileSize);\\nsetMaxFileSize(String value);\\nsetQWForFiles(Writer writer);\\ncomputeCheckPeriod();\\nsetFile(String file);\\nsetFile(String fileName,boolean append);\\ngetCountDirection();\\nsetCountDirection(int direction);\\ngetRollingStyle();\\nsetRollingStyle(int style);\\ngetStaticLogFileName();\\nsetStaticLogFileName(boolean s);\\nsetStaticLogFileName(String value);\\nexistingInit();\\nactivateOptions();\\nrollOverTime();\\nrollFile(String from,String to);\\ndeleteFile(String fileName);\\nrollOverSize();\\nsubAppend(LoggingEvent event);\\n\", \"repo_level\" : \"public interface RollingCalendar { void setType(int type);\\npublic long getNextCheckMillis(Date now);\\npublic Date getNextCheckDate(Date now);\\n }\\npublic interface OptionConverter {static String[] concatanateArrays(String[] l,String[] r);\\nstatic String convertSpecialChars(String s);\\nstatic String getSystemProperty(String key,String def);\\nstatic Object instantiateByKey(Properties props,String key,Class superClass,Object defaultValue);\\nstatic boolean toBoolean(String value,boolean dEfault);\\nstatic int toInt(String value,int dEfault);\\nstatic Level toLevel(String value,Level defaultValue);\\nstatic long toFileSize(String value,long dEfault);\\nstatic String findAndSubst(String key,Properties props);\\nstatic Object instantiateByClassName(String className,Class superClass,Object defaultValue);\\nstatic String substVars(String val,Properties props);\\npublic void selectAndConfigure(InputStream inputStream,String clazz,LoggerRepository hierarchy);\\npublic void selectAndConfigure(URL url,String clazz,LoggerRepository hierarchy);\\n }\\npublic interface QuietWriter {public void write(String string);\\npublic void flush();\\npublic void setErrorHandler(ErrorHandler eh);\\n }\\npublic interface CountingQuietWriter {public void write(String string);\\npublic long getCount();\\npublic void setCount(long count);\\n }\\npublic interface LogLog {public void setInternalDebugging(boolean enabled);\\nstatic void debug(String msg);\\nstatic void debug(String msg,Throwable t);\\nstatic void error(String msg);\\nstatic void error(String msg,Throwable t);\\nstatic void setQuietMode(boolean quietMode);\\nstatic void warn(String msg);\\nstatic void warn(String msg,Throwable t);\\n }\\npublic interface LoggingEvent {public LocationInfo getLocationInformation();\\npublic Level getLevel();\\npublic String getLoggerName();\\npublic Category getLogger();\\npublic Object getMessage();\\npublic String getNDC();\\npublic Object getMDC(String key);\\npublic void getMDCCopy();\\npublic String getRenderedMessage();\\nstatic long getStartTime();\\npublic String getThreadName();\\npublic ThrowableInformation getThrowableInformation();\\npublic String[] getThrowableStrRep();\\nfinal void setProperty(String propName,String propValue);\\nfinal String getProperty(String key);\\nfinal boolean locationInformationExists();\\nfinal long getTimeStamp();\\npublic Set getPropertyKeySet();\\npublic Map getProperties();\\npublic String getFQNOfLoggerClass();\\npublic Object removeProperty(String propName);\\n }\\n\" }",
      "class_name": "CompositeRollingAppender",
      "code": "protected static void deleteFile(String fileName){\n  File file=new File(fileName);\n  if (file.exists()) {\n    file.delete();\n  }\n}\n",
      "docstring": "/** \n * Delete's the specified file if it exists \n */\n",
      "end_lineno": "622",
      "file_content": "package org.apache.log4j;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.log4j.RollingCalendar;\nimport org.apache.log4j.helpers.OptionConverter;\nimport org.apache.log4j.helpers.QuietWriter;\nimport org.apache.log4j.helpers.CountingQuietWriter;\nimport org.apache.log4j.helpers.LogLog;\nimport org.apache.log4j.spi.LoggingEvent;\n\nimport java.util.Date;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.text.SimpleDateFormat;\nimport java.io.File;\nimport java.io.FilenameFilter;\n\n/**\n *  <p>CompositeRollingAppender combines RollingFileAppender and DailyRollingFileAppender<br>\n *  It can function as either or do both at the same time (making size\n *  based rolling files like RollingFileAppender until a data/time boundary\n *  is crossed at which time it rolls all of those files as per the DailyRollingFileAppender)\n *  based on the setting for <code>rollingStyle</code>.<br>\n *  <br>\n *  To use CompositeRollingAppender to roll log files as they reach a certain\n *  size (like RollingFileAppender), set rollingStyle=1 (@see config.size)<br>\n *  To use CompositeRollingAppender to roll log files at certain time intervals\n *  (daily for example), set rollingStyle=2 and a datePattern (@see config.time)<br>\n *  To have CompositeRollingAppender roll log files at a certain size AND rename those\n *  according to time intervals, set rollingStyle=3 (@see config.composite)<br>\n *\n *  <p>A of few additional optional features have been added:<br>\n *  -- Attach date pattern for current log file (@see staticLogFileName)<br>\n *  -- Backup number increments for newer files (@see countDirection)<br>\n *  -- Infinite number of backups by file size (@see maxSizeRollBackups)<br>\n *  <br>\n *  <p>A few notes and warnings:  For large or infinite number of backups\n *  countDirection > 0 is highly recommended, with staticLogFileName = false if\n *  time based rolling is also used -- this will reduce the number of file renamings\n *  to few or none.  Changing staticLogFileName or countDirection without clearing\n *  the directory could have nasty side effects.  If Date/Time based rolling\n *  is enabled, CompositeRollingAppender will attempt to roll existing files\n *  in the directory without a date/time tag based on the last modified date\n *  of the base log files last modification.<br>\n *  <br>\n *  <p>A maximum number of backups based on date/time boundries would be nice\n *  but is not yet implemented.<br>\n *\n *  @author Kevin Steppe\n *  @author Heinz Richter\n *  @author Eirik Lygre\n *  @author Ceki G&uuml;lc&uuml;\n */\npublic class CompositeRollingAppender extends org.apache.log4j.FileAppender\n{\n\t// The code assumes that the following 'time' constants are in a increasing\n\t// sequence.\n\tstatic final int TOP_OF_TROUBLE=-1;\n\tstatic final int TOP_OF_MINUTE = 0;\n\tstatic final int TOP_OF_HOUR   = 1;\n\tstatic final int HALF_DAY      = 2;\n\tstatic final int TOP_OF_DAY    = 3;\n\tstatic final int TOP_OF_WEEK   = 4;\n\tstatic final int TOP_OF_MONTH  = 5;\n\n\t/** Style of rolling to use */\n\tstatic final int BY_SIZE = 1;\n\tstatic final int BY_DATE = 2;\n\tstatic final int BY_COMPOSITE = 3;\n\n\t//Not currently used\n\tstatic final String S_BY_SIZE = \"Size\";\n\tstatic final String S_BY_DATE = \"Date\";\n\tstatic final String S_BY_COMPOSITE = \"Composite\";\n\n\t/**\n\t The date pattern. By default, the pattern is set to\n\t \"'.'yyyy-MM-dd\" meaning daily rollover.\n\t*/\n\tprivate String datePattern = \"'.'yyyy-MM-dd\";\n\n\t/**\t The actual formatted filename that is currently being written to\n\t     or will be the file transferred to on roll over\n\t\t (based on staticLogFileName). */\n\tprivate String scheduledFilename = null;\n\n\t/** The timestamp when we shall next recompute the filename. */\n\tprivate long nextCheck = System.currentTimeMillis () - 1;\n\n\t/** Holds date of last roll over */\n\tDate now = new Date();\n\n\tSimpleDateFormat sdf;\n\n\t/** Helper class to determine next rollover time */\n\tRollingCalendar rc = new RollingCalendar();\n\n\t/** Current period for roll overs */\n\tint checkPeriod = TOP_OF_TROUBLE;\n\n\t/**\t The default maximum file size is 10MB. */\n\tprotected long maxFileSize = 10*1024*1024;\n\n\t/**\t There is zero backup files by default. */\n\tprotected int maxSizeRollBackups = 0;\n\t/** How many sized based backups have been made so far */\n\tprotected int curSizeRollBackups = 0;\n\n\t/** not yet implemented */\n\tprotected int maxTimeRollBackups = -1;\n\tprotected int curTimeRollBackups = 0;\n\n\t/** By default newer files have lower numbers. (countDirection < 0)\n\t *  ie. log.1 is most recent, log.5 is the 5th backup, etc...\n\t *  countDirection > 0 does the opposite ie.\n\t *  log.1 is the first backup made, log.5 is the 5th backup made, etc.\n\t *  For infinite backups use countDirection > 0 to reduce rollOver costs.\n\t */\n\tprotected int countDirection = -1;\n\n\t/** Style of rolling to Use.  BY_SIZE (1), BY_DATE(2), BY COMPOSITE(3) */\n\tprotected int rollingStyle = BY_COMPOSITE;\n\tprotected boolean rollDate = true;\n\tprotected boolean rollSize = true;\n\n\t/** By default file.log is always the current file.  Optionally\n\t *  file.log.yyyy-mm-dd for current formated datePattern can by the currently\n\t *  logging file (or file.log.curSizeRollBackup or even\n\t *  file.log.yyyy-mm-dd.curSizeRollBackup) This will make time based roll\n\t *  overs with a large number of backups much faster -- it won't have to\n\t *  rename all the backups!\n\t */\n\tprotected boolean staticLogFileName = true;\n\n\t/** FileName provided in configuration.  Used for rolling properly */\n\tprotected String baseFileName;\n\n    /** The default constructor does nothing. */\n\tpublic CompositeRollingAppender()  {\n    }\n\n\t/**\n\t Instantiate a <code>CompositeRollingAppender</code> and open the\n\t file designated by <code>filename</code>. The opened filename will\n\t become the ouput destination for this appender.\n\t*/\n\tpublic CompositeRollingAppender (Layout layout, String filename,\n\t\t\t\t   String datePattern) throws IOException {\n\t    this(layout, filename, datePattern, true);\n\t}\n\n\t/**\n\t Instantiate a CompositeRollingAppender and open the file designated by\n\t <code>filename</code>. The opened filename will become the ouput\n\t destination for this appender.\n\n\t <p>If the <code>append</code> parameter is true, the file will be\n\t appended to. Otherwise, the file desginated by\n\t <code>filename</code> will be truncated before being opened.\n\t*/\n\tpublic CompositeRollingAppender(Layout layout, String filename, boolean append)\n\t\t\t\t\t\t\t\t\t  throws IOException {\n\t    super(layout, filename, append);\n\t}\n\n\t/**\n\t Instantiate a CompositeRollingAppender and open the file designated by\n\t <code>filename</code>. The opened filename will become the ouput\n\t destination for this appender.\n\t*/\n\tpublic CompositeRollingAppender (Layout layout, String filename,\n\t\t\t\t   String datePattern, boolean append) throws IOException {\n\t    super(layout, filename, append);\n\t    this.datePattern = datePattern;\n\t\tactivateOptions();\n\t}\n\t/**\n\t Instantiate a CompositeRollingAppender and open the file designated by\n\t <code>filename</code>. The opened filename will become the output\n\t destination for this appender.\n\n\t <p>The file will be appended to.  DatePattern is default.\n\t*/\n\tpublic CompositeRollingAppender(Layout layout, String filename) throws IOException {\n\t    super(layout, filename);\n\t}\n\n\t/**\n\t The <b>DatePattern</b> takes a string in the same format as\n\t expected by {@link SimpleDateFormat}. This options determines the\n\t rollover schedule.\n\t*/\n\tpublic void setDatePattern(String pattern) {\n\t    datePattern = pattern;\n\t}\n\n\t/** Returns the value of the <b>DatePattern</b> option. */\n\tpublic String getDatePattern() {\n\t    return datePattern;\n\t}\n\n\t/**\n\t Returns the value of the <b>maxSizeRollBackups</b> option.\n\t*/\n\tpublic int getMaxSizeRollBackups() {\n\t    return maxSizeRollBackups;\n\t}\n\n\t/**\n\t Get the maximum size that the output file is allowed to reach\n\t before being rolled over to backup files.\n\n\t @since 1.1\n\t*/\n\tpublic long getMaximumFileSize() {\n\t\treturn maxFileSize;\n\t}\n\n\t/**\n\t <p>Set the maximum number of backup files to keep around based on file size.\n\n\t <p>The <b>MaxSizeRollBackups</b> option determines how many backup\n\t files are kept before the oldest is erased. This option takes\n\t an integer value. If set to zero, then there will be no\n\t backup files and the log file will be truncated when it reaches\n\t <code>MaxFileSize</code>.  If a negative number is supplied then\n\t no deletions will be made.  Note that this could result in\n\t very slow performance as a large number of files are rolled over unless\n\t {@link #setCountDirection} up is used.\n\n\t <p>The maximum applys to -each- time based group of files and -not- the total.\n\t Using a daily roll the maximum total files would be (#days run) * (maxSizeRollBackups)\n\n\t*/\n\tpublic void setMaxSizeRollBackups(int maxBackups) {\n\t    maxSizeRollBackups = maxBackups;\n\t}\n\n\t/**\n\t Set the maximum size that the output file is allowed to reach\n\t before being rolled over to backup files.\n\n\t <p>This method is equivalent to {@link #setMaxFileSize} except\n\t that it is required for differentiating the setter taking a\n\t <code>long</code> argument from the setter taking a\n\t <code>String</code> argument by the JavaBeans {@link\n\t java.beans.Introspector Introspector}.\n\n\t @see #setMaxFileSize(String)\n\t*/\n\tpublic void setMaxFileSize(long maxFileSize) {\n\t   this.maxFileSize = maxFileSize;\n\t}\n\n\t/**\n\t Set the maximum size that the output file is allowed to reach\n\t before being rolled over to backup files.\n\n\t <p>This method is equivalent to {@link #setMaxFileSize} except\n\t that it is required for differentiating the setter taking a\n\t <code>long</code> argument from the setter taking a\n\t <code>String</code> argument by the JavaBeans {@link\n\t java.beans.Introspector Introspector}.\n\n\t @see #setMaxFileSize(String)\n\t*/\n\tpublic void setMaximumFileSize(long maxFileSize) {\n\t\tthis.maxFileSize = maxFileSize;\n\t}\n\n\t/**\n\t Set the maximum size that the output file is allowed to reach\n\t before being rolled over to backup files.\n\n\t <p>In configuration files, the <b>MaxFileSize</b> option takes an\n\t long integer in the range 0 - 2^63. You can specify the value\n\t with the suffixes \"KB\", \"MB\" or \"GB\" so that the integer is\n\t interpreted being expressed respectively in kilobytes, megabytes\n\t or gigabytes. For example, the value \"10KB\" will be interpreted\n\t as 10240.\n\t*/\n\tpublic void setMaxFileSize(String value) {\n\t    maxFileSize = OptionConverter.toFileSize(value, maxFileSize + 1);\n\t}\n\n\tprotected void setQWForFiles(Writer writer) {\n\t    qw = new CountingQuietWriter(writer, errorHandler);\n\t}\n\n\t//Taken verbatum from DailyRollingFileAppender\n\tint computeCheckPeriod() {\n\t\tRollingCalendar c = new RollingCalendar();\n\t\t// set sate to 1970-01-01 00:00:00 GMT\n\t\tDate epoch = new Date(0);\n\t\tif(datePattern != null) {\n\t\t\tfor(int i = TOP_OF_MINUTE; i <= TOP_OF_MONTH; i++) {\n\t\t\t\tString r0 = sdf.format(epoch);\n\t\t\t\tc.setType(i);\n\t\t\t\tDate next = new Date(c.getNextCheckMillis(epoch));\n\t\t\t\tString r1 = sdf.format(next);\n\t\t\t\t//LogLog.debug(\"Type = \"+i+\", r0 = \"+r0+\", r1 = \"+r1);\n\t\t\t\tif(r0 != null && r1 != null && !r0.equals(r1)) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn TOP_OF_TROUBLE; // Deliberately head for trouble...\n\t}\n\n\t//Now for the new stuff\n\t/**\n\t * Handles append time behavior for CompositeRollingAppender.  This checks\n\t * if a roll over either by date (checked first) or time (checked second)\n\t * is need and then appends to the file last.\n\t*/\n\tprotected void subAppend(LoggingEvent event) {\n\n\t\tif (rollDate) {\n\t\t\tlong n = System.currentTimeMillis();\n\t\t\tif (n >= nextCheck) {\n\t\t\t\tnow.setTime(n);\n\t\t\t\tnextCheck = rc.getNextCheckMillis(now);\n\n\t\t\t\trollOverTime();\n\t\t\t}\n\t\t}\n\n\t\tif (rollSize) {\n\t\t\tif ((fileName != null) && ((CountingQuietWriter) qw).getCount() >= maxFileSize) {\n\t\t\t    rollOverSize();\n\t\t\t}\n\t\t}\n\n\t\tsuper.subAppend(event);\n\t}\n\n\tpublic void setFile(String file)\n\t{\n\t\tbaseFileName = file.trim();\n\t\tfileName = file.trim();\n\t}\n\n\t/**\n\t * Creates and opens the file for logging.  If <code>staticLogFileName</code>\n\t * is false then the fully qualified name is determined and used.\n\t */\n\tpublic synchronized void setFile(String fileName, boolean append) throws IOException {\n\t\tif (!staticLogFileName) {\n\t\t    scheduledFilename = fileName = fileName.trim() + sdf.format(now);\n\t\t\tif (countDirection > 0) {\n\t\t\t\tscheduledFilename = fileName = fileName + '.' + (++curSizeRollBackups);\n\t\t\t}\n\t\t}\n\n\t\tsuper.setFile(fileName, append);\n\t\tif(append) {\n\t\t  File f = new File(fileName);\n\t\t  ((CountingQuietWriter) qw).setCount(f.length());\n\t\t}\n\t}\n\n\tpublic int getCountDirection() {\n\t\treturn countDirection;\n\t}\n\n\tpublic void setCountDirection(int direction) {\n\t\tcountDirection = direction;\n\t}\n\n\tpublic int getRollingStyle () {\n        return rollingStyle;\n\t}\n\n\tpublic void setRollingStyle(int style) {\n\t    rollingStyle = style;\n\t\tswitch (rollingStyle) {\n\t\t\tcase BY_SIZE:\n\t\t\t\t rollDate = false;\n\t\t\t\t rollSize = true;\n\t\t\t\t break;\n\t\t\tcase BY_DATE:\n\t\t\t\t rollDate = true;\n\t\t\t\t rollSize = false;\n\t\t\t\t break;\n\t\t\tcase BY_COMPOSITE:\n\t\t\t\t rollDate = true;\n\t\t\t\t rollSize = true;\n\t\t\t\t break;\n\t\t\tdefault:\n\t\t\t\terrorHandler.error(\"Invalid rolling Style, use 1 (by size only), 2 (by date only) or 3 (both)\");\n\t\t}\n\t}\n\n/*\n\tpublic void setRollingStyle(String style) {\n\t\tif (style == S_BY_SIZE) {\n\t\t    rollingStyle = BY_SIZE;\n\t\t}\n\t\telse if (style == S_BY_DATE) {\n\t\t    rollingStyle = BY_DATE;\n\t\t}\n\t\telse if (style == S_BY_COMPOSITE) {\n\t\t\trollingStyle = BY_COMPOSITE;\n\t\t}\n\t}\n*/\n\tpublic boolean getStaticLogFileName() {\n\t    return staticLogFileName;\n\t}\n\n\tpublic void setStaticLogFileName(boolean s) {\n\t\tstaticLogFileName = s;\n\t}\n\n\tpublic void setStaticLogFileName(String value) {\n\t\tsetStaticLogFileName(OptionConverter.toBoolean(value, true));\n\t}\n\n\t/**\n\t *  Initializes based on exisiting conditions at time of <code>\n\t *  activateOptions</code>.  The following is done:<br>\n\t *  <br>\n\t *\tA) determine curSizeRollBackups<br>\n\t *\tB) determine curTimeRollBackups (not implemented)<br>\n\t *\tC) initiates a roll over if needed for crossing a date boundary since\n\t *  the last run.\n\t */\n\tprotected void existingInit() {\n\n\t\tcurSizeRollBackups = 0;\n\t\tcurTimeRollBackups = 0;\n\n\t\t//part A starts here\n\t\tString filter;\n\t\tif (staticLogFileName || !rollDate) {\n\t\t\tfilter = baseFileName + \".*\";\n\t\t}\n\t\telse {\n\t\t\tfilter = scheduledFilename + \".*\";\n\t\t}\n\n\t\tFile f = new File(baseFileName);\n\t\tf = f.getParentFile();\n\t\tif (f == null)\n\t\t   f = new File(\".\");\n\n\t\tLogLog.debug(\"Searching for existing files in: \" + f);\n\t\tString[] files = f.list();\n\n\t\tif (files != null) {\n\t\t\tfor (int i = 0; i < files.length; i++) {\n\t\t\t\tif (!files[i].startsWith(baseFileName))\n\t\t\t\t   continue;\n\n\t\t\t\tint index = files[i].lastIndexOf(\".\");\n\n\t\t\t\tif (staticLogFileName) {\n\t\t\t\t   int endLength = files[i].length() - index;\n\t\t\t\t   if (baseFileName.length() + endLength != files[i].length()) {\n\t\t\t\t\t   //file is probably scheduledFilename + .x so I don't care\n\t\t\t\t\t   continue;\n\t\t\t\t   }\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tint backup = Integer.parseInt(files[i].substring(index + 1, files[i].length()));\n\t\t\t\t\tLogLog.debug(\"From file: \" + files[i] + \" -> \" + backup);\n\t\t\t\t\tif (backup > curSizeRollBackups)\n\t\t\t\t\t   curSizeRollBackups = backup;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t//this happens when file.log -> file.log.yyyy-mm-dd which is normal\n\t\t\t\t\t//when staticLogFileName == false\n\t\t\t\t\tLogLog.debug(\"Encountered a backup file not ending in .x \" + files[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLogLog.debug(\"curSizeRollBackups starts at: \" + curSizeRollBackups);\n\t\t//part A ends here\n\n\t\t//part B not yet implemented\n\n\t\t//part C\n\t\tif (staticLogFileName && rollDate) {\n\t\t\tFile old = new File(baseFileName);\n\t\t\tif (old.exists()) {\n\t\t\t\tDate last = new Date(old.lastModified());\n\t\t\t\tif (!(sdf.format(last).equals(sdf.format(now)))) {\n\t\t\t\t\tscheduledFilename = baseFileName + sdf.format(last);\n\t\t\t\t\tLogLog.debug(\"Initial roll over to: \" + scheduledFilename);\n\t\t\t\t\trollOverTime();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLogLog.debug(\"curSizeRollBackups after rollOver at: \" + curSizeRollBackups);\n\t\t//part C ends here\n\n\t}\n\n\t/**\n\t * Sets initial conditions including date/time roll over information, first check,\n\t * scheduledFilename, and calls <code>existingInit</code> to initialize\n\t * the current # of backups.\n\t */\n\tpublic void activateOptions() {\n\n\t    //REMOVE removed rollDate from boolean to enable Alex's change\n\t\tif(datePattern != null) {\n\t\t\tnow.setTime(System.currentTimeMillis());\n\t\t\tsdf = new SimpleDateFormat(datePattern);\n\t\t\tint type = computeCheckPeriod();\n\t\t\t//printPeriodicity(type);\n\t\t\trc.setType(type);\n\t\t\t//next line added as this removes the name check in rollOver\n\t\t\tnextCheck = rc.getNextCheckMillis(now);\n\t\t} else {\n\t\t\tif (rollDate)\n\t\t\t    LogLog.error(\"Either DatePattern or rollingStyle options are not set for [\"+\n\t\t\t      name+\"].\");\n\t\t}\n\n\t\texistingInit();\n\n\t\tsuper.activateOptions();\n\n\t\tif (rollDate && fileName != null && scheduledFilename == null)\n\t\t\tscheduledFilename = fileName + sdf.format(now);\n\t}\n\n\t/**\n\t Rollover the file(s) to date/time tagged file(s).\n\t Opens the new file (through setFile) and resets curSizeRollBackups.\n\t*/\n\tprotected void rollOverTime() {\n\n\t    curTimeRollBackups++;\n\n\t\t//delete the old stuff here\n\n\t\tif (staticLogFileName) {\n\t\t\t/* Compute filename, but only if datePattern is specified */\n\t\t\tif (datePattern == null) {\n\t\t\t\terrorHandler.error(\"Missing DatePattern option in rollOver().\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//is the new file name equivalent to the 'current' one\n\t\t\t//something has gone wrong if we hit this -- we should only\n\t\t\t//roll over if the new file will be different from the old\n\t\t\tString dateFormat = sdf.format(now);\n\t\t\tif (scheduledFilename.equals(fileName + dateFormat)) {\n\t\t\t\terrorHandler.error(\"Compare \" + scheduledFilename + \" : \" + fileName + dateFormat);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// close current file, and rename it to datedFilename\n\t\t\tthis.closeFile();\n\n\t\t\t//we may have to roll over a large number of backups here\n\t        String from, to;\n\t\t\tfor (int i = 1; i <= curSizeRollBackups; i++) {\n\t\t\t\tfrom = fileName + '.' + i;\n\t\t\t\tto = scheduledFilename + '.' + i;\n\t\t\t\trollFile(from, to);\n\t        }\n\n\t\t\trollFile(fileName, scheduledFilename);\n\t\t}\n\n\t\ttry {\n\t\t\t// This will also close the file. This is OK since multiple\n\t\t\t// close operations are safe.\n\t\t\tcurSizeRollBackups = 0; //We're cleared out the old date and are ready for the new\n\n\t\t\t//new scheduled name\n\t\t\tscheduledFilename = fileName + sdf.format(now);\n\t\t\tthis.setFile(baseFileName, false);\n\t\t}\n\t\tcatch(IOException e) {\n\t\t\terrorHandler.error(\"setFile(\"+fileName+\", false) call failed.\");\n\t\t}\n\n\t}\n\n\t/** Renames file <code>from</code> to file <code>to</code>.  It\n\t *  also checks for existence of target file and deletes if it does.\n\t */\n\tprotected static void rollFile(String from, String to) {\n\t\tFile target = new File(to);\n\t\tif (target.exists()) {\n\t\t\tLogLog.debug(\"deleting existing target file: \" + target);\n\t\t\ttarget.delete();\n\t\t}\n\n\t\tFile file = new File(from);\n\t\tfile.renameTo(target);\n\t\tLogLog.debug(from +\" -> \"+ to);\n\t}\n\n\t/** Delete's the specified file if it exists */\n\tprotected static void deleteFile(String fileName) {\n\t\tFile file = new File(fileName);\n\t\tif (file.exists()) {\n\t\t   file.delete();\n\t\t}\n\t}\n\n\t/**\n\t Implements roll overs base on file size.\n\n\t <p>If the maximum number of size based backups is reached\n\t (<code>curSizeRollBackups == maxSizeRollBackups</code) then the oldest\n\t file is deleted -- it's index determined by the sign of countDirection.<br>\n\t If <code>countDirection</code> < 0, then files\n\t {<code>File.1</code>, ..., <code>File.curSizeRollBackups -1</code>}\n\t are renamed to {<code>File.2</code>, ...,\n\t <code>File.curSizeRollBackups</code>}.\t Moreover, <code>File</code> is\n\t renamed <code>File.1</code> and closed.<br>\n\n\t A new file is created to receive further log output.\n\n\t <p>If <code>maxSizeRollBackups</code> is equal to zero, then the\n\t <code>File</code> is truncated with no backup files created.\n\n\t <p>If <code>maxSizeRollBackups</code> < 0, then <code>File</code> is\n\t renamed if needed and no files are deleted.\n\t*/\n\n\t// synchronization not necessary since doAppend is alreasy synched\n\tprotected void rollOverSize() {\n\t\tFile file;\n\n\t\tthis.closeFile(); // keep windows happy.\n\n\t\tLogLog.debug(\"rolling over count=\" + ((CountingQuietWriter) qw).getCount());\n\t\tLogLog.debug(\"maxSizeRollBackups = \" + maxSizeRollBackups);\n\t\tLogLog.debug(\"curSizeRollBackups = \" + curSizeRollBackups);\n\t\tLogLog.debug(\"countDirection = \" + countDirection);\n\n\t\t// If maxBackups <= 0, then there is no file renaming to be done.\n\t\tif (maxSizeRollBackups != 0) {\n\n\t\t\tif (countDirection < 0) {\n\t\t\t\t// Delete the oldest file, to keep Windows happy.\n\t\t\t\tif (curSizeRollBackups == maxSizeRollBackups) {\n\t\t\t\t    deleteFile(fileName + '.' + maxSizeRollBackups);\n\t\t\t\t\tcurSizeRollBackups--;\n\t\t\t\t}\n\n\t\t\t\t// Map {(maxBackupIndex - 1), ..., 2, 1} to {maxBackupIndex, ..., 3, 2}\n\t\t\t\tfor (int i = curSizeRollBackups; i >= 1; i--) {\n\t\t\t\t\trollFile((fileName + \".\" + i), (fileName + '.' + (i + 1)));\n\t\t\t\t}\n\n\t\t\t\tcurSizeRollBackups++;\n\t\t\t\t// Rename fileName to fileName.1\n\t\t\t\trollFile(fileName, fileName + \".1\");\n\n\t\t\t} //REMOVE This code branching for Alexander Cerna's request\n\t\t\telse if (countDirection == 0) {\n\t\t\t\t//rollFile based on date pattern\n\t\t\t\tcurSizeRollBackups++;\n\t\t\t\tnow.setTime(System.currentTimeMillis());\n\t\t\t\tscheduledFilename = fileName + sdf.format(now);\n\t\t\t\trollFile(fileName, scheduledFilename);\n\t\t\t}\n\t\t\telse { //countDirection > 0\n\t\t\t\tif (curSizeRollBackups >= maxSizeRollBackups && maxSizeRollBackups > 0) {\n\t\t\t\t\t//delete the first and keep counting up.\n\t\t\t\t\tint oldestFileIndex = curSizeRollBackups - maxSizeRollBackups + 1;\n\t\t\t\t\tdeleteFile(fileName + '.' + oldestFileIndex);\n\t\t\t\t}\n\n\t\t\t\tif (staticLogFileName) {\n\t\t\t\t\tcurSizeRollBackups++;\n\t\t\t\t\trollFile(fileName, fileName + '.' + curSizeRollBackups);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\t// This will also close the file. This is OK since multiple\n\t\t\t// close operations are safe.\n\t\t\tthis.setFile(baseFileName, false);\n\t\t}\n\t\tcatch(IOException e) {\n\t\t\tLogLog.error(\"setFile(\"+fileName+\", false) call failed.\", e);\n\t\t}\n\t}\n\n}",
      "file_name": "CompositeRollingAppender.java",
      "human_label": "Delete the given file if it exists",
      "level": "slib_runnable",
      "lineno": "616",
      "name": "deleteFile",
      "oracle_context": "{ \"apis\" : \"[exists, delete]\", \"classes\" : \"[File]\", \"vars\" : \"[]\" }",
      "package": "org.apache.log4j",
      "project": "logging-log4j1-main"
    },
    {
      "_id": "636767691a6d9265ec0181aa",
      "all_context": "{ \"class_level\" : \"import java.io.Closeable;\\nimport java.io.IOException;\\nimport java.lang.reflect.Array;\\nimport java.util.Arrays;\\nint INITIAL_HASH;\\nint MULTIPLIER;\\nString EMPTY_STRING;\\nString NULL_STRING;\\nString ARRAY_START;\\nString ARRAY_END;\\nString EMPTY_ARRAY;\\nString ARRAY_ELEMENT_SEPARATOR;\\nObjects();\\nisCompatibleWithThrowsClause(Throwable ex,Class[] declaredExceptions);\\nisArray(Object obj);\\nisEmpty(Object[] array);\\nisEmpty(byte[] array);\\ncontainsElement(Object[] array,Object element);\\ncontainsConstant(Enum<?>[] enumValues,String constant);\\ncontainsConstant(Enum<?>[] enumValues,String constant,boolean caseSensitive);\\ncaseInsensitiveValueOf(E[] enumValues,String constant);\\naddObjectToArray(A[] array,O obj);\\ntoObjectArray(Object source);\\nnullSafeEquals(Object o1,Object o2);\\nnullSafeHashCode(Object obj);\\nnullSafeHashCode(Object[] array);\\nnullSafeHashCode(boolean[] array);\\nnullSafeHashCode(byte[] array);\\nnullSafeHashCode(char[] array);\\nnullSafeHashCode(double[] array);\\nnullSafeHashCode(float[] array);\\nnullSafeHashCode(int[] array);\\nnullSafeHashCode(long[] array);\\nnullSafeHashCode(short[] array);\\nhashCode(boolean bool);\\nhashCode(double dbl);\\nhashCode(float flt);\\nhashCode(long lng);\\nidentityToString(Object obj);\\ngetIdentityHexString(Object obj);\\ngetDisplayString(Object obj);\\nnullSafeClassName(Object obj);\\nnullSafeToString(Object obj);\\nnullSafeToString(Object[] array);\\nnullSafeToString(boolean[] array);\\nnullSafeToString(byte[] array);\\nnullSafeToString(char[] array);\\nnullSafeToString(double[] array);\\nnullSafeToString(float[] array);\\nnullSafeToString(int[] array);\\nnullSafeToString(long[] array);\\nnullSafeToString(short[] array);\\nnullSafeClose(Closeable closeables);\\nisCheckedException(Throwable ex);\\n\", \"repo_level\" : \"\" }",
      "class_name": "Objects",
      "code": "public static int nullSafeHashCode(long[] array){\n  if (array == null) {\n    return 0;\n  }\n  int hash=INITIAL_HASH;\n  int arraySize=array.length;\n  for (int i=0; i < arraySize; i++) {\n    hash=MULTIPLIER * hash + hashCode(array[i]);\n  }\n  return hash;\n}\n",
      "docstring": "/** \n * Return a hash code based on the contents of the specified array. If <code>array</code> is <code>null</code>, this method returns 0.\n * @param array the long array to obtain a hashcode\n * @return the long array's hashcode, which could be 0 if the array is null.\n */\n",
      "end_lineno": "493",
      "file_content": "/*\n * Copyright (C) 2014 jsonwebtoken.io\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.jsonwebtoken.lang;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\n\npublic final class Objects {\n\n    private Objects(){} //prevent instantiation\n\n    private static final int INITIAL_HASH = 7;\n    private static final int MULTIPLIER   = 31;\n\n    private static final String EMPTY_STRING            = \"\";\n    private static final String NULL_STRING             = \"null\";\n    private static final String ARRAY_START             = \"{\";\n    private static final String ARRAY_END               = \"}\";\n    private static final String EMPTY_ARRAY             = ARRAY_START + ARRAY_END;\n    private static final String ARRAY_ELEMENT_SEPARATOR = \", \";\n\n    /**\n     * Return whether the given throwable is a checked exception:\n     * that is, neither a RuntimeException nor an Error.\n     *\n     * @param ex the throwable to check\n     * @return whether the throwable is a checked exception\n     * @see java.lang.Exception\n     * @see java.lang.RuntimeException\n     * @see java.lang.Error\n     */\n    public static boolean isCheckedException(Throwable ex) {\n        return !(ex instanceof RuntimeException || ex instanceof Error);\n    }\n\n    /**\n     * Check whether the given exception is compatible with the exceptions\n     * declared in a throws clause.\n     *\n     * @param ex                 the exception to checked\n     * @param declaredExceptions the exceptions declared in the throws clause\n     * @return whether the given exception is compatible\n     */\n    public static boolean isCompatibleWithThrowsClause(Throwable ex, Class[] declaredExceptions) {\n        if (!isCheckedException(ex)) {\n            return true;\n        }\n        if (declaredExceptions != null) {\n            int i = 0;\n            while (i < declaredExceptions.length) {\n                if (declaredExceptions[i].isAssignableFrom(ex.getClass())) {\n                    return true;\n                }\n                i++;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns {@code true} if the specified argument is an Object or primitive array, {@code false} otherwise.\n     *\n     * @param obj the object instance to check\n     * @return {@code true} if the specified argument is an Object or primitive array, {@code false} otherwise.\n     */\n    public static boolean isArray(Object obj) {\n        return (obj != null && obj.getClass().isArray());\n    }\n\n    /**\n     * {@code true} if the specified array is null or zero length, {@code false} if populated.\n     *\n     * @param array the array to check\n     * @return {@code true} if the specified array is null or zero length, {@code false} if populated.\n     */\n    public static boolean isEmpty(Object[] array) {\n        return (array == null || array.length == 0);\n    }\n\n    /**\n     * Returns {@code true} if the specified byte array is null or of zero length, {@code false} if populated.\n     *\n     * @param array the byte array to check\n     * @return {@code true} if the specified byte array is null or of zero length, {@code false} if populated.\n     */\n    public static boolean isEmpty(byte[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * Check whether the given array contains the given element.\n     *\n     * @param array   the array to check (may be <code>null</code>,\n     *                in which case the return value will always be <code>false</code>)\n     * @param element the element to check for\n     * @return whether the element has been found in the given array\n     */\n    public static boolean containsElement(Object[] array, Object element) {\n        if (array == null) {\n            return false;\n        }\n        for (Object arrayEle : array) {\n            if (nullSafeEquals(arrayEle, element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given array of enum constants contains a constant with the given name,\n     * ignoring case when determining a match.\n     *\n     * @param enumValues the enum values to check, typically the product of a call to MyEnum.values()\n     * @param constant   the constant name to find (must not be null or empty string)\n     * @return whether the constant has been found in the given array\n     */\n    public static boolean containsConstant(Enum<?>[] enumValues, String constant) {\n        return containsConstant(enumValues, constant, false);\n    }\n\n    /**\n     * Check whether the given array of enum constants contains a constant with the given name.\n     *\n     * @param enumValues    the enum values to check, typically the product of a call to MyEnum.values()\n     * @param constant      the constant name to find (must not be null or empty string)\n     * @param caseSensitive whether case is significant in determining a match\n     * @return whether the constant has been found in the given array\n     */\n    public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive) {\n        for (Enum<?> candidate : enumValues) {\n            if (caseSensitive ?\n                candidate.toString().equals(constant) :\n                candidate.toString().equalsIgnoreCase(constant)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Case insensitive alternative to {@link Enum#valueOf(Class, String)}.\n     *\n     * @param <E>        the concrete Enum type\n     * @param enumValues the array of all Enum constants in question, usually per Enum.values()\n     * @param constant   the constant to get the enum value of\n     * @return the enum constant of the specified enum type with the specified case-insensitive name\n     * @throws IllegalArgumentException if the given constant is not found in the given array\n     *                                  of enum values. Use {@link #containsConstant(Enum[], String)} as a guard to\n     *                                  avoid this exception.\n     */\n    public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant) {\n        for (E candidate : enumValues) {\n            if (candidate.toString().equalsIgnoreCase(constant)) {\n                return candidate;\n            }\n        }\n        throw new IllegalArgumentException(\n            String.format(\"constant [%s] does not exist in enum type %s\",\n                          constant, enumValues.getClass().getComponentType().getName()));\n    }\n\n    /**\n     * Append the given object to the given array, returning a new array\n     * consisting of the input array contents plus the given object.\n     *\n     * @param array the array to append to (can be <code>null</code>)\n     * @param <A> the type of each element in the specified {@code array}\n     * @param obj   the object to append\n     * @param <O> the type of the specified object, which must equal to or extend the {@code &lt;A&gt;} type.\n     * @return the new array (of the same component type; never <code>null</code>)\n     */\n    public static <A, O extends A> A[] addObjectToArray(A[] array, O obj) {\n        Class<?> compType = Object.class;\n        if (array != null) {\n            compType = array.getClass().getComponentType();\n        } else if (obj != null) {\n            compType = obj.getClass();\n        }\n        int newArrLength = (array != null ? array.length + 1 : 1);\n        @SuppressWarnings(\"unchecked\")\n        A[] newArr = (A[]) Array.newInstance(compType, newArrLength);\n        if (array != null) {\n            System.arraycopy(array, 0, newArr, 0, array.length);\n        }\n        newArr[newArr.length - 1] = obj;\n        return newArr;\n    }\n\n    /**\n     * Convert the given array (which may be a primitive array) to an\n     * object array (if necessary of primitive wrapper objects).\n     * <p>A <code>null</code> source value will be converted to an\n     * empty Object array.\n     *\n     * @param source the (potentially primitive) array\n     * @return the corresponding object array (never <code>null</code>)\n     * @throws IllegalArgumentException if the parameter is not an array\n     */\n    public static Object[] toObjectArray(Object source) {\n        if (source instanceof Object[]) {\n            return (Object[]) source;\n        }\n        if (source == null) {\n            return new Object[0];\n        }\n        if (!source.getClass().isArray()) {\n            throw new IllegalArgumentException(\"Source is not an array: \" + source);\n        }\n        int length = Array.getLength(source);\n        if (length == 0) {\n            return new Object[0];\n        }\n        Class wrapperType = Array.get(source, 0).getClass();\n        Object[] newArray = (Object[]) Array.newInstance(wrapperType, length);\n        for (int i = 0; i < length; i++) {\n            newArray[i] = Array.get(source, i);\n        }\n        return newArray;\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for content-based equality/hash-code handling\n    //---------------------------------------------------------------------\n\n    /**\n     * Determine if the given objects are equal, returning <code>true</code>\n     * if both are <code>null</code> or <code>false</code> if only one is\n     * <code>null</code>.\n     * <p>Compares arrays with <code>Arrays.equals</code>, performing an equality\n     * check based on the array elements rather than the array reference.\n     *\n     * @param o1 first Object to compare\n     * @param o2 second Object to compare\n     * @return whether the given objects are equal\n     * @see java.util.Arrays#equals\n     */\n    public static boolean nullSafeEquals(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            }\n            if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            }\n            if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            }\n            if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            }\n            if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            }\n            if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            }\n            if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            }\n            if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            }\n            if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return as hash code for the given object; typically the value of\n     * <code>{@link Object#hashCode()}</code>. If the object is an array,\n     * this method will delegate to any of the <code>nullSafeHashCode</code>\n     * methods for arrays in this class. If the object is <code>null</code>,\n     * this method returns 0.\n     *\n     * @see #nullSafeHashCode(Object[])\n     * @see #nullSafeHashCode(boolean[])\n     * @see #nullSafeHashCode(byte[])\n     * @see #nullSafeHashCode(char[])\n     * @see #nullSafeHashCode(double[])\n     * @see #nullSafeHashCode(float[])\n     * @see #nullSafeHashCode(int[])\n     * @see #nullSafeHashCode(long[])\n     * @see #nullSafeHashCode(short[])\n     * @param obj the object to use for obtaining a hashcode\n     * @return the object's hashcode, which could be 0 if the object is null.\n     */\n    public static int nullSafeHashCode(Object obj) {\n        if (obj == null) {\n            return 0;\n        }\n        if (obj.getClass().isArray()) {\n            if (obj instanceof Object[]) {\n                return nullSafeHashCode((Object[]) obj);\n            }\n            if (obj instanceof boolean[]) {\n                return nullSafeHashCode((boolean[]) obj);\n            }\n            if (obj instanceof byte[]) {\n                return nullSafeHashCode((byte[]) obj);\n            }\n            if (obj instanceof char[]) {\n                return nullSafeHashCode((char[]) obj);\n            }\n            if (obj instanceof double[]) {\n                return nullSafeHashCode((double[]) obj);\n            }\n            if (obj instanceof float[]) {\n                return nullSafeHashCode((float[]) obj);\n            }\n            if (obj instanceof int[]) {\n                return nullSafeHashCode((int[]) obj);\n            }\n            if (obj instanceof long[]) {\n                return nullSafeHashCode((long[]) obj);\n            }\n            if (obj instanceof short[]) {\n                return nullSafeHashCode((short[]) obj);\n            }\n        }\n        return obj.hashCode();\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the array to obtain a hashcode\n     * @return the array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(Object[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + nullSafeHashCode(array[i]);\n        }\n        return hash;\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the boolean array to obtain a hashcode\n     * @return the boolean array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(boolean[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + hashCode(array[i]);\n        }\n        return hash;\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the byte array to obtain a hashcode\n     * @return the byte array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(byte[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + array[i];\n        }\n        return hash;\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the char array to obtain a hashcode\n     * @return the char array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(char[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + array[i];\n        }\n        return hash;\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the double array to obtain a hashcode\n     * @return the double array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(double[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + hashCode(array[i]);\n        }\n        return hash;\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the float array to obtain a hashcode\n     * @return the float array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(float[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + hashCode(array[i]);\n        }\n        return hash;\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the int array to obtain a hashcode\n     * @return the int array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(int[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + array[i];\n        }\n        return hash;\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the long array to obtain a hashcode\n     * @return the long array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(long[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + hashCode(array[i]);\n        }\n        return hash;\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the short array to obtain a hashcode\n     * @return the short array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(short[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + array[i];\n        }\n        return hash;\n    }\n\n    /**\n     * Return the same value as <code>{@link Boolean#hashCode()}</code>.\n     *\n     * @param bool the boolean to get a hashcode\n     * @return the same value as {@link Boolean#hashCode()}.\n     * @see Boolean#hashCode()\n     */\n    public static int hashCode(boolean bool) {\n        return bool ? 1231 : 1237;\n    }\n\n    /**\n     * Return the same value as <code>{@link Double#hashCode()}</code>.\n     *\n     * @param dbl the double to get a hashcode\n     * @return the same value as {@link Double#hashCode()}.\n     * @see Double#hashCode()\n     */\n    public static int hashCode(double dbl) {\n        long bits = Double.doubleToLongBits(dbl);\n        return hashCode(bits);\n    }\n\n    /**\n     * Return the same value as <code>{@link Float#hashCode()}</code>.\n     *\n     * @param flt the float to get a hashcode\n     * @return the same value as {@link Float#hashCode()}.\n     * @see Float#hashCode()\n     */\n    public static int hashCode(float flt) {\n        return Float.floatToIntBits(flt);\n    }\n\n    /**\n     * Return the same value as <code>{@link Long#hashCode()}</code>.\n     *\n     * @param lng the long to get a hashcode\n     * @return the same value as {@link Long#hashCode()}.\n     * @see Long#hashCode()\n     */\n    public static int hashCode(long lng) {\n        return (int) (lng ^ (lng >>> 32));\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for toString output\n    //---------------------------------------------------------------------\n\n    /**\n     * Return a String representation of an object's overall identity.\n     *\n     * @param obj the object (which may be <code>null</code>).\n     * @return the object's identity as String representation, or an empty String if the object was <code>null</code>.\n     */\n    public static String identityToString(Object obj) {\n        if (obj == null) {\n            return EMPTY_STRING;\n        }\n        return obj.getClass().getName() + \"@\" + getIdentityHexString(obj);\n    }\n\n    /**\n     * Return a hex String form of an object's identity hash code.\n     *\n     * @param obj the object\n     * @return the object's identity code in hex notation\n     */\n    public static String getIdentityHexString(Object obj) {\n        return Integer.toHexString(System.identityHashCode(obj));\n    }\n\n    /**\n     * Return a content-based String representation if <code>obj</code> is\n     * not <code>null</code>; otherwise returns an empty String.\n     * <p>Differs from {@link #nullSafeToString(Object)} in that it returns\n     * an empty String rather than \"null\" for a <code>null</code> value.\n     *\n     * @param obj the object to build a display String for\n     * @return a display String representation of <code>obj</code>\n     * @see #nullSafeToString(Object)\n     */\n    public static String getDisplayString(Object obj) {\n        if (obj == null) {\n            return EMPTY_STRING;\n        }\n        return nullSafeToString(obj);\n    }\n\n    /**\n     * Determine the class name for the given object.\n     * <p>Returns <code>\"null\"</code> if <code>obj</code> is <code>null</code>.\n     *\n     * @param obj the object to introspect (may be <code>null</code>)\n     * @return the corresponding class name\n     */\n    public static String nullSafeClassName(Object obj) {\n        return (obj != null ? obj.getClass().getName() : NULL_STRING);\n    }\n\n    /**\n     * Return a String representation of the specified Object.\n     * <p>Builds a String representation of the contents in case of an array.\n     * Returns <code>\"null\"</code> if <code>obj</code> is <code>null</code>.\n     *\n     * @param obj the object to build a String representation for\n     * @return a String representation of <code>obj</code>\n     */\n    public static String nullSafeToString(Object obj) {\n        if (obj == null) {\n            return NULL_STRING;\n        }\n        if (obj instanceof String) {\n            return (String) obj;\n        }\n        if (obj instanceof Object[]) {\n            return nullSafeToString((Object[]) obj);\n        }\n        if (obj instanceof boolean[]) {\n            return nullSafeToString((boolean[]) obj);\n        }\n        if (obj instanceof byte[]) {\n            return nullSafeToString((byte[]) obj);\n        }\n        if (obj instanceof char[]) {\n            return nullSafeToString((char[]) obj);\n        }\n        if (obj instanceof double[]) {\n            return nullSafeToString((double[]) obj);\n        }\n        if (obj instanceof float[]) {\n            return nullSafeToString((float[]) obj);\n        }\n        if (obj instanceof int[]) {\n            return nullSafeToString((int[]) obj);\n        }\n        if (obj instanceof long[]) {\n            return nullSafeToString((long[]) obj);\n        }\n        if (obj instanceof short[]) {\n            return nullSafeToString((short[]) obj);\n        }\n        String str = obj.toString();\n        return (str != null ? str : EMPTY_STRING);\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(Object[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n            sb.append(String.valueOf(array[i]));\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(boolean[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n\n            sb.append(array[i]);\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(byte[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n            sb.append(array[i]);\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(char[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n            sb.append(\"'\").append(array[i]).append(\"'\");\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(double[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n\n            sb.append(array[i]);\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(float[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n\n            sb.append(array[i]);\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(int[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n            sb.append(array[i]);\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(long[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n            sb.append(array[i]);\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(short[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n            sb.append(array[i]);\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    public static void nullSafeClose(Closeable... closeables) {\n        if (closeables == null) {\n            return;\n        }\n\n        for (Closeable closeable : closeables) {\n            if (closeable != null) {\n                try {\n                    closeable.close();\n                } catch (IOException e) {\n                    //Ignore the exception during close.\n                }\n            }\n        }\n    }\n}\n",
      "file_name": "Objects.java",
      "human_label": "Compute the hash code of the whole array, by accumulating the multiplication of each element hash code and the  MULTIPLIER.",
      "level": "class_runnable",
      "lineno": "477",
      "name": "nullSafeHashCode",
      "oracle_context": "{ \"apis\" : \"[hashCode]\", \"classes\" : \"[]\", \"vars\" : \"[length, INITIAL_HASH, MULTIPLIER]\" }",
      "package": "io.jsonwebtoken.lang",
      "project": "jjwt-master"
    },
    {
      "_id": "636767441a6d9265ec017cc1",
      "all_context": "{ \"class_level\" : \"import java.util.*;\\nTreeNode<T> virtualRoot;\\nint modCount;\\nTreeNodeIterator iterator;\\nTreeNode<T> nextNode;\\nint expectedModCount;\\nT value;\\nTreeNode<T> parent;\\nTreeNode<T> left;\\nTreeNode<T> right;\\nTreeNode<T> successor;\\nTreeNode<T> predecessor;\\nTreeNode<T> subtreeMin;\\nTreeNode<T> subtreeMax;\\nint height;\\nint subtreeSize;\\nAVLTree();\\nAVLTree(TreeNode root);\\naddMaxNode(TreeNode newMax);\\naddMin(T value);\\naddMinNode(TreeNode newMin);\\nsplitAfter(TreeNode node);\\nsplitBefore(TreeNode node);\\nmergeAfter(AVLTree tree);\\nmergeBefore(AVLTree tree);\\nremoveMin();\\nremoveMax();\\ngetRoot();\\nsuccessor(TreeNode node);\\npredecessor(TreeNode node);\\ngetMin();\\ngetMax();\\nisEmpty();\\nclear();\\ngetSize();\\nmakeRoot(TreeNode node);\\nsplit(TreeNode left,TreeNode right,TreeNode p,boolean leftMove);\\nmerge(TreeNode junctionNode,TreeNode left,TreeNode right);\\nswap(AVLTree tree);\\nrotateRight(TreeNode node);\\nrotateLeft(TreeNode node);\\nbalance(TreeNode node);\\nbalance(TreeNode node,TreeNode stop);\\nbalanceNode(TreeNode node);\\nregisterModification();\\ntoString();\\niterator();\\nnodeIterator();\\nTreeValuesIterator();\\nhasNext();\\nnext();\\nTreeNodeIterator();\\ncheckForComodification();\\nTreeNode(T value);\\ngetValue();\\ngetSubtreeMin();\\ngetSubtreeMax();\\ngetTreeMin();\\ngetTreeMax();\\ngetParent();\\ngetLeft();\\ngetRight();\\ngetHeight();\\ngetSubtreeSize();\\nreset();\\ngetRightHeight();\\ngetLeftHeight();\\ngetLeftSubtreeSize();\\ngetRightSubtreeSize();\\nupdateHeightAndSubtreeSize();\\nisLeftDoubleHeavy();\\nisRightDoubleHeavy();\\nisLeftHeavy();\\nisRightHeavy();\\nisLeftChild();\\nisRightChild();\\ngetSuccessor();\\ngetPredecessor();\\nsetSuccessor(TreeNode node);\\nsetPredecessor(TreeNode node);\\nsetLeftChild(TreeNode node);\\nsetRightChild(TreeNode node);\\nsubstituteChild(TreeNode prevChild,TreeNode newChild);\\naddMax(T value);\\n\", \"repo_level\" : \"\" }",
      "class_name": "AVLTree",
      "code": "private TreeNode<T> rotateRight(TreeNode<T> node){\n  TreeNode<T> left=node.left;\n  left.parent=null;\n  node.setLeftChild(left.right);\n  left.setRightChild(node);\n  node.updateHeightAndSubtreeSize();\n  left.updateHeightAndSubtreeSize();\n  return left;\n}\n",
      "docstring": "/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}\n */\n",
      "end_lineno": "506",
      "file_content": "/*\n * (C) Copyright 2020-2021, by Timofey Chudakov and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.util;\n\nimport java.util.*;\n\n/**\n * Implementation of the <a href=\"https://en.wikipedia.org/wiki/AVL_tree\">AVL tree</a> data\n * structure. <b>Note:</b> this tree doesn't use key comparisons, so this tree can't be used as a\n * binary search tree. This implies that the same key can be added to this tree multiple times.\n * <p>\n * AVL tree is a self-balancing binary tree data structure. In an AVL tree, the heights of two child\n * subtrees differ by at most one. This ensures that the height of the tree is $\\mathcal{O}(\\log n)$\n * where $n$ is the number of elements in the tree. Also this tree doesn't support key comparisons,\n * it does define an element order. As a result, this tree can be used to query node\n * successor/predecessor.\n * <p>\n * Subtree query means that the result is being computed only on the subtree nodes. This tree\n * supports the following operations:\n * <ul>\n * <li>Min/max insertion and deletion in $\\mathcal{O}(\\log n)$ time</li>\n * <li>Subtree min/max queries in $\\mathcal{O}(1)$ time</li>\n * <li>Node successor/predecessor queries in $\\mathcal{O}(1)$ time</li>\n * <li>Tree split in $\\mathcal{O}(\\log n)$ time</li>\n * <li>Tree merge in $\\mathcal{O}(\\log n)$ time</li>\n * </ul>\n * <p>\n * This implementation gives users access to the tree nodes which hold the inserted elements. The\n * user is able to store the tree nodes references but isn't able to modify them.\n *\n * @param <T> the key data type\n * @author Timofey Chudakov\n */\npublic class AVLTree<T>\n    implements\n    Iterable<T>\n{\n    /**\n     * An auxiliary node which's always present in a tree and doesn't contain any data.\n     */\n    private TreeNode<T> virtualRoot = new TreeNode<>(null);\n    /**\n     * Modification tracker\n     */\n    private int modCount = 0;\n\n    /**\n     * Constructs an empty tree\n     */\n    public AVLTree()\n    {\n    }\n\n    /**\n     * Constructor for internal usage\n     *\n     * @param root the root of the newly create tree\n     */\n    private AVLTree(TreeNode<T> root)\n    {\n        makeRoot(root);\n    }\n\n    /**\n     * Adds {@code value} as a maximum element to this tree. The running time of this method is\n     * $\\mathcal{O}(\\log n)$\n     *\n     * @param value a value to add as a tree max\n     * @return a tree node holding the {@code value}\n     */\n    public TreeNode<T> addMax(T value)\n    {\n        TreeNode<T> newMax = new TreeNode<>(value);\n        addMaxNode(newMax);\n        return newMax;\n    }\n\n    /**\n     * Adds the {@code newMax} as a maximum node to this tree.\n     *\n     * @param newMax a node to add as a tree max\n     */\n    public void addMaxNode(TreeNode<T> newMax)\n    {\n        registerModification();\n\n        if (isEmpty()) {\n            virtualRoot.left = newMax;\n            newMax.parent = virtualRoot;\n        } else {\n            TreeNode<T> max = getMax();\n            max.setRightChild(newMax);\n            balance(max);\n        }\n    }\n\n    /**\n     * Adds the {@code value} as a minimum element to this tree\n     *\n     * @param value a value to add as a tree min\n     * @return a tree node holding the {@code value}\n     */\n    public TreeNode<T> addMin(T value)\n    {\n        TreeNode<T> newMin = new TreeNode<>(value);\n        addMinNode(newMin);\n        return newMin;\n    }\n\n    /**\n     * Adds the {@code newMin} as a minimum node to this tree\n     *\n     * @param newMin a node to add as a tree min\n     */\n    public void addMinNode(TreeNode<T> newMin)\n    {\n        registerModification();\n        if (isEmpty()) {\n            virtualRoot.left = newMin;\n            newMin.parent = virtualRoot;\n        } else {\n            TreeNode<T> min = getMin();\n            min.setLeftChild(newMin);\n            balance(min);\n        }\n    }\n\n    /**\n     * Splits the tree into two parts.\n     * <p>\n     * The first part contains the nodes which are smaller than or equal to the {@code node}. The\n     * first part stays in this tree. The second part contains the nodes which are strictly greater\n     * than the {@code node}. The second part is returned as a tree.\n     *\n     * @param node a separating node\n     * @return a tree containing the nodes which are strictly greater than the {@code node}\n     */\n    public AVLTree<T> splitAfter(TreeNode<T> node)\n    {\n        registerModification();\n\n        TreeNode<T> parent = node.parent;\n        boolean nextMove = node.isLeftChild();\n        TreeNode<T> left = node.left;\n        TreeNode<T> right = node.right;\n\n        node.parent.substituteChild(node, null);\n\n        node.reset();\n\n        if (left != null) {\n            left.parent = null;\n        }\n        if (right != null) {\n            right.parent = null;\n        }\n\n        if (left == null) {\n            left = node;\n        } else {\n            // insert node as a left subtree max\n            TreeNode<T> t = left;\n            while (t.right != null) {\n                t = t.right;\n            }\n            t.setRightChild(node);\n\n            while (t != left) {\n                TreeNode<T> p = t.parent;\n                p.substituteChild(t, balanceNode(t));\n                t = p;\n            }\n            left = balanceNode(left);\n\n        }\n        return split(left, right, parent, nextMove);\n    }\n\n    /**\n     * Splits the tree into two parts.\n     * <p>\n     * The first part contains the nodes which are smaller than the {@code node}. The first part\n     * stays in this tree. The second part contains the nodes which are greater than or equal to the\n     * {@code node}. The second part is returned as a tree.\n     *\n     * @param node a separating node\n     * @return a tree containing the nodes which are greater than or equal to the {@code node}\n     */\n    public AVLTree<T> splitBefore(TreeNode<T> node)\n    {\n        registerModification();\n\n        TreeNode<T> predecessor = predecessor(node);\n        if (predecessor == null) {\n            // node is a minimum node\n            AVLTree<T> tree = new AVLTree<>();\n            swap(tree);\n            return tree;\n        }\n        return splitAfter(predecessor);\n    }\n\n    /**\n     * Append the nodes in the {@code tree} after the nodes in this tree.\n     * <p>\n     * The result of this operation is stored in this tree.\n     *\n     * @param tree a tree to append\n     */\n    public void mergeAfter(AVLTree<T> tree)\n    {\n        registerModification();\n        if (tree.isEmpty()) {\n            return;\n        } else if (tree.getSize() == 1) {\n            addMaxNode(tree.removeMin());\n            return;\n        }\n\n        TreeNode<T> junctionNode = tree.removeMin();\n        TreeNode<T> treeRoot = tree.getRoot();\n        tree.clear();\n\n        makeRoot(merge(junctionNode, getRoot(), treeRoot));\n    }\n\n    /**\n     * Prepends the nodes in the {@code tree} before the nodes in this tree.\n     * <p>\n     * The result of this operation is stored in this tree.\n     *\n     * @param tree a tree to prepend\n     */\n    public void mergeBefore(AVLTree<T> tree)\n    {\n        registerModification();\n\n        tree.mergeAfter(this);\n\n        swap(tree);\n    }\n\n    /**\n     * Removes the minimum node in this tree. Returns {@code null} if this tree is empty\n     *\n     * @return the removed node or {@code null} if this tree is empty\n     */\n    public TreeNode<T> removeMin()\n    {\n        registerModification();\n\n        if (isEmpty()) {\n            return null;\n        }\n        TreeNode<T> min = getMin();\n        // min.parent != null\n        if (min.parent == virtualRoot) {\n            makeRoot(min.right);\n        } else {\n            min.parent.setLeftChild(min.right);\n        }\n\n        balance(min.parent);\n\n        return min;\n    }\n\n    /**\n     * Removes the maximum node in this tree. Returns {@code null} if this tree is empty\n     *\n     * @return the removed node or {@code null} if this tree is empty\n     */\n    public TreeNode<T> removeMax()\n    {\n        registerModification();\n        if (isEmpty()) {\n            return null;\n        }\n        TreeNode<T> max = getMax();\n        if (max.parent == virtualRoot) {\n            makeRoot(max.left);\n        } else {\n            max.parent.setRightChild(max.left);\n        }\n        balance(max.parent);\n        return max;\n    }\n\n    /**\n     * Returns the root of this tree or null if this tree is empty.\n     *\n     * @return the root of this tree or null if this tree is empty.\n     */\n    public TreeNode<T> getRoot()\n    {\n        return virtualRoot.left;\n    }\n\n    /**\n     * Returns the node following the {@code node} in the order defined by this tree. Returns null\n     * if the {@code node} is the maximum node in the tree.\n     *\n     * @param node a node to compute successor of\n     * @return the successor of the {@code node}\n     */\n    public TreeNode<T> successor(TreeNode<T> node)\n    {\n        return node.successor;\n    }\n\n    /**\n     * Returns the node, which is before the {@code node} in the order defined by this tree. Returns\n     * null if the {@code node} is the minimum node in the tree.\n     *\n     * @param node a node to compute predecessor of\n     * @return the predecessor of the {@code node}\n     */\n    public TreeNode<T> predecessor(TreeNode<T> node)\n    {\n        return node.predecessor;\n    }\n\n    /**\n     * Returns the minimum node in this tree or null if the tree is empty.\n     *\n     * @return the minimum node in this tree or null if the tree is empty.\n     */\n    public TreeNode<T> getMin()\n    {\n        return getRoot() == null ? null : getRoot().getSubtreeMin();\n    }\n\n    /**\n     * Returns the maximum node in this tree or null if the tree is empty.\n     *\n     * @return the maximum node in this tree or null if the tree is empty.\n     */\n    public TreeNode<T> getMax()\n    {\n        return getRoot() == null ? null : getRoot().getSubtreeMax();\n    }\n\n    /**\n     * Check if this tree is empty\n     *\n     * @return {@code true} if this tree is empty, {@code false otherwise}\n     */\n    public boolean isEmpty()\n    {\n        return getRoot() == null;\n    }\n\n    /**\n     * Removes all nodes from this tree.\n     * <p>\n     * <b>Note:</b> the memory allocated for the tree structure won't be deallocated until there are\n     * active external referenced to the nodes of this tree.\n     */\n    public void clear()\n    {\n        registerModification();\n\n        virtualRoot.left = null;\n    }\n\n    /**\n     * Returns the size of this tree\n     *\n     * @return the size of this tree\n     */\n    public int getSize()\n    {\n        return virtualRoot.left == null ? 0 : virtualRoot.left.subtreeSize;\n    }\n\n    /**\n     * Makes the {@code node} the root of this tree\n     *\n     * @param node a new root of this tree\n     */\n    private void makeRoot(TreeNode<T> node)\n    {\n        virtualRoot.left = node;\n        if (node != null) {\n            node.subtreeMax.successor = null;\n            node.subtreeMin.predecessor = null;\n            node.parent = virtualRoot;\n        }\n    }\n\n    /**\n     * Traverses the tree up until the virtual root and splits it into two parts.\n     * <p>\n     * The algorithm is described in <i>Donald E. Knuth. The art of computer programming. Second\n     * Edition. Volume 3 / Sorting and Searching, p. 474</i>.\n     *\n     * @param left a left subtree\n     * @param right a right subtree\n     * @param p next parent node\n     * @param leftMove {@code true} if we're moving from the left child, {@code false} otherwise.\n     * @return the resulting right tree\n     */\n    private AVLTree<T> split(TreeNode<T> left, TreeNode<T> right, TreeNode<T> p, boolean leftMove)\n    {\n        while (p != virtualRoot) {\n            boolean nextMove = p.isLeftChild();\n            TreeNode<T> nextP = p.parent;\n\n            p.parent.substituteChild(p, null);\n            p.parent = null;\n\n            if (leftMove) {\n                right = merge(p, right, p.right);\n            } else {\n                left = merge(p, p.left, left);\n            }\n            p = nextP;\n            leftMove = nextMove;\n        }\n\n        makeRoot(left);\n\n        return new AVLTree<>(right);\n    }\n\n    /**\n     * Merges the {@code left} and {@code right} subtrees using the {@code junctionNode}.\n     * <p>\n     * The algorithm is described in <i>Donald E. Knuth. The art of computer programming. Second\n     * Edition. Volume 3 / Sorting and Searching, p. 474</i>.\n     *\n     * @param junctionNode a node between left and right subtrees\n     * @param left a left subtree\n     * @param right a right subtree\n     * @return the root of the resulting tree\n     */\n    private TreeNode<T> merge(TreeNode<T> junctionNode, TreeNode<T> left, TreeNode<T> right)\n    {\n        if (left == null && right == null) {\n            junctionNode.reset();\n            return junctionNode;\n        } else if (left == null) {\n            right.setLeftChild(merge(junctionNode, left, right.left));\n            return balanceNode(right);\n        } else if (right == null) {\n            left.setRightChild(merge(junctionNode, left.right, right));\n            return balanceNode(left);\n        } else if (left.getHeight() > right.getHeight() + 1) {\n            left.setRightChild(merge(junctionNode, left.right, right));\n            return balanceNode(left);\n        } else if (right.getHeight() > left.getHeight() + 1) {\n            right.setLeftChild(merge(junctionNode, left, right.left));\n            return balanceNode(right);\n        } else {\n            junctionNode.setLeftChild(left);\n            junctionNode.setRightChild(right);\n            return balanceNode(junctionNode);\n        }\n    }\n\n    /**\n     * Swaps the contents of this tree and the {@code tree}\n     *\n     * @param tree a tree to swap content of\n     */\n    private void swap(AVLTree<T> tree)\n    {\n        TreeNode<T> t = virtualRoot.left;\n        makeRoot(tree.virtualRoot.left);\n        tree.makeRoot(t);\n    }\n\n    /**\n     * Performs a right node rotation.\n     *\n     * @param node a node to rotate\n     * @return a new parent of the {@code node}\n     */\n    private TreeNode<T> rotateRight(TreeNode<T> node)\n    {\n        TreeNode<T> left = node.left;\n        left.parent = null;\n\n        node.setLeftChild(left.right);\n        left.setRightChild(node);\n\n        node.updateHeightAndSubtreeSize();\n        left.updateHeightAndSubtreeSize();\n\n        return left;\n    }\n\n    /**\n     * Performs a left node rotation.\n     *\n     * @param node a node to rotate\n     * @return a new parent of the {@code node}\n     */\n    private TreeNode<T> rotateLeft(TreeNode<T> node)\n    {\n        TreeNode<T> right = node.right;\n        right.parent = null;\n\n        node.setRightChild(right.left);\n\n        right.setLeftChild(node);\n\n        node.updateHeightAndSubtreeSize();\n        right.updateHeightAndSubtreeSize();\n\n        return right;\n    }\n\n    /**\n     * Performs a node balancing on the path from {@code node} up until the root\n     *\n     * @param node a node to start tree balancing from\n     */\n    private void balance(TreeNode<T> node)\n    {\n        balance(node, virtualRoot);\n    }\n\n    /**\n     * Performs a node balancing on the path from {@code node} up until the {@code stop} node\n     *\n     * @param node a node to start tree balancing from\n     * @param stop a node to stop balancing at (this node is not being balanced)\n     */\n    private void balance(TreeNode<T> node, TreeNode<T> stop)\n    {\n        if (node == stop) {\n            return;\n        }\n        TreeNode<T> p = node.parent;\n        if (p == virtualRoot) {\n            makeRoot(balanceNode(node));\n        } else {\n            p.substituteChild(node, balanceNode(node));\n        }\n\n        balance(p, stop);\n    }\n\n    /**\n     * Checks whether the {@code node} is unbalanced. If so, balances the {@code node}\n     *\n     * @param node a node to balance\n     * @return a new parent of {@code node} if the balancing occurs, {@code node} otherwise\n     */\n    private TreeNode<T> balanceNode(TreeNode<T> node)\n    {\n        node.updateHeightAndSubtreeSize();\n        if (node.isLeftDoubleHeavy()) {\n            if (node.left.isRightHeavy()) {\n                node.setLeftChild(rotateLeft(node.left));\n            }\n            rotateRight(node);\n            return node.parent;\n        } else if (node.isRightDoubleHeavy()) {\n            if (node.right.isLeftHeavy()) {\n                node.setRightChild(rotateRight(node.right));\n            }\n            rotateLeft(node);\n            return node.parent;\n        }\n        return node;\n    }\n\n    /**\n     * Registers a modifying operation\n     */\n    private void registerModification()\n    {\n        ++modCount;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder builder = new StringBuilder();\n        for (Iterator<TreeNode<T>> i = nodeIterator(); i.hasNext();) {\n            TreeNode<T> node = i.next();\n            builder.append(node.toString()).append(\"\\n\");\n        }\n        return builder.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Iterator<T> iterator()\n    {\n        return new TreeValuesIterator();\n    }\n\n    /**\n     * Returns an iterator over the tree nodes rather than the node values. The tree are returned in\n     * the same order as the tree values.\n     *\n     * @return an iterator over the tree nodes\n     */\n    public Iterator<TreeNode<T>> nodeIterator()\n    {\n        return new TreeNodeIterator();\n    }\n\n    /**\n     * Iterator over the values stored in this tree. This implementation uses the\n     * {@code TreeNodeIterator} to iterator over the values.\n     */\n    private class TreeValuesIterator\n        implements\n        Iterator<T>\n    {\n        /**\n         * Internally used {@code TreeNodeIterator}\n         */\n        private TreeNodeIterator iterator;\n\n        /**\n         * Constructs a new {@code TreeValuesIterator}\n         */\n        public TreeValuesIterator()\n        {\n            iterator = new TreeNodeIterator();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean hasNext()\n        {\n            return iterator.hasNext();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public T next()\n        {\n            return iterator.next().getValue();\n        }\n    }\n\n    /**\n     * Iterator over the tree nodes. The nodes are returned according to the in order tree\n     * traversal.\n     */\n    private class TreeNodeIterator\n        implements\n        Iterator<TreeNode<T>>\n    {\n        /**\n         * A node that is returned next or {@code null} if all nodes are traversed\n         */\n        private TreeNode<T> nextNode;\n        /**\n         * Number of modifications of the tree at the time this iterator is created.\n         */\n        private final int expectedModCount;\n\n        /**\n         * Constructs a new {@code TreeNodeIterator}\n         */\n        public TreeNodeIterator()\n        {\n            nextNode = getMin();\n            expectedModCount = modCount;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean hasNext()\n        {\n            checkForComodification();\n            return nextNode != null;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public TreeNode<T> next()\n        {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            TreeNode<T> result = nextNode;\n            nextNode = successor(nextNode);\n            return result;\n        }\n\n        /**\n         * Checks if the tree has been modified during the iteration process\n         */\n        private void checkForComodification()\n        {\n            if (expectedModCount != modCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n    }\n\n    /**\n     * Container holding the values stored in the tree.\n     *\n     * @param <T> a tree node value type\n     */\n    public static class TreeNode<T>\n    {\n        /**\n         * A value stored in this tree node\n         */\n        T value;\n\n        /**\n         * Parent of this node\n         */\n        TreeNode<T> parent;\n        /**\n         * Left child of this node\n         */\n        TreeNode<T> left;\n        /**\n         * Right child of this node\n         */\n        TreeNode<T> right;\n        /**\n         * Next node in the tree according to the in order traversal\n         */\n        TreeNode<T> successor;\n        /**\n         * Previous node in the tree according to the in order traversal\n         */\n        TreeNode<T> predecessor;\n        /**\n         * A minimum node in the subtree rooted at this node\n         */\n        TreeNode<T> subtreeMin;\n        /**\n         * A maximum node in the subtree rooted at this node\n         */\n        TreeNode<T> subtreeMax;\n        /**\n         * Height of the node\n         */\n        int height;\n        /**\n         * Size of the subtree rooted at this node\n         */\n        int subtreeSize;\n\n        /**\n         * Constructs a new node with the {@code value} stored in it\n         *\n         * @param value a value to store in this node\n         */\n        TreeNode(T value)\n        {\n            this.value = value;\n            reset();\n        }\n\n        /**\n         * Returns a value stored in this node\n         *\n         * @return a value stored in this node\n         */\n        public T getValue()\n        {\n            return value;\n        }\n\n        /**\n         * Returns a root of the tree this node is stored in\n         *\n         * @return a root of the tree this node is stored in\n         */\n        public TreeNode<T> getRoot()\n        {\n            TreeNode<T> current = this;\n            while (current.parent != null) {\n                current = current.parent;\n            }\n            return current.left;\n        }\n\n        /**\n         * Returns a minimum node stored in the subtree rooted at this node\n         *\n         * @return a minimum node stored in the subtree rooted at this node\n         */\n        public TreeNode<T> getSubtreeMin()\n        {\n            return subtreeMin;\n        }\n\n        /**\n         * Returns a maximum node stored in the subtree rooted at this node\n         *\n         * @return a maximum node stored in the subtree rooted at this node\n         */\n        public TreeNode<T> getSubtreeMax()\n        {\n            return subtreeMax;\n        }\n\n        /**\n         * Returns a minimum node stored in the tree\n         *\n         * @return a minimum node stored in the tree\n         */\n        public TreeNode<T> getTreeMin()\n        {\n            return getRoot().getSubtreeMin();\n        }\n\n        /**\n         * Returns a maximum node stored in the tree\n         *\n         * @return a maximum node stored in the tree\n         */\n        public TreeNode<T> getTreeMax()\n        {\n            return getRoot().getSubtreeMax();\n        }\n\n        /**\n         * Returns a parent of this node\n         *\n         * @return a parent of this node\n         */\n        public TreeNode<T> getParent()\n        {\n            return parent;\n        }\n\n        /**\n         * Returns a left child of this node\n         *\n         * @return a left child of this node\n         */\n        public TreeNode<T> getLeft()\n        {\n            return left;\n        }\n\n        /**\n         * Returns a right child of this node\n         *\n         * @return a right child of this node\n         */\n        public TreeNode<T> getRight()\n        {\n            return right;\n        }\n\n        /**\n         * Returns a height of this node\n         *\n         * @return a height of this node\n         */\n        int getHeight()\n        {\n            return height;\n        }\n\n        /**\n         * Returns a subtree size of the tree rooted at this node\n         *\n         * @return a subtree size of the tree rooted at this node\n         */\n        int getSubtreeSize()\n        {\n            return subtreeSize;\n        }\n\n        /**\n         * Resets this node to the default state\n         */\n        void reset()\n        {\n            this.height = 1;\n            this.subtreeSize = 1;\n            this.subtreeMin = this;\n            this.subtreeMax = this;\n            this.left = this.right = this.parent = this.predecessor = this.successor = null;\n        }\n\n        /**\n         * Returns a height of the right subtree\n         *\n         * @return a height of the right subtree\n         */\n        int getRightHeight()\n        {\n            return right == null ? 0 : right.height;\n        }\n\n        /**\n         * Returns a height of the left subtree\n         *\n         * @return a height of the right subtree\n         */\n        int getLeftHeight()\n        {\n            return left == null ? 0 : left.height;\n        }\n\n        /**\n         * Returns a size of the left subtree\n         *\n         * @return a size of the left subtree\n         */\n        int getLeftSubtreeSize()\n        {\n            return left == null ? 0 : left.subtreeSize;\n        }\n\n        /**\n         * Returns a size of the right subtree\n         *\n         * @return a size of the right subtree\n         */\n        int getRightSubtreeSize()\n        {\n            return right == null ? 0 : right.subtreeSize;\n        }\n\n        /**\n         * Updates the height and subtree size of this node according to the values of the left and\n         * right children\n         */\n        void updateHeightAndSubtreeSize()\n        {\n            height = Math.max(getLeftHeight(), getRightHeight()) + 1;\n            subtreeSize = getLeftSubtreeSize() + getRightSubtreeSize() + 1;\n        }\n\n        /**\n         * Returns {@code true} if this node is unbalanced and the left child's height is greater,\n         * {@code false otherwise}\n         *\n         * @return {@code true} if this node is unbalanced and the left child's height is greater,\n         *         {@code false otherwise}\n         */\n        boolean isLeftDoubleHeavy()\n        {\n            return getLeftHeight() > getRightHeight() + 1;\n        }\n\n        /**\n         * Returns {@code true} if this node is unbalanced and the right child's height is greater,\n         * {@code false otherwise}\n         *\n         * @return {@code true} if this node is unbalanced and the right child's height is greater,\n         *         {@code false otherwise}\n         */\n        boolean isRightDoubleHeavy()\n        {\n            return getRightHeight() > getLeftHeight() + 1;\n        }\n\n        /**\n         * Returns {@code true} if the height of the left child is greater than the height of the\n         * right child\n         *\n         * @return {@code true} if the height of the left child is greater than the height of the\n         *         right child\n         */\n        boolean isLeftHeavy()\n        {\n            return getLeftHeight() > getRightHeight();\n        }\n\n        /**\n         * Returns {@code true} if the height of the right child is greater than the height of the\n         * left child\n         *\n         * @return {@code true} if the height of the right child is greater than the height of the\n         *         left child\n         */\n        boolean isRightHeavy()\n        {\n            return getRightHeight() > getLeftHeight();\n        }\n\n        /**\n         * Returns {@code true} if this node is a left child of its parent, {@code false} otherwise\n         *\n         * @return {@code true} if this node is a left child of its parent, {@code false} otherwise\n         */\n        boolean isLeftChild()\n        {\n            return this == parent.left;\n        }\n\n        /**\n         * Returns {@code true} if this node is a right child of its parent, {@code false} otherwise\n         *\n         * @return {@code true} if this node is a right child of its parent, {@code false} otherwise\n         */\n        boolean isRightChild()\n        {\n            return this == parent.right;\n        }\n\n        /**\n         * Returns a successor of this node according to the tree in order traversal, or\n         * {@code null} if this node is a maximum node in the tree\n         *\n         * @return successor of this node, or {@code} null if this node in a maximum node in the\n         *         tree\n         */\n        public TreeNode<T> getSuccessor()\n        {\n            return successor;\n        }\n\n        /**\n         * Returns a predecessor of this node according to the tree in order traversal, or\n         * {@code null} if this node is a minimum node in the tree\n         *\n         * @return predecessor of this node, or {@code} null if this node in a minimum node in the\n         *         tree\n         */\n        public TreeNode<T> getPredecessor()\n        {\n            return predecessor;\n        }\n\n        /**\n         * Updates the successor reference of this node. If the {@code node} is not {@code null},\n         * updates its predecessor reference as well\n         *\n         * @param node new successor\n         */\n        void setSuccessor(TreeNode<T> node)\n        {\n            successor = node;\n            if (node != null) {\n                node.predecessor = this;\n            }\n        }\n\n        /**\n         * Updates the predecessor reference of this node. If the {@code node} is not {@code null},\n         * updates its successor reference as well\n         *\n         * @param node new predecessor\n         */\n        void setPredecessor(TreeNode<T> node)\n        {\n            predecessor = node;\n            if (node != null) {\n                node.successor = this;\n            }\n        }\n\n        /**\n         * Sets the left child reference of this node to {@code node}. If the {@code node} is not\n         * {@code null}, updates its parent reference as well.\n         *\n         * @param node a new left child\n         */\n        void setLeftChild(TreeNode<T> node)\n        {\n            left = node;\n            if (node != null) {\n                node.parent = this;\n                setPredecessor(node.subtreeMax);\n                subtreeMin = node.subtreeMin;\n            } else {\n                subtreeMin = this;\n                predecessor = null;\n            }\n        }\n\n        /**\n         * Sets the right child reference of this node to {@code node}. If the {@code node} is not\n         * {@code null}, updates its parent reference as well.\n         *\n         * @param node a new right child\n         */\n        void setRightChild(TreeNode<T> node)\n        {\n            right = node;\n            if (node != null) {\n                node.parent = this;\n                setSuccessor(node.subtreeMin);\n                subtreeMax = node.subtreeMax;\n            } else {\n                successor = null;\n                subtreeMax = this;\n            }\n        }\n\n        /**\n         * Substitutes the {@code prevChild} with the {@code newChild}. If the {@code newChild} is\n         * not {@code null}, updates its parent reference as well\n         *\n         * @param prevChild either left or right child of this node\n         * @param newChild a new child of this node\n         */\n        void substituteChild(TreeNode<T> prevChild, TreeNode<T> newChild)\n        {\n            assert left == prevChild || right == prevChild;\n            assert !(left == prevChild && right == prevChild);\n            if (left == prevChild) {\n                setLeftChild(newChild);\n            } else {\n                setRightChild(newChild);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            return String\n                .format(\n                    \"{%s}: [parent = %s, left = %s, right = %s], [subtreeMin = %s, subtreeMax = %s], [predecessor = %s, successor = %s], [height = %d, subtreeSize = %d]\",\n                    value, parent == null ? \"null\" : parent.value,\n                    left == null ? \"null\" : left.value, right == null ? \"null\" : right.value,\n                    subtreeMin == null ? \"null\" : subtreeMin.value,\n                    subtreeMax == null ? \"null\" : subtreeMax.value,\n                    predecessor == null ? \"null\" : predecessor.value,\n                    successor == null ? \"null\" : successor.value, height, subtreeSize);\n        }\n    }\n\n}\n",
      "file_name": "AVLTree.java",
      "human_label": "Perform a right node rotation on the AVL tree.",
      "level": "file_runnable",
      "lineno": "488",
      "name": "rotateRight",
      "oracle_context": "{ \"apis\" : \"[setLeftChild, setRightChild, updateHeightAndSubtreeSize, TreeNode]\", \"classes\" : \"[TreeNode<T>]\", \"vars\" : \"[parent, right]\" }",
      "package": "org.jgrapht.util",
      "project": "jgrapht-master"
    },
    {
      "_id": "6367667f1a6d9265ec01745c",
      "all_context": "{ \"class_level\" : \"import org.slf4j.Logger;\\nimport org.slf4j.LoggerFactory;\\nimport java.io.File;\\nimport java.io.FilenameFilter;\\nimport java.io.IOException;\\nimport java.lang.reflect.Method;\\nimport java.net.InetAddress;\\nimport java.net.MalformedURLException;\\nimport java.net.URL;\\nimport java.net.UnknownHostException;\\nimport java.util.Hashtable;\\nimport java.util.StringTokenizer;\\nimport java.util.Vector;\\nLogger logger;\\nHashtable<Class<?>,Method[]> objectMethods;\\nObject[] emptyArray;\\nint dbg;\\nsetAttribute(Object proxy,String name,Object value);\\ngetAttribute(Object proxy,String name);\\nsetProperty(Object o,String name,String value);\\naddProperty(Object o,String name,String value);\\ninvokeProperty(Object object,String setter,String name,String value);\\ngetProperty(Object object,String name);\\nsetProperty(Object object,String name);\\nreplaceProperties(String value,Hashtable staticProp,PropertySource dynamicProp);\\ncapitalize(String name);\\nunCapitalize(String name);\\naddToClassPath(Vector cpV,String dir);\\naddToolsJar(Vector v);\\ngetFilesByExt(String ld,String ext);\\naccept(File d,String name);\\ngetURL(String base,String file);\\naddJarsFromClassPath(Vector jars,String cp);\\ngetClassPath(Vector v);\\ngetClassPath(String dir,String cpath,String cpathProp,boolean addTools);\\nprocessArgs(Object proxy,String args);\\nprocessArgs(Object proxy,String args,String args0,String args1,Hashtable aliases);\\nclear();\\nfindVoidSetters(Class c);\\nfindBooleanSetters(Class c);\\nfindMethods(Class c);\\nfindMethod(Class c,String name,Class params);\\nhasHook(Object obj,String methodN);\\ncallMain(Class c,String args);\\ncallMethod1(Object target,String methodN,Object param1,String typeParam1,ClassLoader cl);\\ncallMethod0(Object target,String methodN);\\ncallMethodN(Object target,String methodN,Object params,Class typeParams);\\nconvert(String object,Class paramType);\\ngetProperty(String key);\\nsetAttribute(String key,Object o);\\ndebug(String s);\\nexecute(Object proxy,String method);\\n\", \"repo_level\" : \"\" }",
      "class_name": "IntrospectionUtils",
      "code": "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n  try {\n    String cpComp[]=getFilesByExt(dir,\".jar\");\n    if (cpComp != null) {\n      int jarCount=cpComp.length;\n      for (int i=0; i < jarCount; i++) {\n        URL url=getURL(dir,cpComp[i]);\n        if (url != null)         cpV.addElement(url);\n      }\n    }\n  }\n catch (  Exception ex) {\n    logger.debug(\"failed to add urls to classpath\",ex);\n  }\n}\n",
      "docstring": "/** \n * Add all the jar files in a dir to the classpath, represented as a Vector of URLs.\n */\n",
      "end_lineno": "416",
      "file_content": "/*\n * Copyright 2008-2022 Async-IO.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n/*\n * This file incorporates work covered by the following copyright and\n * permission notice:\n *\n * Copyright 2004 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.atmosphere.util;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.net.InetAddress;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.Hashtable;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n/**\n * Utils for introspection and reflection\n */\npublic final class IntrospectionUtils {\n\n    private static final Logger logger = LoggerFactory.getLogger(IntrospectionUtils.class);\n\n    /**\n     * Call execute() - any ant-like task should work\n     */\n    public static void execute(Object proxy, String method) throws Exception {\n        Method executeM = null;\n        Class<?> c = proxy.getClass();\n        Class<?> params[] = new Class[0];\n        //    params[0]=args.getClass();\n        executeM = findMethod(c, method, params);\n        if (executeM == null) {\n            throw new RuntimeException(\"No execute in \" + proxy.getClass());\n        }\n        executeM.invoke(proxy, (Object[]) null);//new Object[] { args });\n    }\n\n    /**\n     * Call void setAttribute( String ,Object )\n     */\n    public static void setAttribute(Object proxy, String name, Object value)\n            throws Exception {\n        if (proxy instanceof AttributeHolder) {\n            ((AttributeHolder) proxy).setAttribute(name, value);\n            return;\n        }\n\n        Method executeM = null;\n        Class<?> c = proxy.getClass();\n        Class<?> params[] = new Class[2];\n        params[0] = String.class;\n        params[1] = Object.class;\n        executeM = findMethod(c, \"setAttribute\", params);\n        if (executeM == null) {\n            logger.debug(\"No setAttribute in {}\", proxy.getClass());\n            return;\n        }\n\n        logger.debug(\"Setting {}={} in proxy: {}\", new Object[]{name, value, proxy});\n        executeM.invoke(proxy, new Object[]{name, value});\n        return;\n    }\n\n    /**\n     * Call void getAttribute( String )\n     */\n    public static Object getAttribute(Object proxy, String name) throws Exception {\n        Class<?> c = proxy.getClass();\n        Class<?> params[] = new Class[1];\n        params[0] = String.class;\n        Method executeM = findMethod(c, \"getAttribute\", params);\n        if (executeM == null) {\n            logger.debug(\"No getAttribute in {}\", proxy.getClass());\n            return null;\n        }\n        return executeM.invoke(proxy, new Object[]{name});\n    }\n\n\n    /**\n     * Find a method with the right name If found, call the method ( if param is\n     * int or boolean we'll convert value to the right type before) - that means\n     * you can have setDebug(1).\n     */\n    final public static boolean setProperty(Object o, String name, String value) {\n        String setter = \"set\" + capitalize(name);\n        return invokeProperty(o, setter, name, value);\n    }\n\n    final public static boolean addProperty(Object o, String name, String value) {\n        String setter = \"add\" + capitalize(name);\n        return invokeProperty(o, setter, name, value);\n    }\n\n    final static public boolean invokeProperty(Object object, String setter, String name, String value) {\n        try {\n            Method methods[] = findMethods(object.getClass());\n            Method setPropertyMethodVoid = null;\n            Method setPropertyMethodBool = null;\n\n            // First, the ideal case - a setFoo( String ) method\n            for (int i = 0; i < methods.length; i++) {\n                Class<?> paramT[] = methods[i].getParameterTypes();\n                if (setter.equals(methods[i].getName()) && paramT.length == 1\n                        && \"java.lang.String\".equals(paramT[0].getName())) {\n\n                    methods[i].invoke(object, new Object[]{value});\n                    return true;\n                }\n            }\n\n            // Try a setFoo ( int ) or ( boolean )\n            for (int i = 0; i < methods.length; i++) {\n                boolean ok = true;\n                if (setter.equals(methods[i].getName())\n                        && methods[i].getParameterTypes().length == 1) {\n\n                    // match - find the type and invoke it\n                    Class<?> paramType = methods[i].getParameterTypes()[0];\n                    Object params[] = new Object[1];\n\n                    // Try a setFoo ( int )\n                    if (\"java.lang.Integer\".equals(paramType.getName())\n                            || \"int\".equals(paramType.getName())) {\n                        try {\n                            params[0] = new Integer(value);\n                        } catch (NumberFormatException ex) {\n                            ok = false;\n                        }\n                        // Try a setFoo ( long )\n                    } else if (\"java.lang.Long\".equals(paramType.getName())\n                            || \"long\".equals(paramType.getName())) {\n                        try {\n                            params[0] = new Long(value);\n                        } catch (NumberFormatException ex) {\n                            ok = false;\n                        }\n\n                        // Try a setFoo ( boolean )\n                    } else if (\"java.lang.Boolean\".equals(paramType.getName())\n                            || \"boolean\".equals(paramType.getName())) {\n                        params[0] = new Boolean(value);\n\n                        // Try a setFoo ( InetAddress )\n                    } else if (\"java.net.InetAddress\".equals(paramType\n                            .getName())) {\n                        try {\n                            params[0] = InetAddress.getByName(value);\n                        } catch (UnknownHostException exc) {\n                            debug(\"Unable to resolve host name:\" + value);\n                            ok = false;\n                        }\n\n                        // Unknown type\n                    } else {\n                        debug(\"Unknown type \" + paramType.getName());\n                    }\n\n                    if (ok) {\n                        methods[i].invoke(object, params);\n                        return true;\n                    }\n                }\n\n                // save \"setProperty\" for later\n                if (\"setProperty\".equals(methods[i].getName())) {\n                    if (methods[i].getReturnType() == Boolean.TYPE) {\n                        setPropertyMethodBool = methods[i];\n                    } else {\n                        setPropertyMethodVoid = methods[i];\n                    }\n\n                }\n            }\n\n            // Ok, no setXXX found, try a setProperty(\"name\", \"value\")\n            if (setPropertyMethodBool != null || setPropertyMethodVoid != null) {\n                Object params[] = new Object[2];\n                params[0] = name;\n                params[1] = value;\n                if (setPropertyMethodBool != null) {\n                    try {\n                        return (Boolean) setPropertyMethodBool.invoke(object, params);\n                    } catch (IllegalArgumentException biae) {\n                        //the boolean method had the wrong\n                        //parameter types. lets try the other\n                        if (setPropertyMethodVoid != null) {\n                            setPropertyMethodVoid.invoke(object, params);\n                            return true;\n                        } else {\n                            throw biae;\n                        }\n                    }\n                } else {\n                    setPropertyMethodVoid.invoke(object, params);\n                    return true;\n                }\n            }\n\n        } catch (IllegalArgumentException e) {\n            logger.info(\"failed, object: \" + object + \", setter: \" + setter + \", value: \" + value, e);\n        } catch (Exception e) {\n            if (dbg > 0) {\n                debug(e.getClass().getSimpleName() + \" for \" + object.getClass() + \" \" + setter + \"=\" + value + \")\");\n            }\n            if (dbg > 1) {\n                logger.debug(\"\", e);\n            }\n        }\n\n        return false;\n    }\n\n    public static Object getProperty(Object object, String name) {\n        String getter = \"get\" + capitalize(name);\n        String isGetter = \"is\" + capitalize(name);\n\n        try {\n            Method methods[] = findMethods(object.getClass());\n            Method getPropertyMethod = null;\n\n            // First, the ideal case - a getFoo() method\n            for (int i = 0; i < methods.length; i++) {\n                Class<?> paramT[] = methods[i].getParameterTypes();\n                if (getter.equals(methods[i].getName()) && paramT.length == 0) {\n                    return methods[i].invoke(object, (Object[]) null);\n                }\n                if (isGetter.equals(methods[i].getName()) && paramT.length == 0) {\n                    return methods[i].invoke(object, (Object[]) null);\n                }\n\n                if (\"getProperty\".equals(methods[i].getName())) {\n                    getPropertyMethod = methods[i];\n                }\n            }\n\n            // Ok, no setXXX found, try a getProperty(\"name\")\n            if (getPropertyMethod != null) {\n                Object params[] = new Object[1];\n                params[0] = name;\n                return getPropertyMethod.invoke(object, params);\n            }\n\n        } catch (IllegalArgumentException e) {\n            logger.info(\"failed, object: \" + object + \", name: \" + name, e);\n        } catch (Exception e) {\n            if (dbg > 0) {\n                debug(e.getClass().getSimpleName() + \" for \" + object.getClass() + \" \" + name + \")\");\n            }\n            if (dbg > 1) {\n                logger.debug(\"\", e);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     */\n    public static void setProperty(Object object, String name) {\n        String setter = \"set\" + capitalize(name);\n        try {\n            Method methods[] = findMethods(object.getClass());\n            Method setPropertyMethod = null;\n            // find setFoo() method\n            for (int i = 0; i < methods.length; i++) {\n                Class<?> paramT[] = methods[i].getParameterTypes();\n                if (setter.equals(methods[i].getName()) && paramT.length == 0) {\n                    methods[i].invoke(object, new Object[]{});\n                    return;\n                }\n            }\n        } catch (Exception e) {\n            if (dbg > 0) {\n                debug(\"Exception for \" + object.getClass() + \" \" + name);\n            }\n            if (dbg > 1) {\n                logger.debug(\"\", e);\n            }\n        }\n    }\n\n    /**\n     * Replace ${NAME} with the property value\n     */\n    public static String replaceProperties(String value,\n                                           Hashtable<String, String> staticProp, PropertySource dynamicProp[]) {\n        if (value.indexOf(\"$\") < 0) {\n            return value;\n        }\n        StringBuilder sb = new StringBuilder();\n        int prev = 0;\n        // assert value!=nil\n        int pos;\n        while ((pos = value.indexOf(\"$\", prev)) >= 0) {\n            if (pos > 0) {\n                sb.append(value.substring(prev, pos));\n            }\n            if (pos == (value.length() - 1)) {\n                sb.append('$');\n                prev = pos + 1;\n            } else if (value.charAt(pos + 1) != '{') {\n                sb.append('$');\n                prev = pos + 1; // XXX\n            } else {\n                int endName = value.indexOf('}', pos);\n                if (endName < 0) {\n                    sb.append(value.substring(pos));\n                    prev = value.length();\n                    continue;\n                }\n                String n = value.substring(pos + 2, endName);\n                String v = null;\n                if (staticProp != null) {\n                    v = staticProp.get(n);\n                }\n                if (v == null && dynamicProp != null) {\n                    for (int i = 0; i < dynamicProp.length; i++) {\n                        v = dynamicProp[i].getProperty(n);\n                        if (v != null) {\n                            break;\n                        }\n                    }\n                }\n                if (v == null)\n                    v = \"${\" + n + \"}\";\n\n                sb.append(v);\n                prev = endName + 1;\n            }\n        }\n        if (prev < value.length())\n            sb.append(value.substring(prev));\n        return sb.toString();\n    }\n\n    /**\n     * Reverse of Introspector.decapitalize\n     */\n    public static String capitalize(String name) {\n        if (name == null || name.length() == 0) {\n            return name;\n        }\n        char chars[] = name.toCharArray();\n        chars[0] = Character.toUpperCase(chars[0]);\n        return new String(chars);\n    }\n\n    public static String unCapitalize(String name) {\n        if (name == null || name.length() == 0) {\n            return name;\n        }\n        char chars[] = name.toCharArray();\n        chars[0] = Character.toLowerCase(chars[0]);\n        return new String(chars);\n    }\n\n    // -------------------- Class path tools --------------------\n\n    /**\n     * Add all the jar files in a dir to the classpath, represented as a Vector\n     * of URLs.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static void addToClassPath(Vector<URL> cpV, String dir) {\n        try {\n            String cpComp[] = getFilesByExt(dir, \".jar\");\n            if (cpComp != null) {\n                int jarCount = cpComp.length;\n                for (int i = 0; i < jarCount; i++) {\n                    URL url = getURL(dir, cpComp[i]);\n                    if (url != null)\n                        cpV.addElement(url);\n                }\n            }\n        } catch (Exception ex) {\n            logger.debug(\"failed to add urls to classpath\", ex);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static void addToolsJar(Vector<URL> v) {\n        try {\n            // Add tools.jar in any case\n            File f = new File(System.getProperty(\"java.home\")\n                    + \"/../lib/tools.jar\");\n\n            if (!f.exists()) {\n                // On some systems java.home gets set to the root of jdk.\n                // That's a bug, but we can work around and be nice.\n                f = new File(System.getProperty(\"java.home\") + \"/lib/tools.jar\");\n                if (f.exists()) {\n                    logger.debug(\"Detected strange java.home value {}, it should point to jre\",\n                            System.getProperty(\"java.home\"));\n                }\n            }\n            URL url = new URL(\"file\", \"\", f.getAbsolutePath());\n\n            v.addElement(url);\n        } catch (MalformedURLException ex) {\n            logger.debug(\"failed to add tools jar url to vector\", ex);\n        }\n    }\n\n    /**\n     * Return all files with a given extension in a dir\n     */\n    public static String[] getFilesByExt(String ld, String ext) {\n        File dir = new File(ld);\n        String[] names = null;\n        final String lext = ext;\n        if (dir.isDirectory()) {\n            names = dir.list(new FilenameFilter() {\n                public boolean accept(File d, String name) {\n                    if (name.endsWith(lext)) {\n                        return true;\n                    }\n                    return false;\n                }\n            });\n        }\n        return names;\n    }\n\n    /**\n     * Construct a file url from a file, using a base dir\n     */\n    public static URL getURL(String base, String file) {\n        try {\n            File baseF = new File(base);\n            File f = new File(baseF, file);\n            String path = f.getCanonicalPath();\n            if (f.isDirectory()) {\n                path += \"/\";\n            }\n            if (!f.exists()) {\n                return null;\n            }\n            return new URL(\"file\", \"\", path);\n        } catch (Exception ex) {\n            logger.debug(\"failed to get url, base: \" + base + \", file: \" + file, ex);\n            return null;\n        }\n    }\n\n    /**\n     * Add elements from the classpath <i>cp </i> to a Vector <i>jars </i> as\n     * file URLs (We use Vector for JDK 1.1 compat).\n     * <p/>\n     *\n     * @param jars The jar list\n     * @param cp   a String classpath of directory or jar file elements\n     *             separated by path.separator delimiters.\n     * @throws IOException           If an I/O error occurs\n     * @throws MalformedURLException Doh ;)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static void addJarsFromClassPath(Vector<URL> jars, String cp)\n            throws IOException, MalformedURLException {\n        String sep = System.getProperty(\"path.separator\");\n        String token;\n        StringTokenizer st;\n        if (cp != null) {\n            st = new StringTokenizer(cp, sep);\n            while (st.hasMoreTokens()) {\n                File f = new File(st.nextToken());\n                String path = f.getCanonicalPath();\n                if (f.isDirectory()) {\n                    path += \"/\";\n                }\n                URL url = new URL(\"file\", \"\", path);\n                if (!jars.contains(url)) {\n                    jars.addElement(url);\n                }\n            }\n        }\n    }\n\n    /**\n     * Return a URL[] that can be used to construct a class loader\n     */\n    public static URL[] getClassPath(Vector<URL> v) {\n        URL[] urls = new URL[v.size()];\n        for (int i = 0; i < v.size(); i++) {\n            urls[i] = v.elementAt(i);\n        }\n        return urls;\n    }\n\n    /**\n     * Construct a URL classpath from files in a directory, a cpath property,\n     * and tools.jar.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static URL[] getClassPath(String dir, String cpath,\n                                     String cpathProp, boolean addTools) throws IOException,\n            MalformedURLException {\n        Vector<URL> jarsV = new Vector<URL>();\n        if (dir != null) {\n            // Add dir/classes first, if it exists\n            URL url = getURL(dir, \"classes\");\n            if (url != null)\n                jarsV.addElement(url);\n            addToClassPath(jarsV, dir);\n        }\n\n        if (cpath != null)\n            addJarsFromClassPath(jarsV, cpath);\n\n        if (cpathProp != null) {\n            String cpath1 = System.getProperty(cpathProp);\n            addJarsFromClassPath(jarsV, cpath1);\n        }\n\n        if (addTools)\n            addToolsJar(jarsV);\n\n        return getClassPath(jarsV);\n    }\n\n    // -------------------- Mapping command line params to setters\n\n    public static boolean processArgs(Object proxy, String args[])\n            throws Exception {\n        String args0[] = null;\n        if (null != findMethod(proxy.getClass(), \"getOptions1\", new Class[]{})) {\n            args0 = (String[]) callMethod0(proxy, \"getOptions1\");\n        }\n\n        if (args0 == null) {\n            //args0=findVoidSetters(proxy.getClass());\n            args0 = findBooleanSetters(proxy.getClass());\n        }\n        Hashtable<String, String> h = null;\n        if (null != findMethod(proxy.getClass(), \"getOptionAliases\",\n                new Class[]{})) {\n            h = (Hashtable<String, String>) callMethod0(proxy, \"getOptionAliases\");\n        }\n        return processArgs(proxy, args, args0, null, h);\n    }\n\n    public static boolean processArgs(Object proxy, String args[],\n                                      String args0[], String args1[],\n                                      Hashtable<String, String> aliases) throws Exception {\n        for (int i = 0; i < args.length; i++) {\n            String arg = args[i];\n            if (arg.startsWith(\"-\"))\n                arg = arg.substring(1);\n            if (aliases != null && aliases.get(arg) != null)\n                arg = aliases.get(arg);\n\n            if (args0 != null) {\n                boolean set = false;\n                for (int j = 0; j < args0.length; j++) {\n                    if (args0[j].equalsIgnoreCase(arg)) {\n                        setProperty(proxy, args0[j], \"true\");\n                        set = true;\n                        break;\n                    }\n                }\n                if (set)\n                    continue;\n            }\n            if (args1 != null) {\n                for (int j = 0; j < args1.length; j++) {\n                    if (args1[j].equalsIgnoreCase(arg)) {\n                        i++;\n                        if (i >= args.length)\n                            return false;\n                        setProperty(proxy, arg, args[i]);\n                        break;\n                    }\n                }\n            } else {\n                // if args1 is not specified,assume all other options have param\n                i++;\n                if (i >= args.length)\n                    return false;\n                setProperty(proxy, arg, args[i]);\n            }\n\n        }\n        return true;\n    }\n\n    // -------------------- other utils --------------------\n\n    public static void clear() {\n        objectMethods.clear();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static String[] findVoidSetters(Class<?> c) {\n        Method m[] = findMethods(c);\n        if (m == null)\n            return null;\n        Vector<String> v = new Vector<String>();\n        for (int i = 0; i < m.length; i++) {\n            if (m[i].getName().startsWith(\"set\")\n                    && m[i].getParameterTypes().length == 0) {\n                String arg = m[i].getName().substring(3);\n                v.addElement(unCapitalize(arg));\n            }\n        }\n        String s[] = new String[v.size()];\n        for (int i = 0; i < s.length; i++) {\n            s[i] = (String) v.elementAt(i);\n        }\n        return s;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static String[] findBooleanSetters(Class<?> c) {\n        Method m[] = findMethods(c);\n        if (m == null)\n            return null;\n        Vector<String> v = new Vector<String>();\n        for (int i = 0; i < m.length; i++) {\n            if (m[i].getName().startsWith(\"set\")\n                    && m[i].getParameterTypes().length == 1\n                    && \"boolean\".equalsIgnoreCase(m[i].getParameterTypes()[0]\n                    .getName())) {\n                String arg = m[i].getName().substring(3);\n                v.addElement(unCapitalize(arg));\n            }\n        }\n        String s[] = new String[v.size()];\n        for (int i = 0; i < s.length; i++) {\n            s[i] = v.elementAt(i);\n        }\n        return s;\n    }\n\n    static Hashtable<Class<?>, Method[]> objectMethods =\n            new Hashtable<Class<?>, Method[]>();\n\n    @SuppressWarnings(\"unchecked\")\n    public static Method[] findMethods(Class<?> c) {\n        Method methods[] = (Method[]) objectMethods.get(c);\n        if (methods != null)\n            return methods;\n\n        methods = c.getMethods();\n        objectMethods.put(c, methods);\n        return methods;\n    }\n\n    public static Method findMethod(Class<?> c, String name,\n                                    Class<?> params[]) {\n        Method methods[] = findMethods(c);\n        if (methods == null)\n            return null;\n        for (int i = 0; i < methods.length; i++) {\n            if (methods[i].getName().equals(name)) {\n                Class<?> methodParams[] = methods[i].getParameterTypes();\n                if (methodParams == null)\n                    if (params == null || params.length == 0)\n                        return methods[i];\n                if (params == null)\n                    if (methodParams == null || methodParams.length == 0)\n                        return methods[i];\n                if (params.length != methodParams.length)\n                    continue;\n                boolean found = true;\n                for (int j = 0; j < params.length; j++) {\n                    if (params[j] != methodParams[j]) {\n                        found = false;\n                        break;\n                    }\n                }\n                if (found)\n                    return methods[i];\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Test if the object implements a particular\n     * method\n     */\n    public static boolean hasHook(Object obj, String methodN) {\n        try {\n            Method myMethods[] = findMethods(obj.getClass());\n            for (int i = 0; i < myMethods.length; i++) {\n                if (methodN.equals(myMethods[i].getName())) {\n                    // check if it's overriden\n                    Class<?> declaring = myMethods[i].getDeclaringClass();\n                    Class<?> parentOfDeclaring = declaring.getSuperclass();\n                    // this works only if the base class doesn't extend\n                    // another class.\n\n                    // if the method is declared in a top level class\n                    // like BaseInterceptor parent is Object, otherwise\n                    // parent is BaseInterceptor or an intermediate class\n                    if (!\"java.lang.Object\".equals(parentOfDeclaring.getName())) {\n                        return true;\n                    }\n                }\n            }\n        } catch (Exception ex) {\n            logger.debug(\"hasHook() failed\", ex);\n        }\n        return false;\n    }\n\n    public static void callMain(Class<?> c, String args[]) throws Exception {\n        Class<?> p[] = new Class[1];\n        p[0] = args.getClass();\n        @SuppressWarnings(\"unchecked\")\n        Method m = c.getMethod(\"main\", p);\n        m.invoke(c, new Object[]{args});\n    }\n\n    public static Object callMethod1(Object target, String methodN,\n                                     Object param1, String typeParam1, ClassLoader cl) throws Exception {\n        if (target == null || param1 == null) {\n            debug(\"Assert: Illegal params \" + target + \" \" + param1);\n        }\n        if (dbg > 0)\n            debug(\"callMethod1 \" + target.getClass().getName() + \" \" + param1.getClass().getName() + \" \" +\n                    typeParam1);\n\n        Class<?> params[] = new Class[1];\n        if (typeParam1 == null) {\n            params[0] = param1.getClass();\n        } else {\n            params[0] = cl.loadClass(typeParam1);\n        }\n        Method m = findMethod(target.getClass(), methodN, params);\n        if (m == null) {\n            throw new NoSuchMethodException(target.getClass().getName() + \" \" + methodN);\n        }\n        return m.invoke(target, new Object[]{param1});\n    }\n\n    public static Object callMethod0(Object target, String methodN)\n            throws Exception {\n        if (target == null) {\n            debug(\"Assert: Illegal params \" + target);\n            return null;\n        }\n        if (dbg > 0) {\n            debug(\"callMethod0 \" + target.getClass().getName() + \".\" + methodN);\n        }\n\n        Class params[] = new Class[0];\n        Method m = findMethod(target.getClass(), methodN, params);\n        if (m == null) {\n            throw new NoSuchMethodException(target.getClass().getName() + \" \" + methodN);\n        }\n        return m.invoke(target, emptyArray);\n    }\n\n    static Object[] emptyArray = new Object[]{};\n\n    public static Object callMethodN(Object target, String methodN,\n                                     Object params[], Class<?> typeParams[]) throws Exception {\n        Method m = null;\n        m = findMethod(target.getClass(), methodN, typeParams);\n        if (m == null) {\n            debug(\"Can't find method \" + methodN + \" in \" + target + \" CLASS \" + target.getClass());\n            return null;\n        }\n        Object o = m.invoke(target, params);\n\n        if (dbg > 0) {\n            // debug\n            StringBuffer sb = new StringBuffer();\n            sb.append(\"\" + target.getClass().getName() + \".\" + methodN + \"( \");\n            for (int i = 0; i < params.length; i++) {\n                if (i > 0)\n                    sb.append(\", \");\n                sb.append(params[i]);\n            }\n            sb.append(\")\");\n            debug(sb.toString());\n        }\n        return o;\n    }\n\n    public static Object convert(String object, Class<?> paramType) {\n        Object result = null;\n        if (\"java.lang.String\".equals(paramType.getName())) {\n            result = object;\n        } else if (\"java.lang.Integer\".equals(paramType.getName())\n                || \"int\".equals(paramType.getName())) {\n            try {\n                result = new Integer(object);\n            } catch (NumberFormatException ex) {\n            }\n            // Try a setFoo ( boolean )\n        } else if (\"java.lang.Boolean\".equals(paramType.getName())\n                || \"boolean\".equals(paramType.getName())) {\n            result = new Boolean(object);\n\n            // Try a setFoo ( InetAddress )\n        } else if (\"java.net.InetAddress\".equals(paramType\n                .getName())) {\n            try {\n                result = InetAddress.getByName(object);\n            } catch (UnknownHostException exc) {\n                debug(\"Unable to resolve host name:\" + object);\n            }\n\n            // Unknown type\n        } else {\n            debug(\"Unknown type \" + paramType.getName());\n        }\n        if (result == null) {\n            throw new IllegalArgumentException(\"Can't convert argument: \" + object);\n        }\n        return result;\n    }\n\n    // -------------------- Get property --------------------\n    // This provides a layer of abstraction\n\n    public static interface PropertySource {\n\n        public String getProperty(String key);\n\n    }\n\n    public static interface AttributeHolder {\n\n        public void setAttribute(String key, Object o);\n\n    }\n\n    // debug --------------------\n    static final int dbg = 0;\n\n    static void debug(String s) {\n        logger.debug(\"IntrospectionUtils: {}\", s);\n    }\n}\n",
      "file_name": "IntrospectionUtils.java",
      "human_label": "Add all the jar files in the given dir to the classpath. The classpath is represented as a Vector of URLs.",
      "level": "class_runnable",
      "lineno": "397",
      "name": "addToClassPath",
      "oracle_context": "{ \"apis\" : \"[getFilesByExt, getURL, addElement, debug]\", \"classes\" : \"[String, URL]\", \"vars\" : \"[length, logger]\" }",
      "package": "org.atmosphere.util",
      "project": "atmosphere-atmosphere-2.7.x"
    },
    {
      "_id": "6367677e1a6d9265ec01830f",
      "all_context": "{ \"class_level\" : \"import org.apache.log4j.spi.LoggingEvent;\\nimport org.apache.log4j.helpers.PatternParser;\\nimport org.apache.log4j.helpers.PatternConverter;\\nString DEFAULT_CONVERSION_PATTERN;\\nString TTCC_CONVERSION_PATTERN;\\nint BUF_SIZE;\\nint MAX_CAPACITY;\\nStringBuffer sbuf;\\nString pattern;\\nPatternConverter head;\\nPatternLayout();\\nPatternLayout(String pattern);\\nsetConversionPattern(String conversionPattern);\\ngetConversionPattern();\\nignoresThrowable();\\ncreatePatternParser(String pattern);\\nformat(LoggingEvent event);\\nactivateOptions();\\n\", \"repo_level\" : \"public interface LoggingEvent {public LocationInfo getLocationInformation();\\npublic Level getLevel();\\npublic String getLoggerName();\\npublic Category getLogger();\\npublic Object getMessage();\\npublic String getNDC();\\npublic Object getMDC(String key);\\npublic void getMDCCopy();\\npublic String getRenderedMessage();\\nstatic long getStartTime();\\npublic String getThreadName();\\npublic ThrowableInformation getThrowableInformation();\\npublic String[] getThrowableStrRep();\\nfinal void setProperty(String propName,String propValue);\\nfinal String getProperty(String key);\\nfinal boolean locationInformationExists();\\nfinal long getTimeStamp();\\npublic Set getPropertyKeySet();\\npublic Map getProperties();\\npublic String getFQNOfLoggerClass();\\npublic Object removeProperty(String propName);\\n }\\npublic interface PatternParser {protected String extractOption();\\nprotected int extractPrecisionOption();\\npublic PatternConverter parse();\\nprotected void finalizeConverter(char c);\\nprotected void addConverter(PatternConverter pc);\\npublic String convert(LoggingEvent event);\\nfinal void format(StringBuffer sbuf,LoggingEvent event);\\npublic String convert(LoggingEvent event);\\npublic String convert(LoggingEvent event);\\npublic String convert(LoggingEvent event);\\npublic String convert(LoggingEvent event);\\nabstract String getFullyQualifiedName(LoggingEvent event);\\npublic String convert(LoggingEvent event);\\n String getFullyQualifiedName(LoggingEvent event);\\n String getFullyQualifiedName(LoggingEvent event);\\n }\\npublic interface PatternConverter {protected String convert(LoggingEvent event);\\npublic void format(StringBuffer sbuf,LoggingEvent e);\\npublic void spacePad(StringBuffer sbuf,int length);\\n }\\n\" }",
      "class_name": "PatternLayout",
      "code": "public String format(LoggingEvent event){\n  if (sbuf.capacity() > MAX_CAPACITY) {\n    sbuf=new StringBuffer(BUF_SIZE);\n  }\n else {\n    sbuf.setLength(0);\n  }\n  PatternConverter c=head;\n  while (c != null) {\n    c.format(sbuf,event);\n    c=c.next;\n  }\n  return sbuf.toString();\n}\n",
      "docstring": "/** \n * Produces a formatted string as specified by the conversion pattern.\n */\n",
      "end_lineno": "510",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j;\n\nimport org.apache.log4j.spi.LoggingEvent;\nimport org.apache.log4j.helpers.PatternParser;\nimport org.apache.log4j.helpers.PatternConverter;\n\n\n// Contributors:   Nelson Minar <nelson@monkey.org>\n//                 Anders Kristensen <akristensen@dynamicsoft.com>\n\n/**\n\n   A flexible layout configurable with pattern string.\n   \n   This code is known to have synchronization and other issues\n   which are not present in org.apache.log4j.EnhancedPatternLayout.\n   EnhancedPatternLayout should be used in preference to PatternLayout.\n   EnhancedPatternLayout is distributed in the log4j extras companion.\n\n   <p>The goal of this class is to {@link #format format} a {@link\n   LoggingEvent} and return the results as a String. The results\n   depend on the <em>conversion pattern</em>.\n\n   <p>The conversion pattern is closely related to the conversion\n   pattern of the printf function in C. A conversion pattern is\n   composed of literal text and format control expressions called\n   <em>conversion specifiers</em>.\n\n   <p><i>You are free to insert any literal text within the conversion\n   pattern.</i>\n\n   <p>Each conversion specifier starts with a percent sign (%) and is\n   followed by optional <em>format modifiers</em> and a <em>conversion\n   character</em>. The conversion character specifies the type of\n   data, e.g. category, priority, date, thread name. The format\n   modifiers control such things as field width, padding, left and\n   right justification. The following is a simple example.\n\n   <p>Let the conversion pattern be <b>\"%-5p [%t]: %m%n\"</b> and assume\n   that the log4j environment was set to use a PatternLayout. Then the\n   statements\n   <pre>\n   Category root = Category.getRoot();\n   root.debug(\"Message 1\");\n   root.warn(\"Message 2\");\n   </pre>\n   would yield the output\n   <pre>\n   DEBUG [main]: Message 1\n   WARN  [main]: Message 2\n   </pre>\n\n   <p>Note that there is no explicit separator between text and\n   conversion specifiers. The pattern parser knows when it has reached\n   the end of a conversion specifier when it reads a conversion\n   character. In the example above the conversion specifier\n   <b>%-5p</b> means the priority of the logging event should be left\n   justified to a width of five characters.\n\n   The recognized conversion characters are\n\n   <p>\n   <table border=\"1\" CELLPADDING=\"8\">\n   <th>Conversion Character</th>\n   <th>Effect</th>\n\n   <tr>\n     <td align=center><b>c</b></td>\n\n     <td>Used to output the category of the logging event. The\n     category conversion specifier can be optionally followed by\n     <em>precision specifier</em>, that is a decimal constant in\n     brackets.\n\n     <p>If a precision specifier is given, then only the corresponding\n     number of right most components of the category name will be\n     printed. By default the category name is printed in full.\n\n     <p>For example, for the category name \"a.b.c\" the pattern\n     <b>%c{2}</b> will output \"b.c\".\n\n     </td>\n   </tr>\n\n   <tr>\n     <td align=center><b>C</b></td>\n\n     <td>Used to output the fully qualified class name of the caller\n     issuing the logging request. This conversion specifier\n     can be optionally followed by <em>precision specifier</em>, that\n     is a decimal constant in brackets.\n\n     <p>If a precision specifier is given, then only the corresponding\n     number of right most components of the class name will be\n     printed. By default the class name is output in fully qualified form.\n\n     <p>For example, for the class name \"org.apache.xyz.SomeClass\", the\n     pattern <b>%C{1}</b> will output \"SomeClass\".\n\n     <p><b>WARNING</b> Generating the caller class information is\n     slow. Thus, use should be avoided unless execution speed is\n     not an issue.\n\n     </td>\n     </tr>\n\n   <tr> <td align=center><b>d</b></td> <td>Used to output the date of\n\t the logging event. The date conversion specifier may be\n\t followed by a <em>date format specifier</em> enclosed between\n\t braces. For example, <b>%d{HH:mm:ss,SSS}</b> or\n\t <b>%d{dd&nbsp;MMM&nbsp;yyyy&nbsp;HH:mm:ss,SSS}</b>.  If no\n\t date format specifier is given then ISO8601 format is\n\t assumed.\n\n\t <p>The date format specifier admits the same syntax as the\n\t time pattern string of the {@link\n\t java.text.SimpleDateFormat}. Although part of the standard\n\t JDK, the performance of <code>SimpleDateFormat</code> is\n\t quite poor.\n\n\t <p>For better results it is recommended to use the log4j date\n\t formatters. These can be specified using one of the strings\n\t \"ABSOLUTE\", \"DATE\" and \"ISO8601\" for specifying {@link\n\t org.apache.log4j.helpers.AbsoluteTimeDateFormat\n\t AbsoluteTimeDateFormat}, {@link\n\t org.apache.log4j.helpers.DateTimeDateFormat DateTimeDateFormat}\n\t and respectively {@link\n\t org.apache.log4j.helpers.ISO8601DateFormat\n\t ISO8601DateFormat}. For example, <b>%d{ISO8601}</b> or\n\t <b>%d{ABSOLUTE}</b>.\n\n\t <p>These dedicated date formatters perform significantly\n\t better than {@link java.text.SimpleDateFormat}.\n     </td>\n   </tr>\n\n   <tr>\n   <td align=center><b>F</b></td>\n\n   <td>Used to output the file name where the logging request was\n   issued.\n\n   <p><b>WARNING</b> Generating caller location information is\n   extremely slow and should be avoided unless execution speed\n   is not an issue.\n\n   </tr>\n\n   <tr>\n   <td align=center><b>l</b></td>\n\n     <td>Used to output location information of the caller which generated\n     the logging event.\n\n     <p>The location information depends on the JVM implementation but\n     usually consists of the fully qualified name of the calling\n     method followed by the callers source the file name and line\n     number between parentheses.\n\n     <p>The location information can be very useful. However, its\n     generation is <em>extremely</em> slow and should be avoided\n     unless execution speed is not an issue.\n\n     </td>\n   </tr>\n\n   <tr>\n   <td align=center><b>L</b></td>\n\n   <td>Used to output the line number from where the logging request\n   was issued.\n\n   <p><b>WARNING</b> Generating caller location information is\n   extremely slow and should be avoided unless execution speed\n   is not an issue.\n\n   </tr>\n\n\n   <tr>\n     <td align=center><b>m</b></td>\n     <td>Used to output the application supplied message associated with\n     the logging event.</td>\n   </tr>\n\n   <tr>\n   <td align=center><b>M</b></td>\n\n   <td>Used to output the method name where the logging request was\n   issued.\n\n   <p><b>WARNING</b> Generating caller location information is\n   extremely slow and should be avoided unless execution speed\n   is not an issue.\n\n   </tr>\n\n   <tr>\n     <td align=center><b>n</b></td>\n\n     <td>Outputs the platform dependent line separator character or\n     characters.\n\n     <p>This conversion character offers practically the same\n     performance as using non-portable line separator strings such as\n     \"\\n\", or \"\\r\\n\". Thus, it is the preferred way of specifying a\n     line separator.\n\n\n   </tr>\n\n   <tr>\n     <td align=center><b>p</b></td>\n     <td>Used to output the priority of the logging event.</td>\n   </tr>\n\n   <tr>\n\n     <td align=center><b>r</b></td>\n\n     <td>Used to output the number of milliseconds elapsed from the construction \n     of the layout until the creation of the logging event.</td>\n   </tr>\n\n\n   <tr>\n     <td align=center><b>t</b></td>\n\n     <td>Used to output the name of the thread that generated the\n     logging event.</td>\n\n   </tr>\n\n   <tr>\n\n     <td align=center><b>x</b></td>\n\n     <td>Used to output the NDC (nested diagnostic context) associated\n     with the thread that generated the logging event.\n     </td>\n   </tr>\n\n\n   <tr>\n     <td align=center><b>X</b></td>\n\n     <td> \n     \n     <p>Used to output the MDC (mapped diagnostic context) associated\n     with the thread that generated the logging event. The <b>X</b>\n     conversion character <em>must</em> be followed by the key for the\n     map placed between braces, as in <b>%X{clientNumber}</b> where\n     <code>clientNumber</code> is the key. The value in the MDC\n     corresponding to the key will be output.</p>\n     \n     <p>See {@link MDC} class for more details.\n     </p>\n     \n     </td>\n   </tr>\n\n   <tr>\n\n     <td align=center><b>%</b></td>\n\n     <td>The sequence %% outputs a single percent sign.\n     </td>\n   </tr>\n\n   </table>\n\n   <p>By default the relevant information is output as is. However,\n   with the aid of format modifiers it is possible to change the\n   minimum field width, the maximum field width and justification.\n\n   <p>The optional format modifier is placed between the percent sign\n   and the conversion character.\n\n   <p>The first optional format modifier is the <em>left justification\n   flag</em> which is just the minus (-) character. Then comes the\n   optional <em>minimum field width</em> modifier. This is a decimal\n   constant that represents the minimum number of characters to\n   output. If the data item requires fewer characters, it is padded on\n   either the left or the right until the minimum width is\n   reached. The default is to pad on the left (right justify) but you\n   can specify right padding with the left justification flag. The\n   padding character is space. If the data item is larger than the\n   minimum field width, the field is expanded to accommodate the\n   data. The value is never truncated.\n\n   <p>This behavior can be changed using the <em>maximum field\n   width</em> modifier which is designated by a period followed by a\n   decimal constant. If the data item is longer than the maximum\n   field, then the extra characters are removed from the\n   <em>beginning</em> of the data item and not from the end. For\n   example, it the maximum field width is eight and the data item is\n   ten characters long, then the first two characters of the data item\n   are dropped. This behavior deviates from the printf function in C\n   where truncation is done from the end.\n\n   <p>Below are various format modifier examples for the category\n   conversion specifier.\n\n   <p>\n   <TABLE BORDER=1 CELLPADDING=8>\n   <th>Format modifier\n   <th>left justify\n   <th>minimum width\n   <th>maximum width\n   <th>comment\n\n   <tr>\n   <td align=center>%20c</td>\n   <td align=center>false</td>\n   <td align=center>20</td>\n   <td align=center>none</td>\n\n   <td>Left pad with spaces if the category name is less than 20\n   characters long.\n\n   <tr> <td align=center>%-20c</td> <td align=center>true</td> <td\n   align=center>20</td> <td align=center>none</td> <td>Right pad with\n   spaces if the category name is less than 20 characters long.\n\n   <tr>\n   <td align=center>%.30c</td>\n   <td align=center>NA</td>\n   <td align=center>none</td>\n   <td align=center>30</td>\n\n   <td>Truncate from the beginning if the category name is longer than 30\n   characters.\n\n   <tr>\n   <td align=center>%20.30c</td>\n   <td align=center>false</td>\n   <td align=center>20</td>\n   <td align=center>30</td>\n\n   <td>Left pad with spaces if the category name is shorter than 20\n   characters. However, if category name is longer than 30 characters,\n   then truncate from the beginning.\n\n   <tr>\n   <td align=center>%-20.30c</td>\n   <td align=center>true</td>\n   <td align=center>20</td>\n   <td align=center>30</td>\n\n   <td>Right pad with spaces if the category name is shorter than 20\n   characters. However, if category name is longer than 30 characters,\n   then truncate from the beginning.\n\n   </table>\n\n   <p>Below are some examples of conversion patterns.\n\n   <dl>\n\n   <p><dt><b>%r [%t] %-5p %c %x - %m%n</b>\n   <p><dd>This is essentially the TTCC layout.\n\n   <p><dt><b>%-6r [%15.15t] %-5p %30.30c %x - %m%n</b>\n\n   <p><dd>Similar to the TTCC layout except that the relative time is\n   right padded if less than 6 digits, thread name is right padded if\n   less than 15 characters and truncated if longer and the category\n   name is left padded if shorter than 30 characters and truncated if\n   longer.\n\n  </dl>\n\n   <p>The above text is largely inspired from Peter A. Darnell and\n   Philip E. Margolis' highly recommended book \"C -- a Software\n   Engineering Approach\", ISBN 0-387-97389-3.\n\n   @author <a href=\"mailto:cakalijp@Maritz.com\">James P. Cakalic</a>\n   @author Ceki G&uuml;lc&uuml;\n\n\n   @since 0.8.2 */\npublic class PatternLayout extends Layout {\n\n\n  /** Default pattern string for log output. Currently set to the\n      string <b>\"%m%n\"</b> which just prints the application supplied\n      message. */\n  public final static String DEFAULT_CONVERSION_PATTERN =\"%m%n\";\n\n  /** A conversion pattern equivalent to the TTCCCLayout.\n      Current value is <b>%r [%t] %p %c %x - %m%n</b>. */\n  public final static String TTCC_CONVERSION_PATTERN\n                                             = \"%r [%t] %p %c %x - %m%n\";\n\n\n  protected final int BUF_SIZE = 256;\n  protected final int MAX_CAPACITY = 1024;\n\n\n  // output buffer appended to when format() is invoked\n  private StringBuffer sbuf = new StringBuffer(BUF_SIZE);\n\n  private String pattern;\n\n  private PatternConverter head;\n\n  /**\n     Constructs a PatternLayout using the DEFAULT_LAYOUT_PATTERN.\n\n     The default pattern just produces the application supplied message.\n  */\n  public PatternLayout() {\n    this(DEFAULT_CONVERSION_PATTERN);\n  }\n\n  /**\n     Constructs a PatternLayout using the supplied conversion pattern.\n  */\n  public PatternLayout(String pattern) {\n    this.pattern = pattern;\n    head = createPatternParser((pattern == null) ? DEFAULT_CONVERSION_PATTERN :\n\t\t\t     pattern).parse();\n  }\n\n   /**\n     Set the <b>ConversionPattern</b> option. This is the string which\n     controls formatting and consists of a mix of literal content and\n     conversion specifiers.\n   */\n  public\n  void setConversionPattern(String conversionPattern) {\n    pattern = conversionPattern;\n    head = createPatternParser(conversionPattern).parse();\n  }\n\n  /**\n     Returns the value of the <b>ConversionPattern</b> option.\n   */\n  public\n  String getConversionPattern() {\n    return pattern;\n  }\n\n  /**\n     Does not do anything as options become effective\n  */\n  public\n  void activateOptions() {\n    // nothing to do.\n  }\n\n /**\n     The PatternLayout does not handle the throwable contained within\n     {@link LoggingEvent LoggingEvents}. Thus, it returns\n     <code>true</code>.\n\n     @since 0.8.4 */\n  public\n  boolean ignoresThrowable() {\n    return true;\n  }\n\n  /**\n    Returns PatternParser used to parse the conversion string. Subclasses\n    may override this to return a subclass of PatternParser which recognize\n    custom conversion characters.\n\n    @since 0.9.0\n  */\n  protected PatternParser createPatternParser(String pattern) {\n    return new PatternParser(pattern);\n  }\n\n\n  /**\n     Produces a formatted string as specified by the conversion pattern.\n  */\n  public String format(LoggingEvent event) {\n    // Reset working stringbuffer\n    if(sbuf.capacity() > MAX_CAPACITY) {\n      sbuf = new StringBuffer(BUF_SIZE);\n    } else {\n      sbuf.setLength(0);\n    }\n\n    PatternConverter c = head;\n\n    while(c != null) {\n      c.format(sbuf, event);\n      c = c.next;\n    }\n    return sbuf.toString();\n  }\n}\n",
      "file_name": "PatternLayout.java",
      "human_label": "Format the buffered string with the pattern converter, and return the result.",
      "level": "project_runnable",
      "lineno": "492",
      "name": "format",
      "oracle_context": "{ \"apis\" : \"[capacity, setLength, toString]\", \"classes\" : \"[PatternConverter]\", \"vars\" : \"[next, sbuf, MAX_CAPACITY, BUF_SIZE, head]\" }",
      "package": "org.apache.log4j",
      "project": "logging-log4j1-main"
    },
    {
      "_id": "636767031a6d9265ec0178dd",
      "all_context": "{ \"class_level\" : \"import javax.servlet.http.HttpServletRequest;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport static java.lang.String.format;\\nHttpServletRequest request;\\nServletRequestContext(HttpServletRequest request);\\ngetCharacterEncoding();\\ngetContentType();\\ngetInputStream();\\ntoString();\\n\", \"repo_level\" : \"\" }",
      "class_name": "ServletRequestContext",
      "code": "public long contentLength(){\n  long size;\n  try {\n    size=Long.parseLong(request.getHeader(FileUpload.CONTENT_LENGTH));\n  }\n catch (  NumberFormatException e) {\n    size=request.getContentLength();\n  }\n  return size;\n}\n",
      "docstring": "/** \n * Retrieve the content length of the request.\n * @return The content length of the request.\n * @since 1.3\n */\n",
      "end_lineno": "73",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.web.upload;\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static java.lang.String.format;\n\n/**\n * <p>Provides access to the request information needed for a request made to an HTTP servlet.</p>\n * @since FileUpload 1.1\n * @version $Id: ServletRequestContext.java 1564788 2014-02-05 14:36:41Z markt $\n */\nclass ServletRequestContext {\n    // ----------------------------------------------------- Instance Variables\n    /** The request for which the context is being provided. */\n    private final HttpServletRequest request;\n    // ----------------------------------------------------------- Constructors\n\n    /**\n     * Construct a context for this request.\n     * @param request The request to which this context applies.\n     */\n    public ServletRequestContext(HttpServletRequest request) {\n        this.request = request;\n    }\n    // --------------------------------------------------------- Public Methods\n\n    /**\n     * Retrieve the character encoding for the request.\n     * @return The character encoding for the request.\n     */\n    public String getCharacterEncoding() {\n        return request.getCharacterEncoding();\n    }\n\n    /**\n     * Retrieve the content type of the request.\n     * @return The content type of the request.\n     */\n    public String getContentType() {\n        return request.getContentType();\n    }\n\n    /**\n     * Retrieve the content length of the request.\n     * @return The content length of the request.\n     * @since 1.3\n     */\n    public long contentLength() {\n        long size;\n        try {\n            size = Long.parseLong(request.getHeader(FileUpload.CONTENT_LENGTH));\n        } catch (NumberFormatException e) {\n            size = request.getContentLength();\n        }\n        return size;\n    }\n\n    /**\n     * Retrieve the input stream for the request.\n     * @return The input stream for the request.\n     *\n     * @throws IOException if a problem occurs.\n     */\n    public InputStream getInputStream() throws IOException {\n        return request.getInputStream();\n    }\n\n    /**\n     * Returns a string representation of this object.\n     * @return a string representation of this object.\n     */\n    @Override\n    public String toString() {\n        return format(\"ContentLength=%s, ContentType=%s\", Long.valueOf(this.contentLength()), this.getContentType());\n    }\n}",
      "file_name": "ServletRequestContext.java",
      "human_label": "Compute and return the length of the request content header, return the content length if NumberFormatException happens.",
      "level": "project_runnable",
      "lineno": "60",
      "name": "contentLength",
      "oracle_context": "{ \"apis\" : \"[parseLong, getHeader, getContentLength]\", \"classes\" : \"[FileUpload]\", \"vars\" : \"[CONTENT_LENGTH, request]\" }",
      "package": "net.hasor.web.upload",
      "project": "hasor-master"
    },
    {
      "_id": "636766f11a6d9265ec017658",
      "all_context": "{ \"class_level\" : \"import java.io.File;\\nimport java.util.Collection;\\nchar EXTENSION_SEPARATOR;\\nString EXTENSION_SEPARATOR_STR;\\nchar UNIX_SEPARATOR;\\nchar WINDOWS_SEPARATOR;\\nchar SYSTEM_SEPARATOR;\\nchar OTHER_SEPARATOR;\\nFilenameUtils();\\nisSeparator(char ch);\\nnormalize(String filename);\\nnormalize(String filename,boolean unixSeparator);\\nnormalizeNoEndSeparator(String filename);\\nnormalizeNoEndSeparator(String filename,boolean unixSeparator);\\ndoNormalize(String filename,char separator,boolean keepSeparator);\\nconcat(String basePath,String fullFilenameToAdd);\\nseparatorsToUnix(String path);\\nseparatorsToWindows(String path);\\nseparatorsToSystem(String path);\\ngetPrefixLength(String filename);\\nindexOfLastSeparator(String filename);\\nindexOfExtension(String filename);\\ngetPrefix(String filename);\\ngetPath(String filename);\\ngetPathNoEndSeparator(String filename);\\ndoGetPath(String filename,int separatorAdd);\\ngetFullPath(String filename);\\ngetFullPathNoEndSeparator(String filename);\\ndoGetFullPath(String filename,boolean includeSeparator);\\ngetName(String filename);\\ngetBaseName(String filename);\\ngetExtension(String filename);\\nremoveExtension(String filename);\\nisExtension(String filename,String extension);\\nisExtension(String filename,String[] extensions);\\nisExtension(String filename,Collection extensions);\\nisSystemWindows();\\n\", \"repo_level\" : \"\" }",
      "class_name": "FilenameUtils",
      "code": "public static int indexOfLastSeparator(String filename){\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos,lastWindowsPos);\n}\n",
      "docstring": "/** \n * Returns the index of the last directory separator character. <p> This method will handle a file in either Unix or Windows format. The position of the last forward or backslash is returned. <p> The output will be the same irrespective of the machine that the code is running on.\n * @param filename  the filename to find the last path separator in, null returns -1\n * @return the index of the last separator character, or -1 if thereis no such character\n */\n",
      "end_lineno": "635",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.io;\nimport java.io.File;\nimport java.util.Collection;\n\n/**\n * General filename and filepath manipulation utilities.\n * <p>\n * When dealing with filenames you can hit problems when moving from a Windows\n * based development machine to a Unix based production machine.\n * This class aims to help avoid those problems.\n * <p>\n * <b>NOTE</b>: You may be able to avoid using this class entirely simply by\n * using JDK {@link File File} objects and the two argument constructor\n * {@link File#File(File, String) File(File,String)}.\n * <p>\n * Most methods on this class are designed to work the same on both Unix and Windows.\n * Those that don't include 'System', 'Unix' or 'Windows' in their name.\n * <p>\n * Most methods recognise both separators (forward and back), and both\n * sets of prefixes. See the javadoc of each method for details.\n * <p>\n * This class defines six components within a filename\n * (example C:\\dev\\project\\file.txt):\n * <ul>\n * <li>the prefix - C:\\</li>\n * <li>the path - dev\\project\\</li>\n * <li>the full path - C:\\dev\\project\\</li>\n * <li>the name - file.txt</li>\n * <li>the base name - file</li>\n * <li>the extension - txt</li>\n * </ul>\n * Note that this class works best if directory filenames end with a separator.\n * If you omit the last separator, it is impossible to determine if the filename\n * corresponds to a file or a directory. As a result, we have chosen to say\n * it corresponds to a file.\n * <p>\n * This class only supports Unix and Windows style names.\n * Prefixes are matched as follows:\n * <pre>\n * Windows:\n * a\\b\\c.txt           --> \"\"          --> relative\n * \\a\\b\\c.txt          --> \"\\\"         --> current drive absolute\n * C:a\\b\\c.txt         --> \"C:\"        --> drive relative\n * C:\\a\\b\\c.txt        --> \"C:\\\"       --> absolute\n * \\\\server\\a\\b\\c.txt  --> \"\\\\server\\\" --> UNC\n *\n * Unix:\n * a/b/c.txt           --> \"\"          --> relative\n * /a/b/c.txt          --> \"/\"         --> absolute\n * ~/a/b/c.txt         --> \"~/\"        --> current user\n * ~                   --> \"~/\"        --> current user (slash added)\n * ~user/a/b/c.txt     --> \"~user/\"    --> named user\n * ~user               --> \"~user/\"    --> named user (slash added)\n * </pre>\n * Both prefix styles are matched always, irrespective of the machine that you are\n * currently running on.\n * <p>\n * Origin of code: Excalibur, Alexandria, Tomcat, Commons-Utils.\n *\n * @version $Id: FilenameUtils.java 1307462 2012-03-30 15:13:11Z ggregory $\n * @since 1.1\n */\npublic class FilenameUtils {\n    /**\n     * The extension separator character.\n     * @since 1.4\n     */\n    public static final  char   EXTENSION_SEPARATOR     = '.';\n    /**\n     * The extension separator String.\n     * @since 1.4\n     */\n    public static final  String EXTENSION_SEPARATOR_STR = Character.toString(EXTENSION_SEPARATOR);\n    /**\n     * The Unix separator character.\n     */\n    private static final char   UNIX_SEPARATOR          = '/';\n    /**\n     * The Windows separator character.\n     */\n    private static final char   WINDOWS_SEPARATOR       = '\\\\';\n    /**\n     * The system separator character.\n     */\n    private static final char   SYSTEM_SEPARATOR        = File.separatorChar;\n    /**\n     * The separator character that is the opposite of the system separator.\n     */\n    private static final char   OTHER_SEPARATOR;\n\n    static {\n        if (isSystemWindows()) {\n            OTHER_SEPARATOR = UNIX_SEPARATOR;\n        } else {\n            OTHER_SEPARATOR = WINDOWS_SEPARATOR;\n        }\n    }\n\n    /**\n     * Instances should NOT be constructed in standard programming.\n     */\n    public FilenameUtils() {\n        super();\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Determines if Windows file system is in use.\n     *\n     * @return true if the system is Windows\n     */\n    static boolean isSystemWindows() {\n        return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR;\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Checks if the character is a separator.\n     *\n     * @param ch  the character to check\n     * @return true if it is a separator character\n     */\n    private static boolean isSeparator(char ch) {\n        return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR;\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               -->   /foo/\n     * /foo/./              -->   /foo/\n     * /foo/../bar          -->   /bar\n     * /foo/../bar/         -->   /bar/\n     * /foo/../bar/../baz   -->   /baz\n     * //foo//./bar         -->   /foo/bar\n     * /../                 -->   null\n     * ../foo               -->   null\n     * foo/bar/..           -->   foo/\n     * foo/../../bar        -->   null\n     * foo/../bar           -->   bar\n     * //server/foo/../bar  -->   //server/bar\n     * //server/../bar      -->   null\n     * C:\\foo\\..\\bar        -->   C:\\bar\n     * C:\\..\\bar            -->   null\n     * ~/foo/../bar/        -->   ~/bar/\n     * ~/../bar             -->   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param filename  the filename to normalize, null returns null\n     * @return the normalized filename, or null if invalid\n     */\n    public static String normalize(String filename) {\n        return doNormalize(filename, SYSTEM_SEPARATOR, true);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               -->   /foo/\n     * /foo/./              -->   /foo/\n     * /foo/../bar          -->   /bar\n     * /foo/../bar/         -->   /bar/\n     * /foo/../bar/../baz   -->   /baz\n     * //foo//./bar         -->   /foo/bar\n     * /../                 -->   null\n     * ../foo               -->   null\n     * foo/bar/..           -->   foo/\n     * foo/../../bar        -->   null\n     * foo/../bar           -->   bar\n     * //server/foo/../bar  -->   //server/bar\n     * //server/../bar      -->   null\n     * C:\\foo\\..\\bar        -->   C:\\bar\n     * C:\\..\\bar            -->   null\n     * ~/foo/../bar/        -->   ~/bar/\n     * ~/../bar             -->   null\n     * </pre>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     *\n     * @param filename  the filename to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized filename, or null if invalid\n     * @since 2.0\n     */\n    public static String normalize(String filename, boolean unixSeparator) {\n        char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(filename, separator, true);\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               -->   /foo\n     * /foo/./              -->   /foo\n     * /foo/../bar          -->   /bar\n     * /foo/../bar/         -->   /bar\n     * /foo/../bar/../baz   -->   /baz\n     * //foo//./bar         -->   /foo/bar\n     * /../                 -->   null\n     * ../foo               -->   null\n     * foo/bar/..           -->   foo\n     * foo/../../bar        -->   null\n     * foo/../bar           -->   bar\n     * //server/foo/../bar  -->   //server/bar\n     * //server/../bar      -->   null\n     * C:\\foo\\..\\bar        -->   C:\\bar\n     * C:\\..\\bar            -->   null\n     * ~/foo/../bar/        -->   ~/bar\n     * ~/../bar             -->   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param filename  the filename to normalize, null returns null\n     * @return the normalized filename, or null if invalid\n     */\n    public static String normalizeNoEndSeparator(String filename) {\n        return doNormalize(filename, SYSTEM_SEPARATOR, false);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     * <pre>\n     * /foo//               -->   /foo\n     * /foo/./              -->   /foo\n     * /foo/../bar          -->   /bar\n     * /foo/../bar/         -->   /bar\n     * /foo/../bar/../baz   -->   /baz\n     * //foo//./bar         -->   /foo/bar\n     * /../                 -->   null\n     * ../foo               -->   null\n     * foo/bar/..           -->   foo\n     * foo/../../bar        -->   null\n     * foo/../bar           -->   bar\n     * //server/foo/../bar  -->   //server/bar\n     * //server/../bar      -->   null\n     * C:\\foo\\..\\bar        -->   C:\\bar\n     * C:\\..\\bar            -->   null\n     * ~/foo/../bar/        -->   ~/bar\n     * ~/../bar             -->   null\n     * </pre>\n     *\n     * @param filename  the filename to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separtor should be used.\n     * @return the normalized filename, or null if invalid\n     * @since 2.0\n     */\n    public static String normalizeNoEndSeparator(String filename, boolean unixSeparator) {\n        char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(filename, separator, false);\n    }\n\n    /**\n     * Internal method to perform the normalization.\n     *\n     * @param filename  the filename\n     * @param separator The separator character to use\n     * @param keepSeparator  true to keep the final separator\n     * @return the normalized filename\n     */\n    private static String doNormalize(String filename, char separator, boolean keepSeparator) {\n        if (filename == null) {\n            return null;\n        }\n        int size = filename.length();\n        if (size == 0) {\n            return filename;\n        }\n        int prefix = getPrefixLength(filename);\n        if (prefix < 0) {\n            return null;\n        }\n        char[] array = new char[size + 2];  // +1 for possible extra slash, +2 for arraycopy\n        filename.getChars(0, filename.length(), array, 0);\n        // fix separators throughout\n        char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR;\n        for (int i = 0; i < array.length; i++) {\n            if (array[i] == otherSeparator) {\n                array[i] = separator;\n            }\n        }\n        // add extra separator on the end to simplify code below\n        boolean lastIsDirectory = true;\n        if (array[size - 1] != separator) {\n            array[size++] = separator;\n            lastIsDirectory = false;\n        }\n        // adjoining slashes\n        for (int i = prefix + 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == separator) {\n                System.arraycopy(array, i, array, i - 1, size - i);\n                size--;\n                i--;\n            }\n        }\n        // dot slash\n        for (int i = prefix + 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' && (i == prefix + 1 || array[i - 2] == separator)) {\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                System.arraycopy(array, i + 1, array, i - 1, size - i);\n                size -= 2;\n                i--;\n            }\n        }\n        // double dot slash\n        outer:\n        for (int i = prefix + 2; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' && (i == prefix + 2 || array[i - 3] == separator)) {\n                if (i == prefix + 2) {\n                    return null;\n                }\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                int j;\n                for (j = i - 4; j >= prefix; j--) {\n                    if (array[j] == separator) {\n                        // remove b/../ from a/b/../c\n                        System.arraycopy(array, i + 1, array, j + 1, size - i);\n                        size -= i - j;\n                        i = j + 1;\n                        continue outer;\n                    }\n                }\n                // remove a/../ from a/../c\n                System.arraycopy(array, i + 1, array, prefix, size - i);\n                size -= i + 1 - prefix;\n                i = prefix + 1;\n            }\n        }\n        if (size <= 0) {  // should never be less than 0\n            return \"\";\n        }\n        if (size <= prefix) {  // should never be less than prefix\n            return new String(array, 0, size);\n        }\n        if (lastIsDirectory && keepSeparator) {\n            return new String(array, 0, size);  // keep trailing separator\n        }\n        return new String(array, 0, size - 1);  // lose trailing separator\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Concatenates a filename to a base path using normal command line style rules.\n     * <p>\n     * The effect is equivalent to resultant directory after changing\n     * directory to the first argument, followed by changing directory to\n     * the second argument.\n     * <p>\n     * The first argument is the base path, the second is the path to concatenate.\n     * The returned path is always normalized via {@link #normalize(String)},\n     * thus <code>..</code> is handled.\n     * <p>\n     * If <code>pathToAdd</code> is absolute (has an absolute prefix), then\n     * it will be normalized and returned.\n     * Otherwise, the paths will be joined, normalized and returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo/ + bar          -->   /foo/bar\n     * /foo + bar           -->   /foo/bar\n     * /foo + /bar          -->   /bar\n     * /foo + C:/bar        -->   C:/bar\n     * /foo + C:bar         -->   C:bar (*)\n     * /foo/a/ + ../bar     -->   foo/bar\n     * /foo/ + ../../bar    -->   null\n     * /foo/ + /bar         -->   /bar\n     * /foo/.. + /bar       -->   /bar\n     * /foo + bar/c.txt     -->   /foo/bar/c.txt\n     * /foo/c.txt + bar     -->   /foo/c.txt/bar (!)\n     * </pre>\n     * (*) Note that the Windows relative drive prefix is unreliable when\n     * used with this method.\n     * (!) Note that the first parameter must be a path. If it ends with a name, then\n     * the name will be built into the concatenated path. If this might be a problem,\n     * use {@link #getFullPath(String)} on the base path argument.\n     *\n     * @param basePath  the base path to attach to, always treated as a path\n     * @param fullFilenameToAdd  the filename (or path) to attach to the base\n     * @return the concatenated path, or null if invalid\n     */\n    public static String concat(String basePath, String fullFilenameToAdd) {\n        int prefix = getPrefixLength(fullFilenameToAdd);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix > 0) {\n            return normalize(fullFilenameToAdd);\n        }\n        if (basePath == null) {\n            return null;\n        }\n        int len = basePath.length();\n        if (len == 0) {\n            return normalize(fullFilenameToAdd);\n        }\n        char ch = basePath.charAt(len - 1);\n        if (isSeparator(ch)) {\n            return normalize(basePath + fullFilenameToAdd);\n        } else {\n            return normalize(basePath + '/' + fullFilenameToAdd);\n        }\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Converts all separators to the Unix separator of forward slash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToUnix(String path) {\n        if (path == null || path.indexOf(WINDOWS_SEPARATOR) == -1) {\n            return path;\n        }\n        return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the Windows separator of backslash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToWindows(String path) {\n        if (path == null || path.indexOf(UNIX_SEPARATOR) == -1) {\n            return path;\n        }\n        return path.replace(UNIX_SEPARATOR, WINDOWS_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the system separator.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToSystem(String path) {\n        if (path == null) {\n            return null;\n        }\n        if (isSystemWindows()) {\n            return separatorsToWindows(path);\n        } else {\n            return separatorsToUnix(path);\n        }\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Returns the length of the filename prefix, such as <code>C:/</code> or <code>~/</code>.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * <p>\n     * The prefix length includes the first slash in the full filename\n     * if applicable. Thus, it is possible that the length returned is greater\n     * than the length of the input string.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --> \"\"          --> relative\n     * \\a\\b\\c.txt          --> \"\\\"         --> current drive absolute\n     * C:a\\b\\c.txt         --> \"C:\"        --> drive relative\n     * C:\\a\\b\\c.txt        --> \"C:\\\"       --> absolute\n     * \\\\server\\a\\b\\c.txt  --> \"\\\\server\\\" --> UNC\n     *\n     * Unix:\n     * a/b/c.txt           --> \"\"          --> relative\n     * /a/b/c.txt          --> \"/\"         --> absolute\n     * ~/a/b/c.txt         --> \"~/\"        --> current user\n     * ~                   --> \"~/\"        --> current user (slash added)\n     * ~user/a/b/c.txt     --> \"~user/\"    --> named user\n     * ~user               --> \"~user/\"    --> named user (slash added)\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * @param filename  the filename to find the prefix in, null returns -1\n     * @return the length of the prefix, -1 if invalid or null\n     */\n    public static int getPrefixLength(String filename) {\n        if (filename == null) {\n            return -1;\n        }\n        int len = filename.length();\n        if (len == 0) {\n            return 0;\n        }\n        char ch0 = filename.charAt(0);\n        if (ch0 == ':') {\n            return -1;\n        }\n        if (len == 1) {\n            if (ch0 == '~') {\n                return 2;  // return a length greater than the input\n            }\n            return isSeparator(ch0) ? 1 : 0;\n        } else {\n            if (ch0 == '~') {\n                int posUnix = filename.indexOf(UNIX_SEPARATOR, 1);\n                int posWin = filename.indexOf(WINDOWS_SEPARATOR, 1);\n                if (posUnix == -1 && posWin == -1) {\n                    return len + 1;  // return a length greater than the input\n                }\n                posUnix = posUnix == -1 ? posWin : posUnix;\n                posWin = posWin == -1 ? posUnix : posWin;\n                return Math.min(posUnix, posWin) + 1;\n            }\n            char ch1 = filename.charAt(1);\n            if (ch1 == ':') {\n                ch0 = Character.toUpperCase(ch0);\n                if (ch0 >= 'A' && ch0 <= 'Z') {\n                    if (len == 2 || isSeparator(filename.charAt(2)) == false) {\n                        return 2;\n                    }\n                    return 3;\n                }\n                return -1;\n            } else if (isSeparator(ch0) && isSeparator(ch1)) {\n                int posUnix = filename.indexOf(UNIX_SEPARATOR, 2);\n                int posWin = filename.indexOf(WINDOWS_SEPARATOR, 2);\n                if (posUnix == -1 && posWin == -1 || posUnix == 2 || posWin == 2) {\n                    return -1;\n                }\n                posUnix = posUnix == -1 ? posWin : posUnix;\n                posWin = posWin == -1 ? posUnix : posWin;\n                return Math.min(posUnix, posWin) + 1;\n            } else {\n                return isSeparator(ch0) ? 1 : 0;\n            }\n        }\n    }\n\n    /**\n     * Returns the index of the last directory separator character.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The position of the last forward or backslash is returned.\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param filename  the filename to find the last path separator in, null returns -1\n     * @return the index of the last separator character, or -1 if there\n     * is no such character\n     */\n    public static int indexOfLastSeparator(String filename) {\n        if (filename == null) {\n            return -1;\n        }\n        int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n        int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n        return Math.max(lastUnixPos, lastWindowsPos);\n    }\n\n    /**\n     * Returns the index of the last extension separator character, which is a dot.\n     * <p>\n     * This method also checks that there is no directory separator after the last dot.\n     * To do this it uses {@link #indexOfLastSeparator(String)} which will\n     * handle a file in either Unix or Windows format.\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param filename  the filename to find the last path separator in, null returns -1\n     * @return the index of the last separator character, or -1 if there\n     * is no such character\n     */\n    public static int indexOfExtension(String filename) {\n        if (filename == null) {\n            return -1;\n        }\n        int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n        int lastSeparator = indexOfLastSeparator(filename);\n        return lastSeparator > extensionPos ? -1 : extensionPos;\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Gets the prefix from a full filename, such as <code>C:/</code>\n     * or <code>~/</code>.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The prefix includes the first slash in the full filename where applicable.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --> \"\"          --> relative\n     * \\a\\b\\c.txt          --> \"\\\"         --> current drive absolute\n     * C:a\\b\\c.txt         --> \"C:\"        --> drive relative\n     * C:\\a\\b\\c.txt        --> \"C:\\\"       --> absolute\n     * \\\\server\\a\\b\\c.txt  --> \"\\\\server\\\" --> UNC\n     *\n     * Unix:\n     * a/b/c.txt           --> \"\"          --> relative\n     * /a/b/c.txt          --> \"/\"         --> absolute\n     * ~/a/b/c.txt         --> \"~/\"        --> current user\n     * ~                   --> \"~/\"        --> current user (slash added)\n     * ~user/a/b/c.txt     --> \"~user/\"    --> named user\n     * ~user               --> \"~user/\"    --> named user (slash added)\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * @param filename  the filename to query, null returns null\n     * @return the prefix of the file, null if invalid\n     */\n    public static String getPrefix(String filename) {\n        if (filename == null) {\n            return null;\n        }\n        int len = getPrefixLength(filename);\n        if (len < 0) {\n            return null;\n        }\n        if (len > filename.length()) {\n            return filename + UNIX_SEPARATOR;  // we know this only happens for unix\n        }\n        return filename.substring(0, len);\n    }\n\n    /**\n     * Gets the path from a full filename, which excludes the prefix.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --> a\\b\\\n     * ~/a/b/c.txt  --> a/b/\n     * a.txt        --> \"\"\n     * a/b/c        --> a/b/\n     * a/b/c/       --> a/b/c/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPath(String)} for the method that retains the prefix.\n     *\n     * @param filename  the filename to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getPath(String filename) {\n        return doGetPath(filename, 1);\n    }\n\n    /**\n     * Gets the path from a full filename, which excludes the prefix, and\n     * also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --> a\\b\n     * ~/a/b/c.txt  --> a/b\n     * a.txt        --> \"\"\n     * a/b/c        --> a/b\n     * a/b/c/       --> a/b/c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.\n     *\n     * @param filename  the filename to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getPathNoEndSeparator(String filename) {\n        return doGetPath(filename, 0);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param filename  the filename\n     * @param separatorAdd  0 to omit the end separator, 1 to return it\n     * @return the path\n     */\n    private static String doGetPath(String filename, int separatorAdd) {\n        if (filename == null) {\n            return null;\n        }\n        int prefix = getPrefixLength(filename);\n        if (prefix < 0) {\n            return null;\n        }\n        int index = indexOfLastSeparator(filename);\n        int endIndex = index + separatorAdd;\n        if (prefix >= filename.length() || index < 0 || prefix >= endIndex) {\n            return \"\";\n        }\n        return filename.substring(prefix, endIndex);\n    }\n\n    /**\n     * Gets the full path from a full filename, which is the prefix + path.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --> C:\\a\\b\\\n     * ~/a/b/c.txt  --> ~/a/b/\n     * a.txt        --> \"\"\n     * a/b/c        --> a/b/\n     * a/b/c/       --> a/b/c/\n     * C:           --> C:\n     * C:\\          --> C:\\\n     * ~            --> ~/\n     * ~/           --> ~/\n     * ~user        --> ~user/\n     * ~user/       --> ~user/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param filename  the filename to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPath(String filename) {\n        return doGetFullPath(filename, true);\n    }\n\n    /**\n     * Gets the full path from a full filename, which is the prefix + path,\n     * and also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --> C:\\a\\b\n     * ~/a/b/c.txt  --> ~/a/b\n     * a.txt        --> \"\"\n     * a/b/c        --> a/b\n     * a/b/c/       --> a/b/c\n     * C:           --> C:\n     * C:\\          --> C:\\\n     * ~            --> ~\n     * ~/           --> ~\n     * ~user        --> ~user\n     * ~user/       --> ~user\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param filename  the filename to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPathNoEndSeparator(String filename) {\n        return doGetFullPath(filename, false);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param filename  the filename\n     * @param includeSeparator  true to include the end separator\n     * @return the path\n     */\n    private static String doGetFullPath(String filename, boolean includeSeparator) {\n        if (filename == null) {\n            return null;\n        }\n        int prefix = getPrefixLength(filename);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix >= filename.length()) {\n            if (includeSeparator) {\n                return getPrefix(filename);  // add end slash if necessary\n            } else {\n                return filename;\n            }\n        }\n        int index = indexOfLastSeparator(filename);\n        if (index < 0) {\n            return filename.substring(0, prefix);\n        }\n        int end = index + (includeSeparator ? 1 : 0);\n        if (end == 0) {\n            end++;\n        }\n        return filename.substring(0, end);\n    }\n\n    /**\n     * Gets the name minus the path from a full filename.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash is returned.\n     * <pre>\n     * a/b/c.txt --> c.txt\n     * a.txt     --> a.txt\n     * a/b/c     --> c\n     * a/b/c/    --> \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param filename  the filename to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists\n     */\n    public static String getName(String filename) {\n        if (filename == null) {\n            return null;\n        }\n        int index = indexOfLastSeparator(filename);\n        return filename.substring(index + 1);\n    }\n\n    /**\n     * Gets the base name, minus the full path and extension, from a full filename.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash and before the last dot is returned.\n     * <pre>\n     * a/b/c.txt --> c\n     * a.txt     --> a\n     * a/b/c     --> c\n     * a/b/c/    --> \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param filename  the filename to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists\n     */\n    public static String getBaseName(String filename) {\n        return removeExtension(getName(filename));\n    }\n\n    /**\n     * Gets the extension of a filename.\n     * <p>\n     * This method returns the textual part of the filename after the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt      --> \"txt\"\n     * a/b/c.jpg    --> \"jpg\"\n     * a/b.txt/c    --> \"\"\n     * a/b/c        --> \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param filename the filename to retrieve the extension of.\n     * @return the extension of the file or an empty string if none exists or {@code null}\n     * if the filename is {@code null}.\n     */\n    public static String getExtension(String filename) {\n        if (filename == null) {\n            return null;\n        }\n        int index = indexOfExtension(filename);\n        if (index == -1) {\n            return \"\";\n        } else {\n            return filename.substring(index + 1);\n        }\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Removes the extension from a filename.\n     * <p>\n     * This method returns the textual part of the filename before the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt    --> foo\n     * a\\b\\c.jpg  --> a\\b\\c\n     * a\\b\\c      --> a\\b\\c\n     * a.b\\c      --> a.b\\c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param filename  the filename to query, null returns null\n     * @return the filename minus the extension\n     */\n    public static String removeExtension(String filename) {\n        if (filename == null) {\n            return null;\n        }\n        int index = indexOfExtension(filename);\n        if (index == -1) {\n            return filename;\n        } else {\n            return filename.substring(0, index);\n        }\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Checks whether the extension of the filename is that specified.\n     * <p>\n     * This method obtains the extension as the textual part of the filename\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param filename  the filename to query, null returns false\n     * @param extension  the extension to check for, null or empty checks for no extension\n     * @return true if the filename has the specified extension\n     */\n    public static boolean isExtension(String filename, String extension) {\n        if (filename == null) {\n            return false;\n        }\n        if (extension == null || extension.length() == 0) {\n            return indexOfExtension(filename) == -1;\n        }\n        String fileExt = getExtension(filename);\n        return fileExt.equals(extension);\n    }\n\n    /**\n     * Checks whether the extension of the filename is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the filename\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param filename  the filename to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the filename is one of the extensions\n     */\n    public static boolean isExtension(String filename, String[] extensions) {\n        if (filename == null) {\n            return false;\n        }\n        if (extensions == null || extensions.length == 0) {\n            return indexOfExtension(filename) == -1;\n        }\n        String fileExt = getExtension(filename);\n        for (String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the extension of the filename is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the filename\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param filename  the filename to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the filename is one of the extensions\n     */\n    public static boolean isExtension(String filename, Collection<String> extensions) {\n        if (filename == null) {\n            return false;\n        }\n        if (extensions == null || extensions.isEmpty()) {\n            return indexOfExtension(filename) == -1;\n        }\n        String fileExt = getExtension(filename);\n        for (String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
      "file_name": "FilenameUtils.java",
      "human_label": "Return the index of the last directory separator character, under Unix or Windows.",
      "level": "class_runnable",
      "lineno": "616",
      "name": "indexOfLastSeparator",
      "oracle_context": "{ \"apis\" : \"[lastIndexOf, max]\", \"classes\" : \"[]\", \"vars\" : \"[UNIX_SEPARATOR, WINDOWS_SEPARATOR]\" }",
      "package": "net.hasor.utils.io",
      "project": "hasor-master"
    },
    {
      "_id": "636767121a6d9265ec017b0a",
      "all_context": "{ \"class_level\" : \"import net.hasor.core.Settings;\\nimport net.hasor.utils.ExceptionUtils;\\nimport net.hasor.web.FileItem;\\nimport net.hasor.web.FileItemFactory;\\nimport net.hasor.web.FileItemHeaders;\\nimport net.hasor.web.FileItemStream;\\nimport net.hasor.web.upload.util.Closeable;\\nimport net.hasor.web.upload.util.HeadersSet;\\nimport net.hasor.web.upload.util.LimitedInputStream;\\nimport net.hasor.web.upload.util.Streams;\\nimport javax.servlet.http.HttpServletRequest;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.nio.charset.StandardCharsets;\\nimport java.util.*;\\nimport static java.lang.String.format;\\nimport static net.hasor.web.upload.FileUploadException.UploadErrorCodes.*;\\nString CONTENT_TYPE;\\nString CONTENT_DISPOSITION;\\nString CONTENT_LENGTH;\\nString FORM_DATA;\\nString ATTACHMENT;\\nString MULTIPART;\\nString MULTIPART_FORM_DATA;\\nString MULTIPART_MIXED;\\nString POST_METHOD;\\nlong sizeMax;\\nlong fileSizeMax;\\nString headerEncoding;\\nString contentType;\\nString fieldName;\\nString name;\\nboolean formField;\\nInputStream stream;\\nboolean opened;\\nFileItemHeaders headers;\\nMultipartStream multi;\\nbyte[] boundary;\\nFileItemStreamImpl currentItem;\\nString currentFieldName;\\nboolean skipPreamble;\\nboolean itemValid;\\nboolean eof;\\nFileUpload();\\nFileUpload(Settings settings);\\ngetSizeMax();\\nsetSizeMax(long sizeMax);\\ngetFileSizeMax();\\nsetFileSizeMax(long fileSizeMax);\\ngetHeaderEncoding();\\nsetHeaderEncoding(String encoding);\\ngetItemIterator(HttpServletRequest request);\\nparseRequest(HttpServletRequest request,FileItemFactory factory);\\ngetBoundary(String contentType);\\ngetFileName(FileItemHeaders headers);\\ngetFileName(String pContentDisposition);\\ngetFieldName(FileItemHeaders headers);\\ngetFieldName(String pContentDisposition);\\ngetParsedHeaders(String headerPart);\\nparseEndOfLine(String headerPart,int end);\\nparseHeaderLine(HeadersSet headers,String header);\\nFileItemStreamImpl(FileItemHeaders headers,String pName,String pFieldName,boolean pFormField,long pContentLength);\\nraiseError(long pSizeMax,long pCount);\\ngetContentType();\\ngetFieldName();\\ngetName();\\nisFormField();\\nopenStream();\\nclose();\\ngetHeaders();\\nFileItemIteratorImpl(ServletRequestContext ctx);\\nfindNextItem();\\ngetContentLength(FileItemHeaders pHeaders);\\nremove();\\nhasNext();\\nnext();\\nisMultipartContent(HttpServletRequest request);\\n\", \"repo_level\" : \"public interface Settings {public String[] getSettingArray();\\npublic Settings getSettings(String namespace);\\npublic void refresh();\\npublic void setSetting(String key,Object value);\\npublic void setSetting(String key,Object value,String namespace);\\npublic void removeSetting(String s);\\npublic void removeSetting(String key,String namespace);\\npublic void addSetting(String key,Object var);\\npublic void addSetting(String key,Object var,String namespace);\\npublic Character getChar(String name);\\npublic Character getChar(String name,Character defaultValue);\\npublic String getString(String name);\\npublic String getString(String name,String defaultValue);\\npublic Boolean getBoolean(String name);\\npublic Boolean getBoolean(String name,Boolean defaultValue);\\npublic Short getShort(String name);\\npublic Short getShort(String name,Short defaultValue);\\npublic Integer getInteger(String name);\\npublic Integer getInteger(String name,Integer defaultValue);\\npublic Long getLong(String name);\\npublic Long getLong(String name,Long defaultValue);\\npublic Float getFloat(String name);\\npublic Float getFloat(String name,Float defaultValue);\\npublic Double getDouble(String name);\\npublic Double getDouble(String name,Double defaultValue);\\npublic Date getDate(String name);\\npublic Date getDate(String name,Date defaultValue);\\npublic Date getDate(String name,long defaultValue);\\npublic Date getDate(String name,String format);\\npublic Date getDate(String name,String format,Date defaultValue);\\npublic Date getDate(String name,String format,long defaultValue);\\npublic T getEnum(String name,Class enmType);\\npublic T getEnum(String name,Class enmType,T defaultValue);\\npublic String getFilePath(String name);\\npublic String getFilePath(String name,String defaultValue);\\npublic String getDirectoryPath(String name);\\npublic String getDirectoryPath(String name,String defaultValue);\\npublic SettingNode getNode(String name);\\npublic Character[] getCharArray(String name);\\npublic Character[] getCharArray(String name,Character defaultValue);\\npublic String[] getStringArray(String name);\\npublic String[] getStringArray(String name,String defaultValue);\\npublic Boolean[] getBooleanArray(String name);\\npublic Boolean[] getBooleanArray(String name,Boolean defaultValue);\\npublic Short[] getShortArray(String name);\\npublic Short[] getShortArray(String name,Short defaultValue);\\npublic Integer[] getIntegerArray(String name);\\npublic Integer[] getIntegerArray(String name,Integer defaultValue);\\npublic Long[] getLongArray(String name);\\npublic Long[] getLongArray(String name,Long defaultValue);\\npublic Float[] getFloatArray(String name);\\npublic Float[] getFloatArray(String name,Float defaultValue);\\npublic Double[] getDoubleArray(String name);\\npublic Double[] getDoubleArray(String name,Double defaultValue);\\npublic Date[] getDateArray(String name);\\npublic Date[] getDateArray(String name,Date defaultValue);\\npublic Date[] getDateArray(String name,long defaultValue);\\npublic Date[] getDateArray(String name,String format);\\npublic Date[] getDateArray(String name,String format,Date defaultValue);\\npublic Date[] getDateArray(String name,String format,long defaultValue);\\npublic T[] getEnumArray(String name,Class enmType);\\npublic T[] getEnumArray(String name,Class enmType,T defaultValue);\\npublic String[] getFilePathArray(String name);\\npublic String[] getFilePathArray(String name,String defaultValue);\\npublic String[] getDirectoryPathArray(String name);\\npublic String[] getDirectoryPathArray(String name,String defaultValue);\\npublic SettingNode[] getNodeArray(String name);\\n }\\npublic interface ExceptionUtils {static RuntimeException toRuntime(Throwable proxy);\\nstatic RuntimeException toRuntime(Throwable proxy,Function convert);\\nstatic Throwable toRuntime(Throwable proxy,Class<?>[] exceptionTypes);\\nstatic Throwable getRootCause(Throwable throwable);\\nstatic int getThrowableCount(Throwable throwable);\\nstatic Throwable[] getThrowables(Throwable throwable);\\nstatic List<Throwable> getThrowableList(Throwable throwable);\\nstatic int indexOfThrowable(Throwable throwable,Class clazz);\\nstatic int indexOfThrowable(Throwable throwable,Class clazz,int fromIndex);\\nstatic int indexOfType(Throwable throwable,Class type);\\nstatic int indexOfType(Throwable throwable,Class type,int fromIndex);\\nstatic void printRootCauseStackTrace(Throwable throwable);\\nstatic void printRootCauseStackTrace(Throwable throwable,PrintStream stream);\\nstatic void printRootCauseStackTrace(Throwable throwable,PrintWriter writer);\\nstatic String[] getRootCauseStackTrace(Throwable throwable);\\nstatic void removeCommonFrames(List causeFrames,List wrapperFrames);\\nstatic String getStackTrace(Throwable throwable);\\nstatic String[] getStackFrames(Throwable throwable);\\nstatic String[] getStackFrames(String stackTrace);\\nstatic List<String> getStackFrameList(Throwable t);\\nstatic String getMessage(Throwable th);\\nstatic String getRootCauseMessage(Throwable th);\\n }\\npublic interface FileItem {public long getSize();\\npublic void writeTo(OutputStream outStream);\\npublic void deleteOrSkip();\\npublic byte[] get();\\npublic String getString(String encoding);\\npublic String getString();\\n }\\npublic interface FileItemFactory {public FileItem createItem(FileItemStream itemStream);\\n }\\npublic interface FileItemHeaders {public String getHeader(String name);\\npublic Iterator<String> getHeaders(String name);\\npublic Iterator<String> getHeaderNames();\\n }\\npublic interface FileItemStream {public FileItemHeaders getHeaders();\\npublic String getContentType();\\npublic String getName();\\npublic String getFieldName();\\npublic boolean isFormField();\\npublic InputStream openStream();\\n }\\npublic interface Closeable { void close();\\n boolean isClosed();\\n }\\npublic interface HeadersSet {public String getHeader(String name);\\npublic Iterator<String> getHeaderNames();\\npublic Iterator<String> getHeaders(String name);\\nsynchronized void addHeader(String name,String value);\\n }\\npublic interface LimitedInputStream {abstract void raiseError(long pSizeMax,long pCount);\\npublic int read();\\npublic int read(byte[] b,int off,int len);\\npublic boolean isClosed();\\npublic void close();\\n }\\npublic interface Streams {static long copy(InputStream inputStream,OutputStream outputStream,boolean closeOutputStream);\\nstatic long copy(InputStream inputStream,OutputStream outputStream,boolean closeOutputStream,byte[] buffer);\\nstatic String asString(InputStream inputStream);\\nstatic String asString(InputStream inputStream,String encoding);\\nstatic String checkFileName(String fileName);\\n }\\n\" }",
      "class_name": "FileUpload",
      "code": "private int parseEndOfLine(String headerPart,int end){\n  int index=end;\n  for (; ; ) {\n    int offset=headerPart.indexOf('\\r',index);\n    if (offset == -1 || offset + 1 >= headerPart.length()) {\n      throw new IllegalStateException(\"Expected headers to be terminated by an empty line.\");\n    }\n    if (headerPart.charAt(offset + 1) == '\\n') {\n      return offset;\n    }\n    index=offset + 1;\n  }\n}\n",
      "docstring": "/** \n * Skips bytes until the end of the current line.\n * @param headerPart The headers, which are being parsed.\n * @param end Index of the last byte, which has yet been processed.\n * @return Index of the \\r\\n sequence, which indicates end of line.\n */\n",
      "end_lineno": "357",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.web.upload;\nimport net.hasor.core.Settings;\nimport net.hasor.utils.ExceptionUtils;\nimport net.hasor.web.FileItem;\nimport net.hasor.web.FileItemFactory;\nimport net.hasor.web.FileItemHeaders;\nimport net.hasor.web.FileItemStream;\nimport net.hasor.web.upload.util.Closeable;\nimport net.hasor.web.upload.util.HeadersSet;\nimport net.hasor.web.upload.util.LimitedInputStream;\nimport net.hasor.web.upload.util.Streams;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.*;\n\nimport static java.lang.String.format;\nimport static net.hasor.web.upload.FileUploadException.UploadErrorCodes.*;\n\n/**\n * <p>High level API for processing file uploads.</p>\n *\n * <p>This class handles multiple files per single HTML widget, sent using <code>multipart/mixed</code> encoding type, as specified by\n * <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>.\n *\n * <p>How the data for individual parts is stored is determined by the factory\n * used to create them; a given part may be in memory, on disk, or somewhere else.</p>\n *\n * @version $Id: FileUpload.java 1743630 2016-05-13 09:20:45Z jochen $\n */\npublic class FileUpload {\n    /** HTTP content type header name. */\n    public static final  String CONTENT_TYPE        = \"Content-type\";\n    /** HTTP content disposition header name. */\n    public static final  String CONTENT_DISPOSITION = \"Content-disposition\";\n    /** HTTP content length header name. */\n    public static final  String CONTENT_LENGTH      = \"Content-length\";\n    /** Content-disposition value for form data. */\n    public static final  String FORM_DATA           = \"form-data\";\n    /** Content-disposition value for file attachment. */\n    public static final  String ATTACHMENT          = \"attachment\";\n    /** Part of HTTP content type header. */\n    public static final  String MULTIPART           = \"multipart/\";\n    /** HTTP content type header for multipart forms. */\n    public static final  String MULTIPART_FORM_DATA = \"multipart/form-data\";\n    /** HTTP content type header for multiple uploads. */\n    public static final  String MULTIPART_MIXED     = \"multipart/mixed\";\n    /** Constant for HTTP POST method. */\n    private static final String POST_METHOD         = \"POST\";\n    // ---------------------------------------------------------- Class methods\n\n    /**\n     * Utility method that determines whether the request contains multipart content.\n     * @param request The servlet request to be evaluated. Must be non-null.\n     * @return <code>true</code> if the request is multipart;\n     *         <code>false</code> otherwise.\n     */\n    public static final boolean isMultipartContent(HttpServletRequest request) {\n        if (!POST_METHOD.equalsIgnoreCase(request.getMethod())) {\n            return false;\n        }\n        String contentType = new ServletRequestContext(request).getContentType();\n        if (contentType == null) {\n            return false;\n        }\n        if (contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART)) {\n            return true;\n        }\n        return false;\n    }\n    // ----------------------------------------------------------- Data members\n    /** The maximum size permitted for the complete request, as opposed to {@link #fileSizeMax}. A value of -1 indicates no maximum. */\n    private long   sizeMax     = -1;\n    /** The maximum size permitted for a single uploaded file, as opposed to {@link #sizeMax}. A value of -1 indicates no maximum. */\n    private long   fileSizeMax = -1;\n    /** The content encoding to use when reading part headers. */\n    private String headerEncoding;\n\n    // ----------------------------------------------------- Property accessors\n    public FileUpload() {\n    }\n\n    public FileUpload(Settings settings) {\n        this.setHeaderEncoding(Settings.DefaultCharset);\n        this.setSizeMax(settings.getInteger(\"hasor.fileupload.maxRequestSize\", -1));\n        this.setFileSizeMax(settings.getInteger(\"hasor.fileupload.maxFileSize\", -1));\n    }\n\n    /**\n     * Returns the maximum allowed size of a complete request, as opposed to {@link #getFileSizeMax()}.\n     * @return The maximum allowed size, in bytes. The default value of -1 indicates, that there is no limit.\n     * @see #setSizeMax(long)\n     */\n    public long getSizeMax() {\n        return sizeMax;\n    }\n\n    /**\n     * Sets the maximum allowed size of a complete request, as opposed to {@link #setFileSizeMax(long)}.\n     * @param sizeMax The maximum allowed size, in bytes. The default value of -1 indicates, that there is no limit.\n     * @see #getSizeMax()\n     */\n    public void setSizeMax(long sizeMax) {\n        this.sizeMax = sizeMax;\n    }\n\n    /**\n     * Returns the maximum allowed size of a single uploaded file, as opposed to {@link #getSizeMax()}.\n     * @see #setFileSizeMax(long)\n     * @return Maximum size of a single uploaded file.\n     */\n    public long getFileSizeMax() {\n        return fileSizeMax;\n    }\n\n    /**\n     * Sets the maximum allowed size of a single uploaded file, as opposed to {@link #getSizeMax()}.\n     * @see #getFileSizeMax()\n     * @param fileSizeMax Maximum size of a single uploaded file.\n     */\n    public void setFileSizeMax(long fileSizeMax) {\n        this.fileSizeMax = fileSizeMax;\n    }\n\n    /**\n     * Retrieves the character encoding used when reading the headers of an individual part.\n     * When not specified, or <code>null</code>, the request encoding is used.\n     * If that is also not specified, or <code>null</code>, the platform default encoding is used.\n     * @return The encoding used to read part headers.\n     */\n    public String getHeaderEncoding() {\n        return headerEncoding;\n    }\n\n    /**\n     * Specifies the character encoding to be used when reading the headers of individual part.\n     * When not specified, or <code>null</code>, the request encoding is used.\n     * If that is also not specified, or <code>null</code>, the platform default encoding is used.\n     * @param encoding The encoding used to read part headers.\n     */\n    public void setHeaderEncoding(String encoding) {\n        headerEncoding = encoding;\n    }\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Processes an <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a> compliant <code>multipart/form-data</code> stream.\n     * @param request The  request.\n     * @return An iterator to instances of <code>FileItemStream</code>\n     *         parsed from the request, in the order that they were transmitted.\n     * @throws net.hasor.web.upload.FileUploadException if there are problems reading/parsing the request or storing files.\n     * @throws IOException An I/O error occurred. This may be a network\n     *   error while communicating with the client or a problem while storing the uploaded content.\n     */\n    public Iterator<FileItemStream> getItemIterator(HttpServletRequest request) throws IOException {\n        return new FileItemIteratorImpl(new ServletRequestContext(request));\n    }\n\n    /**\n     * Processes an <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a> compliant <code>multipart/form-data</code> stream.\n     * @param request the request.\n     * @return A list of <code>FileItem</code> instances parsed from the request, in the order that they were transmitted.\n     * @throws FileUploadException if there are problems reading/parsing the request or storing files.\n     */\n    public List<FileItem> parseRequest(HttpServletRequest request, FileItemFactory factory) throws IOException {\n        List<FileItem> items = new ArrayList<>();\n        boolean successful = false;\n        try {\n            Iterator<FileItemStream> fileItems = this.getItemIterator(request);\n            if (factory == null) {\n                throw new NullPointerException(\"No FileItemFactory has been set.\");\n            }\n            while (fileItems.hasNext()) {\n                FileItemStream itemStream = fileItems.next();\n                FileItem fileItem = factory.createItem(itemStream);\n                items.add(fileItem);\n            }\n            successful = true;\n            return items;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (!successful) {\n                for (FileItem fileItem : items) {\n                    try {\n                        fileItem.deleteOrSkip();\n                    } catch (Throwable e) { /*ignore it*/ }\n                }\n            }\n        }\n    }\n    // ------------------------------------------------------ Protected methods\n\n    /**\n     * Retrieves the boundary from the <code>Content-type</code> header.\n     * @param contentType The value of the content type header from which to extract the boundary value.\n     * @return The boundary, as a byte array.\n     */\n    protected byte[] getBoundary(String contentType) {\n        ParameterParser parser = new ParameterParser();\n        parser.setLowerCaseNames(true);\n        // Parameter parser can handle null input\n        Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });\n        String boundaryStr = params.get(\"boundary\");\n        if (boundaryStr == null) {\n            return null;\n        }\n        byte[] boundary;\n        boundary = boundaryStr.getBytes(StandardCharsets.ISO_8859_1);\n        return boundary;\n    }\n\n    /**\n     * Retrieves the file name from the <code>Content-disposition</code> header.\n     * @param headers The HTTP headers object.\n     * @return The file name for the current <code>encapsulation</code>.\n     */\n    protected String getFileName(FileItemHeaders headers) {\n        return getFileName(headers.getHeader(CONTENT_DISPOSITION));\n    }\n\n    /**\n     * Returns the given content-disposition headers file name.\n     * @param pContentDisposition The content-disposition headers value.\n     * @return The file name\n     */\n    private String getFileName(String pContentDisposition) {\n        String fileName = null;\n        if (pContentDisposition != null) {\n            String cdl = pContentDisposition.toLowerCase(Locale.ENGLISH);\n            if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {\n                ParameterParser parser = new ParameterParser();\n                parser.setLowerCaseNames(true);\n                // Parameter parser can handle null input\n                Map<String, String> params = parser.parse(pContentDisposition, ';');\n                if (params.containsKey(\"filename\")) {\n                    fileName = params.get(\"filename\");\n                    if (fileName != null) {\n                        fileName = fileName.trim();\n                    } else {\n                        // Even if there is no value, the parameter is present,\n                        // so we return an empty file name rather than no file\n                        // name.\n                        fileName = \"\";\n                    }\n                }\n            }\n        }\n        return fileName;\n    }\n\n    /**\n     * Retrieves the field name from the <code>Content-disposition</code> header.\n     * @param headers A <code>Map</code> containing the HTTP request headers.\n     * @return The field name for the current <code>encapsulation</code>.\n     */\n    protected String getFieldName(FileItemHeaders headers) {\n        return getFieldName(headers.getHeader(CONTENT_DISPOSITION));\n    }\n\n    /**\n     * Returns the field name, which is given by the content-disposition header.\n     * @param pContentDisposition The content-dispositions header value.\n     * @return The field jake\n     */\n    private String getFieldName(String pContentDisposition) {\n        String fieldName = null;\n        if (pContentDisposition != null && pContentDisposition.toLowerCase(Locale.ENGLISH).startsWith(FORM_DATA)) {\n            ParameterParser parser = new ParameterParser();\n            parser.setLowerCaseNames(true);\n            // Parameter parser can handle null input\n            Map<String, String> params = parser.parse(pContentDisposition, ';');\n            fieldName = params.get(\"name\");\n            if (fieldName != null) {\n                fieldName = fieldName.trim();\n            }\n        }\n        return fieldName;\n    }\n\n    /**\n     * <p> Parses the <code>header-part</code> and returns as key/value pairs.\n     * <p> If there are multiple headers of the same names, the name will map to a comma-separated list containing the values.\n     * @param headerPart The <code>header-part</code> of the current\n     *                   <code>encapsulation</code>.\n     * @return A <code>Map</code> containing the parsed HTTP request headers.\n     */\n    protected FileItemHeaders getParsedHeaders(String headerPart) {\n        final int len = headerPart.length();\n        HeadersSet headers = new HeadersSet();\n        int start = 0;\n        for (; ; ) {\n            int end = parseEndOfLine(headerPart, start);\n            if (start == end) {\n                break;\n            }\n            StringBuilder header = new StringBuilder(headerPart.substring(start, end));\n            start = end + 2;\n            while (start < len) {\n                int nonWs = start;\n                while (nonWs < len) {\n                    char c = headerPart.charAt(nonWs);\n                    if (c != ' ' && c != '\\t') {\n                        break;\n                    }\n                    ++nonWs;\n                }\n                if (nonWs == start) {\n                    break;\n                }\n                // Continuation line found\n                end = parseEndOfLine(headerPart, nonWs);\n                header.append(\" \").append(headerPart.substring(nonWs, end));\n                start = end + 2;\n            }\n            parseHeaderLine(headers, header.toString());\n        }\n        return headers;\n    }\n\n    /**\n     * Skips bytes until the end of the current line.\n     * @param headerPart The headers, which are being parsed.\n     * @param end Index of the last byte, which has yet been processed.\n     * @return Index of the \\r\\n sequence, which indicates end of line.\n     */\n    private int parseEndOfLine(String headerPart, int end) {\n        int index = end;\n        for (; ; ) {\n            int offset = headerPart.indexOf('\\r', index);\n            if (offset == -1 || offset + 1 >= headerPart.length()) {\n                throw new IllegalStateException(\"Expected headers to be terminated by an empty line.\");\n            }\n            if (headerPart.charAt(offset + 1) == '\\n') {\n                return offset;\n            }\n            index = offset + 1;\n        }\n    }\n\n    /**\n     * Reads the next header line.\n     * @param headers String with all headers.\n     * @param header Map where to store the current header.\n     */\n    private void parseHeaderLine(HeadersSet headers, String header) {\n        final int colonOffset = header.indexOf(':');\n        if (colonOffset == -1) {\n            // This header line is malformed, skip it.\n            return;\n        }\n        String headerName = header.substring(0, colonOffset).trim();\n        String headerValue = header.substring(header.indexOf(':') + 1).trim();\n        headers.addHeader(headerName, headerValue);\n    }\n    //\n    //\n\n    /** The iterator, which is returned by {@link FileUpload#getItemIterator(HttpServletRequest)}. */\n    public class FileItemIteratorImpl implements Iterator<FileItemStream> {\n        class FileItemStreamImpl implements FileItemStream {\n            /** The file items content type. */\n            private final String          contentType;\n            /** The file items field name. */\n            private final String          fieldName;\n            /** The file items file name. */\n            private final String          name;\n            /** Whether the file item is a form field. */\n            private final boolean         formField;\n            /** The file items input stream. */\n            private final InputStream     stream;\n            /** Whether the file item was already opened. */\n            private       boolean         opened;\n            /** The headers, if any. */\n            private       FileItemHeaders headers;\n\n            /**\n             * Creates a new instance.\n             * @param pName The items file name, or null.\n             * @param pFieldName The items field name.\n             * @param pFormField Whether the item is a form field.\n             * @param pContentLength The items content length, if known, or -1\n             * @throws IOException Creating the file item failed.\n             */\n            FileItemStreamImpl(FileItemHeaders headers, String pName, String pFieldName, boolean pFormField, long pContentLength) throws IOException {\n                this.headers = headers;\n                this.name = pName;\n                this.fieldName = pFieldName;\n                this.contentType = headers.getHeader(CONTENT_TYPE);\n                this.formField = pFormField;\n                final MultipartStream.ItemInputStream itemStream = multi.newInputStream();\n                InputStream istream = itemStream;\n                if (fileSizeMax != -1) {\n                    if (pContentLength != -1 && pContentLength > fileSizeMax) {\n                        String logMessage = format(\"The field %s exceeds its maximum permitted size of %s bytes.\", fieldName, fileSizeMax);\n                        throw new FileUploadException(FileSizeLimitExceededException, logMessage);\n                    }\n                    istream = new LimitedInputStream(istream, fileSizeMax) {\n                        @Override\n                        protected void raiseError(long pSizeMax, long pCount) throws IOException {\n                            itemStream.close(true);\n                            String logMessage = format(\"The field %s exceeds its maximum permitted size of %s bytes.\", fieldName, pSizeMax);\n                            throw new FileUploadException(FileSizeLimitExceededException, logMessage);\n                        }\n                    };\n                }\n                this.stream = istream;\n            }\n\n            /**\n             * Returns the items content type, or null.\n             *\n             * @return Content type, if known, or null.\n             */\n            public String getContentType() {\n                return contentType;\n            }\n\n            /**\n             * Returns the items field name.\n             *\n             * @return Field name.\n             */\n            public String getFieldName() {\n                return fieldName;\n            }\n\n            /**\n             * Returns the items file name.\n             *\n             * @return File name, if known, or null.\n             * @throws IllegalArgumentException The file name contains a NUL character,\n             *   which might be an indicator of a security attack. If you intend to\n             *   use the file name anyways, catch the exception and use\n             *   InvalidFileNameException#getName().\n             */\n            public String getName() {\n                return Streams.checkFileName(name);\n            }\n\n            /**\n             * Returns, whether this is a form field.\n             *\n             * @return True, if the item is a form field,\n             *   otherwise false.\n             */\n            public boolean isFormField() {\n                return formField;\n            }\n\n            /**\n             * Returns an input stream, which may be used to\n             * read the items contents.\n             *\n             * @return Opened input stream.\n             * @throws IOException An I/O error occurred.\n             */\n            public InputStream openStream() throws IOException {\n                if (opened) {\n                    throw new IllegalStateException(\"The stream was already opened.\");\n                }\n                if (((Closeable) stream).isClosed()) {\n                    throw new FileUploadException(ItemSkippedException);\n                }\n                return stream;\n            }\n\n            /**\n             * Closes the file item.\n             *\n             * @throws IOException An I/O error occurred.\n             */\n            void close() throws IOException {\n                stream.close();\n            }\n\n            /**\n             * Returns the file item headers.\n             * @return The items header object\n             */\n            public FileItemHeaders getHeaders() {\n                return headers;\n            }\n        }\n\n        /** The multi part stream to process. */\n        private final MultipartStream    multi;\n        /** The boundary, which separates the various parts. */\n        private final byte[]             boundary;\n        /** The item, which we currently process. */\n        private       FileItemStreamImpl currentItem;\n        /** The current items field name. */\n        private       String             currentFieldName;\n        /** Whether we are currently skipping the preamble. */\n        private       boolean            skipPreamble;\n        /** Whether the current item may still be read. */\n        private       boolean            itemValid;\n        /** Whether we have seen the end of the file. */\n        private       boolean            eof;\n\n        /**\n         * Creates a new instance.\n         * @param ctx The request context.\n         * @throws FileUploadException An error occurred while parsing the request.\n         * @throws IOException An I/O error occurred.\n         */\n        FileItemIteratorImpl(ServletRequestContext ctx) throws IOException {\n            if (ctx == null) {\n                throw new NullPointerException(\"ctx parameter\");\n            }\n            String contentType = ctx.getContentType();\n            if ((null == contentType) || (!contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART))) {\n                String logMEssage = format(\"the request doesn't contain a %s or %s stream, content type header is %s\", MULTIPART_FORM_DATA, MULTIPART_MIXED, contentType);\n                throw new FileUploadException(InvalidContentTypeException, logMEssage);\n            }\n            InputStream input = ctx.getInputStream();\n            long requestSize = ctx.contentLength();\n            // CHECKSTYLE:ON\n            if (sizeMax >= 0) {\n                if (requestSize != -1 && requestSize > sizeMax) {\n                    String logMEssage = format(\"the request was rejected because its size (%s) exceeds the configured maximum (%s)\", requestSize, sizeMax);\n                    throw new FileUploadException(SizeLimitExceededException, logMEssage);\n                }\n                input = new LimitedInputStream(input, sizeMax) {\n                    @Override\n                    protected void raiseError(long pSizeMax, long pCount) throws IOException {\n                        String logMEssage = format(\"the request was rejected because its size (%s) exceeds the configured maximum (%s)\", pCount, pSizeMax);\n                        throw new FileUploadException(SizeLimitExceededException, logMEssage);\n                    }\n                };\n            }\n            String charEncoding = headerEncoding;\n            if (charEncoding == null) {\n                charEncoding = ctx.getCharacterEncoding();\n            }\n            boundary = getBoundary(contentType);\n            if (boundary == null) {\n                throw new FileUploadException(\"the request was rejected because no multipart boundary was found\");\n            }\n            try {\n                multi = new MultipartStream(input, boundary);\n            } catch (IllegalArgumentException iae) {\n                String logMessage = format(\"The boundary specified in the %s header is too long\", CONTENT_TYPE);\n                throw new FileUploadException(InvalidContentTypeException, logMessage);\n            }\n            multi.setHeaderEncoding(charEncoding);\n            skipPreamble = true;\n            findNextItem();\n        }\n\n        /**\n         * Called for finding the next item, if any.\n         * @return True, if an next item was found, otherwise false.\n         * @throws IOException An I/O error occurred.\n         */\n        private boolean findNextItem() throws IOException {\n            if (eof) {\n                return false;\n            }\n            if (currentItem != null) {\n                currentItem.close();\n                currentItem = null;\n            }\n            for (; ; ) {\n                boolean nextPart;\n                if (skipPreamble) {\n                    nextPart = multi.skipPreamble();\n                } else {\n                    nextPart = multi.readBoundary();\n                }\n                if (!nextPart) {\n                    if (currentFieldName == null) {\n                        eof = true; // Outer multipart terminated -> No more data\n                        return false;\n                    }\n                    multi.setBoundary(boundary);// Inner multipart terminated -> Return to parsing the outer\n                    currentFieldName = null;\n                    continue;\n                }\n                FileItemHeaders headers = getParsedHeaders(multi.readHeaders());\n                if (currentFieldName == null) {\n                    // We're parsing the outer multipart\n                    String fieldName = getFieldName(headers);\n                    if (fieldName != null) {\n                        String subContentType = headers.getHeader(CONTENT_TYPE);\n                        if (subContentType != null && subContentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART_MIXED)) {\n                            currentFieldName = fieldName;\n                            // Multiple files associated with this field name\n                            byte[] subBoundary = getBoundary(subContentType);\n                            multi.setBoundary(subBoundary);\n                            skipPreamble = true;\n                            continue;\n                        }\n                        String fileName = getFileName(headers);\n                        currentItem = new FileItemStreamImpl(headers, fileName, fieldName, fileName == null, getContentLength(headers));\n                        itemValid = true;\n                        return true;\n                    }\n                } else {\n                    String fileName = getFileName(headers);\n                    if (fileName != null) {\n                        currentItem = new FileItemStreamImpl(headers, fileName, currentFieldName, false, getContentLength(headers));\n                        itemValid = true;\n                        return true;\n                    }\n                }\n                multi.discardBodyData();\n            }\n        }\n\n        private long getContentLength(FileItemHeaders pHeaders) {\n            try {\n                return Long.parseLong(pHeaders.getHeader(CONTENT_LENGTH));\n            } catch (Exception e) {\n                return -1;\n            }\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * Returns, whether another instance of {@link FileItemStream} is available.\n         *\n         * @throws FileUploadException Parsing or processing the file item failed.\n         * @throws IOException Reading the file item failed.\n         * @return True, if one or more additional file items are available, otherwise false.\n         */\n        public boolean hasNext() {\n            if (eof) {\n                return false;\n            }\n            if (itemValid) {\n                return true;\n            }\n            try {\n                return findNextItem();\n            } catch (IOException e) {\n                throw ExceptionUtils.toRuntime(e);\n            }\n        }\n\n        /**\n         * Returns the next available {@link FileItemStream}.\n         *\n         * @throws java.util.NoSuchElementException No more items are available.\n         *          Use {@link #hasNext()} to prevent this exception.\n         * @throws FileUploadException Parsing or processing the file item failed.\n         * @throws IOException Reading the file item failed.\n         * @return FileItemStream instance, which provides access to the next file item.\n         */\n        public FileItemStream next() {\n            if (eof || (!itemValid && !hasNext())) {\n                throw new NoSuchElementException();\n            }\n            itemValid = false;\n            return currentItem;\n        }\n    }\n}\n",
      "file_name": "FileUpload.java",
      "human_label": "Parse the header part starting from the given end position and return the index of the enter sequence. ",
      "level": "self_contained",
      "lineno": "339",
      "name": "parseEndOfLine",
      "oracle_context": "{ \"apis\" : \"[indexOf, length, charAt]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
      "package": "net.hasor.web.upload",
      "project": "hasor-master"
    },
    {
      "_id": "636766f61a6d9265ec017701",
      "all_context": "{ \"class_level\" : \"import net.hasor.core.Singleton;\\nimport net.hasor.dataql.UdfSourceAssembly;\\nimport net.hasor.utils.StringUtils;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nPattern linePattern;\\nPattern humpPattern;\\nstartsWithIgnoreCase(String str,String prefix);\\nendsWith(String str,String suffix);\\nendsWithIgnoreCase(String str,String suffix);\\n_startsWith(String str,String prefix,boolean ignoreCase);\\n_endsWith(String str,String suffix,boolean ignoreCase);\\nlineToHump(String str);\\nhumpToLine(String str);\\nfirstCharToUpperCase(String value);\\nfirstCharToLowerCase(String value);\\ntoUpperCase(String value);\\ntoLowerCase(String value);\\nindexOf(String str,String searchStr);\\nindexOfWithStart(String str,String searchStr,int startPos);\\nindexOfIgnoreCase(String str,String searchStr);\\nindexOfIgnoreCaseWithStart(String str,String searchStr,int startPos);\\nlastIndexOf(String str,String searchStr);\\nlastIndexOfWithStart(String str,String searchChar,int startPos);\\nlastIndexOfIgnoreCase(String str,String searchStr);\\nlastIndexOfIgnoreCaseWithStart(String str,String searchStr,int startPos);\\ncontains(String str,String searchStr);\\ncontainsIgnoreCase(String str,String searchStr);\\ncontainsAny(String str,List searchStrArray);\\ncontainsAnyIgnoreCase(String str,List searchStrArray);\\ntrim(String str);\\nsub(String str,int start,int end);\\nleft(String str,int len);\\nright(String str,int len);\\nalignRight(String str,String padChar,int len);\\nalignLeft(String str,String padChar,int len);\\nalignCenter(String str,String padChar,int len);\\ncompareString(String str1,String str2);\\ncompareStringIgnoreCase(String str1,String str2);\\nsplit(String str,String separatorChars);\\njoin(List array,String separator);\\nisEmpty(String str);\\nequalsIgnoreCase(String str1,String str2);\\nstartsWith(String str,String prefix);\\n\", \"repo_level\" : \"public interface UdfSourceAssembly {default Supplier<?> getSupplier(Class targetType,Finder finder);\\ndefault Predicate<Method> getPredicate(Class targetType);\\npublic Object[] allParams();\\ndefault Supplier<Map<String,Udf>> getUdfResource(Finder finder);\\npublic Class<? extends Annotation> annotationType();\\npublic String value();\\npublic Object call(Hints readOnly,Object values);\\npublic Object call(Hints readOnly,Object values);\\n }\\npublic interface StringUtils {static boolean isEmpty(String str);\\nstatic boolean isNotEmpty(String str);\\nstatic boolean isBlank(String str);\\nstatic boolean isNotBlank(String str);\\nstatic String trim(String str);\\nstatic String trimToNull(String str);\\nstatic String trimToEmpty(String str);\\nstatic String strip(String str);\\nstatic String stripToNull(String str);\\nstatic String stripToEmpty(String str);\\nstatic String strip(String str,String stripChars);\\nstatic String stripStart(String str,String stripChars);\\nstatic String stripEnd(String str,String stripChars);\\nstatic String[] stripAll(String[] strs);\\nstatic String[] stripAll(String[] strs,String stripChars);\\nstatic boolean equals(String str1,String str2);\\nstatic boolean equalsIgnoreCase(String str1,String str2);\\nstatic int indexOf(String str,char searchChar);\\nstatic int indexOf(String str,char searchChar,int startPos);\\nstatic int indexOf(String str,String searchStr);\\nstatic int ordinalIndexOf(String str,String searchStr,int ordinal);\\nstatic int indexOf(String str,String searchStr,int startPos);\\nstatic int indexOfIgnoreCase(String str,String searchStr);\\nstatic int indexOfIgnoreCase(String str,String searchStr,int startPos);\\nstatic int lastIndexOf(String str,char searchChar);\\nstatic int lastIndexOf(String str,char searchChar,int startPos);\\nstatic int lastIndexOf(String str,String searchStr);\\nstatic int lastOrdinalIndexOf(String str,String searchStr,int ordinal);\\nstatic int lastIndexOf(String str,String searchStr,int startPos);\\nstatic int lastIndexOfIgnoreCase(String str,String searchStr);\\nstatic int lastIndexOfIgnoreCase(String str,String searchStr,int startPos);\\nstatic boolean contains(String str,char searchChar);\\nstatic boolean contains(String str,String searchStr);\\nstatic boolean containsIgnoreCase(String str,String searchStr);\\nstatic int indexOfAny(String str,char[] searchChars);\\nstatic int indexOfAny(String str,String searchChars);\\nstatic boolean containsAny(String str,char[] searchChars);\\nstatic boolean containsAny(String str,String searchChars);\\nstatic int indexOfAnyBut(String str,char[] searchChars);\\nstatic int indexOfAnyBut(String str,String searchChars);\\nstatic boolean containsOnly(String str,char[] valid);\\nstatic boolean containsOnly(String str,String validChars);\\nstatic boolean containsNone(String str,char[] searchChars);\\nstatic boolean containsNone(String str,String invalidChars);\\nstatic int indexOfAny(String str,String[] searchStrs);\\nstatic int lastIndexOfAny(String str,String[] searchStrs);\\nstatic String substring(String str,int start);\\nstatic String substring(String str,int start,int end);\\nstatic String left(String str,int len);\\nstatic String right(String str,int len);\\nstatic String mid(String str,int pos,int len);\\nstatic String substringBefore(String str,String separator);\\nstatic String substringAfter(String str,String separator);\\nstatic String substringBeforeLast(String str,String separator);\\nstatic String substringAfterLast(String str,String separator);\\nstatic String substringBetween(String str,String tag);\\nstatic String substringBetween(String str,String open,String close);\\nstatic String[] substringsBetween(String str,String open,String close);\\nstatic String[] splitKeep(String str,char separatorChar);\\nstatic String[] splitKeep(String str,String separatorStr);\\nstatic String[] split(String str);\\nstatic String[] split(String str,char separatorChar);\\nstatic String[] split(String str,String separatorChars);\\nstatic String[] split(String str,String separatorChars,int max);\\nstatic String[] splitByWholeSeparator(String str,String separator);\\nstatic String[] splitByWholeSeparator(String str,String separator,int max);\\nstatic String[] splitByWholeSeparatorPreserveAllTokens(String str,String separator);\\nstatic String[] splitByWholeSeparatorPreserveAllTokens(String str,String separator,int max);\\nstatic String[] splitPreserveAllTokens(String str);\\nstatic String[] splitPreserveAllTokens(String str,char separatorChar);\\nstatic String[] splitPreserveAllTokens(String str,String separatorChars);\\nstatic String[] splitPreserveAllTokens(String str,String separatorChars,int max);\\nstatic String[] splitByCharacterType(String str);\\nstatic String[] splitByCharacterTypeCamelCase(String str);\\nstatic String join(Object[] array);\\nstatic String join(Object[] array,char separator);\\nstatic String join(Object[] array,char separator,int startIndex,int endIndex);\\nstatic String join(Object[] array,String separator);\\nstatic String join(Object[] array,String separator,int startIndex,int endIndex);\\nstatic String deleteWhitespace(String str);\\nstatic String removeStart(String str,String remove);\\nstatic String removeStartIgnoreCase(String str,String remove);\\nstatic String removeEnd(String str,String remove);\\nstatic String removeEndIgnoreCase(String str,String remove);\\nstatic String remove(String str,String remove);\\nstatic String remove(String str,char remove);\\nstatic String replaceOnce(String text,String searchString,String replacement);\\nstatic String replace(String text,String searchString,String replacement);\\nstatic String replace(String text,String searchString,String replacement,int max);\\nstatic String replaceEach(String text,String[] searchList,String[] replacementList);\\nstatic String replaceEachRepeatedly(String text,String[] searchList,String[] replacementList);\\nstatic String replaceChars(String str,char searchChar,char replaceChar);\\nstatic String replaceChars(String str,String searchChars,String replaceChars);\\nstatic String overlay(String str,String overlay,int start,int end);\\nstatic String chomp(String str);\\nstatic String chomp(String str,String separator);\\nstatic String chop(String str);\\nstatic String repeat(char character,int repeat);\\nstatic String repeat(String str,int repeat);\\nstatic String repeat(String str,String separator,int repeat);\\nstatic String rightPad(String str,int size);\\nstatic String rightPad(String str,int size,char padChar);\\nstatic String rightPad(String str,int size,String padStr);\\nstatic String leftPad(String str,int size);\\nstatic String leftPad(String str,int size,char padChar);\\nstatic String leftPad(String str,int size,String padStr);\\nstatic int length(String str);\\nstatic String center(String str,int size);\\nstatic String center(String str,int size,char padChar);\\nstatic String center(String str,int size,String padStr);\\nstatic String upperCase(String str);\\nstatic String upperCase(String str,Locale locale);\\nstatic String lowerCase(String str);\\nstatic String lowerCase(String str,Locale locale);\\nstatic String capitalize(String str);\\nstatic String uncapitalize(String str);\\nstatic String swapCase(String str);\\nstatic int countMatches(String str,String sub);\\nstatic boolean isAlpha(String str);\\nstatic boolean isAlphaSpace(String str);\\nstatic boolean isAlphanumeric(String str);\\nstatic boolean isAlphanumericSpace(String str);\\nstatic boolean isAsciiPrintable(String str);\\nstatic boolean isNumeric(String str);\\nstatic boolean isNumericSpace(String str);\\nstatic boolean isWhitespace(String str);\\nstatic boolean isAllLowerCase(String str);\\nstatic boolean isAllUpperCase(String str);\\nstatic String defaultString(String str);\\nstatic String defaultString(String str,String defaultStr);\\nstatic String defaultIfBlank(String str,String defaultStr);\\nstatic String defaultIfEmpty(String str,String defaultStr);\\nstatic String reverse(String str);\\nstatic String reverseDelimited(String str,char separatorChar);\\nstatic String abbreviate(String str,int maxWidth);\\nstatic String abbreviate(String str,int offset,int maxWidth);\\nstatic String abbreviateMiddle(String str,String middle,int length);\\nstatic String difference(String str1,String str2);\\nstatic int indexOfDifference(String str1,String str2);\\nstatic int indexOfDifference(String[] strs);\\nstatic String getCommonPrefix(String[] strs);\\nstatic int getLevenshteinDistance(String s,String t);\\nstatic boolean startsWith(String str,String prefix);\\nstatic boolean startsWithIgnoreCase(String str,String prefix);\\nstatic boolean startsWithAny(String string,String[] searchStrings);\\nstatic boolean endsWith(String str,String suffix);\\nstatic boolean endsWithIgnoreCase(String str,String suffix);\\nstatic String normalizeSpace(String str);\\nstatic boolean endsWithAny(String string,String[] searchStrings);\\nstatic String firstCharToUpperCase(String value);\\nstatic String firstCharToLowerCase(String value);\\nstatic boolean equalsBlankIgnoreCase(String str1,String str2);\\nstatic String quote(String input);\\nstatic void quote(Appendable buffer,String input);\\nstatic String toString(Object object);\\n }\\n\" }",
      "class_name": "StringUdfSource",
      "code": "public static int lastIndexOf(String str,String searchStr){\n  if (StringUtils.isEmpty(str)) {\n    return StringUtils.INDEX_NOT_FOUND;\n  }\n  return str.lastIndexOf(searchStr);\n}\n",
      "docstring": "/** \n * Finds the last index within a String, handling <code>null</code>. This method uses  {@link String#lastIndexOf(String)}. \n */\n",
      "end_lineno": "166",
      "file_content": "/*\n * Copyright 2008-2009 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.dataql.fx.basic;\nimport net.hasor.core.Singleton;\nimport net.hasor.dataql.UdfSourceAssembly;\nimport net.hasor.utils.StringUtils;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * 字符串函数 <code>import 'net.hasor.dataql.fx.basic.StringUdfSource' as string;</code>\n * @version : 2019-12-12\n */\n@Singleton\npublic class StringUdfSource implements UdfSourceAssembly {\n    // startsWith/endsWith\n    //-----------------------------------------------------------------------\n\n    /** Check if a String starts with a specified prefix. */\n    public static boolean startsWith(String str, String prefix) {\n        return _startsWith(str, prefix, false);\n    }\n\n    /** Case insensitive check if a String starts with a specified prefix. */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        return _startsWith(str, prefix, true);\n    }\n\n    /** Case insensitive check if a String ends with a specified suffix. */\n    public static boolean endsWith(String str, String suffix) {\n        return _endsWith(str, suffix, false);\n    }\n\n    /** Case insensitive check if a String ends with a specified suffix. */\n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        return _endsWith(str, suffix, true);\n    }\n\n    private static boolean _startsWith(String str, String prefix, boolean ignoreCase) {\n        if (str == null || prefix == null) {\n            return str == null && prefix == null;\n        }\n        if (prefix.length() > str.length()) {\n            return false;\n        }\n        return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n    }\n\n    private static boolean _endsWith(String str, String suffix, boolean ignoreCase) {\n        if (str == null || suffix == null) {\n            return str == null && suffix == null;\n        }\n        if (suffix.length() > str.length()) {\n            return false;\n        }\n        int strOffset = str.length() - suffix.length();\n        return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n    }\n\n    // Hump\n    //-----------------------------------------------------------------------\n    private static final Pattern linePattern = Pattern.compile(\"_(\\\\w)\");\n    private static final Pattern humpPattern = Pattern.compile(\"[A-Z]\");\n\n    /** 下划线转驼峰 */\n    public static String lineToHump(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = str.toLowerCase();\n        Matcher matcher = linePattern.matcher(str);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            matcher.appendReplacement(sb, matcher.group(1).toUpperCase());\n        }\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n\n    /** 驼峰转下划线 */\n    public static String humpToLine(String str) {\n        if (str == null) {\n            return null;\n        }\n        Matcher matcher = humpPattern.matcher(str);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            matcher.appendReplacement(sb, \"_\" + matcher.group(0).toLowerCase());\n        }\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n    // UpperCase/LowerCase\n    //-----------------------------------------------------------------------\n\n    /** 转换首字母大写 */\n    public static String firstCharToUpperCase(String value) {\n        return StringUtils.firstCharToUpperCase(value);\n    }\n\n    /** 转换首字母小写 */\n    public static String firstCharToLowerCase(String value) {\n        return StringUtils.firstCharToLowerCase(value);\n    }\n\n    /** 转换大写 */\n    public static String toUpperCase(String value) {\n        return StringUtils.upperCase(value);\n    }\n\n    /** 转换小写 */\n    public static String toLowerCase(String value) {\n        return StringUtils.lowerCase(value);\n    }\n    // IndexOf/lastIndexOf\n    //-----------------------------------------------------------------------\n\n    /** Finds the first index within a String, handling <code>null</code>. This method uses {@link String#indexOf(String)}. */\n    public static int indexOf(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchStr);\n    }\n\n    /** Finds the first index within a String from a start position, handling <code>null</code>. This method uses {@link String#indexOf(String, int)}. */\n    public static int indexOfWithStart(String str, String searchStr, int startPos) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchStr, startPos);\n    }\n\n    /** Case in-sensitive find of the first index within a String. */\n    public static int indexOfIgnoreCase(String str, String searchStr) {\n        return StringUtils.indexOfIgnoreCase(str, searchStr, 0);\n    }\n\n    /** Case in-sensitive find of the first index within a String from the specified position. */\n    public static int indexOfIgnoreCaseWithStart(String str, String searchStr, int startPos) {\n        return StringUtils.indexOfIgnoreCase(str, searchStr, startPos);\n    }\n\n    /** Finds the last index within a String, handling <code>null</code>. This method uses {@link String#lastIndexOf(String)}. */\n    public static int lastIndexOf(String str, String searchStr) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchStr);\n    }\n\n    /** Finds the last index within a String from a start position, handling <code>null</code>. This method uses {@link String#lastIndexOf(String, int)}. */\n    public static int lastIndexOfWithStart(String str, String searchChar, int startPos) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchChar, startPos);\n    }\n\n    /** Case in-sensitive find of the last index within a String from the specified position. */\n    public static int lastIndexOfIgnoreCase(String str, String searchStr) {\n        return StringUtils.lastIndexOfIgnoreCase(str, searchStr, 0);\n    }\n\n    /** Case in-sensitive find of the last index within a String from the specified position. */\n    public static int lastIndexOfIgnoreCaseWithStart(String str, String searchStr, int startPos) {\n        return StringUtils.lastIndexOfIgnoreCase(str, searchStr, startPos);\n    }\n    // Contains\n    //-----------------------------------------------------------------------\n\n    /** Checks if String contains a search String, handling <code>null</code>. This method uses {@link String#indexOf(String)}. */\n    public static boolean contains(String str, String searchStr) {\n        return StringUtils.contains(str, searchStr);\n    }\n\n    /** Checks if String contains a search String irrespective of case, handling <code>null</code>. Case-insensitivity is defined as by {@link String#equalsIgnoreCase(String)}. */\n    public static boolean containsIgnoreCase(String str, String searchStr) {\n        return StringUtils.containsIgnoreCase(str, searchStr);\n    }\n\n    /** Checks if the String contains any character in the given set of string. */\n    public static boolean containsAny(String str, List<String> searchStrArray) {\n        if (StringUtils.isEmpty(str) || searchStrArray == null || searchStrArray.isEmpty()) {\n            return false;\n        }\n        for (String item : searchStrArray) {\n            if (contains(str, item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /** Case in-sensitive Checks if the String contains any character in the given set of string. */\n    public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n        if (StringUtils.isEmpty(str) || searchStrArray == null || searchStrArray.isEmpty()) {\n            return false;\n        }\n        for (String item : searchStrArray) {\n            if (containsIgnoreCase(str, item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // trim/Sub/left/right\n    //-----------------------------------------------------------------------\n\n    /** 截断两边空格，如果为空返回为空。 */\n    public static String trim(final String str) {\n        return str == null ? null : str.trim();\n    }\n\n    /** Gets a substring from the specified String avoiding exceptions. */\n    public static String sub(String str, int start, int end) {\n        return StringUtils.substring(str, start, end);\n    }\n\n    /** Gets the leftmost <code>len</code> characters of a String. */\n    public static String left(String str, int len) {\n        return StringUtils.left(str, len);\n    }\n\n    /** Gets the rightmost <code>len</code> characters of a String. */\n    public static String right(String str, int len) {\n        return StringUtils.right(str, len);\n    }\n    // align/pading\n    //-----------------------------------------------------------------------\n\n    /** 字符串在指定长度下进行右对齐，空出来的字符使用padChar补齐。如果传入多个字符将会取第一个字符。 */\n    public static String alignRight(String str, String padChar, int len) {\n        if (str != null) {\n            if (str.length() > len) {\n                return str;\n            }\n        }\n        char pad = padChar.length() == 0 ? ' ' : padChar.charAt(0);\n        return StringUtils.rightPad(str, len, pad);\n    }\n\n    /** 字符串在指定长度下进行左对齐，空出来的字符使用padChar补齐。如果传入多个字符将会取第一个字符。 */\n    public static String alignLeft(String str, String padChar, int len) {\n        if (str != null) {\n            if (str.length() > len) {\n                return str;\n            }\n        }\n        char pad = padChar.length() == 0 ? ' ' : padChar.charAt(0);\n        return StringUtils.leftPad(str, len, pad);\n    }\n\n    /** 字符串在指定长度下进行剧中对齐，空出来的字符使用padChar补齐。如果传入多个字符将会取第一个字符。 */\n    public static String alignCenter(String str, String padChar, int len) {\n        if (str != null) {\n            if (str.length() > len) {\n                return str;\n            }\n        }\n        char pad = padChar.length() == 0 ? ' ' : padChar.charAt(0);\n        return StringUtils.center(str, len, pad);\n    }\n    // compare\n    //-----------------------------------------------------------------------\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * <p>\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let <i>k</i> be the smallest such index; then the string\n     * whose character at position <i>k</i> has the smaller value, as\n     * determined by using the &lt; operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * <blockquote><pre>\n     * this.charAt(k)-anotherString.charAt(k)\n     * </pre></blockquote>\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * <blockquote><pre>\n     * this.length()-anotherString.length()\n     * </pre></blockquote>\n     *\n     * @param   str1   the {@code String} to be compared.\n     * @param   str2   the {@code String} to be compared.\n     * @return the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public static int compareString(String str1, String str2) {\n        str1 = str1 == null ? \"\" : str1;\n        str2 = str2 == null ? \"\" : str2;\n        return str1.compareTo(str2);\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with normalized versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(character))} on\n     * each character.\n     * <p>\n     * Note that this method does <em>not</em> take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The java.text package provides <em>collators</em> to allow\n     * locale-sensitive ordering.\n     *\n     * @param   str1   the {@code String} to be compared.\n     * @param   str2   the {@code String} to be compared.\n     * @return a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator#compare(String, String)\n     * @since 1.2\n     */\n    public static int compareStringIgnoreCase(String str1, String str2) {\n        str1 = str1 == null ? \"\" : str1;\n        str2 = str2 == null ? \"\" : str2;\n        return str1.compareToIgnoreCase(str2);\n    }\n    // other\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Splits the provided text into an array, separators specified.\n     * This is an alternative to using StringTokenizer.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as one separator.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separatorChars splits on whitespace.</p>\n     *\n     * <pre>\n     * StringUtils.split(null, *)         = null\n     * StringUtils.split(\"\", *)           = []\n     * StringUtils.split(\"abc def\", null) = [\"abc\", \"def\"]\n     * StringUtils.split(\"abc def\", \" \")  = [\"abc\", \"def\"]\n     * StringUtils.split(\"abc  def\", \" \") = [\"abc\", \"def\"]\n     * StringUtils.split(\"ab:cd:ef\", \":\") = [\"ab\", \"cd\", \"ef\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separatorChars  the characters used as the delimiters, <code>null</code> splits on whitespace\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    public static List<String> split(String str, String separatorChars) {\n        return Arrays.asList(StringUtils.split(str, separatorChars));\n    }\n\n    /** Joins the elements of the provided array into a single String containing the provided list of elements. */\n    public static String join(List<Object> array, String separator) {\n        if (array == null) {\n            return null;\n        }\n        return StringUtils.join(array.toArray(), separator);\n    }\n\n    /** Checks if a String is empty (\"\") or null.*/\n    public static boolean isEmpty(String str) {\n        return str == null || str.length() == 0;\n    }\n\n    /** 忽略大小写比较相等 */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n}\n",
      "file_name": "StringUdfSource.java",
      "human_label": "Find the last index of the searchStr in str, and return INDEXNOTFOUND if str is empty.",
      "level": "project_runnable",
      "lineno": "160",
      "name": "lastIndexOf",
      "oracle_context": "{ \"apis\" : \"[isEmpty]\", \"classes\" : \"[StringUtils]\", \"vars\" : \"[INDEX_NOT_FOUND]\" }",
      "package": "net.hasor.dataql.fx.basic",
      "project": "hasor-master"
    },
    {
      "_id": "6367670b1a6d9265ec0179fe",
      "all_context": "{ \"class_level\" : \"import java.io.IOException;\\nimport java.io.OutputStream;\\nint threshold;\\nlong written;\\nboolean thresholdExceeded;\\nThresholdingOutputStream(int threshold);\\nwrite(byte b);\\nwrite(byte b,int off,int len);\\nflush();\\nclose();\\ngetThreshold();\\ngetByteCount();\\nisThresholdExceeded();\\ncheckThreshold(int count);\\nresetByteCount();\\ngetStream();\\nthresholdReached();\\nwrite(int b);\\n\", \"repo_level\" : \"\" }",
      "class_name": "ThresholdingOutputStream",
      "code": "@Override public void write(byte b[]) throws IOException {\n  checkThreshold(b.length);\n  getStream().write(b);\n  written+=b.length;\n}\n",
      "docstring": "/** \n * Writes <code>b.length</code> bytes from the specified byte array to this output stream.\n * @param b The array of bytes to be written.\n * @exception IOException if an error occurs.\n */\n",
      "end_lineno": "91",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.io.output;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\n/**\n * An output stream which triggers an event when a specified number of bytes of\n * data have been written to it. The event can be used, for example, to throw\n * an exception if a maximum has been reached, or to switch the underlying\n * stream type when the threshold is exceeded.\n * <p>\n * This class overrides all <code>OutputStream</code> methods. However, these\n * overrides ultimately call the corresponding methods in the underlying output\n * stream implementation.\n * <p>\n * NOTE: This implementation may trigger the event <em>before</em> the threshold\n * is actually reached, since it triggers when a pending write operation would\n * cause the threshold to be exceeded.\n *\n * @version $Id: ThresholdingOutputStream.java 1307462 2012-03-30 15:13:11Z ggregory $\n */\npublic abstract class ThresholdingOutputStream extends OutputStream {\n    // ----------------------------------------------------------- Data members\n    /**\n     * The threshold at which the event will be triggered.\n     */\n    private final int     threshold;\n    /**\n     * The number of bytes written to the output stream.\n     */\n    private       long    written;\n    /**\n     * Whether or not the configured threshold has been exceeded.\n     */\n    private       boolean thresholdExceeded;\n    // ----------------------------------------------------------- Constructors\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the\n     * specified threshold.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     */\n    public ThresholdingOutputStream(int threshold) {\n        this.threshold = threshold;\n    }\n    // --------------------------------------------------- OutputStream methods\n\n    /**\n     * Writes the specified byte to this output stream.\n     *\n     * @param b The byte to be written.\n     *\n     * @exception IOException if an error occurs.\n     */\n    @Override\n    public void write(int b) throws IOException {\n        checkThreshold(1);\n        getStream().write(b);\n        written++;\n    }\n\n    /**\n     * Writes <code>b.length</code> bytes from the specified byte array to this\n     * output stream.\n     *\n     * @param b The array of bytes to be written.\n     *\n     * @exception IOException if an error occurs.\n     */\n    @Override\n    public void write(byte b[]) throws IOException {\n        checkThreshold(b.length);\n        getStream().write(b);\n        written += b.length;\n    }\n\n    /**\n     * Writes <code>len</code> bytes from the specified byte array starting at\n     * offset <code>off</code> to this output stream.\n     *\n     * @param b   The byte array from which the data will be written.\n     * @param off The start offset in the byte array.\n     * @param len The number of bytes to write.\n     *\n     * @exception IOException if an error occurs.\n     */\n    @Override\n    public void write(byte b[], int off, int len) throws IOException {\n        checkThreshold(len);\n        getStream().write(b, off, len);\n        written += len;\n    }\n\n    /**\n     * Flushes this output stream and forces any buffered output bytes to be\n     * written out.\n     *\n     * @exception IOException if an error occurs.\n     */\n    @Override\n    public void flush() throws IOException {\n        getStream().flush();\n    }\n\n    /**\n     * Closes this output stream and releases any system resources associated\n     * with this stream.\n     *\n     * @exception IOException if an error occurs.\n     */\n    @Override\n    public void close() throws IOException {\n        try {\n            flush();\n        } catch (IOException ignored) {\n            // ignore\n        }\n        getStream().close();\n    }\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Returns the threshold, in bytes, at which an event will be triggered.\n     *\n     * @return The threshold point, in bytes.\n     */\n    public int getThreshold() {\n        return threshold;\n    }\n\n    /**\n     * Returns the number of bytes that have been written to this output stream.\n     *\n     * @return The number of bytes written.\n     */\n    public long getByteCount() {\n        return written;\n    }\n\n    /**\n     * Determines whether or not the configured threshold has been exceeded for\n     * this output stream.\n     *\n     * @return {@code true} if the threshold has been reached;\n     *         {@code false} otherwise.\n     */\n    public boolean isThresholdExceeded() {\n        return written > threshold;\n    }\n    // ------------------------------------------------------ Protected methods\n\n    /**\n     * Checks to see if writing the specified number of bytes would cause the\n     * configured threshold to be exceeded. If so, triggers an event to allow\n     * a concrete implementation to take action on this.\n     *\n     * @param count The number of bytes about to be written to the underlying\n     *              output stream.\n     *\n     * @exception IOException if an error occurs.\n     */\n    protected void checkThreshold(int count) throws IOException {\n        if (!thresholdExceeded && written + count > threshold) {\n            thresholdExceeded = true;\n            thresholdReached();\n        }\n    }\n\n    /**\n     * Resets the byteCount to zero.  You can call this from \n     * {@link #thresholdReached()} if you want the event to be triggered again. \n     */\n    protected void resetByteCount() {\n        this.thresholdExceeded = false;\n        this.written = 0;\n    }\n    // ------------------------------------------------------- Abstract methods\n\n    /**\n     * Returns the underlying output stream, to which the corresponding\n     * <code>OutputStream</code> methods in this class will ultimately delegate.\n     *\n     * @return The underlying output stream.\n     *\n     * @exception IOException if an error occurs.\n     */\n    protected abstract OutputStream getStream() throws IOException;\n\n    /**\n     * Indicates that the configured threshold has been reached, and that a\n     * subclass should take whatever action necessary on this event. This may\n     * include changing the underlying output stream.\n     *\n     * @exception IOException if an error occurs.\n     */\n    protected abstract void thresholdReached() throws IOException;\n}\n",
      "file_name": "ThresholdingOutputStream.java",
      "human_label": "Write the given byte array b into the output stream that this class represents.",
      "level": "class_runnable",
      "lineno": "78",
      "name": "write",
      "oracle_context": "{ \"apis\" : \"[checkThreshold, getStream]\", \"classes\" : \"[]\", \"vars\" : \"[length, written]\" }",
      "package": "net.hasor.utils.io.output",
      "project": "hasor-master"
    },
    {
      "_id": "636767df1a6d9265ec01873c",
      "all_context": "{ \"class_level\" : \"import lombok.Getter;\\nimport org.apache.skywalking.oap.server.core.Const;\\nlong point;\\nPointOfTime(long point);\\n\", \"repo_level\" : \"public interface Const { }\\n\" }",
      "class_name": "PointOfTime",
      "code": "public String id(String entityId){\n  if (entityId == null) {\n    return String.valueOf(point);\n  }\n else {\n    return point + Const.ID_CONNECTOR + entityId;\n  }\n}\n",
      "docstring": "/** \n * @return the row id\n */\n",
      "end_lineno": "45",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage org.apache.skywalking.oap.server.core.query;\n\nimport lombok.Getter;\nimport org.apache.skywalking.oap.server.core.Const;\n\n/**\n * PointOfTime represents any point of time based on different precisions.\n */\n@Getter\npublic class PointOfTime {\n    private long point;\n\n    public PointOfTime(long point) {\n        this.point = point;\n    }\n\n    /**\n     * @return the row id\n     */\n    public String id(String entityId) {\n        // null means scope = all or unexpected entity.\n        if (entityId == null) {\n            return String.valueOf(point);\n        } else {\n            return point + Const.ID_CONNECTOR + entityId;\n        }\n    }\n}",
      "file_name": "PointOfTime.java",
      "human_label": "Return the id by concatenating the point and the entity id with id connector.",
      "level": "project_runnable",
      "lineno": "35",
      "name": "id",
      "oracle_context": "{ \"apis\" : \"[valueOf]\", \"classes\" : \"[Const]\", \"vars\" : \"[ID_CONNECTOR, point]\" }",
      "package": "org.apache.skywalking.oap.server.core.query",
      "project": "skywalking-master"
    },
    {
      "_id": "636766f91a6d9265ec01777f",
      "all_context": "{ \"class_level\" : \"BooleanUtils();\\nisTrue(Boolean bool);\\nisNotTrue(Boolean bool);\\nisFalse(Boolean bool);\\nisNotFalse(Boolean bool);\\ntoBooleanObject(boolean bool);\\ntoBoolean(Boolean bool);\\ntoBooleanDefaultIfNull(Boolean bool,boolean valueIfNull);\\ntoBoolean(int value);\\ntoBooleanObject(int value);\\ntoBooleanObject(Integer value);\\ntoBoolean(int value,int trueValue,int falseValue);\\ntoBoolean(Integer value,Integer trueValue,Integer falseValue);\\ntoBooleanObject(int value,int trueValue,int falseValue,int nullValue);\\ntoBooleanObject(Integer value,Integer trueValue,Integer falseValue,Integer nullValue);\\ntoInteger(boolean bool);\\ntoInteger(boolean bool,int trueValue,int falseValue);\\ntoInteger(Boolean bool,int trueValue,int falseValue,int nullValue);\\ntoIntegerObject(boolean bool,Integer trueValue,Integer falseValue);\\ntoIntegerObject(Boolean bool,Integer trueValue,Integer falseValue,Integer nullValue);\\ntoBooleanObject(String str);\\ntoBooleanObject(String str,String trueString,String falseString,String nullString);\\ntoBoolean(String str);\\ntoBoolean(String str,String trueString,String falseString);\\ntoStringTrueFalse(Boolean bool);\\ntoStringOnOff(Boolean bool);\\ntoStringYesNo(Boolean bool);\\ntoString(Boolean bool,String trueString,String falseString,String nullString);\\ntoStringTrueFalse(boolean bool);\\ntoStringOnOff(boolean bool);\\ntoStringYesNo(boolean bool);\\ntoString(boolean bool,String trueString,String falseString);\\nxor(boolean[] array);\\nxor(Boolean[] array);\\nisBooleanType(Class targetType);\\nnegate(Boolean bool);\\n\", \"repo_level\" : \"\" }",
      "class_name": "BooleanUtils",
      "code": "public static boolean toBoolean(Boolean bool){\n  if (bool == null) {\n    return false;\n  }\n  return bool.booleanValue() ? true : false;\n}\n",
      "docstring": "/** \n * <p>Converts a Boolean to a boolean handling <code>null</code> by returning <code>false</code>.</p> <pre> BooleanUtils.toBoolean(Boolean.TRUE)  = true BooleanUtils.toBoolean(Boolean.FALSE) = false BooleanUtils.toBoolean(null)          = false </pre>\n * @param bool  the boolean to convert\n * @return <code>true</code> or <code>false</code>, <code>null</code> returns <code>false</code>\n */\n",
      "end_lineno": "184",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils;\n/**\n * <p>Operations on boolean primitives and Boolean objects.</p>\n *\n * <p>This class tries to handle <code>null</code> input gracefully.\n * An exception will not be thrown for a <code>null</code> input.\n * Each method documents its behaviour in more detail.</p>\n *\n * <p>#ThreadSafe#</p>\n * @author Apache Software Foundation\n * @author Matthew Hawthorne\n * @author Gary Gregory\n * @since 2.0\n * @version $Id: BooleanUtils.java 1057037 2011-01-09 21:35:32Z niallp $\n */\npublic class BooleanUtils {\n    /**\n     * <p><code>BooleanUtils</code> instances should NOT be constructed in standard programming.\n     * Instead, the class should be used as <code>BooleanUtils.toBooleanObject(true);</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     */\n    public BooleanUtils() {\n        super();\n    }\n    // Boolean utilities\n    //--------------------------------------------------------------------------\n\n    /**\n     * <p>Negates the specified boolean.</p>\n     *\n     * <p>If <code>null</code> is passed in, <code>null</code> will be returned.</p>\n     *\n     * <pre>\n     *   BooleanUtils.negate(Boolean.TRUE)  = Boolean.FALSE;\n     *   BooleanUtils.negate(Boolean.FALSE) = Boolean.TRUE;\n     *   BooleanUtils.negate(null)          = null;\n     * </pre>\n     *\n     * @param bool  the Boolean to negate, may be null\n     * @return the negated Boolean, or <code>null</code> if <code>null</code> input\n     */\n    public static Boolean negate(Boolean bool) {\n        if (bool == null) {\n            return null;\n        }\n        return (bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE);\n    }\n    // boolean Boolean methods\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if a <code>Boolean</code> value is <code>true</code>,\n     * handling <code>null</code> by returning <code>false</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.isTrue(Boolean.TRUE)  = true\n     *   BooleanUtils.isTrue(Boolean.FALSE) = false\n     *   BooleanUtils.isTrue(null)          = false\n     * </pre>\n     *\n     * @param bool  the boolean to check, null returns <code>false</code>\n     * @return <code>true</code> only if the input is non-null and true\n     * @since 2.1\n     */\n    public static boolean isTrue(Boolean bool) {\n        if (bool == null) {\n            return false;\n        }\n        return bool.booleanValue() ? true : false;\n    }\n\n    /**\n     * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>true</code>,\n     * handling <code>null</code> by returning <code>true</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.isNotTrue(Boolean.TRUE)  = false\n     *   BooleanUtils.isNotTrue(Boolean.FALSE) = true\n     *   BooleanUtils.isNotTrue(null)          = true\n     * </pre>\n     *\n     * @param bool  the boolean to check, null returns <code>true</code>\n     * @return <code>true</code> if the input is null or false\n     * @since 2.3\n     */\n    public static boolean isNotTrue(Boolean bool) {\n        return !isTrue(bool);\n    }\n\n    /**\n     * <p>Checks if a <code>Boolean</code> value is <code>false</code>,\n     * handling <code>null</code> by returning <code>false</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.isFalse(Boolean.TRUE)  = false\n     *   BooleanUtils.isFalse(Boolean.FALSE) = true\n     *   BooleanUtils.isFalse(null)          = false\n     * </pre>\n     *\n     * @param bool  the boolean to check, null returns <code>false</code>\n     * @return <code>true</code> only if the input is non-null and false\n     * @since 2.1\n     */\n    public static boolean isFalse(Boolean bool) {\n        if (bool == null) {\n            return false;\n        }\n        return bool.booleanValue() ? false : true;\n    }\n\n    /**\n     * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>false</code>,\n     * handling <code>null</code> by returning <code>true</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.isNotFalse(Boolean.TRUE)  = true\n     *   BooleanUtils.isNotFalse(Boolean.FALSE) = false\n     *   BooleanUtils.isNotFalse(null)          = true\n     * </pre>\n     *\n     * @param bool  the boolean to check, null returns <code>true</code>\n     * @return <code>true</code> if the input is null or true\n     * @since 2.3\n     */\n    public static boolean isNotFalse(Boolean bool) {\n        return !isFalse(bool);\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Boolean factory that avoids creating new Boolean objecs all the time.</p>\n     *\n     * <p>This method was added to JDK1.4 but is available here for earlier JDKs.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBooleanObject(false) = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(true)  = Boolean.TRUE\n     * </pre>\n     *\n     * @param bool  the boolean to convert\n     * @return Boolean.TRUE or Boolean.FALSE as appropriate\n     */\n    public static Boolean toBooleanObject(boolean bool) {\n        return bool ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    /**\n     * <p>Converts a Boolean to a boolean handling <code>null</code>\n     * by returning <code>false</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(Boolean.TRUE)  = true\n     *   BooleanUtils.toBoolean(Boolean.FALSE) = false\n     *   BooleanUtils.toBoolean(null)          = false\n     * </pre>\n     *\n     * @param bool  the boolean to convert\n     * @return <code>true</code> or <code>false</code>, \n     *  <code>null</code> returns <code>false</code>\n     */\n    public static boolean toBoolean(Boolean bool) {\n        if (bool == null) {\n            return false;\n        }\n        return bool.booleanValue() ? true : false;\n    }\n\n    /**\n     * <p>Converts a Boolean to a boolean handling <code>null</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, false) = true\n     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, true) = false\n     *   BooleanUtils.toBooleanDefaultIfNull(null, true)          = true\n     * </pre>\n     *\n     * @param bool  the boolean to convert\n     * @param valueIfNull  the boolean value to return if <code>null</code>\n     * @return <code>true</code> or <code>false</code>\n     */\n    public static boolean toBooleanDefaultIfNull(Boolean bool, boolean valueIfNull) {\n        if (bool == null) {\n            return valueIfNull;\n        }\n        return bool.booleanValue() ? true : false;\n    }\n    // Integer to Boolean methods\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an int to a boolean using the convention that <code>zero</code>\n     * is <code>false</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(0) = false\n     *   BooleanUtils.toBoolean(1) = true\n     *   BooleanUtils.toBoolean(2) = true\n     * </pre>\n     *\n     * @param value  the int to convert\n     * @return <code>true</code> if non-zero, <code>false</code>\n     *  if zero\n     */\n    public static boolean toBoolean(int value) {\n        return value == 0 ? false : true;\n    }\n\n    /**\n     * <p>Converts an int to a Boolean using the convention that <code>zero</code>\n     * is <code>false</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(0) = Boolean.FALSE\n     *   BooleanUtils.toBoolean(1) = Boolean.TRUE\n     *   BooleanUtils.toBoolean(2) = Boolean.TRUE\n     * </pre>\n     *\n     * @param value  the int to convert\n     * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n     *  <code>null</code> if <code>null</code>\n     */\n    public static Boolean toBooleanObject(int value) {\n        return value == 0 ? Boolean.FALSE : Boolean.TRUE;\n    }\n\n    /**\n     * <p>Converts an Integer to a Boolean using the convention that <code>zero</code>\n     * is <code>false</code>.</p>\n     *\n     * <p><code>null</code> will be converted to <code>null</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(new Integer(0))    = Boolean.FALSE\n     *   BooleanUtils.toBoolean(new Integer(1))    = Boolean.TRUE\n     *   BooleanUtils.toBoolean(new Integer(null)) = null\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n     *  <code>null</code> if <code>null</code> input\n     */\n    public static Boolean toBooleanObject(Integer value) {\n        if (value == null) {\n            return null;\n        }\n        return value.intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n    }\n\n    /**\n     * <p>Converts an int to a boolean specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(0, 1, 0) = false\n     *   BooleanUtils.toBoolean(1, 1, 0) = true\n     *   BooleanUtils.toBoolean(2, 1, 2) = false\n     *   BooleanUtils.toBoolean(2, 2, 0) = true\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @param trueValue  the value to match for <code>true</code>\n     * @param falseValue  the value to match for <code>false</code>\n     * @return <code>true</code> or <code>false</code>\n     * @throws IllegalArgumentException if no match\n     */\n    public static boolean toBoolean(int value, int trueValue, int falseValue) {\n        if (value == trueValue) {\n            return true;\n        } else if (value == falseValue) {\n            return false;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n    }\n\n    /**\n     * <p>Converts an Integer to a boolean specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(new Integer(0), new Integer(1), new Integer(0)) = false\n     *   BooleanUtils.toBoolean(new Integer(1), new Integer(1), new Integer(0)) = true\n     *   BooleanUtils.toBoolean(new Integer(2), new Integer(1), new Integer(2)) = false\n     *   BooleanUtils.toBoolean(new Integer(2), new Integer(2), new Integer(0)) = true\n     *   BooleanUtils.toBoolean(null, null, new Integer(0))                     = true\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @param trueValue  the value to match for <code>true</code>,\n     *  may be <code>null</code>\n     * @param falseValue  the value to match for <code>false</code>,\n     *  may be <code>null</code>\n     * @return <code>true</code> or <code>false</code>\n     * @throws IllegalArgumentException if no match\n     */\n    public static boolean toBoolean(Integer value, Integer trueValue, Integer falseValue) {\n        if (value == null) {\n            if (trueValue == null) {\n                return true;\n            } else if (falseValue == null) {\n                return false;\n            }\n        } else if (value.equals(trueValue)) {\n            return true;\n        } else if (value.equals(falseValue)) {\n            return false;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n    }\n\n    /**\n     * <p>Converts an int to a Boolean specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBooleanObject(0, 0, 2, 3) = Boolean.TRUE\n     *   BooleanUtils.toBooleanObject(2, 1, 2, 3) = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(3, 1, 2, 3) = null\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @param trueValue  the value to match for <code>true</code>\n     * @param falseValue  the value to match for <code>false</code>\n     * @param nullValue  the value to to match for <code>null</code>\n     * @return Boolean.TRUE, Boolean.FALSE, or <code>null</code>\n     * @throws IllegalArgumentException if no match\n     */\n    public static Boolean toBooleanObject(int value, int trueValue, int falseValue, int nullValue) {\n        if (value == trueValue) {\n            return Boolean.TRUE;\n        } else if (value == falseValue) {\n            return Boolean.FALSE;\n        } else if (value == nullValue) {\n            return null;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n    }\n\n    /**\n     * <p>Converts an Integer to a Boolean specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBooleanObject(new Integer(0), new Integer(0), new Integer(2), new Integer(3)) = Boolean.TRUE\n     *   BooleanUtils.toBooleanObject(new Integer(2), new Integer(1), new Integer(2), new Integer(3)) = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(new Integer(3), new Integer(1), new Integer(2), new Integer(3)) = null\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @param trueValue  the value to match for <code>true</code>,\n     *  may be <code>null</code>\n     * @param falseValue  the value to match for <code>false</code>,\n     *  may be <code>null</code>\n     * @param nullValue  the value to to match for <code>null</code>,\n     *  may be <code>null</code>\n     * @return Boolean.TRUE, Boolean.FALSE, or <code>null</code>\n     * @throws IllegalArgumentException if no match\n     */\n    public static Boolean toBooleanObject(Integer value, Integer trueValue, Integer falseValue, Integer nullValue) {\n        if (value == null) {\n            if (trueValue == null) {\n                return Boolean.TRUE;\n            } else if (falseValue == null) {\n                return Boolean.FALSE;\n            } else if (nullValue == null) {\n                return null;\n            }\n        } else if (value.equals(trueValue)) {\n            return Boolean.TRUE;\n        } else if (value.equals(falseValue)) {\n            return Boolean.FALSE;\n        } else if (value.equals(nullValue)) {\n            return null;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n    }\n    // Boolean to Integer methods\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts a boolean to an int using the convention that\n     * <code>zero</code> is <code>false</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toInteger(true)  = 1\n     *   BooleanUtils.toInteger(false) = 0\n     * </pre>\n     *\n     * @param bool  the boolean to convert\n     * @return one if <code>true</code>, zero if <code>false</code>\n     */\n    public static int toInteger(boolean bool) {\n        return bool ? 1 : 0;\n    }\n\n    /**\n     * <p>Converts a boolean to an int specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toInteger(true, 1, 0)  = 1\n     *   BooleanUtils.toInteger(false, 1, 0) = 0\n     * </pre>\n     *\n     * @param bool  the to convert\n     * @param trueValue  the value to return if <code>true</code>\n     * @param falseValue  the value to return if <code>false</code>\n     * @return the appropriate value\n     */\n    public static int toInteger(boolean bool, int trueValue, int falseValue) {\n        return bool ? trueValue : falseValue;\n    }\n\n    /**\n     * <p>Converts a Boolean to an int specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toInteger(Boolean.TRUE, 1, 0, 2)  = 1\n     *   BooleanUtils.toInteger(Boolean.FALSE, 1, 0, 2) = 0\n     *   BooleanUtils.toInteger(null, 1, 0, 2)          = 2\n     * </pre>\n     *\n     * @param bool  the Boolean to convert\n     * @param trueValue  the value to return if <code>true</code>\n     * @param falseValue  the value to return if <code>false</code>\n     * @param nullValue  the value to return if <code>null</code>\n     * @return the appropriate value\n     */\n    public static int toInteger(Boolean bool, int trueValue, int falseValue, int nullValue) {\n        if (bool == null) {\n            return nullValue;\n        }\n        return bool.booleanValue() ? trueValue : falseValue;\n    }\n\n    /**\n     * <p>Converts a boolean to an Integer specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toIntegerObject(true, new Integer(1), new Integer(0))  = new Integer(1)\n     *   BooleanUtils.toIntegerObject(false, new Integer(1), new Integer(0)) = new Integer(0)\n     * </pre>\n     *\n     * @param bool  the to convert\n     * @param trueValue  the value to return if <code>true</code>,\n     *  may be <code>null</code>\n     * @param falseValue  the value to return if <code>false</code>,\n     *  may be <code>null</code>\n     * @return the appropriate value\n     */\n    public static Integer toIntegerObject(boolean bool, Integer trueValue, Integer falseValue) {\n        return bool ? trueValue : falseValue;\n    }\n\n    /**\n     * <p>Converts a Boolean to an Integer specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toIntegerObject(Boolean.TRUE, new Integer(1), new Integer(0), new Integer(2))  = new Integer(1)\n     *   BooleanUtils.toIntegerObject(Boolean.FALSE, new Integer(1), new Integer(0), new Integer(2)) = new Integer(0)\n     *   BooleanUtils.toIntegerObject(null, new Integer(1), new Integer(0), new Integer(2))          = new Integer(2)\n     * </pre>\n     *\n     * @param bool  the Boolean to convert\n     * @param trueValue  the value to return if <code>true</code>,\n     *  may be <code>null</code>\n     * @param falseValue  the value to return if <code>false</code>,\n     *  may be <code>null</code>\n     * @param nullValue  the value to return if <code>null</code>,\n     *  may be <code>null</code>\n     * @return the appropriate value\n     */\n    public static Integer toIntegerObject(Boolean bool, Integer trueValue, Integer falseValue, Integer nullValue) {\n        if (bool == null) {\n            return nullValue;\n        }\n        return bool.booleanValue() ? trueValue : falseValue;\n    }\n    // String to Boolean methods\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts a String to a Boolean.</p>\n     *\n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>.\n     * <code>'false'</code>, <code>'off'</code> or <code>'no'</code>\n     * (case insensitive) will return <code>false</code>.\n     * Otherwise, <code>null</code> is returned.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBooleanObject(null)    = null\n     *   BooleanUtils.toBooleanObject(\"true\")  = Boolean.TRUE\n     *   BooleanUtils.toBooleanObject(\"false\") = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(\"on\")    = Boolean.TRUE\n     *   BooleanUtils.toBooleanObject(\"ON\")    = Boolean.TRUE\n     *   BooleanUtils.toBooleanObject(\"off\")   = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(\"oFf\")   = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(\"blue\")  = null\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the Boolean value of the string,\n     *  <code>null</code> if no match or <code>null</code> input\n     */\n    public static Boolean toBooleanObject(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == null) {\n            return null;\n        }\n        if (\"true\".equals(str)) {\n            return Boolean.TRUE;\n        }\n        switch (str.length()) {\n        case 1: {\n            char ch0 = str.charAt(0);\n            if ((ch0 == 'y' || ch0 == 'Y') || (ch0 == 't' || ch0 == 'T')) {\n                return Boolean.TRUE;\n            }\n            if ((ch0 == 'n' || ch0 == 'N') || (ch0 == 'f' || ch0 == 'F')) {\n                return Boolean.FALSE;\n            }\n            break;\n        }\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) {\n                return Boolean.TRUE;\n            }\n            if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) {\n                return Boolean.FALSE;\n            }\n            break;\n        }\n        case 3: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) {\n                return Boolean.TRUE;\n            }\n            if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) {\n                return Boolean.FALSE;\n            }\n            break;\n        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) {\n                return Boolean.TRUE;\n            }\n            break;\n        }\n        case 5: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) {\n                return Boolean.FALSE;\n            }\n            break;\n        }\n        }\n        return null;\n    }\n\n    /**\n     * <p>Converts a String to a Boolean throwing an exception if no match.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBooleanObject(\"true\", \"true\", \"false\", \"null\")  = Boolean.TRUE\n     *   BooleanUtils.toBooleanObject(\"false\", \"true\", \"false\", \"null\") = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(\"null\", \"true\", \"false\", \"null\")  = null\n     * </pre>\n     *\n     * @param str  the String to check\n     * @param trueString  the String to match for <code>true</code>\n     *  (case sensitive), may be <code>null</code>\n     * @param falseString  the String to match for <code>false</code>\n     *  (case sensitive), may be <code>null</code>\n     * @param nullString  the String to match for <code>null</code>\n     *  (case sensitive), may be <code>null</code>\n     * @return the Boolean value of the string,\n     *  <code>null</code> if either the String matches <code>nullString</code>\n     *  or if <code>null</code> input and <code>nullString</code> is\n     *  <code>null</code>\n     * @throws IllegalArgumentException if the String doesn't match\n     */\n    public static Boolean toBooleanObject(String str, String trueString, String falseString, String nullString) {\n        if (str == null) {\n            if (trueString == null) {\n                return Boolean.TRUE;\n            } else if (falseString == null) {\n                return Boolean.FALSE;\n            } else if (nullString == null) {\n                return null;\n            }\n        } else if (str.equals(trueString)) {\n            return Boolean.TRUE;\n        } else if (str.equals(falseString)) {\n            return Boolean.FALSE;\n        } else if (str.equals(nullString)) {\n            return null;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The String did not match any specified value\");\n    }\n    // String to boolean methods\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts a String to a boolean (optimised for performance).</p>\n     *\n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>. Otherwise,\n     * <code>false</code> is returned.</p>\n     *\n     * <p>This method performs 4 times faster (JDK1.4) than\n     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n     * 'on' and 'yes' as true values.\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(null)    = false\n     *   BooleanUtils.toBoolean(\"true\")  = true\n     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n     *   BooleanUtils.toBoolean(\"on\")    = true\n     *   BooleanUtils.toBoolean(\"yes\")   = true\n     *   BooleanUtils.toBoolean(\"false\") = false\n     *   BooleanUtils.toBoolean(\"x gti\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the boolean value of the string, <code>false</code> if no match or the String is null\n     */\n    public static boolean toBoolean(String str) {\n        return toBoolean(toBooleanObject(str));\n    }\n\n    /**\n     * <p>Converts a String to a Boolean throwing an exception if no match found.</p>\n     *\n     * <p>null is returned if there is no match.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(\"true\", \"true\", \"false\")  = true\n     *   BooleanUtils.toBoolean(\"false\", \"true\", \"false\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @param trueString  the String to match for <code>true</code>\n     *  (case sensitive), may be <code>null</code>\n     * @param falseString  the String to match for <code>false</code>\n     *  (case sensitive), may be <code>null</code>\n     * @return the boolean value of the string\n     * @throws IllegalArgumentException if the String doesn't match\n     */\n    public static boolean toBoolean(String str, String trueString, String falseString) {\n        if (str == null) {\n            if (trueString == null) {\n                return true;\n            } else if (falseString == null) {\n                return false;\n            }\n        } else if (str.equals(trueString)) {\n            return true;\n        } else if (str.equals(falseString)) {\n            return false;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The String did not match either specified value\");\n    }\n    // Boolean to String methods\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts a Boolean to a String returning <code>'true'</code>,\n     * <code>'false'</code>, or <code>null</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toStringTrueFalse(Boolean.TRUE)  = \"true\"\n     *   BooleanUtils.toStringTrueFalse(Boolean.FALSE) = \"false\"\n     *   BooleanUtils.toStringTrueFalse(null)          = null;\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @return <code>'true'</code>, <code>'false'</code>,\n     *  or <code>null</code>\n     */\n    public static String toStringTrueFalse(Boolean bool) {\n        return toString(bool, \"true\", \"false\", null);\n    }\n\n    /**\n     * <p>Converts a Boolean to a String returning <code>'on'</code>,\n     * <code>'off'</code>, or <code>null</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toStringOnOff(Boolean.TRUE)  = \"on\"\n     *   BooleanUtils.toStringOnOff(Boolean.FALSE) = \"off\"\n     *   BooleanUtils.toStringOnOff(null)          = null;\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @return <code>'on'</code>, <code>'off'</code>,\n     *  or <code>null</code>\n     */\n    public static String toStringOnOff(Boolean bool) {\n        return toString(bool, \"on\", \"off\", null);\n    }\n\n    /**\n     * <p>Converts a Boolean to a String returning <code>'yes'</code>,\n     * <code>'no'</code>, or <code>null</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toStringYesNo(Boolean.TRUE)  = \"yes\"\n     *   BooleanUtils.toStringYesNo(Boolean.FALSE) = \"no\"\n     *   BooleanUtils.toStringYesNo(null)          = null;\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @return <code>'yes'</code>, <code>'no'</code>,\n     *  or <code>null</code>\n     */\n    public static String toStringYesNo(Boolean bool) {\n        return toString(bool, \"yes\", \"no\", null);\n    }\n\n    /**\n     * <p>Converts a Boolean to a String returning one of the input Strings.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toString(Boolean.TRUE, \"true\", \"false\", null)   = \"true\"\n     *   BooleanUtils.toString(Boolean.FALSE, \"true\", \"false\", null)  = \"false\"\n     *   BooleanUtils.toString(null, \"true\", \"false\", null)           = null;\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @param trueString  the String to return if <code>true</code>,\n     *  may be <code>null</code>\n     * @param falseString  the String to return if <code>false</code>,\n     *  may be <code>null</code>\n     * @param nullString  the String to return if <code>null</code>,\n     *  may be <code>null</code>\n     * @return one of the three input Strings\n     */\n    public static String toString(Boolean bool, String trueString, String falseString, String nullString) {\n        if (bool == null) {\n            return nullString;\n        }\n        return bool.booleanValue() ? trueString : falseString;\n    }\n    // boolean to String methods\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts a boolean to a String returning <code>'true'</code>\n     * or <code>'false'</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toStringTrueFalse(true)   = \"true\"\n     *   BooleanUtils.toStringTrueFalse(false)  = \"false\"\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @return <code>'true'</code>, <code>'false'</code>,\n     *  or <code>null</code>\n     */\n    public static String toStringTrueFalse(boolean bool) {\n        return toString(bool, \"true\", \"false\");\n    }\n\n    /**\n     * <p>Converts a boolean to a String returning <code>'on'</code>\n     * or <code>'off'</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toStringOnOff(true)   = \"on\"\n     *   BooleanUtils.toStringOnOff(false)  = \"off\"\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @return <code>'on'</code>, <code>'off'</code>,\n     *  or <code>null</code>\n     */\n    public static String toStringOnOff(boolean bool) {\n        return toString(bool, \"on\", \"off\");\n    }\n\n    /**\n     * <p>Converts a boolean to a String returning <code>'yes'</code>\n     * or <code>'no'</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toStringYesNo(true)   = \"yes\"\n     *   BooleanUtils.toStringYesNo(false)  = \"no\"\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @return <code>'yes'</code>, <code>'no'</code>,\n     *  or <code>null</code>\n     */\n    public static String toStringYesNo(boolean bool) {\n        return toString(bool, \"yes\", \"no\");\n    }\n\n    /**\n     * <p>Converts a boolean to a String returning one of the input Strings.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toString(true, \"true\", \"false\")   = \"true\"\n     *   BooleanUtils.toString(false, \"true\", \"false\")  = \"false\"\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @param trueString  the String to return if <code>true</code>,\n     *  may be <code>null</code>\n     * @param falseString  the String to return if <code>false</code>,\n     *  may be <code>null</code>\n     * @return one of the two input Strings\n     */\n    public static String toString(boolean bool, String trueString, String falseString) {\n        return bool ? trueString : falseString;\n    }\n    // xor methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Performs an xor on a set of booleans.</p>\n     *\n     * <pre>\n     *   BooleanUtils.xor(new boolean[] { true, true })   = false\n     *   BooleanUtils.xor(new boolean[] { false, false }) = false\n     *   BooleanUtils.xor(new boolean[] { true, false })  = true\n     * </pre>\n     *\n     * @param array  an array of <code>boolean<code>s\n     * @return <code>true</code> if the xor is successful.\n     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n     * @throws IllegalArgumentException if <code>array</code> is empty.\n     */\n    public static boolean xor(boolean[] array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        // Loops through array, comparing each item\n        int trueCount = 0;\n        for (int i = 0; i < array.length; i++) {\n            // If item is true, and trueCount is < 1, increments count\n            // Else, xor fails\n            if (array[i]) {\n                if (trueCount < 1) {\n                    trueCount++;\n                } else {\n                    return false;\n                }\n            }\n        }\n        // Returns true if there was exactly 1 true item\n        return trueCount == 1;\n    }\n\n    /**\n     * <p>Performs an xor on an array of Booleans.</p>\n     *\n     * <pre>\n     *   BooleanUtils.xor(new Boolean[] { Boolean.TRUE, Boolean.TRUE })   = Boolean.FALSE\n     *   BooleanUtils.xor(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) = Boolean.FALSE\n     *   BooleanUtils.xor(new Boolean[] { Boolean.TRUE, Boolean.FALSE })  = Boolean.TRUE\n     * </pre>\n     *\n     * @param array  an array of <code>Boolean<code>s\n     * @return <code>true</code> if the xor is successful.\n     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n     * @throws IllegalArgumentException if <code>array</code> is empty.\n     * @throws IllegalArgumentException if <code>array</code> contains a <code>null</code>\n     */\n    public static Boolean xor(Boolean[] array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        boolean[] primitive = null;\n        try {\n            primitive = ArrayUtils.toPrimitive(array);\n        } catch (NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n        return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    //\n    public static boolean isBooleanType(Class targetType) {\n        return targetType.equals(Boolean.class) || targetType.equals(Boolean.TYPE);\n    }\n}\n",
      "file_name": "BooleanUtils.java",
      "human_label": "Convert a Boolean to a boolean handling null by returning false.",
      "level": "self_contained",
      "lineno": "165",
      "name": "toBoolean",
      "oracle_context": "{ \"apis\" : \"[booleanValue]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
      "package": "net.hasor.utils",
      "project": "hasor-master"
    },
    {
      "_id": "6367675f1a6d9265ec0180d3",
      "all_context": "{ \"class_level\" : \"import org.jgrapht.*;\\nimport org.jgrapht.util.*;\\nimport java.util.*;\\nint NULL_NODE;\\nMap<V,V> forwardMapping;\\nMap<V,V> backwardMapping;\\nGraph<V,E> graph1;\\nGraph<V,E> graph2;\\nIsomorphicGraphMapping(GraphOrdering g1,GraphOrdering g2,int[] core1,int[] core2);\\nIsomorphicGraphMapping(Map forwardMapping,Map backwardMapping,Graph graph1,Graph graph2);\\ngetVertexCorrespondence(V v,boolean forward);\\ngetEdgeCorrespondence(E e,boolean forward);\\ngetForwardMapping();\\ngetBackwardMapping();\\ngetMappingDomain();\\ngetMappingRange();\\nhasEdgeCorrespondence(E e);\\nequals(Object o);\\nhashCode();\\ntoString();\\nisValidIsomorphism();\\nisEqualMapping(GraphMapping rel);\\ncompose(IsomorphicGraphMapping otherMapping);\\nidentity(Graph graph);\\nhasVertexCorrespondence(V v);\\n\", \"repo_level\" : \"\" }",
      "class_name": "IsomorphicGraphMapping",
      "code": "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n  Map<V,V> fMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());\n  Map<V,V> bMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());\n  for (  V v : graph.vertexSet()) {\n    fMap.put(v,v);\n    bMap.put(v,v);\n  }\n  return new IsomorphicGraphMapping<>(fMap,bMap,graph,graph);\n}\n",
      "docstring": "/** \n * Computes an identity automorphism (i.e. a self-mapping of a graph in which each vertex also maps to itself).\n * @param graph the input graph\n * @param < V > the graph vertex type\n * @param < E > the graph edge type\n * @return a mapping from graph to graph\n */\n",
      "end_lineno": "358",
      "file_content": "/*\n * (C) Copyright 2015-2021, by Fabian Späh and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.alg.isomorphism;\n\nimport org.jgrapht.*;\nimport org.jgrapht.util.*;\n\nimport java.util.*;\n\n/**\n * This class represents a GraphMapping between two (subgraph)isomorphic graphs. In the subgraph\n * isomorphic case, the second one is assumed to be a subgraph of the first one.\n *\n * @author Fabian Späh\n * @author Alexandru Valeanu\n *\n * @param <V> the type of the vertices\n * @param <E> the type of the edges\n */\npublic class IsomorphicGraphMapping<V, E>\n    implements\n    GraphMapping<V, E>\n{\n\n    public static final int NULL_NODE = -1;\n\n    private final Map<V, V> forwardMapping;\n    private final Map<V, V> backwardMapping;\n\n    private final Graph<V, E> graph1;\n    private final Graph<V, E> graph2;\n\n    /**\n     * Construct a new isomorphic graph mapping\n     * \n     * @param g1 the first graph\n     * @param g2 the second graph which is a possible subgraph of g1\n     * @param core1 the mapping as array (forwards)\n     * @param core2 the mapping as array (backwards)\n     */\n    public IsomorphicGraphMapping(\n        GraphOrdering<V, E> g1, GraphOrdering<V, E> g2, int[] core1, int[] core2)\n    {\n        this.graph1 = g1.getGraph();\n        this.graph2 = g2.getGraph();\n\n        this.forwardMapping =\n            CollectionUtil.newHashMapWithExpectedSize(this.graph1.vertexSet().size());\n        this.backwardMapping =\n            CollectionUtil.newHashMapWithExpectedSize(this.graph1.vertexSet().size());\n\n        for (V v : graph1.vertexSet()) {\n            int vNumber = g1.getVertexNumber(v);\n            int uNumber = core1[vNumber];\n\n            if (uNumber != NULL_NODE) {\n                forwardMapping.put(v, g2.getVertex(uNumber));\n            }\n        }\n\n        for (V v : graph2.vertexSet()) {\n            int vNumber = g2.getVertexNumber(v);\n            int uNumber = core2[vNumber];\n\n            if (uNumber != NULL_NODE) {\n                backwardMapping.put(v, g1.getVertex(uNumber));\n            }\n        }\n    }\n\n    /**\n     * Construct a new isomorphic graph mapping.\n     *\n     * @param forwardMapping the mapping from graph1 to graph2\n     * @param backwardMapping the mapping from graph2 to graph1 (inverse of forwardMapping)\n     * @param graph1 the first graph\n     * @param graph2 the second graph\n     * \n     */\n    public IsomorphicGraphMapping(\n        Map<V, V> forwardMapping, Map<V, V> backwardMapping, Graph<V, E> graph1, Graph<V, E> graph2)\n    {\n        this.forwardMapping = Objects.requireNonNull(forwardMapping);\n        this.backwardMapping = Objects.requireNonNull(backwardMapping);\n\n        this.graph1 = Objects.requireNonNull(graph1);\n        this.graph2 = Objects.requireNonNull(graph2);\n    }\n\n    @Override\n    public V getVertexCorrespondence(V v, boolean forward)\n    {\n        if (forward)\n            return forwardMapping.get(v);\n        else\n            return backwardMapping.get(v);\n    }\n\n    @Override\n    public E getEdgeCorrespondence(E e, boolean forward)\n    {\n        Graph<V, E> fromGraph;\n        Graph<V, E> toGraph;\n\n        if (forward) {\n            fromGraph = graph1;\n            toGraph = graph2;\n\n        } else {\n            fromGraph = graph2;\n            toGraph = graph1;\n        }\n\n        V u = fromGraph.getEdgeSource(e);\n        V v = fromGraph.getEdgeTarget(e);\n\n        V uu = getVertexCorrespondence(u, forward);\n        if (uu == null) {\n            return null;\n        }\n\n        V vv = getVertexCorrespondence(v, forward);\n        if (vv == null) {\n            return null;\n        }\n\n        return toGraph.getEdge(uu, vv);\n    }\n\n    /**\n     * Get an unmodifiable version of the forward mapping function.\n     *\n     * @return the unmodifiable forward mapping function\n     */\n    public Map<V, V> getForwardMapping()\n    {\n        return Collections.unmodifiableMap(forwardMapping);\n    }\n\n    /**\n     * Get an unmodifiable version of the backward mapping function.\n     *\n     * @return the unmodifiable backward mapping function\n     */\n    public Map<V, V> getBackwardMapping()\n    {\n        return Collections.unmodifiableMap(backwardMapping);\n    }\n\n    /**\n     * Get the active domain of the isomorphism.\n     *\n     * @return the set of vertices $v$ for which the mapping is defined\n     */\n    public Set<V> getMappingDomain()\n    {\n        return Collections.unmodifiableSet(forwardMapping.keySet());\n    }\n\n    /**\n     * Get the range of the isomorphism.\n     *\n     * @return the set of vertices $v$ for which a preimage exists\n     */\n    public Set<V> getMappingRange()\n    {\n        return Collections.unmodifiableSet(backwardMapping.keySet());\n    }\n\n    /**\n     * Checks if a vertex $v$ from the first graph has a corresponding vertex in the second graph\n     *\n     * @param v the vertex\n     * @return is there a corresponding vertex to $v$ in the subgraph\n     */\n    public boolean hasVertexCorrespondence(V v)\n    {\n        return getVertexCorrespondence(v, true) != null;\n    }\n\n    /**\n     * Checks if a edge e from the first graph has a corresponding edge in the second graph\n     *\n     * @param e the edge\n     * @return is there a corresponding edge to $e$ in the subgraph\n     */\n    public boolean hasEdgeCorrespondence(E e)\n    {\n        return getEdgeCorrespondence(e, true) != null;\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        IsomorphicGraphMapping<?, ?> that = (IsomorphicGraphMapping<?, ?>) o;\n        return Objects.equals(forwardMapping, that.forwardMapping)\n            && Objects.equals(backwardMapping, that.backwardMapping) && graph1 == that.graph1\n            && graph2 == that.graph2;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return Objects\n            .hash(\n                forwardMapping, backwardMapping, System.identityHashCode(graph1),\n                System.identityHashCode(graph2));\n    }\n\n    @Override\n    public String toString()\n    {\n        StringBuilder str = new StringBuilder(\"[\");\n        Set<V> vertexSet = graph1.vertexSet();\n        Map<String, V> vertexMap = new TreeMap<>();\n\n        for (V v : vertexSet) {\n            vertexMap.put(v.toString(), v);\n        }\n\n        int i = 0;\n        for (Map.Entry<String, V> entry : vertexMap.entrySet()) {\n            V u = getVertexCorrespondence(entry.getValue(), true);\n            str\n                .append((i++ == 0) ? \"\" : \" \").append(entry.getKey()).append(\"=\")\n                .append((u == null) ? \"~~\" : u);\n        }\n\n        return str + \"]\";\n    }\n\n    /**\n     * Determines whether this mapping is indeed a valid isomorphic mapping between the first graph\n     * and the second graph. Note that this method will return false for a homomorphism returned by\n     * a subgraph isomorphism inspector unless the resulting mapping happens to be bijective as well\n     * (mapping all of the vertices and edges from the first graph to the second graph and vice\n     * versa).\n     *\n     * @return true iff this mapping is a valid isomorphism between the two graphs\n     */\n    public boolean isValidIsomorphism()\n    {\n        for (V v : graph1.vertexSet()) {\n            if (!forwardMapping.containsKey(v) || !graph2.containsVertex(forwardMapping.get(v)))\n                return false;\n        }\n\n        for (V v : graph2.vertexSet()) {\n            if (!backwardMapping.containsKey(v) || !graph1.containsVertex(backwardMapping.get(v)))\n                return false;\n        }\n\n        for (E edge : graph1.edgeSet()) {\n            E e = getEdgeCorrespondence(edge, true);\n            V u = graph1.getEdgeSource(e);\n            V v = graph1.getEdgeTarget(e);\n\n            if (!graph2.containsEdge(u, v))\n                return false;\n        }\n\n        for (E edge : graph2.edgeSet()) {\n            E e = getEdgeCorrespondence(edge, false);\n            V u = graph2.getEdgeSource(e);\n            V v = graph2.getEdgeTarget(e);\n\n            if (!graph1.containsEdge(u, v))\n                return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks for equality. Assuming both are mappings on the same graphs.\n     *\n     * @param rel the corresponding mapping\n     * @return do both relations map to the same vertices\n     */\n    public boolean isEqualMapping(GraphMapping<V, E> rel)\n    {\n        for (V v : graph2.vertexSet()) {\n            if (!getVertexCorrespondence(v, false).equals(rel.getVertexCorrespondence(v, false))) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Computes the composition of two isomorphisms. Let $f : V_{G_1} \\rightarrow V_{G_2}$ be an\n     * isomorphism from $V_{G_1}$ to $V_{G_2}$ and $g : V_{G_2} \\rightarrow V_{G_3}$ one from\n     * $V_{G_2}$ to $V_{G_3}$.\n     *\n     * This method computes an isomorphism $h : V_{G_1} \\rightarrow V_{G_3}$ from $V_{G_1}$ to\n     * $V_{G_3}$.\n     *\n     * Note: The composition $g ∘ f$ can be built only if $f$'s codomain equals $g$'s domain; this\n     * implementation only requires that the former is a subset of the latter.\n     *\n     * @param otherMapping the other isomorphism (i.e. function $g$)\n     * @return the composition of the two isomorphism\n     */\n    public IsomorphicGraphMapping<V, E> compose(IsomorphicGraphMapping<V, E> otherMapping)\n    {\n        Map<V, V> fMap = CollectionUtil.newHashMapWithExpectedSize(forwardMapping.size());\n        Map<V, V> bMap = CollectionUtil.newHashMapWithExpectedSize(forwardMapping.size());\n\n        for (V v : graph1.vertexSet()) {\n            V u = otherMapping.getVertexCorrespondence(forwardMapping.get(v), true);\n            fMap.put(v, u);\n            bMap.put(u, v);\n        }\n\n        return new IsomorphicGraphMapping<>(fMap, bMap, graph1, otherMapping.graph2);\n    }\n\n    /**\n     * Computes an identity automorphism (i.e. a self-mapping of a graph in which each vertex also\n     * maps to itself).\n     *\n     * @param graph the input graph\n     * @param <V> the graph vertex type\n     * @param <E> the graph edge type\n     * @return a mapping from graph to graph\n     */\n    public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph)\n    {\n        Map<V, V> fMap = CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());\n        Map<V, V> bMap = CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());\n\n        for (V v : graph.vertexSet()) {\n            fMap.put(v, v);\n            bMap.put(v, v);\n        }\n\n        return new IsomorphicGraphMapping<>(fMap, bMap, graph, graph);\n    }\n}\n",
      "file_name": "IsomorphicGraphMapping.java",
      "human_label": "Compute and return an identity automorphism for the given graph.",
      "level": "project_runnable",
      "lineno": "338",
      "name": "identity",
      "oracle_context": "{ \"apis\" : \"[newHashMapWithExpectedSize, size, vertexSet, put, IsomorphicGraphMapping]\", \"classes\" : \"[Map<V,V>]\", \"vars\" : \"[]\" }",
      "package": "org.jgrapht.alg.isomorphism",
      "project": "jgrapht-master"
    },
    {
      "_id": "636766fe1a6d9265ec017833",
      "all_context": "{ \"class_level\" : \"import java.io.*;\\nimport java.util.Collection;\\nimport java.util.List;\\nreadFileToString(File file);\\nreadFileToByteArray(File file);\\nreadLines(File file,String encoding);\\nreadLines(File file);\\nlineIterator(File file,String encoding);\\nlineIterator(File file);\\nwriteStringToFile(File file,String data,String encoding);\\nwriteStringToFile(File file,String data,String encoding,boolean append);\\nwriteStringToFile(File file,String data);\\nwriteStringToFile(File file,String data,boolean append);\\nwrite(File file,CharSequence data);\\nwrite(File file,CharSequence data,boolean append);\\nwrite(File file,CharSequence data,String encoding);\\nwrite(File file,CharSequence data,String encoding,boolean append);\\nwriteByteArrayToFile(File file,byte[] data);\\nwriteByteArrayToFile(File file,byte[] data,boolean append);\\nwriteLines(File file,String encoding,Collection lines);\\nwriteLines(File file,String encoding,Collection lines,boolean append);\\nwriteLines(File file,Collection lines);\\nwriteLines(File file,Collection lines,boolean append);\\nwriteLines(File file,String encoding,Collection lines,String lineEnding);\\nwriteLines(File file,String encoding,Collection lines,String lineEnding,boolean append);\\nwriteLines(File file,Collection lines,String lineEnding);\\nwriteLines(File file,Collection lines,String lineEnding,boolean append);\\nopenInputStream(File file);\\nopenOutputStream(File file);\\nopenOutputStream(File file,boolean append);\\ndeleteDirectory(File directory);\\ncleanDirectory(File directory);\\ndeleteQuietly(File file);\\ndeleteDirectoryOnExit(File directory);\\ncleanDirectoryOnExit(File directory);\\nisSymlink(File file);\\nforceDelete(File file);\\nforceDeleteOnExit(File file);\\nreadFileToString(File file,String encoding);\\n\", \"repo_level\" : \"\" }",
      "class_name": "FileUtils",
      "code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  }\n else {\n    file.deleteOnExit();\n  }\n}\n",
      "docstring": "/** \n * Schedules a file to be deleted when JVM exits. If file is directory delete it and all sub-directories.\n * @param file  file or directory to delete, must not be {@code null}\n * @throws NullPointerException if the file is {@code null}\n * @throws IOException in case deletion is unsuccessful\n */\n",
      "end_lineno": "783",
      "file_content": "/*\n * Copyright 2008-2009 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.io;\nimport java.io.*;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * 文件工具\n * @version : 2011-6-3\n * @author 赵永春 (zyc@hasor.net)\n */\npublic abstract class FileUtils {\n    /**\n     * Reads the contents of a file into a String.\n     * The file is always closed.\n     *\n     * @param file  the file to read, must not be <code>null</code>\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @return the file contents, never <code>null</code>\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     */\n    public static String readFileToString(File file, String encoding) throws IOException {\n        InputStream in = null;\n        try {\n            in = openInputStream(file);\n            return IOUtils.toString(in, encoding);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }\n\n    /**\n     * Reads the contents of a file into a String using the default encoding for the VM. \n     * The file is always closed.\n     *\n     * @param file  the file to read, must not be <code>null</code>\n     * @return the file contents, never <code>null</code>\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 1.3.1\n     */\n    public static String readFileToString(File file) throws IOException {\n        return readFileToString(file, null);\n    }\n\n    /**\n     * Reads the contents of a file into a byte array.\n     * The file is always closed.\n     *\n     * @param file  the file to read, must not be <code>null</code>\n     * @return the file contents, never <code>null</code>\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 1.1\n     */\n    public static byte[] readFileToByteArray(File file) throws IOException {\n        InputStream in = null;\n        try {\n            in = openInputStream(file);\n            return IOUtils.toByteArray(in, file.length());\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }\n\n    /**\n     * Reads the contents of a file line by line to a List of Strings.\n     * The file is always closed.\n     *\n     * @param file  the file to read, must not be <code>null</code>\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @return the list of Strings representing each line in the file, never <code>null</code>\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     * @since Commons IO 1.1\n     */\n    public static List<String> readLines(File file, String encoding) throws IOException {\n        InputStream in = null;\n        try {\n            in = openInputStream(file);\n            return IOUtils.readLines(in, encoding);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }\n\n    /**\n     * Reads the contents of a file line by line to a List of Strings using the default encoding for the VM.\n     * The file is always closed.\n     *\n     * @param file  the file to read, must not be <code>null</code>\n     * @return the list of Strings representing each line in the file, never <code>null</code>\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 1.3\n     */\n    public static List<String> readLines(File file) throws IOException {\n        return readLines(file, null);\n    }\n\n    /**\n     * Returns an Iterator for the lines in a <code>File</code>.\n     * <p>\n     * This method opens an <code>InputStream</code> for the file.\n     * When you have finished with the iterator you should close the stream\n     * to free internal resources. This can be done by calling the\n     * {@link LineIterator#close()} or\n     * {@link LineIterator#closeQuietly(LineIterator)} method.\n     * <p>\n     * The recommended usage pattern is:\n     * <pre>\n     * LineIterator it = FileUtils.lineIterator(file, \"UTF-8\");\n     * try {\n     *   while (it.hasNext()) {\n     *     String line = it.nextLine();\n     *     /// do something with line\n     *   }\n     * } finally {\n     *   LineIterator.closeQuietly(iterator);\n     * }\n     * </pre>\n     * <p>\n     * If an exception occurs during the creation of the iterator, the\n     * underlying stream is closed.\n     *\n     * @param file  the file to open for input, must not be <code>null</code>\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @return an Iterator of the lines in the file, never <code>null</code>\n     * @throws IOException in case of an I/O error (file closed)\n     * @since Commons IO 1.2\n     */\n    public static LineIterator lineIterator(File file, String encoding) throws IOException {\n        InputStream in = null;\n        try {\n            in = openInputStream(file);\n            return IOUtils.lineIterator(in, encoding);\n        } catch (IOException ex) {\n            IOUtils.closeQuietly(in);\n            throw ex;\n        } catch (RuntimeException ex) {\n            IOUtils.closeQuietly(in);\n            throw ex;\n        }\n    }\n\n    /**\n     * Returns an Iterator for the lines in a <code>File</code> using the default encoding for the VM.\n     *\n     * @param file  the file to open for input, must not be <code>null</code>\n     * @return an Iterator of the lines in the file, never <code>null</code>\n     * @throws IOException in case of an I/O error (file closed)\n     * @since Commons IO 1.3\n     * @see #lineIterator(File, String)\n     */\n    public static LineIterator lineIterator(File file) throws IOException {\n        return lineIterator(file, null);\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Writes a String to a file creating the file if it does not exist.\n     *\n     * NOTE: As from v1.3, the parent directories of the file will be created\n     * if they do not exist.\n     *\n     * @param file  the file to write\n     * @param data  the content to write to the file\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     */\n    public static void writeStringToFile(File file, String data, String encoding) throws IOException {\n        writeStringToFile(file, data, encoding, false);\n    }\n\n    /**\n     * Writes a String to a file creating the file if it does not exist.\n     *\n     * @param file  the file to write\n     * @param data  the content to write to the file\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @param append if <code>true</code>, then the String will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     * @since Commons IO 2.1\n     */\n    public static void writeStringToFile(File file, String data, String encoding, boolean append) throws IOException {\n        OutputStream out = null;\n        try {\n            out = openOutputStream(file, append);\n            IOUtils.write(data, out, encoding);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    /**\n     * Writes a String to a file creating the file if it does not exist using the default encoding for the VM.\n     *\n     * @param file  the file to write\n     * @param data  the content to write to the file\n     * @throws IOException in case of an I/O error\n     */\n    public static void writeStringToFile(File file, String data) throws IOException {\n        writeStringToFile(file, data, null, false);\n    }\n\n    /**\n     * Writes a String to a file creating the file if it does not exist using the default encoding for the VM.\n     *\n     * @param file  the file to write\n     * @param data  the content to write to the file\n     * @param append if <code>true</code>, then the String will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 2.1\n     */\n    public static void writeStringToFile(File file, String data, boolean append) throws IOException {\n        writeStringToFile(file, data, null, append);\n    }\n\n    /**\n     * Writes a CharSequence to a file creating the file if it does not exist using the default encoding for the VM.\n     *\n     * @param file  the file to write\n     * @param data  the content to write to the file\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 2.0\n     */\n    public static void write(File file, CharSequence data) throws IOException {\n        write(file, data, null, false);\n    }\n\n    /**\n     * Writes a CharSequence to a file creating the file if it does not exist using the default encoding for the VM.\n     *\n     * @param file  the file to write\n     * @param data  the content to write to the file\n     * @param append if <code>true</code>, then the data will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 2.1\n     */\n    public static void write(File file, CharSequence data, boolean append) throws IOException {\n        write(file, data, null, append);\n    }\n\n    /**\n     * Writes a CharSequence to a file creating the file if it does not exist.\n     *\n     * @param file  the file to write\n     * @param data  the content to write to the file\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     * @since Commons IO 2.0\n     */\n    public static void write(File file, CharSequence data, String encoding) throws IOException {\n        write(file, data, encoding, false);\n    }\n\n    /**\n     * Writes a CharSequence to a file creating the file if it does not exist.\n     *\n     * @param file  the file to write\n     * @param data  the content to write to the file\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @param append if <code>true</code>, then the data will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     * @since IO 2.1\n     */\n    public static void write(File file, CharSequence data, String encoding, boolean append) throws IOException {\n        String str = data == null ? null : data.toString();\n        writeStringToFile(file, str, encoding, append);\n    }\n\n    /**\n     * Writes a byte array to a file creating the file if it does not exist.\n     * <p>\n     * NOTE: As from v1.3, the parent directories of the file will be created\n     * if they do not exist.\n     *\n     * @param file  the file to write to\n     * @param data  the content to write to the file\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 1.1\n     */\n    public static void writeByteArrayToFile(File file, byte[] data) throws IOException {\n        writeByteArrayToFile(file, data, false);\n    }\n\n    /**\n     * Writes a byte array to a file creating the file if it does not exist.\n     *\n     * @param file  the file to write to\n     * @param data  the content to write to the file\n     * @param append if <code>true</code>, then bytes will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @since IO 2.1\n     */\n    public static void writeByteArrayToFile(File file, byte[] data, boolean append) throws IOException {\n        OutputStream out = null;\n        try {\n            out = openOutputStream(file, append);\n            out.write(data);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    /**\n     * Writes the <code>toString()</code> value of each item in a collection to\n     * the specified <code>File</code> line by line.\n     * The specified character encoding and the default line ending will be used.\n     * <p>\n     * NOTE: As from v1.3, the parent directories of the file will be created\n     * if they do not exist.\n     *\n     * @param file  the file to write to\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @param lines  the lines to write, <code>null</code> entries produce blank lines\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     * @since Commons IO 1.1\n     */\n    public static void writeLines(File file, String encoding, Collection<?> lines) throws IOException {\n        writeLines(file, encoding, lines, null, false);\n    }\n\n    /**\n     * Writes the <code>toString()</code> value of each item in a collection to\n     * the specified <code>File</code> line by line, optionally appending.\n     * The specified character encoding and the default line ending will be used.\n     *\n     * @param file  the file to write to\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @param lines  the lines to write, <code>null</code> entries produce blank lines\n     * @param append if <code>true</code>, then the lines will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     * @since Commons IO 2.1\n     */\n    public static void writeLines(File file, String encoding, Collection<?> lines, boolean append) throws IOException {\n        writeLines(file, encoding, lines, null, append);\n    }\n\n    /**\n     * Writes the <code>toString()</code> value of each item in a collection to\n     * the specified <code>File</code> line by line.\n     * The default VM encoding and the default line ending will be used.\n     *\n     * @param file  the file to write to\n     * @param lines  the lines to write, <code>null</code> entries produce blank lines\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 1.3\n     */\n    public static void writeLines(File file, Collection<?> lines) throws IOException {\n        writeLines(file, null, lines, null, false);\n    }\n\n    /**\n     * Writes the <code>toString()</code> value of each item in a collection to\n     * the specified <code>File</code> line by line.\n     * The default VM encoding and the default line ending will be used.\n     *\n     * @param file  the file to write to\n     * @param lines  the lines to write, <code>null</code> entries produce blank lines\n     * @param append if <code>true</code>, then the lines will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 2.1\n     */\n    public static void writeLines(File file, Collection<?> lines, boolean append) throws IOException {\n        writeLines(file, null, lines, null, append);\n    }\n\n    /**\n     * Writes the <code>toString()</code> value of each item in a collection to\n     * the specified <code>File</code> line by line.\n     * The specified character encoding and the line ending will be used.\n     * <p>\n     * NOTE: As from v1.3, the parent directories of the file will be created\n     * if they do not exist.\n     *\n     * @param file  the file to write to\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @param lines  the lines to write, <code>null</code> entries produce blank lines\n     * @param lineEnding  the line separator to use, <code>null</code> is system default\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     * @since Commons IO 1.1\n     */\n    public static void writeLines(File file, String encoding, Collection<?> lines, String lineEnding) throws IOException {\n        writeLines(file, encoding, lines, lineEnding, false);\n    }\n\n    /**\n     * Writes the <code>toString()</code> value of each item in a collection to\n     * the specified <code>File</code> line by line.\n     * The specified character encoding and the line ending will be used.\n     *\n     * @param file  the file to write to\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @param lines  the lines to write, <code>null</code> entries produce blank lines\n     * @param lineEnding  the line separator to use, <code>null</code> is system default\n     * @param append if <code>true</code>, then the lines will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     * @since Commons IO 2.1\n     */\n    public static void writeLines(File file, String encoding, Collection<?> lines, String lineEnding, boolean append) throws IOException {\n        OutputStream out = null;\n        try {\n            out = openOutputStream(file, append);\n            IOUtils.writeLines(lines, lineEnding, out, encoding);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    /**\n     * Writes the <code>toString()</code> value of each item in a collection to\n     * the specified <code>File</code> line by line.\n     * The default VM encoding and the specified line ending will be used.\n     *\n     * @param file  the file to write to\n     * @param lines  the lines to write, <code>null</code> entries produce blank lines\n     * @param lineEnding  the line separator to use, <code>null</code> is system default\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 1.3\n     */\n    public static void writeLines(File file, Collection<?> lines, String lineEnding) throws IOException {\n        writeLines(file, null, lines, lineEnding, false);\n    }\n\n    /**\n     * Writes the <code>toString()</code> value of each item in a collection to\n     * the specified <code>File</code> line by line.\n     * The default VM encoding and the specified line ending will be used.\n     *\n     * @param file  the file to write to\n     * @param lines  the lines to write, <code>null</code> entries produce blank lines\n     * @param lineEnding  the line separator to use, <code>null</code> is system default\n     * @param append if <code>true</code>, then the lines will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 2.1\n     */\n    public static void writeLines(File file, Collection<?> lines, String lineEnding, boolean append) throws IOException {\n        writeLines(file, null, lines, lineEnding, append);\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Opens a {@link FileInputStream} for the specified file, providing better\n     * error messages than simply calling <code>new FileInputStream(file)</code>.\n     * <p>\n     * At the end of the method either the stream will be successfully opened,\n     * or an exception will have been thrown.\n     * <p>\n     * An exception is thrown if the file does not exist.\n     * An exception is thrown if the file object exists but is a directory.\n     * An exception is thrown if the file exists but cannot be read.\n     *\n     * @param file  the file to open for input, must not be <code>null</code>\n     * @return a new {@link FileInputStream} for the specified file\n     * @throws FileNotFoundException if the file does not exist\n     * @throws IOException if the file object is a directory\n     * @throws IOException if the file cannot be read\n     * @since Commons IO 1.3\n     */\n    public static FileInputStream openInputStream(File file) throws IOException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                throw new IOException(\"File '\" + file + \"' exists but is a directory\");\n            }\n            if (file.canRead() == false) {\n                throw new IOException(\"File '\" + file + \"' cannot be read\");\n            }\n        } else {\n            throw new FileNotFoundException(\"File '\" + file + \"' does not exist\");\n        }\n        return new FileInputStream(file);\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Opens a {@link FileOutputStream} for the specified file, checking and\n     * creating the parent directory if it does not exist.\n     * <p>\n     * At the end of the method either the stream will be successfully opened,\n     * or an exception will have been thrown.\n     * <p>\n     * The parent directory will be created if it does not exist.\n     * The file will be created if it does not exist.\n     * An exception is thrown if the file object exists but is a directory.\n     * An exception is thrown if the file exists but cannot be written to.\n     * An exception is thrown if the parent directory cannot be created.\n     *\n     * @param file  the file to open for output, must not be <code>null</code>\n     * @return a new {@link FileOutputStream} for the specified file\n     * @throws IOException if the file object is a directory\n     * @throws IOException if the file cannot be written to\n     * @throws IOException if a parent directory needs creating but that fails\n     * @since Commons IO 1.3\n     */\n    public static FileOutputStream openOutputStream(File file) throws IOException {\n        return openOutputStream(file, false);\n    }\n\n    /**\n     * Opens a {@link FileOutputStream} for the specified file, checking and\n     * creating the parent directory if it does not exist.\n     * <p>\n     * At the end of the method either the stream will be successfully opened,\n     * or an exception will have been thrown.\n     * <p>\n     * The parent directory will be created if it does not exist.\n     * The file will be created if it does not exist.\n     * An exception is thrown if the file object exists but is a directory.\n     * An exception is thrown if the file exists but cannot be written to.\n     * An exception is thrown if the parent directory cannot be created.\n     *\n     * @param file  the file to open for output, must not be <code>null</code>\n     * @param append if <code>true</code>, then bytes will be added to the\n     * end of the file rather than overwriting\n     * @return a new {@link FileOutputStream} for the specified file\n     * @throws IOException if the file object is a directory\n     * @throws IOException if the file cannot be written to\n     * @throws IOException if a parent directory needs creating but that fails\n     * @since Commons IO 2.1\n     */\n    public static FileOutputStream openOutputStream(File file, boolean append) throws IOException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                throw new IOException(\"File '\" + file + \"' exists but is a directory\");\n            }\n            if (file.canWrite() == false) {\n                throw new IOException(\"File '\" + file + \"' cannot be written to\");\n            }\n        } else {\n            File parent = file.getParentFile();\n            if (parent != null) {\n                if (!parent.mkdirs() && !parent.isDirectory()) {\n                    throw new IOException(\"Directory '\" + parent + \"' could not be created\");\n                }\n            }\n        }\n        return new FileOutputStream(file, append);\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Deletes a directory recursively. \n     *\n     * @param directory  directory to delete\n     * @throws IOException in case deletion is unsuccessful\n     */\n    public static void deleteDirectory(File directory) throws IOException {\n        if (!directory.exists()) {\n            return;\n        }\n        if (!isSymlink(directory)) {\n            cleanDirectory(directory);\n        }\n        if (!directory.delete()) {\n            String message = \"Unable to delete directory \" + directory + \".\";\n            throw new IOException(message);\n        }\n    }\n\n    /**\n     * Cleans a directory without deleting it.\n     *\n     * @param directory directory to clean\n     * @throws IOException in case cleaning is unsuccessful\n     */\n    public static void cleanDirectory(File directory) throws IOException {\n        if (!directory.exists()) {\n            String message = directory + \" does not exist\";\n            throw new IllegalArgumentException(message);\n        }\n        if (!directory.isDirectory()) {\n            String message = directory + \" is not a directory\";\n            throw new IllegalArgumentException(message);\n        }\n        File[] files = directory.listFiles();\n        if (files == null) {  // null if security restricted\n            throw new IOException(\"Failed to list contents of \" + directory);\n        }\n        IOException exception = null;\n        for (File file : files) {\n            try {\n                forceDelete(file);\n            } catch (IOException ioe) {\n                exception = ioe;\n            }\n        }\n        if (null != exception) {\n            throw exception;\n        }\n    }\n\n    /**\n     * Deletes a file, never throwing an exception. If file is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * <ul>\n     * <li>A directory to be deleted does not have to be empty.</li>\n     * <li>No exceptions are thrown when a file or directory cannot be deleted.</li>\n     * </ul>\n     *\n     * @param file  file or directory to delete, can be {@code null}\n     * @return {@code true} if the file or directory was deleted, otherwise\n     * {@code false}\n     *\n     * @since 1.4\n     */\n    public static boolean deleteQuietly(File file) {\n        if (file == null) {\n            return false;\n        }\n        try {\n            if (file.isDirectory()) {\n                cleanDirectory(file);\n            }\n        } catch (Exception ignored) {\n        }\n        try {\n            return file.delete();\n        } catch (Exception ignored) {\n            return false;\n        }\n    }\n\n    /**\n     * Schedules a directory recursively for deletion on JVM exit.\n     *\n     * @param directory  directory to delete, must not be {@code null}\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException in case deletion is unsuccessful\n     */\n    private static void deleteDirectoryOnExit(File directory) throws IOException {\n        if (!directory.exists()) {\n            return;\n        }\n        directory.deleteOnExit();\n        if (!isSymlink(directory)) {\n            cleanDirectoryOnExit(directory);\n        }\n    }\n\n    /**\n     * Cleans a directory without deleting it.\n     *\n     * @param directory  directory to clean, must not be {@code null}\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException in case cleaning is unsuccessful\n     */\n    private static void cleanDirectoryOnExit(File directory) throws IOException {\n        if (!directory.exists()) {\n            String message = directory + \" does not exist\";\n            throw new IllegalArgumentException(message);\n        }\n        if (!directory.isDirectory()) {\n            String message = directory + \" is not a directory\";\n            throw new IllegalArgumentException(message);\n        }\n        File[] files = directory.listFiles();\n        if (files == null) {  // null if security restricted\n            throw new IOException(\"Failed to list contents of \" + directory);\n        }\n        IOException exception = null;\n        for (File file : files) {\n            try {\n                forceDeleteOnExit(file);\n            } catch (IOException ioe) {\n                exception = ioe;\n            }\n        }\n        if (null != exception) {\n            throw exception;\n        }\n    }\n\n    /**\n     * Determines whether the specified file is a Symbolic Link rather than an actual file.\n     * <p>\n     * Will not return true if there is a Symbolic Link anywhere in the path,\n     * only if the specific file is.\n     * <p>\n     * <b>Note:</b> the current implementation always returns {@code false} if the system\n     * is detected as Windows using {@link FilenameUtils#isSystemWindows()}\n     *\n     * @param file the file to check\n     * @return true if the file is a Symbolic Link\n     * @throws IOException if an IO error occurs while checking the file\n     * @since 2.0\n     */\n    public static boolean isSymlink(File file) throws IOException {\n        if (file == null) {\n            throw new NullPointerException(\"File must not be null\");\n        }\n        if (FilenameUtils.isSystemWindows()) {\n            return false;\n        }\n        File fileInCanonicalDir = null;\n        if (file.getParent() == null) {\n            fileInCanonicalDir = file;\n        } else {\n            File canonicalDir = file.getParentFile().getCanonicalFile();\n            fileInCanonicalDir = new File(canonicalDir, file.getName());\n        }\n        if (fileInCanonicalDir.getCanonicalFile().equals(fileInCanonicalDir.getAbsoluteFile())) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Deletes a file. If file is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * <ul>\n     * <li>A directory to be deleted does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted.\n     *      (java.io.File methods returns a boolean)</li>\n     * </ul>\n     *\n     * @param file  file or directory to delete, must not be {@code null}\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws FileNotFoundException if the file was not found\n     * @throws IOException in case deletion is unsuccessful\n     */\n    public static void forceDelete(File file) throws IOException {\n        if (file.isDirectory()) {\n            deleteDirectory(file);\n        } else {\n            boolean filePresent = file.exists();\n            if (!file.delete()) {\n                if (!filePresent) {\n                    throw new FileNotFoundException(\"File does not exist: \" + file);\n                }\n                String message = \"Unable to delete file: \" + file;\n                throw new IOException(message);\n            }\n        }\n    }\n\n    /**\n     * Schedules a file to be deleted when JVM exits.\n     * If file is directory delete it and all sub-directories.\n     *\n     * @param file  file or directory to delete, must not be {@code null}\n     * @throws NullPointerException if the file is {@code null}\n     * @throws IOException in case deletion is unsuccessful\n     */\n    public static void forceDeleteOnExit(File file) throws IOException {\n        if (file.isDirectory()) {\n            deleteDirectoryOnExit(file);\n        } else {\n            file.deleteOnExit();\n        }\n    }\n}",
      "file_name": "FileUtils.java",
      "human_label": "Delete the file or the whole directory when exiting.",
      "level": "class_runnable",
      "lineno": "769",
      "name": "forceDeleteOnExit",
      "oracle_context": "{ \"apis\" : \"[isDirectory, deleteDirectoryOnExit, deleteOnExit]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
      "package": "net.hasor.utils.io",
      "project": "hasor-master"
    },
    {
      "_id": "636767791a6d9265ec018257",
      "all_context": "{ \"class_level\" : \"import java.awt.BorderLayout;\\nimport java.awt.Color;\\nimport java.awt.Component;\\nimport java.awt.Dimension;\\nimport java.awt.FlowLayout;\\nimport java.awt.Font;\\nimport java.awt.GraphicsEnvironment;\\nimport java.awt.Toolkit;\\nimport java.awt.event.ActionEvent;\\nimport java.awt.event.ActionListener;\\nimport java.awt.event.WindowAdapter;\\nimport java.awt.event.WindowEvent;\\nimport java.io.File;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.net.MalformedURLException;\\nimport java.net.URL;\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.StringTokenizer;\\nimport java.util.Vector;\\nimport javax.swing.BorderFactory;\\nimport javax.swing.ImageIcon;\\nimport javax.swing.JButton;\\nimport javax.swing.JCheckBoxMenuItem;\\nimport javax.swing.JColorChooser;\\nimport javax.swing.JComboBox;\\nimport javax.swing.JFileChooser;\\nimport javax.swing.JFrame;\\nimport javax.swing.JLabel;\\nimport javax.swing.JMenu;\\nimport javax.swing.JMenuBar;\\nimport javax.swing.JMenuItem;\\nimport javax.swing.JOptionPane;\\nimport javax.swing.JPanel;\\nimport javax.swing.JScrollPane;\\nimport javax.swing.JSplitPane;\\nimport javax.swing.JTextArea;\\nimport javax.swing.JToolBar;\\nimport javax.swing.KeyStroke;\\nimport javax.swing.SwingUtilities;\\nimport org.apache.log4j.lf5.LogLevel;\\nimport org.apache.log4j.lf5.LogRecord;\\nimport org.apache.log4j.lf5.LogRecordFilter;\\nimport org.apache.log4j.lf5.util.DateFormatManager;\\nimport org.apache.log4j.lf5.util.LogFileParser;\\nimport org.apache.log4j.lf5.viewer.categoryexplorer.CategoryExplorerTree;\\nimport org.apache.log4j.lf5.viewer.categoryexplorer.CategoryPath;\\nimport org.apache.log4j.lf5.viewer.configure.ConfigurationManager;\\nimport org.apache.log4j.lf5.viewer.configure.MRUFileManager;\\nString DETAILED_VIEW;\\nJFrame _logMonitorFrame;\\nint _logMonitorFrameWidth;\\nint _logMonitorFrameHeight;\\nLogTable _table;\\nCategoryExplorerTree _categoryExplorerTree;\\nString _searchText;\\nString _NDCTextFilter;\\nLogLevel _leastSevereDisplayedLogLevel;\\nJScrollPane _logTableScrollPane;\\nJLabel _statusLabel;\\nObject _lock;\\nJComboBox _fontSizeCombo;\\nint _fontSize;\\nString _fontName;\\nString _currentView;\\nboolean _loadSystemFonts;\\nboolean _trackTableScrollPane;\\nDimension _lastTableViewportSize;\\nboolean _callSystemExitOnClose;\\nList _displayedLogBrokerProperties;\\nMap _logLevelMenuItems;\\nMap _logTableColumnMenuItems;\\nList _levels;\\nList _columns;\\nboolean _isDisposed;\\nConfigurationManager _configurationManager;\\nMRUFileManager _mruFileManager;\\nFile _fileLocation;\\nLogBrokerMonitor _monitor;\\nLogBrokerMonitor(List logLevels);\\nrun();\\nshow();\\ndispose();\\nhide();\\ngetDateFormatManager();\\nsetDateFormatManager(DateFormatManager dfm);\\ngetCallSystemExitOnClose();\\nsetCallSystemExitOnClose(boolean callSystemExitOnClose);\\naddMessage(LogRecord lr);\\nsetMaxNumberOfLogRecords(int maxNumberOfLogRecords);\\ngetBaseFrame();\\nsetTitle(String title);\\nsetFrameSize(int width,int height);\\nsetFontSize(int fontSize);\\naddDisplayedProperty(Object messageLine);\\ngetLogLevelMenuItems();\\ngetLogTableColumnMenuItems();\\ngetTableColumnMenuItem(LogTableColumn column);\\ngetCategoryExplorerTree();\\ngetNDCTextFilter();\\nsetNDCLogRecordFilter(String textFilter);\\nsetSearchText(String text);\\nsetNDCTextFilter(String text);\\nsortByNDC();\\nfindSearchText();\\ngetFirstSelectedRow();\\nselectRow(int foundRow);\\nfindRecord(int startRow,String searchText,List records);\\nmatches(LogRecord record,String text);\\nrefresh(JTextArea textArea);\\nrefreshDetailTextArea();\\nclearDetailTextArea();\\nchangeFontSizeCombo(JComboBox box,int requestedSize);\\nsetFontSizeSilently(int fontSize);\\nsetFontSize(Component component,int fontSize);\\nupdateFrameSize();\\npause(int millis);\\ninitComponents();\\ncreateLogRecordFilter();\\npasses(LogRecord record);\\ncreateNDCLogRecordFilter(String text);\\nupdateStatusLabel();\\ngetRecordsDisplayedMessage();\\naddTableModelProperties();\\ntoString();\\ngetStatusText(int displayedRows,int totalRows);\\nmakeLogTableListenToCategoryExplorer();\\nactionPerformed(ActionEvent e);\\ncreateStatusArea();\\ncreateDetailTextArea();\\ncreateMenuBar();\\ncreateLogLevelMenu();\\ncreateAllLogLevelsMenuItem();\\ncreateNoLogLevelsMenuItem();\\ncreateLogLevelColorMenu();\\ncreateResetLogLevelColorMenuItem();\\nselectAllLogLevels(boolean selected);\\ngetMenuItem(LogLevel level);\\ncreateSubMenuItem(LogLevel level);\\nshowLogLevelColorChangeDialog(JMenuItem result,LogLevel level);\\ncreateMenuItem(LogLevel level);\\ncreateViewMenu();\\ngetLogTableColumnMenuItem(LogTableColumn column);\\ncreateLogTableColumnMenuItem(LogTableColumn column);\\nupdateView();\\ncreateAllLogTableColumnsMenuItem();\\ncreateNoLogTableColumnsMenuItem();\\nselectAllLogTableColumns(boolean selected);\\ncreateFileMenu();\\ncreateOpenMI();\\ncreateOpenURLMI();\\ncreateCloseMI();\\ncreateMRUFileListMI(JMenu menu);\\ncreateExitMI();\\ncreateConfigureMenu();\\ncreateConfigureSave();\\ncreateConfigureReset();\\ncreateConfigureMaxRecords();\\nsaveConfiguration();\\nresetConfiguration();\\nsetMaxRecordConfiguration();\\ncreateHelpMenu();\\ncreateHelpProperties();\\nshowPropertiesDialog(String title);\\ncreateEditMenu();\\ncreateEditFindNextMI();\\ncreateEditFindMI();\\ncreateEditSortNDCMI();\\ncreateEditRestoreAllNDCMI();\\ncreateToolBar();\\nsetView(String viewString,LogTable table);\\ncreateLogLevelCombo();\\nsetLeastSevereDisplayedLogLevel(LogLevel level);\\ntrackTableScrollPane();\\ncenterFrame(JFrame frame);\\nrequestOpen();\\nrequestOpenURL();\\nupdateMRUList();\\nrequestClose();\\nrequestOpenMRU(ActionEvent e);\\nrequestExit();\\ncloseAfterConfirm();\\ngetLogLevels();\\ngetLogTableColumns();\\nloadLogFile(File file);\\nloadLogFile(URL url);\\nLogBrokerMonitorWindowAdaptor(LogBrokerMonitor monitor);\\nwindowClosing(WindowEvent ev);\\nshow(int delay);\\n\", \"repo_level\" : \"public interface LogLevel {public String getLabel();\\npublic boolean encompasses(LogLevel level);\\nstatic LogLevel valueOf(String level);\\nstatic LogLevel register(LogLevel logLevel);\\nstatic void register(LogLevel[] logLevels);\\nstatic void register(List logLevels);\\npublic boolean equals(Object o);\\npublic int hashCode();\\npublic String toString();\\npublic void setLogLevelColorMap(LogLevel level,Color color);\\nstatic void resetLogLevelColorMap();\\nstatic List getLog4JLevels();\\nstatic List getJdk14Levels();\\nstatic List getAllDefaultLevels();\\nstatic Map getLogLevelColorMap();\\nprotected int getPrecedence();\\n }\\npublic interface LogRecord {public LogLevel getLevel();\\npublic void setLevel(LogLevel level);\\nabstract boolean isSevereLevel();\\npublic boolean hasThrown();\\npublic boolean isFatal();\\npublic String getCategory();\\npublic void setCategory(String category);\\npublic String getMessage();\\npublic void setMessage(String message);\\npublic long getSequenceNumber();\\npublic void setSequenceNumber(long number);\\npublic long getMillis();\\npublic void setMillis(long millis);\\npublic String getThreadDescription();\\npublic void setThreadDescription(String threadDescription);\\npublic String getThrownStackTrace();\\npublic void setThrownStackTrace(String trace);\\npublic Throwable getThrown();\\npublic void setThrown(Throwable thrown);\\npublic String toString();\\npublic String getNDC();\\npublic void setNDC(String ndc);\\npublic String getLocation();\\npublic void setLocation(String location);\\nsynchronized void resetSequenceNumber();\\nsynchronized long getNextId();\\n }\\npublic interface LogRecordFilter {public boolean passes(LogRecord record);\\n }\\npublic interface DateFormatManager {synchronized TimeZone getTimeZone();\\nsynchronized void setTimeZone(TimeZone timeZone);\\nsynchronized Locale getLocale();\\nsynchronized void setLocale(Locale locale);\\nsynchronized String getPattern();\\nsynchronized void setPattern(String pattern);\\nsynchronized String getOutputFormat();\\nsynchronized void setOutputFormat(String pattern);\\nsynchronized DateFormat getDateFormatInstance();\\nsynchronized void setDateFormatInstance(DateFormat dateFormat);\\npublic String format(Date date);\\npublic String format(Date date,String pattern);\\npublic Date parse(String date);\\npublic Date parse(String date,String pattern);\\n }\\npublic interface LogFileParser {public void parse(LogBrokerMonitor monitor);\\npublic void run();\\npublic void run();\\nprotected void displayError(String message);\\n }\\npublic interface CategoryExplorerTree {public CategoryExplorerModel getExplorerModel();\\npublic String getToolTipText(MouseEvent e);\\nprotected void init();\\nprotected void expandRootNode();\\nprotected void ensureRootExpansion();\\npublic void treeNodesInserted(TreeModelEvent e);\\n }\\npublic interface CategoryPath {public int size();\\npublic boolean isEmpty();\\npublic void removeAllCategoryElements();\\npublic void addCategoryElement(CategoryElement categoryElement);\\npublic CategoryElement categoryElementAt(int index);\\npublic String toString();\\n }\\npublic interface ConfigurationManager {public void save();\\npublic void reset();\\nstatic String treePathToString(TreePath path);\\nprotected void load();\\nprotected void processRecordFilter(Document doc);\\nprotected void processCategories(Document doc);\\nprotected void processLogLevels(Document doc);\\nprotected void processLogLevelColors(Document doc);\\nprotected void processLogTableColumns(Document doc);\\nprotected String getValue(NamedNodeMap map,String attr);\\nprotected void collapseTree();\\nprotected void selectAllNodes();\\nprotected void store(String s);\\nprotected void deleteConfigurationFile();\\nprotected String getFilename();\\n }\\npublic interface MRUFileManager {public void save();\\npublic int size();\\npublic Object getFile(int index);\\npublic InputStream getInputStream(int index);\\npublic void set(File file);\\npublic void set(URL url);\\npublic String[] getMRUFileList();\\npublic void moveToTop(int index);\\nstatic void createConfigurationDirectory();\\nprotected InputStream getInputStream(File file);\\nprotected InputStream getInputStream(URL url);\\nprotected void setMRU(Object o);\\nprotected void load();\\nprotected String getFilename();\\nprotected void setMaxSize(int maxSize);\\n }\\n\" }",
      "class_name": "LogBrokerMonitor",
      "code": "public void addMessage(final LogRecord lr){\n  if (_isDisposed == true) {\n    return;\n  }\n  SwingUtilities.invokeLater(new Runnable(){\n    public void run(){\n      _categoryExplorerTree.getExplorerModel().addLogRecord(lr);\n      _table.getFilteredLogTableModel().addLogRecord(lr);\n      updateStatusLabel();\n    }\n  }\n);\n}\n",
      "docstring": "/** \n * Add a log record message to be displayed in the LogTable. This method is thread-safe as it posts requests to the SwingThread rather than processing directly.\n */\n",
      "end_lineno": "265",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.log4j.lf5.viewer;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Dimension;\nimport java.awt.FlowLayout;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Toolkit;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\nimport javax.swing.BorderFactory;\nimport javax.swing.ImageIcon;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBoxMenuItem;\nimport javax.swing.JColorChooser;\nimport javax.swing.JComboBox;\nimport javax.swing.JFileChooser;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuBar;\nimport javax.swing.JMenuItem;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JSplitPane;\nimport javax.swing.JTextArea;\nimport javax.swing.JToolBar;\nimport javax.swing.KeyStroke;\nimport javax.swing.SwingUtilities;\n\nimport org.apache.log4j.lf5.LogLevel;\nimport org.apache.log4j.lf5.LogRecord;\nimport org.apache.log4j.lf5.LogRecordFilter;\nimport org.apache.log4j.lf5.util.DateFormatManager;\nimport org.apache.log4j.lf5.util.LogFileParser;\nimport org.apache.log4j.lf5.viewer.categoryexplorer.CategoryExplorerTree;\nimport org.apache.log4j.lf5.viewer.categoryexplorer.CategoryPath;\nimport org.apache.log4j.lf5.viewer.configure.ConfigurationManager;\nimport org.apache.log4j.lf5.viewer.configure.MRUFileManager;\n\n/**\n * LogBrokerMonitor\n *.\n * @author Michael J. Sikorsky\n * @author Robert Shaw\n * @author Brad Marlborough\n * @author Richard Wan\n * @author Brent Sprecher\n * @author Richard Hurst\n */\n\n// Contributed by ThoughtWorks Inc.\n\npublic class LogBrokerMonitor {\n  //--------------------------------------------------------------------------\n  //   Constants:\n  //--------------------------------------------------------------------------\n\n  public static final String DETAILED_VIEW = \"Detailed\";\n//    public static final String STANDARD_VIEW = \"Standard\";\n//    public static final String COMPACT_VIEW = \"Compact\";\n  //--------------------------------------------------------------------------\n  //   Protected Variables:\n  //--------------------------------------------------------------------------\n  protected JFrame _logMonitorFrame;\n  protected int _logMonitorFrameWidth = 550;\n  protected int _logMonitorFrameHeight = 500;\n  protected LogTable _table;\n  protected CategoryExplorerTree _categoryExplorerTree;\n  protected String _searchText;\n  protected String _NDCTextFilter = \"\";\n  protected LogLevel _leastSevereDisplayedLogLevel = LogLevel.DEBUG;\n\n  protected JScrollPane _logTableScrollPane;\n  protected JLabel _statusLabel;\n  protected Object _lock = new Object();\n  protected JComboBox _fontSizeCombo;\n\n  protected int _fontSize = 10;\n  protected String _fontName = \"Dialog\";\n  protected String _currentView = DETAILED_VIEW;\n\n  protected boolean _loadSystemFonts = false;\n  protected boolean _trackTableScrollPane = true;\n  protected Dimension _lastTableViewportSize;\n  protected boolean _callSystemExitOnClose = false;\n  protected List _displayedLogBrokerProperties = new Vector();\n\n  protected Map _logLevelMenuItems = new HashMap();\n  protected Map _logTableColumnMenuItems = new HashMap();\n\n  protected List _levels = null;\n  protected List _columns = null;\n  protected boolean _isDisposed = false;\n\n  protected ConfigurationManager _configurationManager = null;\n  protected MRUFileManager _mruFileManager = null;\n  protected File _fileLocation = null;\n\n  //--------------------------------------------------------------------------\n  //   Private Variables:\n  //--------------------------------------------------------------------------\n\n  //--------------------------------------------------------------------------\n  //   Constructors:\n  //--------------------------------------------------------------------------\n\n  /**\n   * Construct a LogBrokerMonitor.\n   */\n  public LogBrokerMonitor(List logLevels) {\n\n    _levels = logLevels;\n    _columns = LogTableColumn.getLogTableColumns();\n    // This allows us to use the LogBroker in command line tools and\n    // have the option for it to shutdown.\n\n    String callSystemExitOnClose =\n        System.getProperty(\"monitor.exit\");\n    if (callSystemExitOnClose == null) {\n      callSystemExitOnClose = \"false\";\n    }\n    callSystemExitOnClose = callSystemExitOnClose.trim().toLowerCase();\n\n    if (callSystemExitOnClose.equals(\"true\")) {\n      _callSystemExitOnClose = true;\n    }\n\n    initComponents();\n\n\n    _logMonitorFrame.addWindowListener(\n        new LogBrokerMonitorWindowAdaptor(this));\n\n  }\n\n  //--------------------------------------------------------------------------\n  //   Public Methods:\n  //--------------------------------------------------------------------------\n\n  /**\n   * Show the frame for the LogBrokerMonitor. Dispatched to the\n   * swing thread.\n   */\n  public void show(final int delay) {\n    if (_logMonitorFrame.isVisible()) {\n      return;\n    }\n    // This request is very low priority, let other threads execute first.\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        Thread.yield();\n        pause(delay);\n        _logMonitorFrame.setVisible(true);\n      }\n    });\n  }\n\n  public void show() {\n    show(0);\n  }\n\n  /**\n   * Dispose of the frame for the LogBrokerMonitor.\n   */\n  public void dispose() {\n    _logMonitorFrame.dispose();\n    _isDisposed = true;\n\n    if (_callSystemExitOnClose == true) {\n      System.exit(0);\n    }\n  }\n\n  /**\n   * Hide the frame for the LogBrokerMonitor.\n   */\n  public void hide() {\n    _logMonitorFrame.setVisible(false);\n  }\n\n  /**\n   * Get the DateFormatManager for formatting dates.\n   */\n  public DateFormatManager getDateFormatManager() {\n    return _table.getDateFormatManager();\n  }\n\n  /**\n   * Set the date format manager for formatting dates.\n   */\n  public void setDateFormatManager(DateFormatManager dfm) {\n    _table.setDateFormatManager(dfm);\n  }\n\n  /**\n   * Get the value of whether or not System.exit() will be called\n   * when the LogBrokerMonitor is closed.\n   */\n  public boolean getCallSystemExitOnClose() {\n    return _callSystemExitOnClose;\n  }\n\n  /**\n   * Set the value of whether or not System.exit() will be called\n   * when the LogBrokerMonitor is closed.\n   */\n  public void setCallSystemExitOnClose(boolean callSystemExitOnClose) {\n    _callSystemExitOnClose = callSystemExitOnClose;\n  }\n\n  /**\n   * Add a log record message to be displayed in the LogTable.\n   * This method is thread-safe as it posts requests to the SwingThread\n   * rather than processing directly.\n   */\n  public void addMessage(final LogRecord lr) {\n    if (_isDisposed == true) {\n      // If the frame has been disposed of, do not log any more\n      // messages.\n      return;\n    }\n\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        _categoryExplorerTree.getExplorerModel().addLogRecord(lr);\n        _table.getFilteredLogTableModel().addLogRecord(lr); // update table\n        updateStatusLabel(); // show updated counts\n      }\n    });\n  }\n\n  public void setMaxNumberOfLogRecords(int maxNumberOfLogRecords) {\n    _table.getFilteredLogTableModel().setMaxNumberOfLogRecords(maxNumberOfLogRecords);\n  }\n\n  public JFrame getBaseFrame() {\n    return _logMonitorFrame;\n  }\n\n  public void setTitle(String title) {\n    _logMonitorFrame.setTitle(title + \" - LogFactor5\");\n  }\n\n  public void setFrameSize(int width, int height) {\n    Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();\n    if (0 < width && width < screen.width) {\n      _logMonitorFrameWidth = width;\n    }\n    if (0 < height && height < screen.height) {\n      _logMonitorFrameHeight = height;\n    }\n    updateFrameSize();\n  }\n\n  public void setFontSize(int fontSize) {\n    changeFontSizeCombo(_fontSizeCombo, fontSize);\n    // setFontSizeSilently(actualFontSize); - changeFontSizeCombo fires event\n    // refreshDetailTextArea();\n  }\n\n  public void addDisplayedProperty(Object messageLine) {\n    _displayedLogBrokerProperties.add(messageLine);\n  }\n\n  public Map getLogLevelMenuItems() {\n    return _logLevelMenuItems;\n  }\n\n  public Map getLogTableColumnMenuItems() {\n    return _logTableColumnMenuItems;\n  }\n\n  public JCheckBoxMenuItem getTableColumnMenuItem(LogTableColumn column) {\n    return getLogTableColumnMenuItem(column);\n  }\n\n  public CategoryExplorerTree getCategoryExplorerTree() {\n    return _categoryExplorerTree;\n  }\n\n  // Added in version 1.2 - gets the value of the NDC text filter\n  // This value is set back to null each time the Monitor is initialized.\n  public String getNDCTextFilter() {\n    return _NDCTextFilter;\n  }\n\n  // Added in version 1.2 - sets the NDC Filter based on\n  // a String passed in by the user.  This value is persisted\n  // in the XML Configuration file.\n  public void setNDCLogRecordFilter(String textFilter) {\n    _table.getFilteredLogTableModel().\n        setLogRecordFilter(createNDCLogRecordFilter(textFilter));\n  }\n  //--------------------------------------------------------------------------\n  //   Protected Methods:\n  //--------------------------------------------------------------------------\n\n  protected void setSearchText(String text) {\n    _searchText = text;\n  }\n\n  // Added in version 1.2 - Sets the text filter for the NDC\n  protected void setNDCTextFilter(String text) {\n    // if no value is set, set it to a blank string\n    // otherwise use the value provided\n    if (text == null) {\n      _NDCTextFilter = \"\";\n    } else {\n      _NDCTextFilter = text;\n    }\n  }\n\n  // Added in version 1.2 - Uses a different filter that sorts\n  // based on an NDC string passed in by the user.  If the string\n  // is null or is an empty string, we do nothing.\n  protected void sortByNDC() {\n    String text = _NDCTextFilter;\n    if (text == null || text.length() == 0) {\n      return;\n    }\n\n    // Use new NDC filter\n    _table.getFilteredLogTableModel().\n        setLogRecordFilter(createNDCLogRecordFilter(text));\n  }\n\n  protected void findSearchText() {\n    String text = _searchText;\n    if (text == null || text.length() == 0) {\n      return;\n    }\n    int startRow = getFirstSelectedRow();\n    int foundRow = findRecord(\n        startRow,\n        text,\n        _table.getFilteredLogTableModel().getFilteredRecords()\n    );\n    selectRow(foundRow);\n  }\n\n  protected int getFirstSelectedRow() {\n    return _table.getSelectionModel().getMinSelectionIndex();\n  }\n\n  protected void selectRow(int foundRow) {\n    if (foundRow == -1) {\n      String message = _searchText + \" not found.\";\n      JOptionPane.showMessageDialog(\n          _logMonitorFrame,\n          message,\n          \"Text not found\",\n          JOptionPane.INFORMATION_MESSAGE\n      );\n      return;\n    }\n    LF5SwingUtils.selectRow(foundRow, _table, _logTableScrollPane);\n  }\n\n  protected int findRecord(\n      int startRow,\n      String searchText,\n      List records\n      ) {\n    if (startRow < 0) {\n      startRow = 0; // start at first element if no rows are selected\n    } else {\n      startRow++; // start after the first selected row\n    }\n    int len = records.size();\n\n    for (int i = startRow; i < len; i++) {\n      if (matches((LogRecord) records.get(i), searchText)) {\n        return i; // found a record\n      }\n    }\n    // wrap around to beginning if when we reach the end with no match\n    len = startRow;\n    for (int i = 0; i < len; i++) {\n      if (matches((LogRecord) records.get(i), searchText)) {\n        return i; // found a record\n      }\n    }\n    // nothing found\n    return -1;\n  }\n\n  /**\n   * Check to see if the any records contain the search string.\n   * Searching now supports NDC messages and date.\n   */\n  protected boolean matches(LogRecord record, String text) {\n    String message = record.getMessage();\n    String NDC = record.getNDC();\n\n    if (message == null && NDC == null || text == null) {\n      return false;\n    }\n    if (message.toLowerCase().indexOf(text.toLowerCase()) == -1 &&\n        NDC.toLowerCase().indexOf(text.toLowerCase()) == -1) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * When the fontsize of a JTextArea is changed, the word-wrapped lines\n   * may become garbled.  This method clears and resets the text of the\n   * text area.\n   */\n  protected void refresh(JTextArea textArea) {\n    String text = textArea.getText();\n    textArea.setText(\"\");\n    textArea.setText(text);\n  }\n\n  protected void refreshDetailTextArea() {\n    refresh(_table._detailTextArea);\n  }\n\n  protected void clearDetailTextArea() {\n    _table._detailTextArea.setText(\"\");\n  }\n\n  /**\n   * Changes the font selection in the combo box and returns the\n   * size actually selected.\n   * @return -1 if unable to select an appropriate font\n   */\n  protected int changeFontSizeCombo(JComboBox box, int requestedSize) {\n    int len = box.getItemCount();\n    int currentValue;\n    Object currentObject;\n    Object selectedObject = box.getItemAt(0);\n    int selectedValue = Integer.parseInt(String.valueOf(selectedObject));\n    for (int i = 0; i < len; i++) {\n      currentObject = box.getItemAt(i);\n      currentValue = Integer.parseInt(String.valueOf(currentObject));\n      if (selectedValue < currentValue && currentValue <= requestedSize) {\n        selectedValue = currentValue;\n        selectedObject = currentObject;\n      }\n    }\n    box.setSelectedItem(selectedObject);\n    return selectedValue;\n  }\n\n  /**\n   * Does not update gui or cause any events to be fired.\n   */\n  protected void setFontSizeSilently(int fontSize) {\n    _fontSize = fontSize;\n    setFontSize(_table._detailTextArea, fontSize);\n    selectRow(0);\n    setFontSize(_table, fontSize);\n  }\n\n  protected void setFontSize(Component component, int fontSize) {\n    Font oldFont = component.getFont();\n    Font newFont =\n        new Font(oldFont.getFontName(), oldFont.getStyle(), fontSize);\n    component.setFont(newFont);\n  }\n\n  protected void updateFrameSize() {\n    _logMonitorFrame.setSize(_logMonitorFrameWidth, _logMonitorFrameHeight);\n    centerFrame(_logMonitorFrame);\n  }\n\n  protected void pause(int millis) {\n    try {\n      Thread.sleep(millis);\n    } catch (InterruptedException e) {\n\n    }\n  }\n\n  protected void initComponents() {\n    //\n    // Configure the Frame.\n    //\n    _logMonitorFrame = new JFrame(\"LogFactor5\");\n\n    _logMonitorFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\n\n    String resource =\n        \"/org/apache/log4j/lf5/viewer/images/lf5_small_icon.gif\";\n    URL lf5IconURL = getClass().getResource(resource);\n\n    if (lf5IconURL != null) {\n      _logMonitorFrame.setIconImage(new ImageIcon(lf5IconURL).getImage());\n    }\n    updateFrameSize();\n\n    //\n    // Configure the LogTable.\n    //\n    JTextArea detailTA = createDetailTextArea();\n    JScrollPane detailTAScrollPane = new JScrollPane(detailTA);\n    _table = new LogTable(detailTA);\n    setView(_currentView, _table);\n    _table.setFont(new Font(_fontName, Font.PLAIN, _fontSize));\n    _logTableScrollPane = new JScrollPane(_table);\n\n    if (_trackTableScrollPane) {\n      _logTableScrollPane.getVerticalScrollBar().addAdjustmentListener(\n          new TrackingAdjustmentListener()\n      );\n    }\n\n\n    // Configure the SplitPane between the LogTable & DetailTextArea\n    //\n\n    JSplitPane tableViewerSplitPane = new JSplitPane();\n    tableViewerSplitPane.setOneTouchExpandable(true);\n    tableViewerSplitPane.setOrientation(JSplitPane.VERTICAL_SPLIT);\n    tableViewerSplitPane.setLeftComponent(_logTableScrollPane);\n    tableViewerSplitPane.setRightComponent(detailTAScrollPane);\n    // Make sure to do this last..\n    //tableViewerSplitPane.setDividerLocation(1.0); Doesn't work\n    //the same under 1.2.x & 1.3\n    // \"350\" is a magic number that provides the correct default\n    // behaviour under 1.2.x & 1.3.  For example, bumping this\n    // number to 400, causes the pane to be completely open in 1.2.x\n    // and closed in 1.3\n    tableViewerSplitPane.setDividerLocation(350);\n\n    //\n    // Configure the CategoryExplorer\n    //\n\n    _categoryExplorerTree = new CategoryExplorerTree();\n\n    _table.getFilteredLogTableModel().setLogRecordFilter(createLogRecordFilter());\n\n    JScrollPane categoryExplorerTreeScrollPane =\n        new JScrollPane(_categoryExplorerTree);\n    categoryExplorerTreeScrollPane.setPreferredSize(new Dimension(130, 400));\n\n    // Load most recently used file list\n    _mruFileManager = new MRUFileManager();\n\n    //\n    // Configure the SplitPane between the CategoryExplorer & (LogTable/Detail)\n    //\n\n    JSplitPane splitPane = new JSplitPane();\n    splitPane.setOneTouchExpandable(true);\n    splitPane.setRightComponent(tableViewerSplitPane);\n    splitPane.setLeftComponent(categoryExplorerTreeScrollPane);\n    // Do this last.\n    splitPane.setDividerLocation(130);\n    //\n    // Add the MenuBar, StatusArea, CategoryExplorer|LogTable to the\n    // LogMonitorFrame.\n    //\n    _logMonitorFrame.getRootPane().setJMenuBar(createMenuBar());\n    _logMonitorFrame.getContentPane().add(splitPane, BorderLayout.CENTER);\n    _logMonitorFrame.getContentPane().add(createToolBar(),\n        BorderLayout.NORTH);\n    _logMonitorFrame.getContentPane().add(createStatusArea(),\n        BorderLayout.SOUTH);\n\n    makeLogTableListenToCategoryExplorer();\n    addTableModelProperties();\n\n    //\n    // Configure ConfigurationManager\n    //\n    _configurationManager = new ConfigurationManager(this, _table);\n\n  }\n\n  protected LogRecordFilter createLogRecordFilter() {\n    LogRecordFilter result = new LogRecordFilter() {\n      public boolean passes(LogRecord record) {\n        CategoryPath path = new CategoryPath(record.getCategory());\n        return\n            getMenuItem(record.getLevel()).isSelected() &&\n            _categoryExplorerTree.getExplorerModel().isCategoryPathActive(path);\n      }\n    };\n    return result;\n  }\n\n  // Added in version 1.2 - Creates a new filter that sorts records based on\n  // an NDC string passed in by the user.\n  protected LogRecordFilter createNDCLogRecordFilter(String text) {\n    _NDCTextFilter = text;\n    LogRecordFilter result = new LogRecordFilter() {\n      public boolean passes(LogRecord record) {\n        String NDC = record.getNDC();\n        CategoryPath path = new CategoryPath(record.getCategory());\n        if (NDC == null || _NDCTextFilter == null) {\n          return false;\n        } else if (NDC.toLowerCase().indexOf(_NDCTextFilter.toLowerCase()) == -1) {\n          return false;\n        } else {\n          return getMenuItem(record.getLevel()).isSelected() &&\n              _categoryExplorerTree.getExplorerModel().isCategoryPathActive(path);\n        }\n      }\n    };\n\n    return result;\n  }\n\n\n  protected void updateStatusLabel() {\n    _statusLabel.setText(getRecordsDisplayedMessage());\n  }\n\n  protected String getRecordsDisplayedMessage() {\n    FilteredLogTableModel model = _table.getFilteredLogTableModel();\n    return getStatusText(model.getRowCount(), model.getTotalRowCount());\n  }\n\n  protected void addTableModelProperties() {\n    final FilteredLogTableModel model = _table.getFilteredLogTableModel();\n\n    addDisplayedProperty(new Object() {\n      public String toString() {\n        return getRecordsDisplayedMessage();\n      }\n    });\n    addDisplayedProperty(new Object() {\n      public String toString() {\n        return \"Maximum number of displayed LogRecords: \"\n            + model._maxNumberOfLogRecords;\n      }\n    });\n  }\n\n  protected String getStatusText(int displayedRows, int totalRows) {\n    StringBuffer result = new StringBuffer();\n    result.append(\"Displaying: \");\n    result.append(displayedRows);\n    result.append(\" records out of a total of: \");\n    result.append(totalRows);\n    result.append(\" records.\");\n    return result.toString();\n  }\n\n  protected void makeLogTableListenToCategoryExplorer() {\n    ActionListener listener = new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        _table.getFilteredLogTableModel().refresh();\n        updateStatusLabel();\n      }\n    };\n    _categoryExplorerTree.getExplorerModel().addActionListener(listener);\n  }\n\n  protected JPanel createStatusArea() {\n    JPanel statusArea = new JPanel();\n    JLabel status =\n        new JLabel(\"No log records to display.\");\n    _statusLabel = status;\n    status.setHorizontalAlignment(JLabel.LEFT);\n\n    statusArea.setBorder(BorderFactory.createEtchedBorder());\n    statusArea.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));\n    statusArea.add(status);\n\n    return (statusArea);\n  }\n\n  protected JTextArea createDetailTextArea() {\n    JTextArea detailTA = new JTextArea();\n    detailTA.setFont(new Font(\"Monospaced\", Font.PLAIN, 14));\n    detailTA.setTabSize(3);\n    detailTA.setLineWrap(true);\n    detailTA.setWrapStyleWord(false);\n    return (detailTA);\n  }\n\n  protected JMenuBar createMenuBar() {\n    JMenuBar menuBar = new JMenuBar();\n    menuBar.add(createFileMenu());\n    menuBar.add(createEditMenu());\n    menuBar.add(createLogLevelMenu());\n    menuBar.add(createViewMenu());\n    menuBar.add(createConfigureMenu());\n    menuBar.add(createHelpMenu());\n\n    return (menuBar);\n  }\n\n  protected JMenu createLogLevelMenu() {\n    JMenu result = new JMenu(\"Log Level\");\n    result.setMnemonic('l');\n    Iterator levels = getLogLevels();\n    while (levels.hasNext()) {\n      result.add(getMenuItem((LogLevel) levels.next()));\n    }\n\n    result.addSeparator();\n    result.add(createAllLogLevelsMenuItem());\n    result.add(createNoLogLevelsMenuItem());\n    result.addSeparator();\n    result.add(createLogLevelColorMenu());\n    result.add(createResetLogLevelColorMenuItem());\n\n    return result;\n  }\n\n  protected JMenuItem createAllLogLevelsMenuItem() {\n    JMenuItem result = new JMenuItem(\"Show all LogLevels\");\n    result.setMnemonic('s');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        selectAllLogLevels(true);\n        _table.getFilteredLogTableModel().refresh();\n        updateStatusLabel();\n      }\n    });\n    return result;\n  }\n\n  protected JMenuItem createNoLogLevelsMenuItem() {\n    JMenuItem result = new JMenuItem(\"Hide all LogLevels\");\n    result.setMnemonic('h');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        selectAllLogLevels(false);\n        _table.getFilteredLogTableModel().refresh();\n        updateStatusLabel();\n      }\n    });\n    return result;\n  }\n\n  protected JMenu createLogLevelColorMenu() {\n    JMenu colorMenu = new JMenu(\"Configure LogLevel Colors\");\n    colorMenu.setMnemonic('c');\n    Iterator levels = getLogLevels();\n    while (levels.hasNext()) {\n      colorMenu.add(createSubMenuItem((LogLevel) levels.next()));\n    }\n\n    return colorMenu;\n  }\n\n  protected JMenuItem createResetLogLevelColorMenuItem() {\n    JMenuItem result = new JMenuItem(\"Reset LogLevel Colors\");\n    result.setMnemonic('r');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        // reset the level colors in the map\n        LogLevel.resetLogLevelColorMap();\n\n        // refresh the table\n        _table.getFilteredLogTableModel().refresh();\n      }\n    });\n    return result;\n  }\n\n  protected void selectAllLogLevels(boolean selected) {\n    Iterator levels = getLogLevels();\n    while (levels.hasNext()) {\n      getMenuItem((LogLevel) levels.next()).setSelected(selected);\n    }\n  }\n\n  protected JCheckBoxMenuItem getMenuItem(LogLevel level) {\n    JCheckBoxMenuItem result = (JCheckBoxMenuItem) (_logLevelMenuItems.get(level));\n    if (result == null) {\n      result = createMenuItem(level);\n      _logLevelMenuItems.put(level, result);\n    }\n    return result;\n  }\n\n  protected JMenuItem createSubMenuItem(LogLevel level) {\n    final JMenuItem result = new JMenuItem(level.toString());\n    final LogLevel logLevel = level;\n    result.setMnemonic(level.toString().charAt(0));\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        showLogLevelColorChangeDialog(result, logLevel);\n      }\n    });\n\n    return result;\n\n  }\n\n  protected void showLogLevelColorChangeDialog(JMenuItem result, LogLevel level) {\n    JMenuItem menuItem = result;\n    Color newColor = JColorChooser.showDialog(\n        _logMonitorFrame,\n        \"Choose LogLevel Color\",\n        result.getForeground());\n\n    if (newColor != null) {\n      // set the color for the record\n      level.setLogLevelColorMap(level, newColor);\n      _table.getFilteredLogTableModel().refresh();\n    }\n\n  }\n\n  protected JCheckBoxMenuItem createMenuItem(LogLevel level) {\n    JCheckBoxMenuItem result = new JCheckBoxMenuItem(level.toString());\n    result.setSelected(true);\n    result.setMnemonic(level.toString().charAt(0));\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        _table.getFilteredLogTableModel().refresh();\n        updateStatusLabel();\n      }\n    });\n    return result;\n  }\n\n  // view menu\n  protected JMenu createViewMenu() {\n    JMenu result = new JMenu(\"View\");\n    result.setMnemonic('v');\n    Iterator columns = getLogTableColumns();\n    while (columns.hasNext()) {\n      result.add(getLogTableColumnMenuItem((LogTableColumn) columns.next()));\n    }\n\n    result.addSeparator();\n    result.add(createAllLogTableColumnsMenuItem());\n    result.add(createNoLogTableColumnsMenuItem());\n    return result;\n  }\n\n  protected JCheckBoxMenuItem getLogTableColumnMenuItem(LogTableColumn column) {\n    JCheckBoxMenuItem result = (JCheckBoxMenuItem) (_logTableColumnMenuItems.get(column));\n    if (result == null) {\n      result = createLogTableColumnMenuItem(column);\n      _logTableColumnMenuItems.put(column, result);\n    }\n    return result;\n  }\n\n  protected JCheckBoxMenuItem createLogTableColumnMenuItem(LogTableColumn column) {\n    JCheckBoxMenuItem result = new JCheckBoxMenuItem(column.toString());\n\n    result.setSelected(true);\n    result.setMnemonic(column.toString().charAt(0));\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        // update list of columns and reset the view\n        List selectedColumns = updateView();\n        _table.setView(selectedColumns);\n      }\n    });\n    return result;\n  }\n\n  protected List updateView() {\n    ArrayList updatedList = new ArrayList();\n    Iterator columnIterator = _columns.iterator();\n    while (columnIterator.hasNext()) {\n      LogTableColumn column = (LogTableColumn) columnIterator.next();\n      JCheckBoxMenuItem result = getLogTableColumnMenuItem(column);\n      // check and see if the checkbox is checked\n      if (result.isSelected()) {\n        updatedList.add(column);\n      }\n    }\n\n    return updatedList;\n  }\n\n  protected JMenuItem createAllLogTableColumnsMenuItem() {\n    JMenuItem result = new JMenuItem(\"Show all Columns\");\n    result.setMnemonic('s');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        selectAllLogTableColumns(true);\n        // update list of columns and reset the view\n        List selectedColumns = updateView();\n        _table.setView(selectedColumns);\n      }\n    });\n    return result;\n  }\n\n  protected JMenuItem createNoLogTableColumnsMenuItem() {\n    JMenuItem result = new JMenuItem(\"Hide all Columns\");\n    result.setMnemonic('h');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        selectAllLogTableColumns(false);\n        // update list of columns and reset the view\n        List selectedColumns = updateView();\n        _table.setView(selectedColumns);\n      }\n    });\n    return result;\n  }\n\n  protected void selectAllLogTableColumns(boolean selected) {\n    Iterator columns = getLogTableColumns();\n    while (columns.hasNext()) {\n      getLogTableColumnMenuItem((LogTableColumn) columns.next()).setSelected(selected);\n    }\n  }\n\n  protected JMenu createFileMenu() {\n    JMenu fileMenu = new JMenu(\"File\");\n    fileMenu.setMnemonic('f');\n    JMenuItem exitMI;\n    fileMenu.add(createOpenMI());\n    fileMenu.add(createOpenURLMI());\n    fileMenu.addSeparator();\n    fileMenu.add(createCloseMI());\n    createMRUFileListMI(fileMenu);\n    fileMenu.addSeparator();\n    fileMenu.add(createExitMI());\n    return fileMenu;\n  }\n\n  /**\n   * Menu item added to allow log files to be opened with\n   * the LF5 GUI.\n   */\n  protected JMenuItem createOpenMI() {\n    JMenuItem result = new JMenuItem(\"Open...\");\n    result.setMnemonic('o');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        requestOpen();\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Menu item added to allow log files loaded from a URL\n   * to be opened by the LF5 GUI.\n   */\n  protected JMenuItem createOpenURLMI() {\n    JMenuItem result = new JMenuItem(\"Open URL...\");\n    result.setMnemonic('u');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        requestOpenURL();\n      }\n    });\n    return result;\n  }\n\n  protected JMenuItem createCloseMI() {\n    JMenuItem result = new JMenuItem(\"Close\");\n    result.setMnemonic('c');\n    result.setAccelerator(KeyStroke.getKeyStroke(\"control Q\"));\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        requestClose();\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Creates a Most Recently Used file list to be\n   * displayed in the File menu\n   */\n  protected void createMRUFileListMI(JMenu menu) {\n\n    String[] files = _mruFileManager.getMRUFileList();\n\n    if (files != null) {\n      menu.addSeparator();\n      for (int i = 0; i < files.length; i++) {\n        JMenuItem result = new JMenuItem((i + 1) + \" \" + files[i]);\n        result.setMnemonic(i + 1);\n        result.addActionListener(new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            requestOpenMRU(e);\n          }\n        });\n        menu.add(result);\n      }\n    }\n  }\n\n  protected JMenuItem createExitMI() {\n    JMenuItem result = new JMenuItem(\"Exit\");\n    result.setMnemonic('x');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        requestExit();\n      }\n    });\n    return result;\n  }\n\n  protected JMenu createConfigureMenu() {\n    JMenu configureMenu = new JMenu(\"Configure\");\n    configureMenu.setMnemonic('c');\n    configureMenu.add(createConfigureSave());\n    configureMenu.add(createConfigureReset());\n    configureMenu.add(createConfigureMaxRecords());\n\n    return configureMenu;\n  }\n\n  protected JMenuItem createConfigureSave() {\n    JMenuItem result = new JMenuItem(\"Save\");\n    result.setMnemonic('s');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        saveConfiguration();\n      }\n    });\n\n    return result;\n  }\n\n  protected JMenuItem createConfigureReset() {\n    JMenuItem result = new JMenuItem(\"Reset\");\n    result.setMnemonic('r');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        resetConfiguration();\n      }\n    });\n\n    return result;\n  }\n\n  protected JMenuItem createConfigureMaxRecords() {\n    JMenuItem result = new JMenuItem(\"Set Max Number of Records\");\n    result.setMnemonic('m');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        setMaxRecordConfiguration();\n      }\n    });\n\n    return result;\n  }\n\n\n  protected void saveConfiguration() {\n    _configurationManager.save();\n  }\n\n  protected void resetConfiguration() {\n    _configurationManager.reset();\n  }\n\n  protected void setMaxRecordConfiguration() {\n    LogFactor5InputDialog inputDialog = new LogFactor5InputDialog(\n        getBaseFrame(), \"Set Max Number of Records\", \"\", 10);\n\n    String temp = inputDialog.getText();\n\n    if (temp != null) {\n      try {\n        setMaxNumberOfLogRecords(Integer.parseInt(temp));\n      } catch (NumberFormatException e) {\n        LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(\n            getBaseFrame(),\n            \"'\" + temp + \"' is an invalid parameter.\\nPlease try again.\");\n        setMaxRecordConfiguration();\n      }\n    }\n  }\n\n\n  protected JMenu createHelpMenu() {\n    JMenu helpMenu = new JMenu(\"Help\");\n    helpMenu.setMnemonic('h');\n    helpMenu.add(createHelpProperties());\n    return helpMenu;\n  }\n\n  protected JMenuItem createHelpProperties() {\n    final String title = \"LogFactor5 Properties\";\n    final JMenuItem result = new JMenuItem(title);\n    result.setMnemonic('l');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        showPropertiesDialog(title);\n      }\n    });\n    return result;\n  }\n\n  protected void showPropertiesDialog(String title) {\n    JOptionPane.showMessageDialog(\n        _logMonitorFrame,\n        _displayedLogBrokerProperties.toArray(),\n        title,\n        JOptionPane.PLAIN_MESSAGE\n    );\n  }\n\n  protected JMenu createEditMenu() {\n    JMenu editMenu = new JMenu(\"Edit\");\n    editMenu.setMnemonic('e');\n    editMenu.add(createEditFindMI());\n    editMenu.add(createEditFindNextMI());\n    editMenu.addSeparator();\n    editMenu.add(createEditSortNDCMI());\n    editMenu.add(createEditRestoreAllNDCMI());\n    return editMenu;\n  }\n\n  protected JMenuItem createEditFindNextMI() {\n    JMenuItem editFindNextMI = new JMenuItem(\"Find Next\");\n    editFindNextMI.setMnemonic('n');\n    editFindNextMI.setAccelerator(KeyStroke.getKeyStroke(\"F3\"));\n    editFindNextMI.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        findSearchText();\n      }\n    });\n    return editFindNextMI;\n  }\n\n  protected JMenuItem createEditFindMI() {\n    JMenuItem editFindMI = new JMenuItem(\"Find\");\n    editFindMI.setMnemonic('f');\n    editFindMI.setAccelerator(KeyStroke.getKeyStroke(\"control F\"));\n\n    editFindMI.addActionListener(\n        new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            String inputValue =\n                JOptionPane.showInputDialog(\n                    _logMonitorFrame,\n                    \"Find text: \",\n                    \"Search Record Messages\",\n                    JOptionPane.QUESTION_MESSAGE\n                );\n            setSearchText(inputValue);\n            findSearchText();\n          }\n        }\n\n    );\n    return editFindMI;\n  }\n\n  // Added version 1.2 - Allows users to Sort Log Records by an\n  // NDC text filter. A new LogRecordFilter was created to\n  // sort the records.\n  protected JMenuItem createEditSortNDCMI() {\n    JMenuItem editSortNDCMI = new JMenuItem(\"Sort by NDC\");\n    editSortNDCMI.setMnemonic('s');\n    editSortNDCMI.addActionListener(\n        new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            String inputValue =\n                JOptionPane.showInputDialog(\n                    _logMonitorFrame,\n                    \"Sort by this NDC: \",\n                    \"Sort Log Records by NDC\",\n                    JOptionPane.QUESTION_MESSAGE\n                );\n            setNDCTextFilter(inputValue);\n            sortByNDC();\n            _table.getFilteredLogTableModel().refresh();\n            updateStatusLabel();\n          }\n        }\n\n    );\n    return editSortNDCMI;\n  }\n\n  // Added in version 1.2 - Resets the LogRecordFilter back to default\n  // filter.\n  protected JMenuItem createEditRestoreAllNDCMI() {\n    JMenuItem editRestoreAllNDCMI = new JMenuItem(\"Restore all NDCs\");\n    editRestoreAllNDCMI.setMnemonic('r');\n    editRestoreAllNDCMI.addActionListener(\n        new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            _table.getFilteredLogTableModel().setLogRecordFilter(createLogRecordFilter());\n            // reset the text filter\n            setNDCTextFilter(\"\");\n            _table.getFilteredLogTableModel().refresh();\n            updateStatusLabel();\n          }\n        }\n    );\n    return editRestoreAllNDCMI;\n  }\n\n  protected JToolBar createToolBar() {\n    JToolBar tb = new JToolBar();\n    tb.putClientProperty(\"JToolBar.isRollover\", Boolean.TRUE);\n    JComboBox fontCombo = new JComboBox();\n    JComboBox fontSizeCombo = new JComboBox();\n    _fontSizeCombo = fontSizeCombo;\n\n    ClassLoader cl = this.getClass().getClassLoader();\n    if(cl == null) {\n        cl = ClassLoader.getSystemClassLoader();\n    }\n    URL newIconURL = cl.getResource(\"org/apache/log4j/lf5/viewer/\" +\n        \"images/channelexplorer_new.gif\");\n\n    ImageIcon newIcon = null;\n\n    if (newIconURL != null) {\n      newIcon = new ImageIcon(newIconURL);\n    }\n\n    JButton newButton = new JButton(\"Clear Log Table\");\n\n    if (newIcon != null) {\n      newButton.setIcon(newIcon);\n    }\n\n    newButton.setToolTipText(\"Clear Log Table.\");\n    //newButton.setBorder(BorderFactory.createEtchedBorder());\n\n    newButton.addActionListener(\n        new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            _table.clearLogRecords();\n            _categoryExplorerTree.getExplorerModel().resetAllNodeCounts();\n            updateStatusLabel();\n            clearDetailTextArea();\n            LogRecord.resetSequenceNumber();\n          }\n        }\n    );\n\n    Toolkit tk = Toolkit.getDefaultToolkit();\n    // This will actually grab all the fonts\n\n    String[] fonts;\n\n    if (_loadSystemFonts) {\n      fonts = GraphicsEnvironment.\n          getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n    } else {\n      fonts = tk.getFontList();\n    }\n\n    for (int j = 0; j < fonts.length; j++) {\n      fontCombo.addItem(fonts[j]);\n    }\n\n    fontCombo.setSelectedItem(_fontName);\n\n    fontCombo.addActionListener(\n\n        new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            JComboBox box = (JComboBox) e.getSource();\n            String font = (String) box.getSelectedItem();\n            _table.setFont(new Font(font, Font.PLAIN, _fontSize));\n            _fontName = font;\n          }\n        }\n    );\n\n    fontSizeCombo.addItem(\"8\");\n    fontSizeCombo.addItem(\"9\");\n    fontSizeCombo.addItem(\"10\");\n    fontSizeCombo.addItem(\"12\");\n    fontSizeCombo.addItem(\"14\");\n    fontSizeCombo.addItem(\"16\");\n    fontSizeCombo.addItem(\"18\");\n    fontSizeCombo.addItem(\"24\");\n\n    fontSizeCombo.setSelectedItem(String.valueOf(_fontSize));\n    fontSizeCombo.addActionListener(\n        new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            JComboBox box = (JComboBox) e.getSource();\n            String size = (String) box.getSelectedItem();\n            int s = Integer.valueOf(size).intValue();\n\n            setFontSizeSilently(s);\n            refreshDetailTextArea();\n            _fontSize = s;\n          }\n        }\n    );\n\n    tb.add(new JLabel(\" Font: \"));\n    tb.add(fontCombo);\n    tb.add(fontSizeCombo);\n    tb.addSeparator();\n    tb.addSeparator();\n    tb.add(newButton);\n\n    newButton.setAlignmentY(0.5f);\n    newButton.setAlignmentX(0.5f);\n\n    fontCombo.setMaximumSize(fontCombo.getPreferredSize());\n    fontSizeCombo.setMaximumSize(\n        fontSizeCombo.getPreferredSize());\n\n    return (tb);\n  }\n\n//    protected void setView(String viewString, LogTable table) {\n//        if (STANDARD_VIEW.equals(viewString)) {\n//            table.setStandardView();\n//        } else if (COMPACT_VIEW.equals(viewString)) {\n//            table.setCompactView();\n//        } else if (DETAILED_VIEW.equals(viewString)) {\n//            table.setDetailedView();\n//        } else {\n//            String message = viewString + \"does not match a supported view.\";\n//            throw new IllegalArgumentException(message);\n//        }\n//        _currentView = viewString;\n//    }\n\n  protected void setView(String viewString, LogTable table) {\n    if (DETAILED_VIEW.equals(viewString)) {\n      table.setDetailedView();\n    } else {\n      String message = viewString + \"does not match a supported view.\";\n      throw new IllegalArgumentException(message);\n    }\n    _currentView = viewString;\n  }\n\n  protected JComboBox createLogLevelCombo() {\n    JComboBox result = new JComboBox();\n    Iterator levels = getLogLevels();\n    while (levels.hasNext()) {\n      result.addItem(levels.next());\n    }\n    result.setSelectedItem(_leastSevereDisplayedLogLevel);\n\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        JComboBox box = (JComboBox) e.getSource();\n        LogLevel level = (LogLevel) box.getSelectedItem();\n        setLeastSevereDisplayedLogLevel(level);\n      }\n    });\n    result.setMaximumSize(result.getPreferredSize());\n    return result;\n  }\n\n  protected void setLeastSevereDisplayedLogLevel(LogLevel level) {\n    if (level == null || _leastSevereDisplayedLogLevel == level) {\n      return; // nothing to do\n    }\n    _leastSevereDisplayedLogLevel = level;\n    _table.getFilteredLogTableModel().refresh();\n    updateStatusLabel();\n  }\n\n  /**\n   * Ensures that the Table's ScrollPane Viewport will \"track\" with updates\n   * to the Table.  When the vertical scroll bar is at its bottom anchor\n   * and tracking is enabled then viewport will stay at the bottom most\n   * point of the component.  The purpose of this feature is to allow\n   * a developer to watch the table as messages arrive and not have to\n   * scroll after each new message arrives.  When the vertical scroll bar\n   * is at any other location, then no tracking will happen.\n   * @deprecated tracking is now done automatically.\n   */\n  protected void trackTableScrollPane() {\n    // do nothing\n  }\n\n  protected void centerFrame(JFrame frame) {\n    Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();\n    Dimension comp = frame.getSize();\n\n    frame.setLocation(((screen.width - comp.width) / 2),\n        ((screen.height - comp.height) / 2));\n\n  }\n\n  /**\n   * Uses a JFileChooser to select a file to opened with the\n   * LF5 GUI.\n   */\n  protected void requestOpen() {\n    JFileChooser chooser;\n\n    if (_fileLocation == null) {\n      chooser = new JFileChooser();\n    } else {\n      chooser = new JFileChooser(_fileLocation);\n    }\n\n    int returnVal = chooser.showOpenDialog(_logMonitorFrame);\n    if (returnVal == JFileChooser.APPROVE_OPTION) {\n      File f = chooser.getSelectedFile();\n      if (loadLogFile(f)) {\n        _fileLocation = chooser.getSelectedFile();\n        _mruFileManager.set(f);\n        updateMRUList();\n      }\n    }\n  }\n\n  /**\n   * Uses a Dialog box to accept a URL to a file to be opened\n   * with the LF5 GUI.\n   */\n  protected void requestOpenURL() {\n    LogFactor5InputDialog inputDialog = new LogFactor5InputDialog(\n        getBaseFrame(), \"Open URL\", \"URL:\");\n    String temp = inputDialog.getText();\n\n    if (temp != null) {\n      if (temp.indexOf(\"://\") == -1) {\n        temp = \"http://\" + temp;\n      }\n\n      try {\n        URL url = new URL(temp);\n        if (loadLogFile(url)) {\n          _mruFileManager.set(url);\n          updateMRUList();\n        }\n      } catch (MalformedURLException e) {\n        LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(\n            getBaseFrame(), \"Error reading URL.\");\n      }\n    }\n  }\n\n  /**\n   * Removes old file list and creates a new file list\n   * with the updated MRU list.\n   */\n  protected void updateMRUList() {\n    JMenu menu = _logMonitorFrame.getJMenuBar().getMenu(0);\n    menu.removeAll();\n    menu.add(createOpenMI());\n    menu.add(createOpenURLMI());\n    menu.addSeparator();\n    menu.add(createCloseMI());\n    createMRUFileListMI(menu);\n    menu.addSeparator();\n    menu.add(createExitMI());\n  }\n\n  protected void requestClose() {\n    setCallSystemExitOnClose(false);\n    closeAfterConfirm();\n  }\n\n  /**\n   * Opens a file in the MRU list.\n   */\n  protected void requestOpenMRU(ActionEvent e) {\n    String file = e.getActionCommand();\n    StringTokenizer st = new StringTokenizer(file);\n    String num = st.nextToken().trim();\n    file = st.nextToken(\"\\n\");\n\n    try {\n      int index = Integer.parseInt(num) - 1;\n\n      InputStream in = _mruFileManager.getInputStream(index);\n      LogFileParser lfp = new LogFileParser(in);\n      lfp.parse(this);\n\n      _mruFileManager.moveToTop(index);\n      updateMRUList();\n\n    } catch (Exception me) {\n      LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(\n          getBaseFrame(), \"Unable to load file \" + file);\n    }\n\n  }\n\n  protected void requestExit() {\n    _mruFileManager.save();\n    setCallSystemExitOnClose(true);\n    closeAfterConfirm();\n  }\n\n  protected void closeAfterConfirm() {\n    StringBuffer message = new StringBuffer();\n\n    if (_callSystemExitOnClose == false) {\n      message.append(\"Are you sure you want to close the logging \");\n      message.append(\"console?\\n\");\n      message.append(\"(Note: This will not shut down the Virtual Machine,\\n\");\n      message.append(\"or the Swing event thread.)\");\n    } else {\n      message.append(\"Are you sure you want to exit?\\n\");\n      message.append(\"This will shut down the Virtual Machine.\\n\");\n    }\n\n    String title =\n        \"Are you sure you want to dispose of the Logging Console?\";\n\n    if (_callSystemExitOnClose == true) {\n      title = \"Are you sure you want to exit?\";\n    }\n    int value = JOptionPane.showConfirmDialog(\n        _logMonitorFrame,\n        message.toString(),\n        title,\n        JOptionPane.OK_CANCEL_OPTION,\n        JOptionPane.QUESTION_MESSAGE,\n        null\n    );\n\n    if (value == JOptionPane.OK_OPTION) {\n      dispose();\n    }\n  }\n\n  protected Iterator getLogLevels() {\n    return _levels.iterator();\n  }\n\n  protected Iterator getLogTableColumns() {\n    return _columns.iterator();\n  }\n\n  /**\n   * Loads and parses a log file.\n   */\n  protected boolean loadLogFile(File file) {\n    boolean ok = false;\n    try {\n      LogFileParser lfp = new LogFileParser(file);\n      lfp.parse(this);\n      ok = true;\n    } catch (IOException e) {\n      LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(\n          getBaseFrame(), \"Error reading \" + file.getName());\n    }\n\n    return ok;\n  }\n\n  /**\n   * Loads a parses a log file running on a server.\n   */\n  protected boolean loadLogFile(URL url) {\n    boolean ok = false;\n    try {\n      LogFileParser lfp = new LogFileParser(url.openStream());\n      lfp.parse(this);\n      ok = true;\n    } catch (IOException e) {\n      LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(\n          getBaseFrame(), \"Error reading URL:\" + url.getFile());\n    }\n    return ok;\n  }\n  //--------------------------------------------------------------------------\n  //   Private Methods:\n  //--------------------------------------------------------------------------\n\n  //--------------------------------------------------------------------------\n  //   Nested Top-Level Classes or Interfaces:\n  //--------------------------------------------------------------------------\n\n  class LogBrokerMonitorWindowAdaptor extends WindowAdapter {\n    protected LogBrokerMonitor _monitor;\n\n    public LogBrokerMonitorWindowAdaptor(LogBrokerMonitor monitor) {\n      _monitor = monitor;\n    }\n\n    public void windowClosing(WindowEvent ev) {\n      _monitor.requestClose();\n    }\n  }\n}\n\n\n",
      "file_name": "LogBrokerMonitor.java",
      "human_label": "Add a log record message to be displayed in the LogTable, with the SwingUtilities.",
      "level": "project_runnable",
      "lineno": "246",
      "name": "addMessage",
      "oracle_context": "{ \"apis\" : \"[invokeLater, addLogRecord, getExplorerModel, getFilteredLogTableModel, updateStatusLabel, run]\", \"classes\" : \"[]\", \"vars\" : \"[_isDisposed, _categoryExplorerTree, _table]\" }",
      "package": "org.apache.log4j.lf5.viewer",
      "project": "logging-log4j1-main"
    },
    {
      "_id": "636767641a6d9265ec01817d",
      "all_context": "{ \"class_level\" : \"import org.jgrapht.*;\\nimport org.jgrapht.util.*;\\nimport java.util.*;\\nint sizeA;\\nint sizeB;\\nSet<V> partitionA;\\nSet<V> partitionB;\\nCompleteBipartiteGraphGenerator(int partitionA,int partitionB);\\nCompleteBipartiteGraphGenerator(Set partitionA,Set partitionB);\\n\", \"repo_level\" : \"\" }",
      "class_name": "CompleteBipartiteGraphGenerator",
      "code": "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n  for (int i=0; i < sizeA; i++) {\n    partitionA.add(target.addVertex());\n  }\n  for (int i=0; i < sizeB; i++) {\n    partitionB.add(target.addVertex());\n  }\n  for (  V u : partitionA) {\n    for (    V v : partitionB) {\n      target.addEdge(u,v);\n    }\n  }\n}\n",
      "docstring": "/** \n * Construct a complete bipartite graph\n */\n",
      "end_lineno": "100",
      "file_content": "/*\n * (C) Copyright 2008-2021, by Andrew Newell and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.generate;\n\nimport org.jgrapht.*;\nimport org.jgrapht.util.*;\n\nimport java.util.*;\n\n/**\n * Generates a <a href=\"http://mathworld.wolfram.com/CompleteBipartiteGraph.html\">complete bipartite\n * graph</a> of any size. This is a graph with two partitions; two vertices will contain an edge if\n * and only if they belong to different partitions.\n *\n * @param <V> the graph vertex type\n * @param <E> the graph edge type\n *\n * @author Andrew Newell\n */\npublic class CompleteBipartiteGraphGenerator<V, E>\n    implements\n    GraphGenerator<V, E, V>\n{\n    private final int sizeA, sizeB;\n    private final Set<V> partitionA, partitionB;\n\n    /**\n     * Creates a new CompleteBipartiteGraphGenerator object.\n     *\n     * @param partitionA number of vertices in the first partition\n     * @param partitionB number of vertices in the second partition\n     */\n    public CompleteBipartiteGraphGenerator(int partitionA, int partitionB)\n    {\n        if (partitionA < 0 || partitionB < 0) {\n            throw new IllegalArgumentException(\"partition sizes must be non-negative\");\n        }\n        this.sizeA = partitionA;\n        this.sizeB = partitionB;\n        this.partitionA = CollectionUtil.newLinkedHashSetWithExpectedSize(sizeA);\n        this.partitionB = CollectionUtil.newLinkedHashSetWithExpectedSize(sizeB);\n    }\n\n    /**\n     * Creates a new CompleteBipartiteGraphGenerator object. A complete bipartite graph is generated\n     * on the vertices provided between the vertices provided in the two partitions. Note that\n     * <i>all</i> vertices in both {@code partitionA} and {@code partitionB} must be present in the\n     * graph or an exception will be thrown during the invocation of\n     * {@link #generateGraph(Graph, Map)}\n     *\n     * @param partitionA first partition\n     * @param partitionB second partition\n     */\n    public CompleteBipartiteGraphGenerator(Set<V> partitionA, Set<V> partitionB)\n    {\n        if (partitionA.isEmpty() || partitionB.isEmpty()) {\n            throw new IllegalArgumentException(\"partitions must be non-empty\");\n        }\n        this.sizeA = 0;\n        this.sizeB = 0;\n        this.partitionA = partitionA;\n        this.partitionB = partitionB;\n    }\n\n    /**\n     * Construct a complete bipartite graph\n     */\n    @Override\n    public void generateGraph(Graph<V, E> target, Map<String, V> resultMap)\n    {\n        // Create vertices in each of the partitions\n        for (int i = 0; i < sizeA; i++) {\n            partitionA.add(target.addVertex());\n        }\n        for (int i = 0; i < sizeB; i++) {\n            partitionB.add(target.addVertex());\n        }\n\n        // Add an edge for each pair of vertices in different partitions\n        for (V u : partitionA) {\n            for (V v : partitionB) {\n                target.addEdge(u, v);\n            }\n        }\n    }\n}\n",
      "file_name": "CompleteBipartiteGraphGenerator.java",
      "human_label": "Construct a complete bipartite graph from partitions A and B.",
      "level": "class_runnable",
      "lineno": "80",
      "name": "generateGraph",
      "oracle_context": "{ \"apis\" : \"[add, addVertex, addEdge]\", \"classes\" : \"[]\", \"vars\" : \"[sizeA, partitionA, sizeB, partitionB]\" }",
      "package": "org.jgrapht.generate",
      "project": "jgrapht-master"
    },
    {
      "_id": "636766ff1a6d9265ec017851",
      "all_context": "{ \"class_level\" : \"import net.hasor.web.upload.util.Streams;\\nimport java.io.*;\\nimport static java.lang.String.format;\\nimport static net.hasor.web.upload.FileUploadException.UploadErrorCodes.*;\\nbyte CR;\\nbyte LF;\\nbyte DASH;\\nint HEADER_PART_SIZE_MAX;\\nint DEFAULT_BUFSIZE;\\nbyte[] HEADER_SEPARATOR;\\nbyte[] FIELD_SEPARATOR;\\nbyte[] STREAM_TERMINATOR;\\nbyte[] BOUNDARY_PREFIX;\\nInputStream input;\\nint boundaryLength;\\nint keepRegion;\\nbyte[] boundary;\\nint bufSize;\\nbyte[] buffer;\\nint head;\\nint tail;\\nString headerEncoding;\\nlong total;\\nint pad;\\nint pos;\\nboolean closed;\\nint BYTE_POSITIVE_OFFSET;\\nMultipartStream(InputStream input,byte[] boundary,int bufSize);\\nMultipartStream(InputStream input,byte[] boundary);\\ngetHeaderEncoding();\\nsetHeaderEncoding(String encoding);\\nreadBoundary();\\nsetBoundary(byte[] boundary);\\nreadHeaders();\\nreadBodyData(OutputStream output);\\nnewInputStream();\\ndiscardBodyData();\\nskipPreamble();\\narrayequals(byte[] a,byte[] b,int count);\\nfindByte(byte value,int pos);\\nfindSeparator();\\nItemInputStream();\\ngetBytesRead();\\navailable();\\nread();\\nread(byte[] b,int off,int len);\\nclose();\\nclose(boolean pCloseUnderlying);\\nskip(long bytes);\\nmakeAvailable();\\nisClosed();\\nreadByte();\\n\", \"repo_level\" : \"public interface Streams {static long copy(InputStream inputStream,OutputStream outputStream,boolean closeOutputStream);\\nstatic long copy(InputStream inputStream,OutputStream outputStream,boolean closeOutputStream,byte[] buffer);\\nstatic String asString(InputStream inputStream);\\nstatic String asString(InputStream inputStream,String encoding);\\nstatic String checkFileName(String fileName);\\n }\\n\" }",
      "class_name": "MultipartStream",
      "code": "protected int findByte(byte value,int pos){\n  for (int i=pos; i < tail; i++) {\n    if (buffer[i] == value) {\n      return i;\n    }\n  }\n  return -1;\n}\n",
      "docstring": "/** \n * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.\n * @param value The value to find.\n * @param pos   The starting position for searching.\n * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.\n */\n",
      "end_lineno": "396",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.web.upload;\nimport net.hasor.web.upload.util.Streams;\n\nimport java.io.*;\n\nimport static java.lang.String.format;\nimport static net.hasor.web.upload.FileUploadException.UploadErrorCodes.*;\n\n/**\n * <p> Low level API for processing file uploads.\n *\n * <p> This class can be used to process data streams conforming to MIME\n * 'multipart' format as defined in\n * <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>. Arbitrarily\n * large amounts of data in the stream can be processed under constant\n * memory usage.\n *\n * <p> The format of the stream is defined in the following way:<br>\n *\n * <code>\n *   multipart-body := preamble 1*encapsulation close-delimiter epilogue<br>\n *   encapsulation := delimiter body CRLF<br>\n *   delimiter := \"--\" boundary CRLF<br>\n *   close-delimiter := \"--\" boundary \"--\"<br>\n *   preamble := &lt;ignore&gt;<br>\n *   epilogue := &lt;ignore&gt;<br>\n *   body := header-part CRLF body-part<br>\n *   header-part := 1*header CRLF<br>\n *   header := header-name \":\" header-value<br>\n *   header-name := &lt;printable ascii characters except \":\"&gt;<br>\n *   header-value := &lt;any ascii characters except CR &amp; LF&gt;<br>\n *   body-data := &lt;arbitrary data&gt;<br>\n * </code>\n *\n * <p>Note that body-data can contain another mulipart entity.  There\n * is limited support for single pass processing of such nested\n * streams.  The nested stream is <strong>required</strong> to have a\n * boundary token of the same length as the parent stream (see {@link\n * #setBoundary(byte[])}).\n *\n * <p>Here is an example of usage of this class.<br>\n *\n * <pre>\n *   try {\n *     MultipartStream multipartStream = new MultipartStream(input, boundary);\n *     boolean nextPart = multipartStream.skipPreamble();\n *     OutputStream output;\n *     while(nextPart) {\n *       String header = multipartStream.readHeaders();\n *       // process headers\n *       // create some output stream\n *       multipartStream.readBodyData(output);\n *       nextPart = multipartStream.readBoundary();\n *     }\n *   } catch(MultipartStream.MalformedStreamException e) {\n *     // the stream failed to follow required syntax\n *   } catch(IOException e) {\n *     // a read or write error occurred\n *   }\n * </pre>\n *\n * @version $Id: MultipartStream.java 1745065 2016-05-22 14:56:37Z britter $\n */\nclass MultipartStream {\n    // ----------------------------------------------------- Manifest constants\n    /** The Carriage Return ASCII character value. */\n    public static final    byte        CR                   = 0x0D;\n    /** The Line Feed ASCII character value. */\n    public static final    byte        LF                   = 0x0A;\n    /** The dash (-) ASCII character value. */\n    public static final    byte        DASH                 = 0x2D;\n    /** The maximum length of <code>header-part</code> that will be processed (10 kilobytes = 10240 bytes.). */\n    public static final    int         HEADER_PART_SIZE_MAX = 10240;\n    /** The default length of the buffer used for processing a request. */\n    protected static final int         DEFAULT_BUFSIZE      = 4096;\n    /** A byte sequence that marks the end of <code>header-part</code> (<code>CRLFCRLF</code>). */\n    protected static final byte[]      HEADER_SEPARATOR     = { CR, LF, CR, LF };\n    /** A byte sequence that that follows a delimiter that will be followed by an encapsulation (<code>CRLF</code>). */\n    protected static final byte[]      FIELD_SEPARATOR      = { CR, LF };\n    /** A byte sequence that that follows a delimiter of the last encapsulation in the stream (<code>--</code>). */\n    protected static final byte[]      STREAM_TERMINATOR    = { DASH, DASH };\n    /** A byte sequence that precedes a boundary (<code>CRLF--</code>). */\n    protected static final byte[]      BOUNDARY_PREFIX      = { CR, LF, DASH, DASH };\n    // ----------------------------------------------------------- Data members\n    /** The input stream from which data is read. */\n    private final          InputStream input;\n    /** The length of the boundary token plus the leading <code>CRLF--</code>. */\n    private                int         boundaryLength;\n    /** The amount of data, in bytes, that must be kept in the buffer in order to detect delimiters reliably. */\n    private                int         keepRegion;\n    /** The byte sequence that partitions the stream. */\n    private                byte[]      boundary;\n    /** The length of the buffer used for processing the request. */\n    private final          int         bufSize;\n    /** The buffer used for processing the request. */\n    private final          byte[]      buffer;\n    /** The index of first valid character in the buffer. <br> 0 <= head < bufSize */\n    private                int         head;\n    /** The index of last valid character in the buffer + 1. <br> 0 <= tail <= bufSize */\n    private                int         tail;\n    /** The content encoding to use when reading headers. */\n    private                String      headerEncoding;\n    // ----------------------------------------------------------- Constructors\n\n    /**\n     * <p> Constructs a <code>MultipartStream</code> with a custom size buffer.\n     *\n     * <p> Note that the buffer must be at least big enough to contain the\n     * boundary string, plus 4 characters for CR/LF and double dash, plus at\n     * least one byte of data.  Too small a buffer size setting will degrade\n     * performance.\n     *\n     * @param input    The <code>InputStream</code> to serve as a data source.\n     * @param boundary The token used for dividing the stream into\n     *                 <code>encapsulations</code>.\n     * @param bufSize  The size of the buffer to be used, in bytes.\n     * @throws IllegalArgumentException If the buffer size is too small\n     * @since 1.3.1\n     */\n    public MultipartStream(InputStream input, byte[] boundary, int bufSize) {\n        if (boundary == null) {\n            throw new IllegalArgumentException(\"boundary may not be null\");\n        }\n        // We prepend CR/LF to the boundary to chop trailing CR/LF from body-data tokens.\n        this.boundaryLength = boundary.length + BOUNDARY_PREFIX.length;\n        if (bufSize < this.boundaryLength + 1) {\n            throw new IllegalArgumentException(\"The buffer size specified for the MultipartStream is too small\");\n        }\n        this.input = input;\n        this.bufSize = Math.max(bufSize, boundaryLength * 2);\n        this.buffer = new byte[this.bufSize];\n        this.boundary = new byte[this.boundaryLength];\n        this.keepRegion = this.boundary.length;\n        System.arraycopy(BOUNDARY_PREFIX, 0, this.boundary, 0, BOUNDARY_PREFIX.length);\n        System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length, boundary.length);\n        head = 0;\n        tail = 0;\n    }\n\n    /**\n     * <p> Constructs a <code>MultipartStream</code> with a default size buffer.\n     * @param input    The <code>InputStream</code> to serve as a data source.\n     * @param boundary The token used for dividing the stream into <code>encapsulations</code>.\n     * @see #MultipartStream(InputStream, byte[], int)\n     */\n    MultipartStream(InputStream input, byte[] boundary) {\n        this(input, boundary, DEFAULT_BUFSIZE);\n    }\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Retrieves the character encoding used when reading the headers of an\n     * individual part. When not specified, or <code>null</code>, the platform default encoding is used.\n     * @return The encoding used to read part headers.\n     */\n    public String getHeaderEncoding() {\n        return headerEncoding;\n    }\n\n    /**\n     * Specifies the character encoding to be used when reading the headers of\n     * individual parts. When not specified, or <code>null</code>, the platform\n     * default encoding is used.\n     * @param encoding The encoding used to read part headers.\n     */\n    public void setHeaderEncoding(String encoding) {\n        headerEncoding = encoding;\n    }\n\n    /**\n     * Reads a byte from the <code>buffer</code>, and refills it as necessary.\n     * @return The next byte from the input stream.\n     * @throws IOException if there is no more data available.\n     */\n    public byte readByte() throws IOException {\n        // Buffer depleted ?\n        if (head == tail) {\n            head = 0;\n            // Refill.\n            tail = input.read(buffer, head, bufSize);\n            if (tail == -1) {\n                // No more data available.\n                throw new IOException(\"No more data is available\");\n            }\n        }\n        return buffer[head++];\n    }\n\n    /**\n     * Skips a <code>boundary</code> token, and checks whether more\n     * <code>encapsulations</code> are contained in the stream.\n     * @return <code>true</code> if there are more encapsulations in this stream; <code>false</code> otherwise.\n     * @throws FileUploadException if the stream ends unexpectedly or fails to follow required syntax.\n     */\n    public boolean readBoundary() throws IOException {\n        byte[] marker = new byte[2];\n        boolean nextChunk = false;\n        head += boundaryLength;\n        marker[0] = readByte();\n        if (marker[0] == LF) {\n            // Work around IE5 Mac bug with input type=image.\n            // Because the boundary delimiter, not including the trailing CRLF, \n            // must not appear within any file (RFC 2046, section 5.1.1),\n            // we know the missing CR is due to a buggy browser rather than a file \n            // containing something similar to a boundary.\n            return true;\n        }\n        marker[1] = readByte();\n        if (arrayequals(marker, STREAM_TERMINATOR, 2)) {\n            nextChunk = false;\n        } else if (arrayequals(marker, FIELD_SEPARATOR, 2)) {\n            nextChunk = true;\n        } else {\n            throw new FileUploadException(MalformedStreamException, \"Unexpected characters follow a boundary\");\n        }\n        return nextChunk;\n    }\n\n    /**\n     * <p>Changes the boundary token used for partitioning the stream.\n     * <p>This method allows single pass processing of nested multipart streams.\n     * <p>The boundary token of the nested stream is <code>required</code> to be of the same length as the boundary token in parent stream.\n     * <p>Restoring the parent stream boundary token after processing of a nested stream is left to the application.\n     * @param boundary The boundary to be used for parsing of the nested stream.\n     * @throws FileUploadException if the <code>boundary</code> has a different length than the one being currently parsed.\n     */\n    public void setBoundary(byte[] boundary) throws FileUploadException {\n        if (boundary.length != boundaryLength - BOUNDARY_PREFIX.length) {\n            throw new FileUploadException(IllegalBoundaryException, \"The length of a boundary token can not be changed\");\n        }\n        System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length, boundary.length);\n    }\n\n    /**\n     * <p>Reads the <code>header-part</code> of the current\n     * <code>encapsulation</code>.\n     * <p>Headers are returned verbatim to the input stream, including the\n     * trailing <code>CRLF</code> marker. Parsing is left to the application.\n     * <p><strong>TODO</strong> allow limiting maximum header size to protect against abuse.\n     *\n     * @return The <code>header-part</code> of the current encapsulation.\n     * @throws FileUploadException if the stream ends unexpectedly.\n     */\n    public String readHeaders() throws IOException {\n        int i = 0;\n        byte b;\n        // to support multi-byte characters\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        int size = 0;\n        while (i < HEADER_SEPARATOR.length) {\n            try {\n                b = readByte();\n            } catch (IOException e) {\n                throw e;\n            }\n            if (++size > HEADER_PART_SIZE_MAX) {\n                String logMEssage = format(\"Header section has more than %s bytes (maybe it is not properly terminated)\", Integer.valueOf(HEADER_PART_SIZE_MAX));\n                throw new FileUploadException(MalformedStreamException, logMEssage);\n            }\n            if (b == HEADER_SEPARATOR[i]) {\n                i++;\n            } else {\n                i = 0;\n            }\n            baos.write(b);\n        }\n        String headers = null;\n        if (headerEncoding != null) {\n            try {\n                headers = baos.toString(headerEncoding);\n            } catch (UnsupportedEncodingException e) {\n                // Fall back to platform default if specified encoding is not supported.\n                headers = baos.toString();\n            }\n        } else {\n            headers = baos.toString();\n        }\n        return headers;\n    }\n\n    /**\n     * <p>Reads <code>body-data</code> from the current <code>encapsulation</code> and writes its contents into the output <code>Stream</code>.\n     * <p>Arbitrary large amounts of data can be processed by this method using a constant size buffer. \n     * @param output The <code>Stream</code> to write data into. May be null, in which case this method is equivalent to {@link #discardBodyData()}.\n     * @return the amount of data written.\n     * @throws FileUploadException if the stream ends unexpectedly.\n     * @throws IOException              if an i/o error occurs.\n     */\n    public int readBodyData(OutputStream output) throws IOException {\n        final InputStream istream = newInputStream();\n        return (int) Streams.copy(istream, output, false);\n    }\n\n    /**\n     * Creates a new {@link ItemInputStream}.\n     * @return A new instance of {@link ItemInputStream}.\n     */\n    ItemInputStream newInputStream() {\n        return new ItemInputStream();\n    }\n\n    /**\n     * <p> Reads <code>body-data</code> from the current\n     * <code>encapsulation</code> and discards it.\n     *\n     * <p>Use this method to skip encapsulations you don't need or don't understand.\n     *\n     * @return The amount of data discarded.\n     * @throws FileUploadException if the stream ends unexpectedly.\n     * @throws IOException         if an i/o error occurs.\n     */\n    public int discardBodyData() throws IOException {\n        return readBodyData(null);\n    }\n\n    /**\n     * Finds the beginning of the first <code>encapsulation</code>.\n     * @return <code>true</code> if an <code>encapsulation</code> was found in the stream.\n     *\n     * @throws IOException if an i/o error occurs.\n     */\n    public boolean skipPreamble() throws IOException {\n        // First delimiter may be not preceeded with a CRLF.\n        System.arraycopy(boundary, 2, boundary, 0, boundary.length - 2);\n        boundaryLength = boundary.length - 2;\n        try {\n            // Discard all data up to the delimiter.\n            discardBodyData();\n            // Read boundary - if succeeded, the stream contains an encapsulation.\n            return readBoundary();\n        } catch (FileUploadException e) {\n            if (e.getErrorCode() == MalformedStreamException) {\n                return false;\n            }\n            throw e;\n        } finally {\n            // Restore delimiter.\n            System.arraycopy(boundary, 0, boundary, 2, boundary.length - 2);\n            boundaryLength = boundary.length;\n            boundary[0] = CR;\n            boundary[1] = LF;\n        }\n    }\n\n    /**\n     * Compares <code>count</code> first bytes in the arrays <code>a</code> and <code>b</code>.\n     * @param a     The first array to compare.\n     * @param b     The second array to compare.\n     * @param count How many bytes should be compared.\n     *\n     * @return <code>true</code> if <code>count</code> first bytes in arrays\n     *         <code>a</code> and <code>b</code> are equal.\n     */\n    public static boolean arrayequals(byte[] a, byte[] b, int count) {\n        for (int i = 0; i < count; i++) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Searches for a byte of specified value in the <code>buffer</code>,\n     * starting at the specified <code>position</code>.\n     *\n     * @param value The value to find.\n     * @param pos   The starting position for searching.\n     *\n     * @return The position of byte found, counting from beginning of the\n     *         <code>buffer</code>, or <code>-1</code> if not found.\n     */\n    protected int findByte(byte value, int pos) {\n        for (int i = pos; i < tail; i++) {\n            if (buffer[i] == value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Searches for the <code>boundary</code> in the <code>buffer</code>\n     * region delimited by <code>head</code> and <code>tail</code>.\n     *\n     * @return The position of the boundary found, counting from the\n     *         beginning of the <code>buffer</code>, or <code>-1</code> if not found.\n     */\n    protected int findSeparator() {\n        int first;\n        int match = 0;\n        int maxpos = tail - boundaryLength;\n        for (first = head; first <= maxpos && match != boundaryLength; first++) {\n            first = findByte(boundary[0], first);\n            if (first == -1 || first > maxpos) {\n                return -1;\n            }\n            for (match = 1; match < boundaryLength; match++) {\n                if (buffer[first + match] != boundary[match]) {\n                    break;\n                }\n            }\n        }\n        if (match == boundaryLength) {\n            return first - 1;\n        }\n        return -1;\n    }\n\n    /** An {@link InputStream} for reading an items contents. */\n    public class ItemInputStream extends InputStream implements net.hasor.web.upload.util.Closeable {\n        /** The number of bytes, which have been read so far. */\n        private long    total;\n        /** The number of bytes, which must be hold, because they might be a part of the boundary. */\n        private int     pad;\n        /** The current offset in the buffer. */\n        private int     pos;\n        /** Whether the stream is already closed. */\n        private boolean closed;\n\n        /** Creates a new instance. */\n        ItemInputStream() {\n            findSeparator();\n        }\n\n        /** Called for finding the separator. */\n        private void findSeparator() {\n            pos = MultipartStream.this.findSeparator();\n            if (pos == -1) {\n                if (tail - head > keepRegion) {\n                    pad = keepRegion;\n                } else {\n                    pad = tail - head;\n                }\n            }\n        }\n\n        /** Returns the number of bytes, which have been read by the stream.\n         * @return Number of bytes, which have been read so far.\n         */\n        public long getBytesRead() {\n            return total;\n        }\n\n        /**\n         * Returns the number of bytes, which are currently available, without blocking.\n         * @return Number of bytes in the buffer.\n         */\n        @Override\n        public int available() {\n            if (pos == -1) {\n                return tail - head - pad;\n            }\n            return pos - head;\n        }\n\n        /** Offset when converting negative bytes to integers. */\n        private static final int BYTE_POSITIVE_OFFSET = 256;\n\n        /**\n         * Returns the next byte in the stream.\n         * @return The next byte in the stream, as a non-negative integer, or -1 for EOF.\n         * @throws IOException An I/O error occurred.\n         */\n        @Override\n        public int read() throws IOException {\n            if (closed) {\n                throw new FileUploadException(ItemSkippedException);\n            }\n            if (available() == 0 && makeAvailable() == 0) {\n                return -1;\n            }\n            ++total;\n            int b = buffer[head++];\n            if (b >= 0) {\n                return b;\n            }\n            return b + BYTE_POSITIVE_OFFSET;\n        }\n\n        /**\n         * Reads bytes into the given buffer.\n         * @param b The destination buffer, where to write to.\n         * @param off Offset of the first byte in the buffer.\n         * @param len Maximum number of bytes to read.\n         * @return Number of bytes, which have been actually read, or -1 for EOF.\n         * @throws IOException An I/O error occurred.\n         */\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (closed) {\n                throw new FileUploadException(ItemSkippedException);\n            }\n            if (len == 0) {\n                return 0;\n            }\n            int res = available();\n            if (res == 0) {\n                res = makeAvailable();\n                if (res == 0) {\n                    return -1;\n                }\n            }\n            res = Math.min(res, len);\n            System.arraycopy(buffer, head, b, off, res);\n            head += res;\n            total += res;\n            return res;\n        }\n\n        /**\n         * Closes the input stream.\n         * @throws IOException An I/O error occurred.\n         */\n        @Override\n        public void close() throws IOException {\n            close(false);\n        }\n\n        /**\n         * Closes the input stream.\n         * @param pCloseUnderlying Whether to close the underlying stream (hard close)\n         * @throws IOException An I/O error occurred.\n         */\n        public void close(boolean pCloseUnderlying) throws IOException {\n            if (closed) {\n                return;\n            }\n            if (pCloseUnderlying) {\n                closed = true;\n                input.close();\n            } else {\n                for (; ; ) {\n                    int av = available();\n                    if (av == 0) {\n                        av = makeAvailable();\n                        if (av == 0) {\n                            break;\n                        }\n                    }\n                    skip(av);\n                }\n            }\n            closed = true;\n        }\n\n        /**\n         * Skips the given number of bytes.\n         * @param bytes Number of bytes to skip.\n         * @return The number of bytes, which have actually been skipped.\n         * @throws IOException An I/O error occurred.\n         */\n        @Override\n        public long skip(long bytes) throws IOException {\n            if (closed) {\n                throw new FileUploadException(ItemSkippedException);\n            }\n            int av = available();\n            if (av == 0) {\n                av = makeAvailable();\n                if (av == 0) {\n                    return 0;\n                }\n            }\n            long res = Math.min(av, bytes);\n            head += res;\n            return res;\n        }\n\n        /**\n         * Attempts to read more data.\n         * @return Number of available bytes\n         * @throws IOException An I/O error occurred.\n         */\n        private int makeAvailable() throws IOException {\n            if (pos != -1) {\n                return 0;\n            }\n            // Move the data to the beginning of the buffer.\n            total += tail - head - pad;\n            System.arraycopy(buffer, tail - pad, buffer, 0, pad);\n            // Refill buffer with new data.\n            head = 0;\n            tail = pad;\n            for (; ; ) {\n                int bytesRead = input.read(buffer, tail, bufSize - tail);\n                if (bytesRead == -1) {\n                    // The last pad amount is left in the buffer. Boundary can't be in there so signal an error condition.\n                    final String msg = \"Stream ended unexpectedly\";\n                    throw new FileUploadException(MalformedStreamException, msg);\n                }\n                tail += bytesRead;\n                findSeparator();\n                int av = available();\n                if (av > 0 || pos != -1) {\n                    return av;\n                }\n            }\n        }\n\n        /**\n         * Returns, whether the stream is closed.\n         * @return True, if the stream is closed, otherwise false.\n         */\n        public boolean isClosed() {\n            return closed;\n        }\n    }\n}",
      "file_name": "MultipartStream.java",
      "human_label": "Searche for a byte of the specified value in the buffer, starting at the specified position.",
      "level": "class_runnable",
      "lineno": "379",
      "name": "findByte",
      "oracle_context": "{ \"apis\" : \"[]\", \"classes\" : \"[]\", \"vars\" : \"[tail, buffer]\" }",
      "package": "net.hasor.web.upload",
      "project": "hasor-master"
    },
    {
      "_id": "636767a41a6d9265ec018582",
      "all_context": "{ \"class_level\" : \"import java.io.DataInput;\\nimport java.io.DataOutput;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.io.OutputStream;\\nimport java.util.ArrayList;\\nimport java.util.List;\\nProtobufIOUtil();\\nnewPipe(byte[] data,int offset,int len);\\nbegin(Pipe.Schema pipeSchema);\\nend(Pipe.Schema pipeSchema,Input input,boolean cleanupOnly);\\nnewPipe(InputStream in);\\nmergeFrom(byte[] data,T message,Schema schema);\\nmergeFrom(byte[] data,int offset,int length,T message,Schema schema);\\nmergeFrom(InputStream in,T message,Schema schema);\\nmergeFrom(InputStream in,T message,Schema schema,LinkedBuffer buffer);\\nmergeDelimitedFrom(InputStream in,T message,Schema schema);\\nmergeDelimitedFrom(InputStream in,T message,Schema schema,LinkedBuffer buffer);\\nmergeDelimitedFrom(DataInput in,T message,Schema schema);\\ntoByteArray(T message,Schema schema,LinkedBuffer buffer);\\nwriteTo(LinkedBuffer buffer,T message,Schema schema);\\nwriteTo(OutputStream out,T message,Schema schema,LinkedBuffer buffer);\\nwriteDelimitedTo(OutputStream out,T message,Schema schema,LinkedBuffer buffer);\\nwriteDelimitedTo(DataOutput out,T message,Schema schema);\\nwriteListTo(OutputStream out,List messages,Schema schema,LinkedBuffer buffer);\\nparseListFrom(InputStream in,Schema schema);\\noptMergeDelimitedFrom(InputStream in,T message,Schema schema,LinkedBuffer buffer);\\noptMergeDelimitedFrom(InputStream in,T message,Schema schema,boolean drainRemainingBytesIfTooLarge,LinkedBuffer buffer);\\noptWriteDelimitedTo(OutputStream out,T message,Schema schema,LinkedBuffer buffer);\\nnewPipe(byte[] data);\\n\", \"repo_level\" : \"\" }",
      "class_name": "ProtobufIOUtil",
      "code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n  if (buffer.start != buffer.offset)   throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\n  final ProtobufOutput output=new ProtobufOutput(buffer);\n  schema.writeTo(output,message);\n  final int size=output.getSize();\n  ProtobufOutput.writeRawVarInt32Bytes(out,size);\n  final int msgSize=LinkedBuffer.writeTo(out,buffer);\n  assert size == msgSize;\n  return size;\n}\n",
      "docstring": "/** \n * Serializes the  {@code message}, prefixed with its length, into an  {@link OutputStream}.\n * @return the size of the message\n */\n",
      "end_lineno": "256",
      "file_content": "//========================================================================\r\n//Copyright 2007-2010 David Yu dyuproject@gmail.com\r\n//------------------------------------------------------------------------\r\n//Licensed under the Apache License, Version 2.0 (the \"License\");\r\n//you may not use this file except in compliance with the License.\r\n//You may obtain a copy of the License at \r\n//http://www.apache.org/licenses/LICENSE-2.0\r\n//Unless required by applicable law or agreed to in writing, software\r\n//distributed under the License is distributed on an \"AS IS\" BASIS,\r\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n//See the License for the specific language governing permissions and\r\n//limitations under the License.\r\n//========================================================================\r\n\r\npackage io.protostuff;\r\n\r\nimport java.io.DataInput;\r\nimport java.io.DataOutput;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * Protobuf ser/deser util for messages/objects.\r\n * \r\n * @author David Yu\r\n * @created Oct 5, 2010\r\n */\r\npublic final class ProtobufIOUtil\r\n{\r\n\r\n    private ProtobufIOUtil()\r\n    {\r\n    }\r\n\r\n    /**\r\n     * Creates a protobuf pipe from a byte array.\r\n     */\r\n    public static Pipe newPipe(byte[] data)\r\n    {\r\n        return newPipe(data, 0, data.length);\r\n    }\r\n\r\n    /**\r\n     * Creates a protobuf pipe from a byte array.\r\n     */\r\n    public static Pipe newPipe(byte[] data, int offset, int len)\r\n    {\r\n        final ByteArrayInput byteArrayInput = new ByteArrayInput(data, offset, len, false);\r\n        return new Pipe()\r\n        {\r\n            @Override\r\n            protected Input begin(Pipe.Schema<?> pipeSchema) throws IOException\r\n            {\r\n                return byteArrayInput;\r\n            }\r\n\r\n            @Override\r\n            protected void end(Pipe.Schema<?> pipeSchema, Input input,\r\n                    boolean cleanupOnly) throws IOException\r\n            {\r\n                if (cleanupOnly)\r\n                    return;\r\n\r\n                assert input == byteArrayInput;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates a protobuf pipe from an {@link InputStream}.\r\n     */\r\n    public static Pipe newPipe(final InputStream in)\r\n    {\r\n        final CodedInput codedInput = new CodedInput(in, false);\r\n        return new Pipe()\r\n        {\r\n            @Override\r\n            protected Input begin(Pipe.Schema<?> pipeSchema) throws IOException\r\n            {\r\n                return codedInput;\r\n            }\r\n\r\n            @Override\r\n            protected void end(Pipe.Schema<?> pipeSchema, Input input,\r\n                    boolean cleanupOnly) throws IOException\r\n            {\r\n                if (cleanupOnly)\r\n                    return;\r\n\r\n                assert input == codedInput;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Merges the {@code message} with the byte array using the given {@code schema}.\r\n     */\r\n    public static <T> void mergeFrom(byte[] data, T message, Schema<T> schema)\r\n    {\r\n        IOUtil.mergeFrom(data, 0, data.length, message, schema, false);\r\n    }\r\n\r\n    /**\r\n     * Merges the {@code message} with the byte array using the given {@code schema}.\r\n     */\r\n    public static <T> void mergeFrom(byte[] data, int offset, int length, T message,\r\n            Schema<T> schema)\r\n    {\r\n        IOUtil.mergeFrom(data, offset, length, message, schema, false);\r\n    }\r\n\r\n    /**\r\n     * Merges the {@code message} from the {@link InputStream} using the given {@code schema}.\r\n     */\r\n    public static <T> void mergeFrom(InputStream in, T message, Schema<T> schema)\r\n            throws IOException\r\n    {\r\n        IOUtil.mergeFrom(in, message, schema, false);\r\n    }\r\n\r\n    /**\r\n     * Merges the {@code message} from the {@link InputStream} using the given {@code schema}.\r\n     * <p>\r\n     * The {@code buffer}'s internal byte array will be used for reading the message.\r\n     */\r\n    public static <T> void mergeFrom(InputStream in, T message, Schema<T> schema,\r\n            LinkedBuffer buffer) throws IOException\r\n    {\r\n        IOUtil.mergeFrom(in, buffer.buffer, message, schema, false);\r\n    }\r\n\r\n    /**\r\n     * Merges the {@code message} (delimited) from the {@link InputStream} using the given {@code schema}.\r\n     * \r\n     * @return the size of the message\r\n     */\r\n    public static <T> int mergeDelimitedFrom(InputStream in, T message, Schema<T> schema)\r\n            throws IOException\r\n    {\r\n        return IOUtil.mergeDelimitedFrom(in, message, schema, false);\r\n    }\r\n\r\n    /**\r\n     * Merges the {@code message} (delimited) from the {@link InputStream} using the given {@code schema}.\r\n     * <p>\r\n     * The delimited message size must not be larger than the {@code buffer}'s size/capacity. {@link ProtobufException}\r\n     * \"size limit exceeded\" is thrown otherwise.\r\n     * \r\n     * @return the size of the message\r\n     */\r\n    public static <T> int mergeDelimitedFrom(InputStream in, T message, Schema<T> schema,\r\n            LinkedBuffer buffer) throws IOException\r\n    {\r\n        return IOUtil.mergeDelimitedFrom(in, buffer.buffer, message, schema, false);\r\n    }\r\n\r\n    /**\r\n     * Used by the code generated messages that implement {@link java.io.Externalizable}. Merges from the\r\n     * {@link DataInput}.\r\n     * \r\n     * @return the size of the message\r\n     */\r\n    public static <T> int mergeDelimitedFrom(DataInput in, T message, Schema<T> schema)\r\n            throws IOException\r\n    {\r\n        return IOUtil.mergeDelimitedFrom(in, message, schema, false);\r\n    }\r\n\r\n    /**\r\n     * Serializes the {@code message} into a byte array using the given schema.\r\n     * \r\n     * @return the byte array containing the data.\r\n     */\r\n    public static <T> byte[] toByteArray(T message, Schema<T> schema, LinkedBuffer buffer)\r\n    {\r\n        if (buffer.start != buffer.offset)\r\n            throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\r\n\r\n        final ProtobufOutput output = new ProtobufOutput(buffer);\r\n        try\r\n        {\r\n            schema.writeTo(output, message);\r\n        }\r\n        catch (IOException e)\r\n        {\r\n            throw new RuntimeException(\"Serializing to a byte array threw an IOException \" +\r\n                    \"(should never happen).\", e);\r\n        }\r\n\r\n        return output.toByteArray();\r\n    }\r\n\r\n    /**\r\n     * Writes the {@code message} into the {@link LinkedBuffer} using the given schema.\r\n     * \r\n     * @return the size of the message\r\n     */\r\n    public static <T> int writeTo(LinkedBuffer buffer, T message, Schema<T> schema)\r\n    {\r\n        if (buffer.start != buffer.offset)\r\n            throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\r\n\r\n        final ProtobufOutput output = new ProtobufOutput(buffer);\r\n        try\r\n        {\r\n            schema.writeTo(output, message);\r\n        }\r\n        catch (IOException e)\r\n        {\r\n            throw new RuntimeException(\"Serializing to a LinkedBuffer threw an IOException \" +\r\n                    \"(should never happen).\", e);\r\n        }\r\n\r\n        return output.getSize();\r\n    }\r\n\r\n    /**\r\n     * Serializes the {@code message} into an {@link OutputStream} using the given schema.\r\n     * \r\n     * @return the size of the message\r\n     */\r\n    public static <T> int writeTo(OutputStream out, T message, Schema<T> schema,\r\n            LinkedBuffer buffer) throws IOException\r\n    {\r\n        if (buffer.start != buffer.offset)\r\n            throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\r\n\r\n        final ProtobufOutput output = new ProtobufOutput(buffer);\r\n        schema.writeTo(output, message);\r\n        return LinkedBuffer.writeTo(out, buffer);\r\n    }\r\n\r\n    /**\r\n     * Serializes the {@code message}, prefixed with its length, into an {@link OutputStream}.\r\n     * \r\n     * @return the size of the message\r\n     */\r\n    public static <T> int writeDelimitedTo(OutputStream out, T message, Schema<T> schema,\r\n            LinkedBuffer buffer) throws IOException\r\n    {\r\n        if (buffer.start != buffer.offset)\r\n            throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\r\n\r\n        final ProtobufOutput output = new ProtobufOutput(buffer);\r\n        schema.writeTo(output, message);\r\n        final int size = output.getSize();\r\n        ProtobufOutput.writeRawVarInt32Bytes(out, size);\r\n        final int msgSize = LinkedBuffer.writeTo(out, buffer);\r\n\r\n        assert size == msgSize;\r\n\r\n        return size;\r\n    }\r\n\r\n    /**\r\n     * Used by the code generated messages that implement {@link java.io.Externalizable}. Writes to the\r\n     * {@link DataOutput} .\r\n     * \r\n     * @return the size of the message.\r\n     */\r\n    public static <T> int writeDelimitedTo(DataOutput out, T message, Schema<T> schema)\r\n            throws IOException\r\n    {\r\n        final LinkedBuffer buffer = new LinkedBuffer(LinkedBuffer.MIN_BUFFER_SIZE);\r\n        final ProtobufOutput output = new ProtobufOutput(buffer);\r\n        schema.writeTo(output, message);\r\n        final int size = output.getSize();\r\n        ProtobufOutput.writeRawVarInt32Bytes(out, size);\r\n\r\n        final int msgSize = LinkedBuffer.writeTo(out, buffer);\r\n\r\n        assert size == msgSize;\r\n\r\n        return size;\r\n    }\r\n\r\n    /**\r\n     * Serializes the {@code messages} (delimited) into an {@link OutputStream} using the given schema.\r\n     * \r\n     * @return the total size of the messages (excluding the length prefix varint)\r\n     */\r\n    public static <T> int writeListTo(OutputStream out, List<T> messages, Schema<T> schema,\r\n            LinkedBuffer buffer) throws IOException\r\n    {\r\n        if (buffer.start != buffer.offset)\r\n            throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\r\n\r\n        final ProtobufOutput output = new ProtobufOutput(buffer);\r\n        int totalSize = 0;\r\n        for (T m : messages)\r\n        {\r\n            schema.writeTo(output, m);\r\n            final int size = output.getSize();\r\n            ProtobufOutput.writeRawVarInt32Bytes(out, size);\r\n            final int msgSize = LinkedBuffer.writeTo(out, buffer);\r\n\r\n            assert size == msgSize;\r\n\r\n            totalSize += size;\r\n            output.clear();\r\n        }\r\n        return totalSize;\r\n    }\r\n\r\n    /**\r\n     * Parses the {@code messages} (delimited) from the {@link InputStream} using the given {@code schema}.\r\n     * \r\n     * @return the list containing the messages.\r\n     */\r\n    public static <T> List<T> parseListFrom(InputStream in, Schema<T> schema) throws IOException\r\n    {\r\n        final ArrayList<T> list = new ArrayList<T>();\r\n        byte[] buf = null;\r\n        int biggestLen = 0;\r\n        LimitedInputStream lin = null;\r\n        for (int size = in.read(); size != -1; size = in.read())\r\n        {\r\n            final T message = schema.newMessage();\r\n            list.add(message);\r\n            final int len = size < 0x80 ? size : CodedInput.readRawVarint32(in, size);\r\n            if (len != 0)\r\n            {\r\n                // not an empty message\r\n                if (len > CodedInput.DEFAULT_BUFFER_SIZE)\r\n                {\r\n                    // message too big\r\n                    if (lin == null)\r\n                        lin = new LimitedInputStream(in);\r\n                    final CodedInput input = new CodedInput(lin.limit(len), false);\r\n                    schema.mergeFrom(input, message);\r\n                    input.checkLastTagWas(0);\r\n                    continue;\r\n                }\r\n\r\n                if (biggestLen < len)\r\n                {\r\n                    // cannot reuse buffer, allocate a bigger buffer\r\n                    // discard the last one for gc\r\n                    buf = new byte[len];\r\n                    biggestLen = len;\r\n                }\r\n                IOUtil.fillBufferFrom(in, buf, 0, len);\r\n                final ByteArrayInput input = new ByteArrayInput(buf, 0, len, false);\r\n                try\r\n                {\r\n                    schema.mergeFrom(input, message);\r\n                }\r\n                catch (ArrayIndexOutOfBoundsException e)\r\n                {\r\n                    throw ProtobufException.truncatedMessage(e);\r\n                }\r\n                input.checkLastTagWas(0);\r\n            }\r\n        }\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * Optimal/Optional mergeDelimitedFrom - If the message does not fit the buffer, no merge is done and this method\r\n     * will return false.\r\n     * <p>\r\n     * This is strictly for reading a single message from the stream because the buffer is aggressively filled when\r\n     * reading the delimited size (which could result into reading more bytes than it has to).\r\n     * <p>\r\n     * The remaining bytes will be drained (consumed and discared) when the message is too large.\r\n     */\r\n    public static <T> boolean optMergeDelimitedFrom(InputStream in,\r\n            T message, Schema<T> schema,\r\n            LinkedBuffer buffer) throws IOException\r\n    {\r\n        return optMergeDelimitedFrom(in, message, schema, true, buffer);\r\n    }\r\n\r\n    /**\r\n     * Optimal/Optional mergeDelimitedFrom - If the message does not fit the buffer, no merge is done and this method\r\n     * will return false.\r\n     * <p>\r\n     * This is strictly for reading a single message from the stream because the buffer is aggressively filled when\r\n     * reading the delimited size (which could result into reading more bytes than it has to).\r\n     */\r\n    public static <T> boolean optMergeDelimitedFrom(InputStream in,\r\n            T message, Schema<T> schema, boolean drainRemainingBytesIfTooLarge,\r\n            LinkedBuffer buffer) throws IOException\r\n    {\r\n        if (buffer.start != buffer.offset)\r\n            throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\r\n\r\n        final int size = IOUtil.fillBufferWithDelimitedMessageFrom(in,\r\n                drainRemainingBytesIfTooLarge, buffer);\r\n\r\n        if (size == 0)\r\n        {\r\n            // empty message\r\n            return true;\r\n        }\r\n\r\n        if (buffer.start == buffer.offset)\r\n        {\r\n            // read offset not set ... message too large\r\n            return false;\r\n        }\r\n\r\n        final ByteArrayInput input = new ByteArrayInput(buffer.buffer,\r\n                buffer.offset, size, false);\r\n        try\r\n        {\r\n            schema.mergeFrom(input, message);\r\n            input.checkLastTagWas(0);\r\n        }\r\n        catch (ArrayIndexOutOfBoundsException e)\r\n        {\r\n            throw ProtobufException.truncatedMessage(e);\r\n        }\r\n        finally\r\n        {\r\n            // reset\r\n            buffer.offset = buffer.start;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Optimal writeDelimitedTo - The varint32 prefix is written to the buffer instead of directly writing to\r\n     * outputstream.\r\n     * \r\n     * @return the size of the message\r\n     */\r\n    public static <T> int optWriteDelimitedTo(OutputStream out, T message,\r\n            Schema<T> schema, LinkedBuffer buffer) throws IOException\r\n    {\r\n        if (buffer.start != buffer.offset)\r\n            throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\r\n\r\n        final ProtobufOutput output = new ProtobufOutput(buffer);\r\n\r\n        // leave space for varint32\r\n        buffer.offset = buffer.start + 5;\r\n        output.size += 5;\r\n\r\n        schema.writeTo(output, message);\r\n\r\n        final int size = output.size - 5;\r\n\r\n        final int delimOffset = IOUtil.putVarInt32AndGetOffset(size, buffer.buffer,\r\n                buffer.start);\r\n\r\n        // write to stream\r\n        out.write(buffer.buffer, delimOffset, buffer.offset - delimOffset);\r\n\r\n        // flush remaining\r\n        if (buffer.next != null)\r\n            LinkedBuffer.writeTo(out, buffer.next);\r\n\r\n        return size;\r\n    }\r\n}\r\n",
      "file_name": "ProtobufIOUtil.java",
      "human_label": "Use ProtobufOutput and the LinkedBuffer to write the message into the given OutputStream out, and return the message size.",
      "level": "project_runnable",
      "lineno": "236",
      "name": "writeDelimitedTo",
      "oracle_context": "{ \"apis\" : \"[writeTo, getSize, writeRawVarInt32Bytes]\", \"classes\" : \"[ProtobufOutput]\", \"vars\" : \"[start, offset]\" }",
      "package": "io.protostuff",
      "project": "protostuff-master"
    },
    {
      "_id": "636767001a6d9265ec01787e",
      "all_context": "{ \"class_level\" : \"import net.hasor.utils.ArrayUtils;\\nimport net.hasor.utils.ClassUtils;\\nimport java.lang.reflect.AccessibleObject;\\nimport java.lang.reflect.Field;\\nimport java.lang.reflect.Modifier;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nboolean appendStatics;\\nboolean appendTransients;\\nString[] excludeFieldNames;\\nClass<?> upToClass;\\ntoString(Object object,ToStringStyle style);\\ntoString(Object object,ToStringStyle style,boolean outputTransients);\\ntoString(Object object,ToStringStyle style,boolean outputTransients,boolean outputStatics);\\ntoString(Object object,ToStringStyle style,boolean outputTransients,boolean outputStatics,Class reflectUpToClass);\\ntoStringExclude(Object object,String excludeFieldName);\\ntoStringExclude(Object object,Collection excludeFieldNames);\\ntoNoNullStringArray(Collection collection);\\ntoNoNullStringArray(Object[] array);\\ntoStringExclude(Object object,String[] excludeFieldNames);\\nReflectionToStringBuilder(Object object);\\nReflectionToStringBuilder(Object object,ToStringStyle style);\\nReflectionToStringBuilder(Object object,ToStringStyle style,StringBuffer buffer);\\nReflectionToStringBuilder(Object object,ToStringStyle style,StringBuffer buffer,Class reflectUpToClass,boolean outputTransients,boolean outputStatics);\\naccept(Field field);\\nappendFieldsIn(Class clazz);\\ngetExcludeFieldNames();\\ngetUpToClass();\\ngetValue(Field field);\\nisAppendStatics();\\nisAppendTransients();\\nreflectionAppendArray(Object array);\\nsetAppendStatics(boolean appendStatics);\\nsetAppendTransients(boolean appendTransients);\\nsetExcludeFieldNames(String[] excludeFieldNamesParam);\\nsetUpToClass(Class clazz);\\ntoString();\\ntoString(Object object);\\n\", \"repo_level\" : \"public interface ArrayUtils {static Map toMap(Object[] array);\\nstatic Object[] clone(Object[] array);\\nstatic long[] clone(long[] array);\\nstatic int[] clone(int[] array);\\nstatic short[] clone(short[] array);\\nstatic char[] clone(char[] array);\\nstatic byte[] clone(byte[] array);\\nstatic double[] clone(double[] array);\\nstatic float[] clone(float[] array);\\nstatic boolean[] clone(boolean[] array);\\nstatic String[] clone(String[] array);\\nstatic Object[] nullToEmpty(Object[] array);\\nstatic String[] nullToEmpty(String[] array);\\nstatic long[] nullToEmpty(long[] array);\\nstatic int[] nullToEmpty(int[] array);\\nstatic short[] nullToEmpty(short[] array);\\nstatic char[] nullToEmpty(char[] array);\\nstatic byte[] nullToEmpty(byte[] array);\\nstatic double[] nullToEmpty(double[] array);\\nstatic float[] nullToEmpty(float[] array);\\nstatic boolean[] nullToEmpty(boolean[] array);\\nstatic Long[] nullToEmpty(Long[] array);\\nstatic Integer[] nullToEmpty(Integer[] array);\\nstatic Short[] nullToEmpty(Short[] array);\\nstatic Character[] nullToEmpty(Character[] array);\\nstatic Byte[] nullToEmpty(Byte[] array);\\nstatic Double[] nullToEmpty(Double[] array);\\nstatic Float[] nullToEmpty(Float[] array);\\nstatic Boolean[] nullToEmpty(Boolean[] array);\\nstatic Object[] subarray(Object[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic long[] subarray(long[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic int[] subarray(int[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic short[] subarray(short[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic char[] subarray(char[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic byte[] subarray(byte[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic double[] subarray(double[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic float[] subarray(float[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic boolean[] subarray(boolean[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic boolean isSameLength(Object[] array1,Object[] array2);\\nstatic boolean isSameLength(long[] array1,long[] array2);\\nstatic boolean isSameLength(int[] array1,int[] array2);\\nstatic boolean isSameLength(short[] array1,short[] array2);\\nstatic boolean isSameLength(char[] array1,char[] array2);\\nstatic boolean isSameLength(byte[] array1,byte[] array2);\\nstatic boolean isSameLength(double[] array1,double[] array2);\\nstatic boolean isSameLength(float[] array1,float[] array2);\\nstatic boolean isSameLength(boolean[] array1,boolean[] array2);\\nstatic int getLength(Object array);\\nstatic boolean isSameType(Object array1,Object array2);\\nstatic void reverse(Object[] array);\\nstatic void reverse(long[] array);\\nstatic void reverse(int[] array);\\nstatic void reverse(short[] array);\\nstatic void reverse(char[] array);\\nstatic void reverse(byte[] array);\\nstatic void reverse(double[] array);\\nstatic void reverse(float[] array);\\nstatic void reverse(boolean[] array);\\nstatic int indexOf(Object[] array,Object objectToFind);\\nstatic int indexOf(Object[] array,Object objectToFind,int startIndex);\\nstatic int lastIndexOf(Object[] array,Object objectToFind);\\nstatic int lastIndexOf(Object[] array,Object objectToFind,int startIndex);\\nstatic boolean contains(Object[] array,Object objectToFind);\\nstatic int indexOf(long[] array,long valueToFind);\\nstatic int indexOf(long[] array,long valueToFind,int startIndex);\\nstatic int lastIndexOf(long[] array,long valueToFind);\\nstatic int lastIndexOf(long[] array,long valueToFind,int startIndex);\\nstatic boolean contains(long[] array,long valueToFind);\\nstatic int indexOf(int[] array,int valueToFind);\\nstatic int indexOf(int[] array,int valueToFind,int startIndex);\\nstatic int lastIndexOf(int[] array,int valueToFind);\\nstatic int lastIndexOf(int[] array,int valueToFind,int startIndex);\\nstatic boolean contains(int[] array,int valueToFind);\\nstatic int indexOf(short[] array,short valueToFind);\\nstatic int indexOf(short[] array,short valueToFind,int startIndex);\\nstatic int lastIndexOf(short[] array,short valueToFind);\\nstatic int lastIndexOf(short[] array,short valueToFind,int startIndex);\\nstatic boolean contains(short[] array,short valueToFind);\\nstatic int indexOf(char[] array,char valueToFind);\\nstatic int indexOf(char[] array,char valueToFind,int startIndex);\\nstatic int lastIndexOf(char[] array,char valueToFind);\\nstatic int lastIndexOf(char[] array,char valueToFind,int startIndex);\\nstatic boolean contains(char[] array,char valueToFind);\\nstatic int indexOf(byte[] array,byte valueToFind);\\nstatic int indexOf(byte[] array,byte valueToFind,int startIndex);\\nstatic int lastIndexOf(byte[] array,byte valueToFind);\\nstatic int lastIndexOf(byte[] array,byte valueToFind,int startIndex);\\nstatic boolean contains(byte[] array,byte valueToFind);\\nstatic int indexOf(double[] array,double valueToFind);\\nstatic int indexOf(double[] array,double valueToFind,double tolerance);\\nstatic int indexOf(double[] array,double valueToFind,int startIndex);\\nstatic int indexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\nstatic int lastIndexOf(double[] array,double valueToFind);\\nstatic int lastIndexOf(double[] array,double valueToFind,double tolerance);\\nstatic int lastIndexOf(double[] array,double valueToFind,int startIndex);\\nstatic int lastIndexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\nstatic boolean contains(double[] array,double valueToFind);\\nstatic boolean contains(double[] array,double valueToFind,double tolerance);\\nstatic int indexOf(float[] array,float valueToFind);\\nstatic int indexOf(float[] array,float valueToFind,int startIndex);\\nstatic int lastIndexOf(float[] array,float valueToFind);\\nstatic int lastIndexOf(float[] array,float valueToFind,int startIndex);\\nstatic boolean contains(float[] array,float valueToFind);\\nstatic int indexOf(boolean[] array,boolean valueToFind);\\nstatic int indexOf(boolean[] array,boolean valueToFind,int startIndex);\\nstatic int lastIndexOf(boolean[] array,boolean valueToFind);\\nstatic int lastIndexOf(boolean[] array,boolean valueToFind,int startIndex);\\nstatic boolean contains(boolean[] array,boolean valueToFind);\\nstatic char[] toPrimitive(Character[] array);\\nstatic char[] toPrimitive(Character[] array,char valueForNull);\\nstatic Character[] toObject(char[] array);\\nstatic long[] toPrimitive(Long[] array);\\nstatic long[] toPrimitive(Long[] array,long valueForNull);\\nstatic Long[] toObject(long[] array);\\nstatic int[] toPrimitive(Integer[] array);\\nstatic int[] toPrimitive(Integer[] array,int valueForNull);\\nstatic Integer[] toObject(int[] array);\\nstatic short[] toPrimitive(Short[] array);\\nstatic short[] toPrimitive(Short[] array,short valueForNull);\\nstatic Short[] toObject(short[] array);\\nstatic byte[] toPrimitive(Byte[] array);\\nstatic byte[] toPrimitive(Byte[] array,byte valueForNull);\\nstatic Byte[] toObject(byte[] array);\\nstatic double[] toPrimitive(Double[] array);\\nstatic double[] toPrimitive(Double[] array,double valueForNull);\\nstatic Double[] toObject(double[] array);\\nstatic float[] toPrimitive(Float[] array);\\nstatic float[] toPrimitive(Float[] array,float valueForNull);\\nstatic Float[] toObject(float[] array);\\nstatic boolean[] toPrimitive(Boolean[] array);\\nstatic boolean[] toPrimitive(Boolean[] array,boolean valueForNull);\\nstatic Boolean[] toObject(boolean[] array);\\nstatic boolean isEmpty(Object[] array);\\nstatic boolean isEmpty(long[] array);\\nstatic boolean isEmpty(int[] array);\\nstatic boolean isEmpty(short[] array);\\nstatic boolean isEmpty(char[] array);\\nstatic boolean isEmpty(byte[] array);\\nstatic boolean isEmpty(double[] array);\\nstatic boolean isEmpty(float[] array);\\nstatic boolean isEmpty(boolean[] array);\\nstatic boolean isNotEmpty(Object[] array);\\nstatic boolean isNotEmpty(long[] array);\\nstatic boolean isNotEmpty(int[] array);\\nstatic boolean isNotEmpty(short[] array);\\nstatic boolean isNotEmpty(char[] array);\\nstatic boolean isNotEmpty(byte[] array);\\nstatic boolean isNotEmpty(double[] array);\\nstatic boolean isNotEmpty(float[] array);\\nstatic boolean isNotEmpty(boolean[] array);\\nstatic Object[] addAll(Object[] array1,Object[] array2);\\nstatic boolean[] addAll(boolean[] array1,boolean[] array2);\\nstatic char[] addAll(char[] array1,char[] array2);\\nstatic byte[] addAll(byte[] array1,byte[] array2);\\nstatic short[] addAll(short[] array1,short[] array2);\\nstatic int[] addAll(int[] array1,int[] array2);\\nstatic long[] addAll(long[] array1,long[] array2);\\nstatic float[] addAll(float[] array1,float[] array2);\\nstatic double[] addAll(double[] array1,double[] array2);\\nstatic String[] addAll(String[] array1,String[] array2);\\nstatic T[] add(T[] array,T element);\\nstatic boolean[] add(boolean[] array,boolean element);\\nstatic byte[] add(byte[] array,byte element);\\nstatic char[] add(char[] array,char element);\\nstatic double[] add(double[] array,double element);\\nstatic float[] add(float[] array,float element);\\nstatic int[] add(int[] array,int element);\\nstatic long[] add(long[] array,long element);\\nstatic short[] add(short[] array,short element);\\nstatic Object[] add(Object[] array,int index,Object element);\\nstatic boolean[] add(boolean[] array,int index,boolean element);\\nstatic char[] add(char[] array,int index,char element);\\nstatic byte[] add(byte[] array,int index,byte element);\\nstatic short[] add(short[] array,int index,short element);\\nstatic int[] add(int[] array,int index,int element);\\nstatic long[] add(long[] array,int index,long element);\\nstatic float[] add(float[] array,int index,float element);\\nstatic double[] add(double[] array,int index,double element);\\nstatic Object[] remove(Object[] array,int index);\\nstatic Object[] removeElement(Object[] array,Object element);\\nstatic boolean[] remove(boolean[] array,int index);\\nstatic boolean[] removeElement(boolean[] array,boolean element);\\nstatic byte[] remove(byte[] array,int index);\\nstatic byte[] removeElement(byte[] array,byte element);\\nstatic char[] remove(char[] array,int index);\\nstatic char[] removeElement(char[] array,char element);\\nstatic double[] remove(double[] array,int index);\\nstatic double[] removeElement(double[] array,double element);\\nstatic float[] remove(float[] array,int index);\\nstatic float[] removeElement(float[] array,float element);\\nstatic int[] remove(int[] array,int index);\\nstatic int[] removeElement(int[] array,int element);\\nstatic long[] remove(long[] array,int index);\\nstatic long[] removeElement(long[] array,long element);\\nstatic short[] remove(short[] array,int index);\\nstatic short[] removeElement(short[] array,short element);\\nstatic Object[] clearNull(Object[] arr);\\n }\\npublic interface ClassUtils {static String getShortClassName(Object object,String valueIfNull);\\nstatic String getShortClassName(Class cls);\\nstatic String getShortClassName(String className);\\nstatic String getPackageName(Object object,String valueIfNull);\\nstatic String getPackageName(Class cls);\\nstatic String getPackageName(String className);\\nstatic List<Class<?>> getAllSuperclasses(Class cls);\\nstatic List<Class<?>> getAllInterfaces(Class cls);\\nstatic List<Class<?>> convertClassNamesToClasses(List classNames);\\nstatic List<String> convertClassesToClassNames(List classes);\\nstatic boolean isAssignable(Class<?>[] classArray,Class<?>[] toClassArray);\\nstatic boolean isAssignable(Class<?>[] classArray,Class<?>[] toClassArray,boolean autoboxing);\\nstatic boolean isAssignable(Class cls,Class toClass);\\nstatic boolean isAssignable(Class cls,Class toClass,boolean autoboxing);\\nstatic Class<?> primitiveToWrapper(Class cls);\\nstatic Class<?>[] primitivesToWrappers(Class<?>[] classes);\\nstatic Class<?> wrapperToPrimitive(Class cls);\\nstatic Class<?>[] wrappersToPrimitives(Class<?>[] classes);\\nstatic boolean isInnerClass(Class cls);\\nstatic Class<?> getClass(ClassLoader classLoader,String className,boolean initialize);\\nstatic Class<?> getClass(ClassLoader classLoader,String className);\\nstatic Class<?> getClass(String className);\\nstatic Class<?> getClass(String className,boolean initialize);\\nstatic Method getPublicMethod(Class cls,String methodName,Class parameterTypes);\\nstatic Class<?>[] toClass(Object[] array);\\nstatic String getShortCanonicalName(Object object,String valueIfNull);\\nstatic String getShortCanonicalName(Class cls);\\nstatic String getShortCanonicalName(String canonicalName);\\nstatic String getPackageCanonicalName(Object object,String valueIfNull);\\nstatic String getPackageCanonicalName(Class cls);\\nstatic String getPackageCanonicalName(String canonicalName);\\nstatic ClassLoader getClassLoader(ClassLoader classLoader);\\nstatic boolean isLangClass(Class target);\\nstatic String getDescName(Class type);\\nstatic String getDescNameWithOutModifiers(Method method);\\nstatic String getDescName(Method method);\\nstatic Class<?> getSuperClassGenricType(Class clazz,int index);\\nstatic T newInstance(Class clazz);\\n }\\n\" }",
      "class_name": "ReflectionToStringBuilder",
      "code": "public String toString(){\n  if (this.getObject() == null) {\n    return this.getStyle().getNullText();\n  }\n  Class<?> clazz=this.getObject().getClass();\n  this.appendFieldsIn(clazz);\n  while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n    clazz=clazz.getSuperclass();\n    this.appendFieldsIn(clazz);\n  }\n  return super.toString();\n}\n",
      "docstring": "/** \n * <p> Gets the String built by this builder. </p>\n * @return the built string\n */\n",
      "end_lineno": "684",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.builder;\nimport net.hasor.utils.ArrayUtils;\nimport net.hasor.utils.ClassUtils;\n\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\n/**\n * <p>\n * Assists in implementing {@link Object#toString()} methods using reflection.\n * </p>\n *\n * <p>\n * This class uses reflection to determine the fields to append. Because these fields are usually private, the class\n * uses {@link java.lang.reflect.AccessibleObject#setAccessible(java.lang.reflect.AccessibleObject[], boolean)} to\n * change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions are\n * set up correctly.\n * </p>\n *\n * <p>\n * A typical invocation for this method would look like:\n * </p>\n *\n * <pre>\n * public String toString() {\n *   return ReflectionToStringBuilder.toString(this);\n * }</pre>\n *\n *\n *\n * <p>\n * You can also use the builder to debug 3rd party objects:\n * </p>\n *\n * <pre>\n * System.out.println(\"An object: \" + ReflectionToStringBuilder.toString(anObject));</pre>\n *\n *\n *\n * <p>\n * A subclass can control field output by overriding the methods:\n * <ul>\n * <li>{@link #accept(java.lang.reflect.Field)}</li>\n * <li>{@link #getValue(java.lang.reflect.Field)}</li>\n * </ul>\n * </p>\n * <p>\n * For example, this method does <i>not</i> include the <code>password</code> field in the returned\n * <code>String</code>:\n * </p>\n *\n * <pre>\n * public String toString() {\n *     return (new ReflectionToStringBuilder(this) {\n *         protected boolean accept(Field f) {\n *             return super.accept(f) && !f.getName().equals(\"password\");\n *         }\n *     }).toString();\n * }</pre>\n *\n *\n *\n * <p>\n * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the\n * constructor.\n * </p>\n *\n * @author Apache Software Foundation\n * @author Gary Gregory\n * @author Pete Gieser\n * @since 2.0\n * @version $Id: ReflectionToStringBuilder.java 905636 2010-02-02 14:03:32Z niallp $\n */\npublic class ReflectionToStringBuilder extends ToStringBuilder {\n    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }\n\n    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object or <code>ToStringStyle</code> is <code>null</code>\n     */\n    public static String toString(Object object, ToStringStyle style) {\n        return toString(object, style, false, false, null);\n    }\n\n    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     *\n     * <p>\n     * Static fields will not be included. Superclass fields will be appended.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\n        return toString(object, style, outputTransients, false, null);\n    }\n\n    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     *\n     * <p>\n     * Static fields will not be included. Superclass fields will be appended.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include transient fields\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\n        return toString(object, style, outputTransients, outputStatics, null);\n    }\n\n    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     *\n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics, Class<?> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics).toString();\n    }\n\n    /**\n     * Builds a String for a toString method excluding the given field name.\n     *\n     * @param object\n     *            The object to \"toString\".\n     * @param excludeFieldName\n     *            The field name to exclude\n     * @return The toString value.\n     */\n    public static String toStringExclude(Object object, final String excludeFieldName) {\n        return toStringExclude(object, new String[] { excludeFieldName });\n    }\n\n    /**\n     * Builds a String for a toString method excluding the given field names.\n     *\n     * @param object\n     *            The object to \"toString\".\n     * @param excludeFieldNames\n     *            The field names to exclude. Null excludes nothing.\n     * @return The toString value.\n     */\n    public static String toStringExclude(Object object, Collection<?> /*String*/ excludeFieldNames) {\n        return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\n    }\n\n    /**\n     * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code>\n     * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element \n     * is <code>null</code>.\n     *\n     * @param collection\n     *            The collection to convert\n     * @return A new array of Strings.\n     */\n    static String[] toNoNullStringArray(Collection<?> collection) {\n        if (collection == null) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        return toNoNullStringArray(collection.toArray());\n    }\n\n    /**\n     * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists\n     * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}\n     * if an array element is <code>null</code>.\n     *\n     * @param array\n     *            The array to check\n     * @return The given array or a new array without null.\n     */\n    static String[] toNoNullStringArray(Object[] array) {\n        ArrayList<String> list = new ArrayList<String>(array.length);\n        for (int i = 0; i < array.length; i++) {\n            Object e = array[i];\n            if (e != null) {\n                list.add(e.toString());\n            }\n        }\n        return (String[]) list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Builds a String for a toString method excluding the given field names.\n     *\n     * @param object\n     *            The object to \"toString\".\n     * @param excludeFieldNames\n     *            The field names to exclude\n     * @return The toString value.\n     */\n    public static String toStringExclude(Object object, String[] excludeFieldNames) {\n        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\n    }\n\n    /**\n     * Whether or not to append static fields.\n     */\n    private boolean  appendStatics    = false;\n    /**\n     * Whether or not to append transient fields.\n     */\n    private boolean  appendTransients = false;\n    /**\n     * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\n     */\n    private String[] excludeFieldNames;\n    /**\n     * The last super class to stop appending fields for.\n     */\n    private Class<?> upToClass        = null;\n\n    /**\n     * <p>\n     * Constructor.\n     * </p>\n     *\n     * <p>\n     * This constructor outputs using the default style set with <code>setDefaultStyle</code>.\n     * </p>\n     *\n     * @param object\n     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the Object passed in is <code>null</code>\n     */\n    public ReflectionToStringBuilder(Object object) {\n        super(object);\n    }\n\n    /**\n     * <p>\n     * Constructor.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default style is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the Object passed in is <code>null</code>\n     */\n    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\n        super(object, style);\n    }\n\n    /**\n     * <p>\n     * Constructor.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default style is used.\n     * </p>\n     *\n     * <p>\n     * If the buffer is <code>null</code>, a new one is created.\n     * </p>\n     *\n     * @param object\n     *            the Object to build a <code>toString</code> for\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param buffer\n     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the Object passed in is <code>null</code>\n     */\n    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n        super(object, style, buffer);\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param object\n     *            the Object to build a <code>toString</code> for\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param buffer\n     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @since 2.1\n     */\n    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer, Class<?> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\n        super(object, style, buffer);\n        this.setUpToClass(reflectUpToClass);\n        this.setAppendTransients(outputTransients);\n        this.setAppendStatics(outputStatics);\n    }\n\n    /**\n     * Returns whether or not to append the given <code>Field</code>.\n     * <ul>\n     * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\n     * <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\n     * <li>Inner class fields are not appened.</li>\n     * </ul>\n     *\n     * @param field The Field to test.\n     * @return Whether or not to append the given <code>Field</code>.\n     */\n    protected boolean accept(Field field) {\n        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n            // Reject field from inner class.\n            return false;\n        }\n        if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n            // Reject transient fields.\n            return false;\n        }\n        if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n            // Reject static fields.\n            return false;\n        }\n        if (this.getExcludeFieldNames() != null && Arrays.binarySearch(this.getExcludeFieldNames(), field.getName()) >= 0) {\n            // Reject fields from the getExcludeFieldNames list.\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     *\n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     *\n     * @param clazz The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length; i++) {\n            Field field = fields[i];\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }\n\n    /**\n     * @return Returns the excludeFieldNames.\n     */\n    public String[] getExcludeFieldNames() {\n        return this.excludeFieldNames;\n    }\n\n    /**\n     * <p>\n     * Gets the last super class to stop appending fields for.\n     * </p>\n     *\n     * @return The last super class to stop appending fields for.\n     */\n    public Class<?> getUpToClass() {\n        return this.upToClass;\n    }\n\n    /**\n     * <p>\n     * Calls <code>java.lang.reflect.Field.get(Object)</code>.\n     * </p>\n     *\n     * @param field The Field to query.\n     * @return The Object from the given Field.\n     *\n     * @throws IllegalArgumentException see {@link java.lang.reflect.Field#get(Object)}\n     * @throws IllegalAccessException see {@link java.lang.reflect.Field#get(Object)}\n     * @see java.lang.reflect.Field#get(Object)\n     */\n    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\n        return field.get(this.getObject());\n    }\n\n    /**\n     * <p>\n     * Gets whether or not to append static fields.\n     * </p>\n     *\n     * @return Whether or not to append static fields.\n     * @since 2.1\n     */\n    public boolean isAppendStatics() {\n        return this.appendStatics;\n    }\n\n    /**\n     * <p>\n     * Gets whether or not to append transient fields.\n     * </p>\n     *\n     * @return Whether or not to append transient fields.\n     */\n    public boolean isAppendTransients() {\n        return this.appendTransients;\n    }\n\n    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     *\n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }\n\n    /**\n     * <p>\n     * Sets whether or not to append static fields.\n     * </p>\n     *\n     * @param appendStatics\n     *            Whether or not to append static fields.\n     * @since 2.1\n     */\n    public void setAppendStatics(boolean appendStatics) {\n        this.appendStatics = appendStatics;\n    }\n\n    /**\n     * <p>\n     * Sets whether or not to append transient fields.\n     * </p>\n     *\n     * @param appendTransients Whether or not to append transient fields.\n     */\n    public void setAppendTransients(boolean appendTransients) {\n        this.appendTransients = appendTransients;\n    }\n\n    /**\n     * Sets the field names to exclude.\n     *\n     * @param excludeFieldNamesParam\n     *            The excludeFieldNames to excluding from toString or <code>null</code>.\n     * @return <code>this</code>\n     */\n    public ReflectionToStringBuilder setExcludeFieldNames(String[] excludeFieldNamesParam) {\n        if (excludeFieldNamesParam == null) {\n            this.excludeFieldNames = null;\n        } else {\n            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\n            Arrays.sort(this.excludeFieldNames);\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Sets the last super class to stop appending fields for.\n     * </p>\n     *\n     * @param clazz\n     *            The last super class to stop appending fields for.\n     */\n    public void setUpToClass(Class<?> clazz) {\n        if (clazz != null) {\n            Object object = getObject();\n            if (object != null && clazz.isInstance(object) == false) {\n                throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n            }\n        }\n        this.upToClass = clazz;\n    }\n\n    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     *\n     * @return the built string\n     */\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }\n}\n",
      "file_name": "ReflectionToStringBuilder.java",
      "human_label": "Return the string built by this string builder.",
      "level": "project_runnable",
      "lineno": "666",
      "name": "toString",
      "oracle_context": "{ \"apis\" : \"[getObject, getNullText, getStyle, getClass, appendFieldsIn, getSuperclass, getUpToClass]\", \"classes\" : \"[Class<?>]\", \"vars\" : \"[]\" }",
      "package": "net.hasor.utils.builder",
      "project": "hasor-master"
    },
    {
      "_id": "636767781a6d9265ec01823d",
      "all_context": "{ \"class_level\" : \"import java.io.File;\\nimport java.io.Writer;\\nimport java.io.FileWriter;\\nimport java.io.BufferedWriter;\\nimport org.apache.log4j.spi.LoggingEvent;\\nimport org.apache.log4j.helpers.OptionConverter;\\nimport org.apache.log4j.spi.ErrorHandler;\\nString PATH_OPTION;\\nString path;\\nString PREFIX_OPTION;\\nString prefix;\\nString SUFFIX_OPTION;\\nString suffix;\\nFile dir;\\nTempFileAppender();\\ngetOptionStrings();\\nsetOption(String key,String value);\\ncheckEntryConditions();\\nsubAppend(LoggingEvent event);\\nrequiresLayout();\\nclose();\\nappend(LoggingEvent event);\\n\", \"repo_level\" : \"public interface LoggingEvent {public LocationInfo getLocationInformation();\\npublic Level getLevel();\\npublic String getLoggerName();\\npublic Category getLogger();\\npublic Object getMessage();\\npublic String getNDC();\\npublic Object getMDC(String key);\\npublic void getMDCCopy();\\npublic String getRenderedMessage();\\nstatic long getStartTime();\\npublic String getThreadName();\\npublic ThrowableInformation getThrowableInformation();\\npublic String[] getThrowableStrRep();\\nfinal void setProperty(String propName,String propValue);\\nfinal String getProperty(String key);\\nfinal boolean locationInformationExists();\\nfinal long getTimeStamp();\\npublic Set getPropertyKeySet();\\npublic Map getProperties();\\npublic String getFQNOfLoggerClass();\\npublic Object removeProperty(String propName);\\n }\\npublic interface OptionConverter {static String[] concatanateArrays(String[] l,String[] r);\\nstatic String convertSpecialChars(String s);\\nstatic String getSystemProperty(String key,String def);\\nstatic Object instantiateByKey(Properties props,String key,Class superClass,Object defaultValue);\\nstatic boolean toBoolean(String value,boolean dEfault);\\nstatic int toInt(String value,int dEfault);\\nstatic Level toLevel(String value,Level defaultValue);\\nstatic long toFileSize(String value,long dEfault);\\nstatic String findAndSubst(String key,Properties props);\\nstatic Object instantiateByClassName(String className,Class superClass,Object defaultValue);\\nstatic String substVars(String val,Properties props);\\npublic void selectAndConfigure(InputStream inputStream,String clazz,LoggerRepository hierarchy);\\npublic void selectAndConfigure(URL url,String clazz,LoggerRepository hierarchy);\\n }\\npublic interface ErrorHandler { void setLogger(Logger logger);\\n void error(String message,Exception e,int errorCode);\\n void error(String message);\\n void error(String message,Exception e,int errorCode,LoggingEvent event);\\n void setAppender(Appender appender);\\n void setBackupAppender(Appender appender);\\n }\\n\" }",
      "class_name": "TempFileAppender",
      "code": "protected void subAppend(LoggingEvent event){\n  try {\n    File tmp=File.createTempFile(prefix,suffix,dir);\n    Writer out=new BufferedWriter(new FileWriter(tmp));\n    out.write(event.message);\n    out.close();\n  }\n catch (  Exception e) {\n    errorHandler.error(\"Error during creation of temporary File!\",e,1);\n  }\n}\n",
      "docstring": "/** \n * This method does actual writing\n */\n",
      "end_lineno": "175",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n package org.apache.log4j;\n \nimport java.io.File;\nimport java.io.Writer;\nimport java.io.FileWriter;\nimport java.io.BufferedWriter;\nimport org.apache.log4j.spi.LoggingEvent;\nimport org.apache.log4j.helpers.OptionConverter;\nimport org.apache.log4j.spi.ErrorHandler;\n\n/**\n   TempFileAppender creates new unique file for each logging statement.\n \n   @author <a HREF=\"mailto:leos.literak@12snap.com\">Leos Literak</a>\n   @author Ceki G&uuml;lc&uuml;\n \n*/\npublic class TempFileAppender extends AppenderSkeleton {\n \n  /**\n     A string constant used in naming the option for setting the\n     directory where the log files will be created. Current value \n     of this string constant is <b>Path</b>. java.io.tmpdir directory\n     will be used, if ommited.\n   */\n  static final public String PATH_OPTION = \"Path\";\n  \n  /**\n     The default path is actual directory.\n  */\n  protected String path = null;\n \n  /**\n     A string constant used in naming the option for setting the\n     prefix of the log files. It has to have at least 3 characters!\n     Current value of this string constant is <b>Prefix</b>.\n   */\n  static final public String PREFIX_OPTION = \"Prefix\";\n  \n  /**\n     The default path is actual directory.\n  */\n  protected String prefix = \"l4j_\";\n \n  /**\n     A string constant used in naming the option for setting the\n     suffix of the log files. Current value of this string constant \n     is <b>Suffix</b>.\n   */\n  static final public String SUFFIX_OPTION = \"Suffix\";\n  \n  /**\n     The default path is actual directory.\n  */\n  protected String suffix = \".tmp\";\n  \n  /**\n     Default dir\n  */\n  \n  protected File dir = null;\n\n\n\n\n  /**\n     The default constructor simply calls its parent's constructor. \n  */\n  public TempFileAppender() {\n      super();\n  }\n \n  /**\n     Retuns the option names for this component\n  */\n  public String[] getOptionStrings() {\n      return OptionConverter.concatanateArrays(super.getOptionStrings(),\n                 new String[] {PATH_OPTION,PREFIX_OPTION,SUFFIX_OPTION});\n  }  \n\n  /**\n     Set TempFileAppender specific options.\n \n     The recognized options are <b>Path</b>, <b>Prefix</b> and <b>Suffix</b>,\n     i.e. the values of the string constants {@link #PATH_OPTION}, \n     {@link #PREFIX_OPTION} and respectively {@link #SUFFIX_OPTION}. \n     The options of the super class {@link AppenderSkeleton} are also \n     recognized.\n  */\n  \n  public void setOption(String key, String value) {\n      super.setOption(key, value);\n      if(key.equalsIgnoreCase(PATH_OPTION)) {\n\t  path = value;\n\t  if(path==null) {\n              errorHandler.error(\"Path cannot be empty!\",null,0);\n\t  }\n\n\t  dir = new File(path);\n\t  if(!(dir.exists() && dir.isDirectory() && dir.canWrite())) {\n              errorHandler.error(\"Cannot write to directory \" + path + \"!\",null,0);\n\t  }\n      }\n      else if(key.equalsIgnoreCase(PREFIX_OPTION)) {\n          if(value!=null && value.length()>=3) {\n\t      prefix = value;\n\t  } else {\n              errorHandler.error(\"Prefix cannot be shorter than 3 characters!\",\n\t                         null,0);\n\t  }\n      }\n      else if(key.equalsIgnoreCase(SUFFIX_OPTION)) {\n          if(value!=null && value.length()>=1) {\n\t      suffix = value;\n\t  } else {\n              errorHandler.error(\"Suffix cannot be empty!\",null,0);\n\t  }\n      }\n  }\n\n  /**\n     This method is called by {@link AppenderSkeleton#doAppend}\n     method.\n \n     <p>Whenever this method is called, new unique file is created\n     with specified prefix and suffix. The file is closed afterwards.\n \n     <p>The format of the output will depend on this appender's\n     layout.\n \n  */ \n  public void append(LoggingEvent event) { \n      if(!checkEntryConditions()) {\n          return;\n      }\n      subAppend(event);\n  }\n \n  /**\n     This method determines if there is a sense in attempting to append.\n  */\n  protected boolean checkEntryConditions() {\n      return true;\n  }   \n\n  /**\n     This method does actual writing\n  */\n  protected void subAppend(LoggingEvent event) {\n      try {\n          File tmp = File.createTempFile(prefix,suffix,dir);\n\t  Writer out = new BufferedWriter(new FileWriter(tmp));\n\t  out.write(event.message);\n\t  out.close();\n /* this Appender is not supposed to be used for logging of Exceptions */\n      } catch (Exception e) {\n          errorHandler.error(\"Error during creation of temporary File!\",e,1);\n      }\n  }\n  \n  public boolean requiresLayout() {\n      return false;\n  }\n  \n  public void close() {\n  /* nothing to do */\n  }\n} \n/*\n * @author $Author$\n * @version $Revision$\n * @since $Date$\n *\n * $Log$\n * Revision 1.1.2.1  2005/05/27 03:27:54  mwomack\n * Fix for #35032.  Added license header to .java files that did not already have a license.\n *\n * Revision 1.1  2001/04/20 17:38:31  ceki\n *\n * Added LeosLiterak's TempFileAppender.java\n *\n*/\n",
      "file_name": "TempFileAppender.java",
      "human_label": "Write the message in the event into a temp file.",
      "level": "project_runnable",
      "lineno": "162",
      "name": "subAppend",
      "oracle_context": "{ \"apis\" : \"[createTempFile, write, close, error]\", \"classes\" : \"[File, Writer]\", \"vars\" : \"[message, prefix, suffix, dir]\" }",
      "package": "org.apache.log4j",
      "project": "logging-log4j1-main"
    },
    {
      "_id": "636766ef1a6d9265ec01761a",
      "all_context": "{ \"class_level\" : \"ClassWriter classWriter;\\nClassReader sourceClassReader;\\nint majorVersion;\\nString className;\\nint entryCount;\\nEntry[] entries;\\nint constantPoolCount;\\nByteVector constantPool;\\nint bootstrapMethodCount;\\nByteVector bootstrapMethods;\\nint typeCount;\\nEntry[] typeTable;\\nint hashCode;\\nEntry next;\\nSymbolTable(ClassWriter classWriter);\\nSymbolTable(ClassWriter classWriter,ClassReader classReader);\\ngetSource();\\ngetMajorVersion();\\ngetClassName();\\nsetMajorVersionAndClassName(int majorVersion,String className);\\ngetConstantPoolCount();\\ngetConstantPoolLength();\\nputConstantPool(ByteVector output);\\ncomputeBootstrapMethodsSize();\\nputBootstrapMethods(ByteVector output);\\nget(int hashCode);\\nput(Entry entry);\\nadd(Entry entry);\\naddConstant(Object value);\\naddConstantClass(String value);\\naddConstantFieldref(String owner,String name,String descriptor);\\naddConstantMethodref(String owner,String name,String descriptor,boolean isInterface);\\naddConstantMemberReference(int tag,String owner,String name,String descriptor);\\naddConstantMemberReference(int index,int tag,String owner,String name,String descriptor);\\naddConstantString(String value);\\naddConstantInteger(int value);\\naddConstantFloat(float value);\\naddConstantIntegerOrFloat(int tag,int value);\\naddConstantIntegerOrFloat(int index,int tag,int value);\\naddConstantLong(long value);\\naddConstantDouble(double value);\\naddConstantLongOrDouble(int tag,long value);\\naddConstantLongOrDouble(int index,int tag,long value);\\naddConstantNameAndType(String name,String descriptor);\\naddConstantNameAndType(int index,String name,String descriptor);\\naddConstantUtf8(String value);\\naddConstantUtf8(int index,String value);\\naddConstantMethodHandle(int referenceKind,String owner,String name,String descriptor,boolean isInterface);\\naddConstantMethodHandle(int index,int referenceKind,String owner,String name,String descriptor);\\naddConstantMethodType(String methodDescriptor);\\naddConstantDynamic(String name,String descriptor,Handle bootstrapMethodHandle,Object bootstrapMethodArguments);\\naddConstantInvokeDynamic(String name,String descriptor,Handle bootstrapMethodHandle,Object bootstrapMethodArguments);\\naddConstantDynamicOrInvokeDynamicReference(int tag,String name,String descriptor,int bootstrapMethodIndex);\\naddConstantDynamicOrInvokeDynamicReference(int tag,int index,String name,String descriptor,int bootstrapMethodIndex);\\naddConstantModule(String moduleName);\\naddConstantPackage(String packageName);\\naddConstantUtf8Reference(int tag,String value);\\naddConstantUtf8Reference(int index,int tag,String value);\\naddBootstrapMethod(Handle bootstrapMethodHandle,Object bootstrapMethodArguments);\\naddBootstrapMethod(int offset,int length,int hashCode);\\ngetType(int typeIndex);\\naddType(String value);\\naddUninitializedType(String value,int bytecodeOffset);\\naddMergedType(int typeTableIndex1,int typeTableIndex2);\\naddTypeInternal(Entry entry);\\nhash(int tag,int value);\\nhash(int tag,long value);\\nhash(int tag,String value);\\nhash(int tag,String value1,int value2);\\nhash(int tag,String value1,String value2);\\nhash(int tag,String value1,String value2,int value3);\\nhash(int tag,String value1,String value2,String value3);\\nhash(int tag,String value1,String value2,String value3,int value4);\\nEntry(int index,int tag,String owner,String name,String value,long data,int hashCode);\\nEntry(int index,int tag,String value,int hashCode);\\nEntry(int index,int tag,String value,long data,int hashCode);\\nEntry(int index,int tag,String name,String value,int hashCode);\\nEntry(int index,int tag,long data,int hashCode);\\ncopyBootstrapMethods(ClassReader classReader,char[] charBuffer);\\n\", \"repo_level\" : \"\" }",
      "class_name": "SymbolTable",
      "code": "int addType(final String value){\n  int hashCode=hash(Symbol.TYPE_TAG,value);\n  Entry entry=get(hashCode);\n  while (entry != null) {\n    if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {\n      return entry.index;\n    }\n    entry=entry.next;\n  }\n  return addTypeInternal(new Entry(typeCount,Symbol.TYPE_TAG,value,hashCode));\n}\n",
      "docstring": "/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n",
      "end_lineno": "1019",
      "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage net.hasor.utils.asm;\n/**\n * The constant pool entries, the BootstrapMethods attribute entries and the (ASM specific) type\n * table entries of a class.\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4\">JVMS 4.4</a>\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23\">JVMS 4.7.23</a>\n * @author Eric Bruneton\n */\nfinal class SymbolTable {\n    /**\n     * The ClassWriter to which this SymbolTable belongs. This is only used to get access to {@link\n     * ClassWriter#getCommonSuperClass} and to serialize custom attributes with {@link\n     * Attribute#write}.\n     */\n    final         ClassWriter classWriter;\n    /**\n     * The ClassReader from which this SymbolTable was constructed, or {@literal null} if it was\n     * constructed from scratch.\n     */\n    private final ClassReader sourceClassReader;\n    /** The major version number of the class to which this symbol table belongs. */\n    private       int         majorVersion;\n    /** The internal name of the class to which this symbol table belongs. */\n    private       String      className;\n    /**\n     * The total number of {@link Entry} instances in {@link #entries}. This includes entries that are\n     * accessible (recursively) via {@link Entry#next}.\n     */\n    private       int         entryCount;\n    /**\n     * A hash set of all the entries in this SymbolTable (this includes the constant pool entries, the\n     * bootstrap method entries and the type table entries). Each {@link Entry} instance is stored at\n     * the array index given by its hash code modulo the array size. If several entries must be stored\n     * at the same array index, they are linked together via their {@link Entry#next} field. The\n     * factory methods of this class make sure that this table does not contain duplicated entries.\n     */\n    private       Entry[]     entries;\n    /**\n     * The number of constant pool items in {@link #constantPool}, plus 1. The first constant pool\n     * item has index 1, and long and double items count for two items.\n     */\n    private       int         constantPoolCount;\n    /**\n     * The content of the ClassFile's constant_pool JVMS structure corresponding to this SymbolTable.\n     * The ClassFile's constant_pool_count field is <i>not</i> included.\n     */\n    private       ByteVector  constantPool;\n    /**\n     * The number of bootstrap methods in {@link #bootstrapMethods}. Corresponds to the\n     * BootstrapMethods_attribute's num_bootstrap_methods field value.\n     */\n    private       int         bootstrapMethodCount;\n    /**\n     * The content of the BootstrapMethods attribute 'bootstrap_methods' array corresponding to this\n     * SymbolTable. Note that the first 6 bytes of the BootstrapMethods_attribute, and its\n     * num_bootstrap_methods field, are <i>not</i> included.\n     */\n    private       ByteVector  bootstrapMethods;\n    /**\n     * The actual number of elements in {@link #typeTable}. These elements are stored from index 0 to\n     * typeCount (excluded). The other array entries are empty.\n     */\n    private       int         typeCount;\n    /**\n     * An ASM specific type table used to temporarily store internal names that will not necessarily\n     * be stored in the constant pool. This type table is used by the control flow and data flow\n     * analysis algorithm used to compute stack map frames from scratch. This array stores {@link\n     * Symbol#TYPE_TAG} and {@link Symbol#UNINITIALIZED_TYPE_TAG}) Symbol. The type symbol at index\n     * {@code i} has its {@link Symbol#index} equal to {@code i} (and vice versa).\n     */\n    private       Entry[]     typeTable;\n\n    /**\n     * Constructs a new, empty SymbolTable for the given ClassWriter.\n     *\n     * @param classWriter a ClassWriter.\n     */\n    SymbolTable(final ClassWriter classWriter) {\n        this.classWriter = classWriter;\n        this.sourceClassReader = null;\n        this.entries = new Entry[256];\n        this.constantPoolCount = 1;\n        this.constantPool = new ByteVector();\n    }\n\n    /**\n     * Constructs a new SymbolTable for the given ClassWriter, initialized with the constant pool and\n     * bootstrap methods of the given ClassReader.\n     *\n     * @param classWriter a ClassWriter.\n     * @param classReader the ClassReader whose constant pool and bootstrap methods must be copied to\n     *     initialize the SymbolTable.\n     */\n    SymbolTable(final ClassWriter classWriter, final ClassReader classReader) {\n        this.classWriter = classWriter;\n        this.sourceClassReader = classReader;\n        // Copy the constant pool binary content.\n        byte[] inputBytes = classReader.classFileBuffer;\n        int constantPoolOffset = classReader.getItem(1) - 1;\n        int constantPoolLength = classReader.header - constantPoolOffset;\n        constantPoolCount = classReader.getItemCount();\n        constantPool = new ByteVector(constantPoolLength);\n        constantPool.putByteArray(inputBytes, constantPoolOffset, constantPoolLength);\n        // Add the constant pool items in the symbol table entries. Reserve enough space in 'entries' to\n        // avoid too many hash set collisions (entries is not dynamically resized by the addConstant*\n        // method calls below), and to account for bootstrap method entries.\n        entries = new Entry[constantPoolCount * 2];\n        char[] charBuffer = new char[classReader.getMaxStringLength()];\n        boolean hasBootstrapMethods = false;\n        int itemIndex = 1;\n        while (itemIndex < constantPoolCount) {\n            int itemOffset = classReader.getItem(itemIndex);\n            int itemTag = inputBytes[itemOffset - 1];\n            int nameAndTypeItemOffset;\n            switch (itemTag) {\n            case Symbol.CONSTANT_FIELDREF_TAG:\n            case Symbol.CONSTANT_METHODREF_TAG:\n            case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n                nameAndTypeItemOffset = classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));\n                addConstantMemberReference(itemIndex, itemTag, classReader.readClass(itemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer));\n                break;\n            case Symbol.CONSTANT_INTEGER_TAG:\n            case Symbol.CONSTANT_FLOAT_TAG:\n                addConstantIntegerOrFloat(itemIndex, itemTag, classReader.readInt(itemOffset));\n                break;\n            case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n                addConstantNameAndType(itemIndex, classReader.readUTF8(itemOffset, charBuffer), classReader.readUTF8(itemOffset + 2, charBuffer));\n                break;\n            case Symbol.CONSTANT_LONG_TAG:\n            case Symbol.CONSTANT_DOUBLE_TAG:\n                addConstantLongOrDouble(itemIndex, itemTag, classReader.readLong(itemOffset));\n                break;\n            case Symbol.CONSTANT_UTF8_TAG:\n                addConstantUtf8(itemIndex, classReader.readUtf(itemIndex, charBuffer));\n                break;\n            case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n                int memberRefItemOffset = classReader.getItem(classReader.readUnsignedShort(itemOffset + 1));\n                nameAndTypeItemOffset = classReader.getItem(classReader.readUnsignedShort(memberRefItemOffset + 2));\n                addConstantMethodHandle(itemIndex, classReader.readByte(itemOffset), classReader.readClass(memberRefItemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer));\n                break;\n            case Symbol.CONSTANT_DYNAMIC_TAG:\n            case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n                hasBootstrapMethods = true;\n                nameAndTypeItemOffset = classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));\n                addConstantDynamicOrInvokeDynamicReference(itemTag, itemIndex, classReader.readUTF8(nameAndTypeItemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer), classReader.readUnsignedShort(itemOffset));\n                break;\n            case Symbol.CONSTANT_STRING_TAG:\n            case Symbol.CONSTANT_CLASS_TAG:\n            case Symbol.CONSTANT_METHOD_TYPE_TAG:\n            case Symbol.CONSTANT_MODULE_TAG:\n            case Symbol.CONSTANT_PACKAGE_TAG:\n                addConstantUtf8Reference(itemIndex, itemTag, classReader.readUTF8(itemOffset, charBuffer));\n                break;\n            default:\n                throw new IllegalArgumentException();\n            }\n            itemIndex += (itemTag == Symbol.CONSTANT_LONG_TAG || itemTag == Symbol.CONSTANT_DOUBLE_TAG) ? 2 : 1;\n        }\n        // Copy the BootstrapMethods, if any.\n        if (hasBootstrapMethods) {\n            copyBootstrapMethods(classReader, charBuffer);\n        }\n    }\n\n    /**\n     * Read the BootstrapMethods 'bootstrap_methods' array binary content and add them as entries of\n     * the SymbolTable.\n     *\n     * @param classReader the ClassReader whose bootstrap methods must be copied to initialize the\n     *     SymbolTable.\n     * @param charBuffer a buffer used to read strings in the constant pool.\n     */\n    private void copyBootstrapMethods(final ClassReader classReader, final char[] charBuffer) {\n        // Find attributOffset of the 'bootstrap_methods' array.\n        byte[] inputBytes = classReader.classFileBuffer;\n        int currentAttributeOffset = classReader.getFirstAttributeOffset();\n        for (int i = classReader.readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n            String attributeName = classReader.readUTF8(currentAttributeOffset, charBuffer);\n            if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n                bootstrapMethodCount = classReader.readUnsignedShort(currentAttributeOffset + 6);\n                break;\n            }\n            currentAttributeOffset += 6 + classReader.readInt(currentAttributeOffset + 2);\n        }\n        if (bootstrapMethodCount > 0) {\n            // Compute the offset and the length of the BootstrapMethods 'bootstrap_methods' array.\n            int bootstrapMethodsOffset = currentAttributeOffset + 8;\n            int bootstrapMethodsLength = classReader.readInt(currentAttributeOffset + 2) - 2;\n            bootstrapMethods = new ByteVector(bootstrapMethodsLength);\n            bootstrapMethods.putByteArray(inputBytes, bootstrapMethodsOffset, bootstrapMethodsLength);\n            // Add each bootstrap method in the symbol table entries.\n            int currentOffset = bootstrapMethodsOffset;\n            for (int i = 0; i < bootstrapMethodCount; i++) {\n                int offset = currentOffset - bootstrapMethodsOffset;\n                int bootstrapMethodRef = classReader.readUnsignedShort(currentOffset);\n                currentOffset += 2;\n                int numBootstrapArguments = classReader.readUnsignedShort(currentOffset);\n                currentOffset += 2;\n                int hashCode = classReader.readConst(bootstrapMethodRef, charBuffer).hashCode();\n                while (numBootstrapArguments-- > 0) {\n                    int bootstrapArgument = classReader.readUnsignedShort(currentOffset);\n                    currentOffset += 2;\n                    hashCode ^= classReader.readConst(bootstrapArgument, charBuffer).hashCode();\n                }\n                add(new Entry(i, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode & 0x7FFFFFFF));\n            }\n        }\n    }\n\n    /**\n     * Returns the ClassReader from which this SymbolTable was constructed.\n     *\n     * @return the ClassReader from which this SymbolTable was constructed, or {@literal null} if it\n     *     was constructed from scratch.\n     */\n    ClassReader getSource() {\n        return sourceClassReader;\n    }\n\n    /**\n     * Returns the major version of the class to which this symbol table belongs.\n     *\n     * @return the major version of the class to which this symbol table belongs.\n     */\n    int getMajorVersion() {\n        return majorVersion;\n    }\n\n    /**\n     * Returns the internal name of the class to which this symbol table belongs.\n     *\n     * @return the internal name of the class to which this symbol table belongs.\n     */\n    String getClassName() {\n        return className;\n    }\n\n    /**\n     * Sets the major version and the name of the class to which this symbol table belongs. Also adds\n     * the class name to the constant pool.\n     *\n     * @param majorVersion a major ClassFile version number.\n     * @param className an internal class name.\n     * @return the constant pool index of a new or already existing Symbol with the given class name.\n     */\n    int setMajorVersionAndClassName(final int majorVersion, final String className) {\n        this.majorVersion = majorVersion;\n        this.className = className;\n        return addConstantClass(className).index;\n    }\n\n    /**\n     * Returns the number of items in this symbol table's constant_pool array (plus 1).\n     *\n     * @return the number of items in this symbol table's constant_pool array (plus 1).\n     */\n    int getConstantPoolCount() {\n        return constantPoolCount;\n    }\n\n    /**\n     * Returns the length in bytes of this symbol table's constant_pool array.\n     *\n     * @return the length in bytes of this symbol table's constant_pool array.\n     */\n    int getConstantPoolLength() {\n        return constantPool.length;\n    }\n\n    /**\n     * Puts this symbol table's constant_pool array in the given ByteVector, preceded by the\n     * constant_pool_count value.\n     *\n     * @param output where the JVMS ClassFile's constant_pool array must be put.\n     */\n    void putConstantPool(final ByteVector output) {\n        output.putShort(constantPoolCount).putByteArray(constantPool.data, 0, constantPool.length);\n    }\n\n    /**\n     * Returns the size in bytes of this symbol table's BootstrapMethods attribute. Also adds the\n     * attribute name in the constant pool.\n     *\n     * @return the size in bytes of this symbol table's BootstrapMethods attribute.\n     */\n    int computeBootstrapMethodsSize() {\n        if (bootstrapMethods != null) {\n            addConstantUtf8(Constants.BOOTSTRAP_METHODS);\n            return 8 + bootstrapMethods.length;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * Puts this symbol table's BootstrapMethods attribute in the given ByteVector. This includes the\n     * 6 attribute header bytes and the num_bootstrap_methods value.\n     *\n     * @param output where the JVMS BootstrapMethods attribute must be put.\n     */\n    void putBootstrapMethods(final ByteVector output) {\n        if (bootstrapMethods != null) {\n            output.putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS)).putInt(bootstrapMethods.length + 2).putShort(bootstrapMethodCount).putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length);\n        }\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Generic symbol table entries management.\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the list of entries which can potentially have the given hash code.\n     *\n     * @param hashCode a {@link Entry#hashCode} value.\n     * @return the list of entries which can potentially have the given hash code. The list is stored\n     *     via the {@link Entry#next} field.\n     */\n    private Entry get(final int hashCode) {\n        return entries[hashCode % entries.length];\n    }\n\n    /**\n     * Puts the given entry in the {@link #entries} hash set. This method does <i>not</i> check\n     * whether {@link #entries} already contains a similar entry or not. {@link #entries} is resized\n     * if necessary to avoid hash collisions (multiple entries needing to be stored at the same {@link\n     * #entries} array index) as much as possible, with reasonable memory usage.\n     *\n     * @param entry an Entry (which must not already be contained in {@link #entries}).\n     * @return the given entry\n     */\n    private Entry put(final Entry entry) {\n        if (entryCount > (entries.length * 3) / 4) {\n            int currentCapacity = entries.length;\n            int newCapacity = currentCapacity * 2 + 1;\n            Entry[] newEntries = new Entry[newCapacity];\n            for (int i = currentCapacity - 1; i >= 0; --i) {\n                Entry currentEntry = entries[i];\n                while (currentEntry != null) {\n                    int newCurrentEntryIndex = currentEntry.hashCode % newCapacity;\n                    Entry nextEntry = currentEntry.next;\n                    currentEntry.next = newEntries[newCurrentEntryIndex];\n                    newEntries[newCurrentEntryIndex] = currentEntry;\n                    currentEntry = nextEntry;\n                }\n            }\n            entries = newEntries;\n        }\n        entryCount++;\n        int index = entry.hashCode % entries.length;\n        entry.next = entries[index];\n        return entries[index] = entry;\n    }\n\n    /**\n     * Adds the given entry in the {@link #entries} hash set. This method does <i>not</i> check\n     * whether {@link #entries} already contains a similar entry or not, and does <i>not</i> resize\n     * {@link #entries} if necessary.\n     *\n     * @param entry an Entry (which must not already be contained in {@link #entries}).\n     */\n    private void add(final Entry entry) {\n        entryCount++;\n        int index = entry.hashCode % entries.length;\n        entry.next = entries[index];\n        entries[index] = entry;\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Constant pool entries management.\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Adds a number or string constant to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value the value of the constant to be added to the constant pool. This parameter must be\n     *     an {@link Integer}, {@link Byte}, {@link Character}, {@link Short}, {@link Boolean}, {@link\n     *     Float}, {@link Long}, {@link Double}, {@link String}, {@link Type} or {@link Handle}.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstant(final Object value) {\n        if (value instanceof Integer) {\n            return addConstantInteger(((Integer) value).intValue());\n        } else if (value instanceof Byte) {\n            return addConstantInteger(((Byte) value).intValue());\n        } else if (value instanceof Character) {\n            return addConstantInteger(((Character) value).charValue());\n        } else if (value instanceof Short) {\n            return addConstantInteger(((Short) value).intValue());\n        } else if (value instanceof Boolean) {\n            return addConstantInteger(((Boolean) value).booleanValue() ? 1 : 0);\n        } else if (value instanceof Float) {\n            return addConstantFloat(((Float) value).floatValue());\n        } else if (value instanceof Long) {\n            return addConstantLong(((Long) value).longValue());\n        } else if (value instanceof Double) {\n            return addConstantDouble(((Double) value).doubleValue());\n        } else if (value instanceof String) {\n            return addConstantString((String) value);\n        } else if (value instanceof Type) {\n            Type type = (Type) value;\n            int typeSort = type.getSort();\n            if (typeSort == Type.OBJECT) {\n                return addConstantClass(type.getInternalName());\n            } else if (typeSort == Type.METHOD) {\n                return addConstantMethodType(type.getDescriptor());\n            } else { // type is a primitive or array type.\n                return addConstantClass(type.getDescriptor());\n            }\n        } else if (value instanceof Handle) {\n            Handle handle = (Handle) value;\n            return addConstantMethodHandle(handle.getTag(), handle.getOwner(), handle.getName(), handle.getDesc(), handle.isInterface());\n        } else if (value instanceof ConstantDynamic) {\n            ConstantDynamic constantDynamic = (ConstantDynamic) value;\n            return addConstantDynamic(constantDynamic.getName(), constantDynamic.getDescriptor(), constantDynamic.getBootstrapMethod(), constantDynamic.getBootstrapMethodArgumentsUnsafe());\n        } else {\n            throw new IllegalArgumentException(\"value \" + value);\n        }\n    }\n\n    /**\n     * Adds a CONSTANT_Class_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value the internal name of a class.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantClass(final String value) {\n        return addConstantUtf8Reference(Symbol.CONSTANT_CLASS_TAG, value);\n    }\n\n    /**\n     * Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param owner the internal name of a class.\n     * @param name a field name.\n     * @param descriptor a field descriptor.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantFieldref(final String owner, final String name, final String descriptor) {\n        return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor);\n    }\n\n    /**\n     * Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this\n     * symbol table. Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of a class.\n     * @param name a method name.\n     * @param descriptor a method descriptor.\n     * @param isInterface whether owner is an interface or not.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantMethodref(final String owner, final String name, final String descriptor, final boolean isInterface) {\n        int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG;\n        return addConstantMemberReference(tag, owner, name, descriptor);\n    }\n\n    /**\n     * Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to\n     * the constant pool of this symbol table. Does nothing if the constant pool already contains a\n     * similar item.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\n     *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n     * @param owner the internal name of a class.\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     * @return a new or already existing Symbol with the given value.\n     */\n    private Entry addConstantMemberReference(final int tag, final String owner, final String name, final String descriptor) {\n        int hashCode = hash(tag, owner, name, descriptor);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        constantPool.put122(tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor));\n        return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, 0, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info\n     * to the constant pool of this symbol table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\n     *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n     * @param owner the internal name of a class.\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     */\n    private void addConstantMemberReference(final int index, final int tag, final String owner, final String name, final String descriptor) {\n        add(new Entry(index, tag, owner, name, descriptor, 0, hash(tag, owner, name, descriptor)));\n    }\n\n    /**\n     * Adds a CONSTANT_String_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value a string.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantString(final String value) {\n        return addConstantUtf8Reference(Symbol.CONSTANT_STRING_TAG, value);\n    }\n\n    /**\n     * Adds a CONSTANT_Integer_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value an int.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantInteger(final int value) {\n        return addConstantIntegerOrFloat(Symbol.CONSTANT_INTEGER_TAG, value);\n    }\n\n    /**\n     * Adds a CONSTANT_Float_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value a float.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantFloat(final float value) {\n        return addConstantIntegerOrFloat(Symbol.CONSTANT_FLOAT_TAG, Float.floatToRawIntBits(value));\n    }\n\n    /**\n     * Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n     * @param value an int or float.\n     * @return a constant pool constant with the given tag and primitive values.\n     */\n    private Symbol addConstantIntegerOrFloat(final int tag, final int value) {\n        int hashCode = hash(tag, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        constantPool.putByte(tag).putInt(value);\n        return put(new Entry(constantPoolCount++, tag, value, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\n     * table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n     * @param value an int or float.\n     */\n    private void addConstantIntegerOrFloat(final int index, final int tag, final int value) {\n        add(new Entry(index, tag, value, hash(tag, value)));\n    }\n\n    /**\n     * Adds a CONSTANT_Long_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value a long.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantLong(final long value) {\n        return addConstantLongOrDouble(Symbol.CONSTANT_LONG_TAG, value);\n    }\n\n    /**\n     * Adds a CONSTANT_Double_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value a double.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantDouble(final double value) {\n        return addConstantLongOrDouble(Symbol.CONSTANT_DOUBLE_TAG, Double.doubleToRawLongBits(value));\n    }\n\n    /**\n     * Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n     * @param value a long or double.\n     * @return a constant pool constant with the given tag and primitive values.\n     */\n    private Symbol addConstantLongOrDouble(final int tag, final long value) {\n        int hashCode = hash(tag, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        int index = constantPoolCount;\n        constantPool.putByte(tag).putLong(value);\n        constantPoolCount += 2;\n        return put(new Entry(index, tag, value, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol\n     * table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n     * @param value a long or double.\n     */\n    private void addConstantLongOrDouble(final int index, final int tag, final long value) {\n        add(new Entry(index, tag, value, hash(tag, value)));\n    }\n\n    /**\n     * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     * @return a new or already existing Symbol with the given value.\n     */\n    int addConstantNameAndType(final String name, final String descriptor) {\n        final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;\n        int hashCode = hash(tag, name, descriptor);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.name.equals(name) && entry.value.equals(descriptor)) {\n                return entry.index;\n            }\n            entry = entry.next;\n        }\n        constantPool.put122(tag, addConstantUtf8(name), addConstantUtf8(descriptor));\n        return put(new Entry(constantPoolCount++, tag, name, descriptor, hashCode)).index;\n    }\n\n    /**\n     * Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     */\n    private void addConstantNameAndType(final int index, final String name, final String descriptor) {\n        final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;\n        add(new Entry(index, tag, name, descriptor, hash(tag, name, descriptor)));\n    }\n\n    /**\n     * Adds a CONSTANT_Utf8_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value a string.\n     * @return a new or already existing Symbol with the given value.\n     */\n    int addConstantUtf8(final String value) {\n        int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == Symbol.CONSTANT_UTF8_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {\n                return entry.index;\n            }\n            entry = entry.next;\n        }\n        constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value);\n        return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index;\n    }\n\n    /**\n     * Adds a new CONSTANT_String_info to the constant pool of this symbol table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param value a string.\n     */\n    private void addConstantUtf8(final int index, final String value) {\n        add(new Entry(index, Symbol.CONSTANT_UTF8_TAG, value, hash(Symbol.CONSTANT_UTF8_TAG, value)));\n    }\n\n    /**\n     * Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table. Does nothing if\n     * the constant pool already contains a similar item.\n     *\n     * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\n     *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\n     *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\n     *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n     * @param owner the internal name of a class of interface.\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     * @param isInterface whether owner is an interface or not.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantMethodHandle(final int referenceKind, final String owner, final String name, final String descriptor, final boolean isInterface) {\n        final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;\n        // Note that we don't need to include isInterface in the hash computation, because it is\n        // redundant with owner (we can't have the same owner with different isInterface values).\n        int hashCode = hash(tag, owner, name, descriptor, referenceKind);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.data == referenceKind && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        if (referenceKind <= Opcodes.H_PUTSTATIC) {\n            constantPool.put112(tag, referenceKind, addConstantFieldref(owner, name, descriptor).index);\n        } else {\n            constantPool.put112(tag, referenceKind, addConstantMethodref(owner, name, descriptor, isInterface).index);\n        }\n        return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, referenceKind, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\n     *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\n     *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\n     *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n     * @param owner the internal name of a class of interface.\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     */\n    private void addConstantMethodHandle(final int index, final int referenceKind, final String owner, final String name, final String descriptor) {\n        final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;\n        int hashCode = hash(tag, owner, name, descriptor, referenceKind);\n        add(new Entry(index, tag, owner, name, descriptor, referenceKind, hashCode));\n    }\n\n    /**\n     * Adds a CONSTANT_MethodType_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantMethodType(final String methodDescriptor) {\n        return addConstantUtf8Reference(Symbol.CONSTANT_METHOD_TYPE_TAG, methodDescriptor);\n    }\n\n    /**\n     * Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table. Also adds the related\n     * bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the constant\n     * pool already contains a similar item.\n     *\n     * @param name a method name.\n     * @param descriptor a field descriptor.\n     * @param bootstrapMethodHandle a bootstrap method handle.\n     * @param bootstrapMethodArguments the bootstrap method arguments.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantDynamic(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\n        Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);\n        return addConstantDynamicOrInvokeDynamicReference(Symbol.CONSTANT_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);\n    }\n\n    /**\n     * Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table. Also adds the\n     * related bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param name a method name.\n     * @param descriptor a method descriptor.\n     * @param bootstrapMethodHandle a bootstrap method handle.\n     * @param bootstrapMethodArguments the bootstrap method arguments.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantInvokeDynamic(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\n        Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);\n        return addConstantDynamicOrInvokeDynamicReference(Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);\n    }\n\n    /**\n     * Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol\n     * table. Does nothing if the constant pool already contains a similar item.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\n     *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n     * @param name a method name.\n     * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG) or a method descriptor for\n     *     CONSTANT_INVOKE_DYNAMIC_TAG.\n     * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\n     * @return a new or already existing Symbol with the given value.\n     */\n    private Symbol addConstantDynamicOrInvokeDynamicReference(final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) {\n        int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.data == bootstrapMethodIndex && entry.name.equals(name) && entry.value.equals(descriptor)) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        constantPool.put122(tag, bootstrapMethodIndex, addConstantNameAndType(name, descriptor));\n        return put(new Entry(constantPoolCount++, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this\n     * symbol table.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\n     *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n     * @param index the constant pool index of the new Symbol.\n     * @param name a method name.\n     * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG or a method descriptor for\n     *     CONSTANT_INVOKE_DYNAMIC_TAG.\n     * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\n     */\n    private void addConstantDynamicOrInvokeDynamicReference(final int tag, final int index, final String name, final String descriptor, final int bootstrapMethodIndex) {\n        int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);\n        add(new Entry(index, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));\n    }\n\n    /**\n     * Adds a CONSTANT_Module_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param moduleName a fully qualified name (using dots) of a module.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantModule(final String moduleName) {\n        return addConstantUtf8Reference(Symbol.CONSTANT_MODULE_TAG, moduleName);\n    }\n\n    /**\n     * Adds a CONSTANT_Package_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param packageName the internal name of a package.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantPackage(final String packageName) {\n        return addConstantUtf8Reference(Symbol.CONSTANT_PACKAGE_TAG, packageName);\n    }\n\n    /**\n     * Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\n     * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\n     *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\n     *     Symbol#CONSTANT_PACKAGE_TAG}.\n     * @param value an internal class name, an arbitrary string, a method descriptor, a module or a\n     *     package name, depending on tag.\n     * @return a new or already existing Symbol with the given value.\n     */\n    private Symbol addConstantUtf8Reference(final int tag, final String value) {\n        int hashCode = hash(tag, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.value.equals(value)) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        constantPool.put12(tag, addConstantUtf8(value));\n        return put(new Entry(constantPoolCount++, tag, value, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\n     * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\n     *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\n     *     Symbol#CONSTANT_PACKAGE_TAG}.\n     * @param value an internal class name, an arbitrary string, a method descriptor, a module or a\n     *     package name, depending on tag.\n     */\n    private void addConstantUtf8Reference(final int index, final int tag, final String value) {\n        add(new Entry(index, tag, value, hash(tag, value)));\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Bootstrap method entries management.\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\n     * the BootstrapMethods already contains a similar bootstrap method.\n     *\n     * @param bootstrapMethodHandle a bootstrap method handle.\n     * @param bootstrapMethodArguments the bootstrap method arguments.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addBootstrapMethod(final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\n        ByteVector bootstrapMethodsAttribute = bootstrapMethods;\n        if (bootstrapMethodsAttribute == null) {\n            bootstrapMethodsAttribute = bootstrapMethods = new ByteVector();\n        }\n        // The bootstrap method arguments can be Constant_Dynamic values, which reference other\n        // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool\n        // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified\n        // while adding the given bootstrap method to it, in the rest of this method.\n        for (Object bootstrapMethodArgument : bootstrapMethodArguments) {\n            addConstant(bootstrapMethodArgument);\n        }\n        // Write the bootstrap method in the BootstrapMethods table. This is necessary to be able to\n        // compare it with existing ones, and will be reverted below if there is already a similar\n        // bootstrap method.\n        int bootstrapMethodOffset = bootstrapMethodsAttribute.length;\n        bootstrapMethodsAttribute.putShort(addConstantMethodHandle(bootstrapMethodHandle.getTag(), bootstrapMethodHandle.getOwner(), bootstrapMethodHandle.getName(), bootstrapMethodHandle.getDesc(), bootstrapMethodHandle.isInterface()).index);\n        int numBootstrapArguments = bootstrapMethodArguments.length;\n        bootstrapMethodsAttribute.putShort(numBootstrapArguments);\n        for (Object bootstrapMethodArgument : bootstrapMethodArguments) {\n            bootstrapMethodsAttribute.putShort(addConstant(bootstrapMethodArgument).index);\n        }\n        // Compute the length and the hash code of the bootstrap method.\n        int bootstrapMethodlength = bootstrapMethodsAttribute.length - bootstrapMethodOffset;\n        int hashCode = bootstrapMethodHandle.hashCode();\n        for (Object bootstrapMethodArgument : bootstrapMethodArguments) {\n            hashCode ^= bootstrapMethodArgument.hashCode();\n        }\n        hashCode &= 0x7FFFFFFF;\n        // Add the bootstrap method to the symbol table or revert the above changes.\n        return addBootstrapMethod(bootstrapMethodOffset, bootstrapMethodlength, hashCode);\n    }\n\n    /**\n     * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\n     * the BootstrapMethods already contains a similar bootstrap method (more precisely, reverts the\n     * content of {@link #bootstrapMethods} to remove the last, duplicate bootstrap method).\n     *\n     * @param offset the offset of the last bootstrap method in {@link #bootstrapMethods}, in bytes.\n     * @param length the length of this bootstrap method in {@link #bootstrapMethods}, in bytes.\n     * @param hashCode the hash code of this bootstrap method.\n     * @return a new or already existing Symbol with the given value.\n     */\n    private Symbol addBootstrapMethod(final int offset, final int length, final int hashCode) {\n        final byte[] bootstrapMethodsData = bootstrapMethods.data;\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == Symbol.BOOTSTRAP_METHOD_TAG && entry.hashCode == hashCode) {\n                int otherOffset = (int) entry.data;\n                boolean isSameBootstrapMethod = true;\n                for (int i = 0; i < length; ++i) {\n                    if (bootstrapMethodsData[offset + i] != bootstrapMethodsData[otherOffset + i]) {\n                        isSameBootstrapMethod = false;\n                        break;\n                    }\n                }\n                if (isSameBootstrapMethod) {\n                    bootstrapMethods.length = offset; // Revert to old position.\n                    return entry;\n                }\n            }\n            entry = entry.next;\n        }\n        return put(new Entry(bootstrapMethodCount++, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode));\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Type table entries management.\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the type table element whose index is given.\n     *\n     * @param typeIndex a type table index.\n     * @return the type table element whose index is given.\n     */\n    Symbol getType(final int typeIndex) {\n        return typeTable[typeIndex];\n    }\n\n    /**\n     * Adds a type in the type table of this symbol table. Does nothing if the type table already\n     * contains a similar type.\n     *\n     * @param value an internal class name.\n     * @return the index of a new or already existing type Symbol with the given value.\n     */\n    int addType(final String value) {\n        int hashCode = hash(Symbol.TYPE_TAG, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {\n                return entry.index;\n            }\n            entry = entry.next;\n        }\n        return addTypeInternal(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode));\n    }\n\n    /**\n     * Adds an {@link Frame#ITEM_UNINITIALIZED} type in the type table of this symbol table. Does\n     * nothing if the type table already contains a similar type.\n     *\n     * @param value an internal class name.\n     * @param bytecodeOffset the bytecode offset of the NEW instruction that created this {@link\n     *     Frame#ITEM_UNINITIALIZED} type value.\n     * @return the index of a new or already existing type Symbol with the given value.\n     */\n    int addUninitializedType(final String value, final int bytecodeOffset) {\n        int hashCode = hash(Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == Symbol.UNINITIALIZED_TYPE_TAG && entry.hashCode == hashCode && entry.data == bytecodeOffset && entry.value.equals(value)) {\n                return entry.index;\n            }\n            entry = entry.next;\n        }\n        return addTypeInternal(new Entry(typeCount, Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset, hashCode));\n    }\n\n    /**\n     * Adds a merged type in the type table of this symbol table. Does nothing if the type table\n     * already contains a similar type.\n     *\n     * @param typeTableIndex1 a {@link Symbol#TYPE_TAG} type, specified by its index in the type\n     *     table.\n     * @param typeTableIndex2 another {@link Symbol#TYPE_TAG} type, specified by its index in the type\n     *     table.\n     * @return the index of a new or already existing {@link Symbol#TYPE_TAG} type Symbol,\n     *     corresponding to the common super class of the given types.\n     */\n    int addMergedType(final int typeTableIndex1, final int typeTableIndex2) {\n        long data = typeTableIndex1 < typeTableIndex2 ? typeTableIndex1 | (((long) typeTableIndex2) << 32) : typeTableIndex2 | (((long) typeTableIndex1) << 32);\n        int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == Symbol.MERGED_TYPE_TAG && entry.hashCode == hashCode && entry.data == data) {\n                return entry.info;\n            }\n            entry = entry.next;\n        }\n        String type1 = typeTable[typeTableIndex1].value;\n        String type2 = typeTable[typeTableIndex2].value;\n        int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2));\n        put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG, data, hashCode)).info = commonSuperTypeIndex;\n        return commonSuperTypeIndex;\n    }\n\n    /**\n     * Adds the given type Symbol to {@link #typeTable}.\n     *\n     * @param entry a {@link Symbol#TYPE_TAG} or {@link Symbol#UNINITIALIZED_TYPE_TAG} type symbol.\n     *     The index of this Symbol must be equal to the current value of {@link #typeCount}.\n     * @return the index in {@link #typeTable} where the given type was added, which is also equal to\n     *     entry's index by hypothesis.\n     */\n    private int addTypeInternal(final Entry entry) {\n        if (typeTable == null) {\n            typeTable = new Entry[16];\n        }\n        if (typeCount == typeTable.length) {\n            Entry[] newTypeTable = new Entry[2 * typeTable.length];\n            System.arraycopy(typeTable, 0, newTypeTable, 0, typeTable.length);\n            typeTable = newTypeTable;\n        }\n        typeTable[typeCount++] = entry;\n        return put(entry).index;\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Static helper methods to compute hash codes.\n    // -----------------------------------------------------------------------------------------------\n\n    private static int hash(final int tag, final int value) {\n        return 0x7FFFFFFF & (tag + value);\n    }\n\n    private static int hash(final int tag, final long value) {\n        return 0x7FFFFFFF & (tag + (int) value + (int) (value >>> 32));\n    }\n\n    private static int hash(final int tag, final String value) {\n        return 0x7FFFFFFF & (tag + value.hashCode());\n    }\n\n    private static int hash(final int tag, final String value1, final int value2) {\n        return 0x7FFFFFFF & (tag + value1.hashCode() + value2);\n    }\n\n    private static int hash(final int tag, final String value1, final String value2) {\n        return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode());\n    }\n\n    private static int hash(final int tag, final String value1, final String value2, final int value3) {\n        return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * (value3 + 1));\n    }\n\n    private static int hash(final int tag, final String value1, final String value2, final String value3) {\n        return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode());\n    }\n\n    private static int hash(final int tag, final String value1, final String value2, final String value3, final int value4) {\n        return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode() * value4);\n    }\n\n    /**\n     * An entry of a SymbolTable. This concrete and private subclass of {@link Symbol} adds two fields\n     * which are only used inside SymbolTable, to implement hash sets of symbols (in order to avoid\n     * duplicate symbols). See {@link #entries}.\n     *\n     * @author Eric Bruneton\n     */\n    private static class Entry extends Symbol {\n        /** The hash code of this entry. */\n        final int hashCode;\n        /**\n         * Another entry (and so on recursively) having the same hash code (modulo the size of {@link\n         * #entries}) as this one.\n         */\n        Entry next;\n\n        Entry(final int index, final int tag, final String owner, final String name, final String value, final long data, final int hashCode) {\n            super(index, tag, owner, name, value, data);\n            this.hashCode = hashCode;\n        }\n\n        Entry(final int index, final int tag, final String value, final int hashCode) {\n            super(index, tag, /* owner = */ null, /* name = */ null, value, /* data = */ 0);\n            this.hashCode = hashCode;\n        }\n\n        Entry(final int index, final int tag, final String value, final long data, final int hashCode) {\n            super(index, tag, /* owner = */ null, /* name = */ null, value, data);\n            this.hashCode = hashCode;\n        }\n\n        Entry(final int index, final int tag, final String name, final String value, final int hashCode) {\n            super(index, tag, /* owner = */ null, name, value, /* data = */ 0);\n            this.hashCode = hashCode;\n        }\n\n        Entry(final int index, final int tag, final long data, final int hashCode) {\n            super(index, tag, /* owner = */ null, /* name = */ null, /* value = */ null, data);\n            this.hashCode = hashCode;\n        }\n    }\n}\n",
      "file_name": "SymbolTable.java",
      "human_label": "Add a new type entry of the given value into the type table of this symbol table. Does nothing if the type table already contains a similar type. Return the index of the type entry in the symbol table.",
      "level": "project_runnable",
      "lineno": "1002",
      "name": "addType",
      "oracle_context": "{ \"apis\" : \"[hash, get, equals, addTypeInternal, Entry]\", \"classes\" : \"[Entry, Symbol]\", \"vars\" : \"[TYPE_TAG, tag, index, next, typeCount]\" }",
      "package": "net.hasor.utils.asm",
      "project": "hasor-master"
    },
    {
      "_id": "636766821a6d9265ec0174b6",
      "all_context": "{ \"class_level\" : \"import java.lang.ref.Reference;\\nimport java.lang.ref.WeakReference;\\nimport java.lang.reflect.Array;\\nimport java.lang.reflect.GenericArrayType;\\nimport java.lang.reflect.ParameterizedType;\\nimport java.lang.reflect.Type;\\nimport java.lang.reflect.TypeVariable;\\nimport java.util.Collections;\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.WeakHashMap;\\nMap<Class<?>,Reference<Map<TypeVariable<?>,Type>>> typeVariableCache;\\nboolean cacheEnabled;\\nTypeResolver();\\nUnknown();\\ndisableCache();\\nresolveArgument(Class initialType,Class targetType);\\nresolveArgument(Type genericType,Class targetType);\\nresolveArguments(Class initialType,Class targetType);\\nresolveArguments(Type genericType,Class targetType);\\nresolveGenericType(Type initialType,Class targetType);\\nresolveClass(Type genericType,Class targetType);\\ngetTypeVariableMap(Class targetType);\\nbuildTypeVariableMap(Type[] types,Map map);\\nbuildTypeVariableMap(ParameterizedType type,Map typeVariableMap);\\nresolveBound(TypeVariable typeVariable);\\nenableCache();\\n\", \"repo_level\" : \"\" }",
      "class_name": "TypeResolver",
      "code": "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n  Class<?>[] result=null;\n  if (genericType instanceof ParameterizedType) {\n    ParameterizedType paramType=(ParameterizedType)genericType;\n    Type[] arguments=paramType.getActualTypeArguments();\n    result=new Class[arguments.length];\n    for (int i=0; i < arguments.length; i++)     result[i]=resolveClass(arguments[i],targetType);\n  }\n else   if (genericType instanceof TypeVariable) {\n    result=new Class[1];\n    result[0]=resolveClass(genericType,targetType);\n  }\n  return result;\n}\n",
      "docstring": "/** \n * Resolves the arguments for the  {@code genericType} using the type variable information for the{@code targetType}. Returns  {@code null} if {@code genericType} is not parameterized or ifarguments cannot be resolved.\n */\n",
      "end_lineno": "158",
      "file_content": "/*\n * Copyright 2008-2022 Async-IO.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n/**\n * Copyright 2002-2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * This class is from https://github.com/jhalterman/typetools\n */\npackage org.atmosphere.config.managed;\n\nimport java.lang.ref.Reference;\nimport java.lang.ref.WeakReference;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.WeakHashMap;\n\n/**\n * Enhanced type resolution utilities. Based on org.springframework.core.GenericTypeResolver.\n *\n * @author Jonathan Halterman\n */\npublic final class TypeResolver {\n    private TypeResolver() {\n    }\n\n    /** An unknown type. */\n    public static final class Unknown {\n        private Unknown() {\n        }\n    }\n\n    /** Cache of type variable/argument pairs */\n    private static final Map<Class<?>, Reference<Map<TypeVariable<?>, Type>>> typeVariableCache = Collections.synchronizedMap(new WeakHashMap<>());\n    private static boolean cacheEnabled = true;\n\n    /**\n     * Enables the internal caching of TypeVariables.\n     */\n    public static void enableCache() {\n        cacheEnabled = true;\n    }\n\n    /**\n     * Disables the internal caching of TypeVariables.\n     */\n    public static void disableCache() {\n        typeVariableCache.clear();\n        cacheEnabled = false;\n    }\n\n    /**\n     * Returns the raw class representing the type argument for the {@code targetType} resolved\n     * upwards from the {@code initialType}. If no arguments can be resolved then\n     * {@code Unknown.class} is returned.\n     *\n     * @param initialType to resolve upwards from\n     * @param targetType to resolve arguments for\n     * @return type argument for {@code initialType} else {@code null} if no type arguments are\n     *         declared\n     * @throws IllegalArgumentException if more or less than one type argument is resolved for the\n     *           give types\n     */\n    public static <T, I extends T> Class<?> resolveArgument(Class<I> initialType, Class<T> targetType) {\n        return resolveArgument(resolveGenericType(initialType, targetType), initialType);\n    }\n\n    /**\n     * Resolves the type argument for the {@code genericType} using type variable information from the\n     * {@code sourceType}. If {@code genericType} is an instance of class, then {@code genericType} is\n     * returned. If no arguments can be resolved then {@code Unknown.class} is returned.\n     *\n     * @param genericType to resolve upwards from\n     * @param targetType to resolve arguments for\n     * @return type argument for {@code initialType} else {@code null} if no type arguments are\n     *         declared\n     * @throws IllegalArgumentException if more or less than one type argument is resolved for the\n     *           give types\n     */\n    public static Class<?> resolveArgument(Type genericType, Class<?> targetType) {\n        Class<?>[] arguments = resolveArguments(genericType, targetType);\n        if (arguments == null)\n            return Unknown.class;\n\n        if (arguments.length != 1)\n            throw new IllegalArgumentException(\"Expected 1 type argument on generic type \"\n                    + targetType.getName() + \" but found \" + arguments.length);\n\n        return arguments[0];\n    }\n\n    /**\n     * Returns an array of raw classes representing type arguments for the {@code targetType} resolved\n     * upwards from the {@code initialType}. Arguments for {@code targetType} that cannot be resolved\n     * to a Class are returned as {@code Unknown.class}. If no arguments can be resolved then\n     * {@code null} is returned.\n     *\n     * @param initialType to resolve upwards from\n     * @param targetType to resolve arguments for\n     * @return array of raw classes representing type arguments for {@code initialType} else\n     *         {@code null} if no type arguments are declared\n     */\n    public static <T, I extends T> Class<?>[] resolveArguments(Class<I> initialType,\n                                                               Class<T> targetType) {\n        return resolveArguments(resolveGenericType(initialType, targetType), initialType);\n    }\n\n    /**\n     * Resolves the arguments for the {@code genericType} using the type variable information for the\n     * {@code targetType}. Returns {@code null} if {@code genericType} is not parameterized or if\n     * arguments cannot be resolved.\n     */\n    public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n        Class<?>[] result = null;\n\n        if (genericType instanceof ParameterizedType) {\n            ParameterizedType paramType = (ParameterizedType) genericType;\n            Type[] arguments = paramType.getActualTypeArguments();\n            result = new Class[arguments.length];\n            for (int i = 0; i < arguments.length; i++)\n                result[i] = resolveClass(arguments[i], targetType);\n        } else if (genericType instanceof TypeVariable) {\n            result = new Class[1];\n            result[0] = resolveClass(genericType, targetType);\n        }\n\n        return result;\n    }\n\n    /**\n     * Resolves the generic Type for the {@code targetType} by walking the type hierarchy upwards from\n     * the {@code initialType}.\n     */\n    public static Type resolveGenericType(Type initialType, Class<?> targetType) {\n        Class<?> rawType;\n        if (initialType instanceof ParameterizedType)\n            rawType = (Class<?>) ((ParameterizedType) initialType).getRawType();\n        else\n            rawType = (Class<?>) initialType;\n\n        if (targetType.equals(rawType))\n            return initialType;\n\n        Type result;\n        if (targetType.isInterface()) {\n            for (Type superInterface : rawType.getGenericInterfaces())\n                if (superInterface != null && !superInterface.equals(Object.class))\n                    if ((result = resolveGenericType(superInterface, targetType)) != null)\n                        return result;\n        }\n\n        Type superType = rawType.getGenericSuperclass();\n        if (superType != null && !superType.equals(Object.class))\n            if ((result = resolveGenericType(superType, targetType)) != null)\n                return result;\n\n        return null;\n    }\n\n    /**\n     * Resolves the raw class for the given {@code genericType}, using the type variable information\n     * from the {@code targetType}.\n     */\n    public static Class<?> resolveClass(Type genericType, Class<?> targetType) {\n        if (genericType instanceof Class) {\n            return (Class<?>) genericType;\n        } else if (genericType instanceof ParameterizedType) {\n            return resolveClass(((ParameterizedType) genericType).getRawType(), targetType);\n        } else if (genericType instanceof GenericArrayType) {\n            GenericArrayType arrayType = (GenericArrayType) genericType;\n            Class<?> compoment = resolveClass(arrayType.getGenericComponentType(), targetType);\n            return Array.newInstance(compoment, 0).getClass();\n        } else if (genericType instanceof TypeVariable) {\n            TypeVariable<?> variable = (TypeVariable<?>) genericType;\n            genericType = getTypeVariableMap(targetType).get(variable);\n            genericType = genericType == null ? resolveBound(variable) : resolveClass(genericType,\n                    targetType);\n        }\n\n        return genericType instanceof Class ? (Class<?>) genericType : Unknown.class;\n    }\n\n    private static Map<TypeVariable<?>, Type> getTypeVariableMap(final Class<?> targetType) {\n        Reference<Map<TypeVariable<?>, Type>> ref = typeVariableCache.get(targetType);\n        Map<TypeVariable<?>, Type> map = ref != null ? ref.get() : null;\n\n        if (map == null) {\n            map = new HashMap<>();\n\n            // Populate interfaces\n            buildTypeVariableMap(targetType.getGenericInterfaces(), map);\n\n            // Populate super classes and interfaces\n            Type genericType = targetType.getGenericSuperclass();\n            Class<?> type = targetType.getSuperclass();\n            while (type != null && !Object.class.equals(type)) {\n                if (genericType instanceof ParameterizedType)\n                    buildTypeVariableMap((ParameterizedType) genericType, map);\n                buildTypeVariableMap(type.getGenericInterfaces(), map);\n\n                genericType = type.getGenericSuperclass();\n                type = type.getSuperclass();\n            }\n\n            // Populate enclosing classes\n            type = targetType;\n            while (type.isMemberClass()) {\n                genericType = type.getGenericSuperclass();\n                if (genericType instanceof ParameterizedType)\n                    buildTypeVariableMap((ParameterizedType) genericType, map);\n\n                type = type.getEnclosingClass();\n            }\n\n            if (cacheEnabled)\n                typeVariableCache.put(targetType, new WeakReference<>(map));\n        }\n\n        return map;\n    }\n\n    /**\n     * Populates the {@code map} with with variable/argument pairs for the given {@code types}.\n     */\n    static void buildTypeVariableMap(final Type[] types, final Map<TypeVariable<?>, Type> map) {\n        for (Type type : types) {\n            if (type instanceof ParameterizedType) {\n                ParameterizedType parameterizedType = (ParameterizedType) type;\n                buildTypeVariableMap(parameterizedType, map);\n                Type rawType = parameterizedType.getRawType();\n                if (rawType instanceof Class)\n                    buildTypeVariableMap(((Class<?>) rawType).getGenericInterfaces(), map);\n            } else if (type instanceof Class) {\n                buildTypeVariableMap(((Class<?>) type).getGenericInterfaces(), map);\n            }\n        }\n    }\n\n    /**\n     * Populates the {@code typeVariableMap} with type arguments and parameters for the given\n     * {@code type}.\n     */\n    private static void buildTypeVariableMap(ParameterizedType type,\n                                             Map<TypeVariable<?>, Type> typeVariableMap) {\n        if (type.getRawType() instanceof Class) {\n            TypeVariable<?>[] typeVariables = ((Class<?>) type.getRawType()).getTypeParameters();\n            Type[] typeArguments = type.getActualTypeArguments();\n\n            for (int i = 0; i < typeArguments.length; i++) {\n                TypeVariable<?> variable = typeVariables[i];\n                Type typeArgument = typeArguments[i];\n\n                if (typeArgument instanceof Class) {\n                    typeVariableMap.put(variable, typeArgument);\n                } else if (typeArgument instanceof GenericArrayType) {\n                    typeVariableMap.put(variable, typeArgument);\n                } else if (typeArgument instanceof ParameterizedType) {\n                    typeVariableMap.put(variable, typeArgument);\n                } else if (typeArgument instanceof TypeVariable) {\n                    TypeVariable<?> typeVariableArgument = (TypeVariable<?>) typeArgument;\n                    Type resolvedType = typeVariableMap.get(typeVariableArgument);\n                    if (resolvedType == null)\n                        resolvedType = resolveBound(typeVariableArgument);\n                    typeVariableMap.put(variable, resolvedType);\n                }\n            }\n        }\n    }\n\n    /**\n     * Resolves the first bound for the {@code typeVariable}, returning {@code Unknown.class} if none\n     * can be resolved.\n     */\n    public static Type resolveBound(TypeVariable<?> typeVariable) {\n        Type[] bounds = typeVariable.getBounds();\n        if (bounds.length == 0)\n            return Unknown.class;\n\n        Type bound = bounds[0];\n        if (bound instanceof TypeVariable)\n            bound = resolveBound((TypeVariable<?>) bound);\n\n        return bound == Object.class ? Unknown.class : bound;\n    }\n}\n",
      "file_name": "TypeResolver.java",
      "human_label": "Resolve and return the arguments for the genericType using the type variable information for the targetType. Returns null if  genericType is not parameterized or if arguments cannot be resolved.",
      "level": "class_runnable",
      "lineno": "138",
      "name": "resolveArguments",
      "oracle_context": "{ \"apis\" : \"[getActualTypeArguments, resolveClass]\", \"classes\" : \"[Class<?>[], ParameterizedType, Type[]]\", \"vars\" : \"[length]\" }",
      "package": "org.atmosphere.config.managed",
      "project": "atmosphere-atmosphere-2.7.x"
    },
    {
      "_id": "636767e11a6d9265ec018781",
      "all_context": "{ \"class_level\" : \"import java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.stream.Collectors;\\nimport org.apache.skywalking.oap.server.core.analysis.metrics.Metrics;\\nMap<String,METRICS> buffer;\\nMergableBufferedData();\\nread();\\n\", \"repo_level\" : \"public interface Metrics {abstract boolean combine(Metrics metrics);\\nabstract void calculate();\\nabstract Metrics toHour();\\nabstract Metrics toDay();\\npublic void setLastUpdateTimestamp(long timestamp);\\npublic boolean isExpired(long timestamp,long expiredThreshold);\\npublic long toTimeBucketInHour();\\npublic long toTimeBucketInDay();\\nprotected long getDurationInMinute();\\npublic String id();\\nabstract String id0();\\n }\\n\" }",
      "class_name": "MergableBufferedData",
      "code": "@Override public void accept(final METRICS data){\n  final String id=data.id();\n  final METRICS existed=buffer.get(id);\n  if (existed == null) {\n    buffer.put(id,data);\n  }\n else {\n    final boolean isAbandoned=!existed.combine(data);\n    if (isAbandoned) {\n      buffer.remove(id);\n    }\n  }\n}\n",
      "docstring": "/** \n * Accept the data into the cache and merge with the existing value. This method is not thread safe, should avoid concurrency calling.\n * @param data to be added potentially.\n */\n",
      "end_lineno": "59",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage org.apache.skywalking.oap.server.core.analysis.data;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport org.apache.skywalking.oap.server.core.analysis.metrics.Metrics;\n\n/**\n * MergableBufferedData is a thread no safe implementation of {@link BufferedData}. {@link Metrics} in this cache would\n * be {@link Metrics#combine(Metrics)} if their {@link Metrics#id()}s are same.\n *\n * Concurrency {@link #accept(Metrics)}s and {@link #read()} while {@link #accept(Metrics)} are both not recommended.\n */\npublic class MergableBufferedData<METRICS extends Metrics> implements BufferedData<METRICS> {\n    private Map<String, METRICS> buffer;\n\n    public MergableBufferedData() {\n        buffer = new HashMap<>();\n    }\n\n    /**\n     * Accept the data into the cache and merge with the existing value.\n     *\n     * This method is not thread safe, should avoid concurrency calling.\n     *\n     * @param data to be added potentially.\n     */\n    @Override\n    public void accept(final METRICS data) {\n        final String id = data.id();\n        final METRICS existed = buffer.get(id);\n        if (existed == null) {\n            buffer.put(id, data);\n        } else {\n            final boolean isAbandoned = !existed.combine(data);\n            if (isAbandoned) {\n                buffer.remove(id);\n            }\n        }\n    }\n\n    @Override\n    public List<METRICS> read() {\n        try {\n            return buffer.values().stream().collect(Collectors.toList());\n        } finally {\n            buffer.clear();\n        }\n    }\n}\n",
      "file_name": "MergableBufferedData.java",
      "human_label": "Accept the data into the buffer if its id does not exist in the buffer. Otherwise try to combine it with the existing value, and remove it if the combined is abandoned.",
      "level": "self_contained",
      "lineno": "40",
      "name": "accept",
      "oracle_context": "{ \"apis\" : \"[get, put, combine, remove]\", \"classes\" : \"[String, METRICS]\", \"vars\" : \"[buffer]\" }",
      "package": "org.apache.skywalking.oap.server.core.analysis.data",
      "project": "skywalking-master"
    },
    {
      "_id": "636767531a6d9265ec017efb",
      "all_context": "{ \"class_level\" : \"import java.util.Collection;\\nimport java.util.HashSet;\\nimport java.util.LinkedHashSet;\\nimport java.util.Map;\\nimport java.util.NoSuchElementException;\\nimport java.util.Set;\\nimport org.jgrapht.Graph;\\nimport org.jgrapht.GraphTests;\\nimport org.jgrapht.Graphs;\\nimport org.jgrapht.util.CollectionUtil;\\nBucketList bucketList;\\nV current;\\nBucket head;\\nMap<V,Bucket> bucketMap;\\nBucket next;\\nBucket prev;\\nSet<V> vertices;\\nLexBreadthFirstIterator(Graph graph);\\nnext();\\nisCrossComponentTraversal();\\nsetCrossComponentTraversal(boolean crossComponentTraversal);\\nadvance();\\ngetUnvisitedNeighbours(V vertex);\\nBucketList(Collection vertices);\\ncontainsBucketWith(V vertex);\\npoll();\\nupdateBuckets(Set vertices);\\nBucket(Collection vertices);\\nBucket(V vertex);\\nremoveVertex(V vertex);\\nremoveSelf();\\ninsertBefore(Bucket bucket);\\naddVertex(V vertex);\\nisEmpty();\\nhasNext();\\n\", \"repo_level\" : \"public interface Graph { Set<E> getAllEdges(V sourceVertex,V targetVertex);\\n E getEdge(V sourceVertex,V targetVertex);\\n Supplier<V> getVertexSupplier();\\n Supplier<E> getEdgeSupplier();\\n E addEdge(V sourceVertex,V targetVertex);\\n boolean addEdge(V sourceVertex,V targetVertex,E e);\\n V addVertex();\\n boolean addVertex(V v);\\n boolean containsEdge(V sourceVertex,V targetVertex);\\n boolean containsEdge(E e);\\n boolean containsVertex(V v);\\n Set<E> edgeSet();\\n int degreeOf(V vertex);\\n Set<E> edgesOf(V vertex);\\n int inDegreeOf(V vertex);\\n Set<E> incomingEdgesOf(V vertex);\\n int outDegreeOf(V vertex);\\n Set<E> outgoingEdgesOf(V vertex);\\n boolean removeAllEdges(Collection edges);\\n Set<E> removeAllEdges(V sourceVertex,V targetVertex);\\n boolean removeAllVertices(Collection vertices);\\n E removeEdge(V sourceVertex,V targetVertex);\\n boolean removeEdge(E e);\\n boolean removeVertex(V v);\\n Set<V> vertexSet();\\n V getEdgeSource(E e);\\n V getEdgeTarget(E e);\\n GraphType getType();\\n double getEdgeWeight(E e);\\n void setEdgeWeight(E e,double weight);\\ndefault void setEdgeWeight(V sourceVertex,V targetVertex,double weight);\\ndefault GraphIterables<V,E> iterables();\\n }\\npublic interface Graphs {static E addEdge(Graph g,V sourceVertex,V targetVertex,double weight);\\nstatic E addEdgeWithVertices(Graph g,V sourceVertex,V targetVertex);\\nstatic boolean addEdgeWithVertices(Graph targetGraph,Graph sourceGraph,E edge);\\nstatic E addEdgeWithVertices(Graph g,V sourceVertex,V targetVertex,double weight);\\nstatic boolean addGraph(Graph destination,Graph source);\\nstatic void addGraphReversed(Graph destination,Graph source);\\nstatic boolean addAllEdges(Graph destination,Graph source,Collection edges);\\nstatic boolean addAllVertices(Graph destination,Collection vertices);\\nstatic List<V> neighborListOf(Graph g,V vertex);\\nstatic Set<V> neighborSetOf(Graph g,V vertex);\\nstatic List<V> predecessorListOf(Graph g,V vertex);\\nstatic List<V> successorListOf(Graph g,V vertex);\\nstatic Graph<V,E> undirectedGraph(Graph g);\\nstatic boolean testIncidence(Graph g,E e,V v);\\nstatic V getOppositeVertex(Graph g,E e,V v);\\nstatic boolean removeVertexAndPreserveConnectivity(Graph graph,V vertex);\\nstatic boolean removeVerticesAndPreserveConnectivity(Graph graph,Predicate predicate);\\nstatic boolean removeVertexAndPreserveConnectivity(Graph graph,Iterable vertices);\\nstatic void addOutgoingEdges(Graph graph,V source,Iterable targets);\\nstatic void addIncomingEdges(Graph graph,V target,Iterable sources);\\nstatic boolean vertexHasSuccessors(Graph graph,V vertex);\\nstatic boolean vertexHasPredecessors(Graph graph,V vertex);\\nstatic VertexToIntegerMapping<V> getVertexToIntegerMapping(Graph graph);\\n }\\npublic interface CollectionUtil {static HashMap<K,V> newHashMapWithExpectedSize(int expectedSize);\\nstatic LinkedHashMap<K,V> newLinkedHashMapWithExpectedSize(int expectedSize);\\nstatic HashSet<E> newHashSetWithExpectedSize(int expectedSize);\\nstatic LinkedHashSet<E> newLinkedHashSetWithExpectedSize(int expectedSize);\\nstatic E getElement(Iterable iterable,int index);\\n }\\n\" }",
      "class_name": "LexBreadthFirstIterator$BucketList",
      "code": "void insertBefore(Bucket bucket){\n  this.next=bucket;\n  if (bucket != null) {\n    this.prev=bucket.prev;\n    if (bucket.prev != null) {\n      bucket.prev.next=this;\n    }\n    bucket.prev=this;\n  }\n else {\n    this.prev=null;\n  }\n}\n",
      "docstring": "/** \n * Inserts this bucket in the data structure before the  {@code bucket}.\n * @param bucket the bucket, that will be the next to this bucket.\n */\n",
      "end_lineno": "375",
      "file_content": "/*\n * (C) Copyright 2018-2021, by Timofey Chudakov and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.traverse;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport org.jgrapht.Graph;\nimport org.jgrapht.GraphTests;\nimport org.jgrapht.Graphs;\nimport org.jgrapht.util.CollectionUtil;\n\n/**\n * A lexicographical breadth-first iterator for an undirected graph.\n * <p>\n * Every vertex has an implicit label (they aren't used explicitly in order to reduce time and\n * memory complexity). When some vertex is returned by this iterator, its index is the number of\n * vertices in this graph minus number of already returned vertices. For a given vertex v its label\n * is a concatenation of indices of already returned vertices, that were also its neighbours, with\n * some separator between them. For example, 7#4#3 is a valid vertex label.\n * <p>\n * Iterator chooses vertex with lexicographically largest label and returns it. It breaks ties\n * arbitrarily. For more information on lexicographical BFS see the following article: Corneil D.G.\n * (2004) <a href=\"https://pdfs.semanticscholar.org/d4b5/a492f781f23a30773841ec79c46d2ec2eb9c.pdf\">\n * <i>Lexicographic Breadth First Search – A Survey</i></a>. In: Hromkovič J., Nagl M., Westfechtel\n * B. (eds) Graph-Theoretic Concepts in Computer Science. WG 2004. Lecture Notes in Computer\n * Science, vol 3353. Springer, Berlin, Heidelberg; and the following\n * paper:<a href=\"http://www.cse.iitd.ac.in/~naveen/courses/CSL851/uwaterloo.pdf\"><i>CS 762:\n * Graph-theoretic algorithms. Lecture notes of a graduate course. University of Waterloo</i></a>.\n * <p>\n * For this iterator to work correctly the graph must not be modified during iteration. Currently\n * there are no means to ensure that, nor to fail-fast. The results of such modifications are\n * undefined.\n * <p>\n * Note: only vertex events are fired by this iterator.\n *\n * @param <V> the graph vertex type.\n * @param <E> the graph edge type.\n * @author Timofey Chudakov\n */\npublic class LexBreadthFirstIterator<V, E>\n    extends\n    AbstractGraphIterator<V, E>\n{\n\n    /**\n     * Reference to the {@code BucketList} that contains unvisited vertices.\n     */\n    private BucketList bucketList;\n\n    /**\n     * Contains current vertex of the {@code graph}.\n     */\n    private V current;\n\n    /**\n     * Creates new lexicographical breadth-first iterator for {@code graph}.\n     *\n     * @param graph the graph to be iterated.\n     */\n    public LexBreadthFirstIterator(Graph<V, E> graph)\n    {\n        super(graph);\n        GraphTests.requireUndirected(graph);\n        bucketList = new BucketList(graph.vertexSet());\n    }\n\n    /**\n     * Checks whether there exist unvisited vertices.\n     *\n     * @return true if there exist unvisited vertices.\n     */\n    @Override\n    public boolean hasNext()\n    {\n        if (current != null) {\n            return true;\n        }\n        current = advance();\n        if (current != null && nListeners != 0) {\n            fireVertexTraversed(createVertexTraversalEvent(current));\n        }\n        return current != null;\n    }\n\n    /**\n     * Returns the next vertex in the ordering.\n     *\n     * @return the next vertex in the ordering.\n     */\n    @Override\n    public V next()\n    {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        V result = current;\n        current = null;\n        if (nListeners != 0) {\n            fireVertexFinished(createVertexTraversalEvent(result));\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Always returns true since this iterator doesn't care about connected components.\n     */\n    @Override\n    public boolean isCrossComponentTraversal()\n    {\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Trying to disable the cross components nature of this iterator will result into throwing a\n     * {@link IllegalArgumentException}.\n     */\n    @Override\n    public void setCrossComponentTraversal(boolean crossComponentTraversal)\n    {\n        if (!crossComponentTraversal) {\n            throw new IllegalArgumentException(\"Iterator is always cross-component\");\n        }\n    }\n\n    /**\n     * Retrieves vertex from the {@code bucketList} and returns it.\n     *\n     * @return the vertex retrieved from the {@code bucketList}.\n     */\n    private V advance()\n    {\n        V vertex = bucketList.poll();\n        if (vertex != null) {\n            bucketList.updateBuckets(getUnvisitedNeighbours(vertex));\n        }\n        return vertex;\n    }\n\n    /**\n     * Computes and returns neighbours of {@code vertex} which haven't been visited by this\n     * iterator.\n     *\n     * @param vertex the vertex, whose neighbours are being explored.\n     * @return neighbours of {@code vertex} which have yet to be visited by this iterator.\n     */\n    private Set<V> getUnvisitedNeighbours(V vertex)\n    {\n        Set<V> unmapped = new LinkedHashSet<>();\n        Set<E> edges = graph.edgesOf(vertex);\n        for (E edge : edges) {\n            V oppositeVertex = Graphs.getOppositeVertex(graph, edge, vertex);\n            if (bucketList.containsBucketWith(oppositeVertex)) {\n                unmapped.add(oppositeVertex);\n            }\n        }\n        return unmapped;\n    }\n\n    /**\n     * Data structure for performing lexicographical breadth-first search. Allows to add and\n     * retrieve vertices from buckets, update their buckets after a new vertex has been added to the\n     * LexBFS order. Labels aren't used explicitly, which results in time and space optimization.\n     *\n     * @author Timofey Chudakov\n     */\n    class BucketList\n    {\n        /**\n         * Bucket with the vertices that have lexicographically largest label.\n         */\n        private Bucket head;\n        /**\n         * Map for mapping vertices to buckets they are currently in. Is used for finding the bucket\n         * of the vertex in constant time.\n         */\n        private Map<V, Bucket> bucketMap;\n\n        /**\n         * Creates a {@code BucketList} with a single bucket and all specified {@code vertices} in\n         * it.\n         *\n         * @param vertices the vertices of the graph, that should be stored in the {@code head}\n         *        bucket.\n         */\n        BucketList(Collection<V> vertices)\n        {\n            head = new Bucket(vertices);\n            bucketMap = CollectionUtil.newHashMapWithExpectedSize(vertices.size());\n            for (V vertex : vertices) {\n                bucketMap.put(vertex, head);\n            }\n        }\n\n        /**\n         * Checks whether there exists a bucket with the specified {@code vertex}.\n         *\n         * @param vertex the vertex whose presence in some {@code Bucket} in this {@code BucketList}\n         *        is checked.\n         * @return <tt>true</tt> if there exists a bucket with {@code vertex} in it, otherwise\n         *         <tt>false</tt>.\n         */\n        boolean containsBucketWith(V vertex)\n        {\n            return bucketMap.containsKey(vertex);\n        }\n\n        /**\n         * Retrieves element from the head bucket by invoking {@link Bucket#poll()} or null if this\n         * {@code BucketList} is empty.\n         * <p>\n         * Removes the head bucket if it becomes empty after the operation.\n         *\n         * @return vertex returned by {@link Bucket#poll()} invoked on head bucket or null if this\n         *         {@code BucketList} is empty.\n         */\n        V poll()\n        {\n            if (bucketMap.size() > 0) {\n                V res = head.poll();\n                bucketMap.remove(res);\n                if (head.isEmpty()) {\n                    head = head.next;\n                    if (head != null) {\n                        head.prev = null;\n                    }\n                }\n                return res;\n            } else {\n                return null;\n            }\n        }\n\n        /**\n         * For every bucket B in this {@code BucketList}, which contains vertices from the set\n         * {@code\n         * vertices}, creates a new {@code Bucket} B' and moves vertices from B to B' according to\n         * the following rule: $B' = B\\cap vertices$ and $B = B\\backslash B'$. For every such\n         * {@code Bucket} B only one {@code Bucket} B' is created. If some bucket B becomes empty\n         * after this operation, it is removed from the data structure.\n         *\n         * @param vertices the vertices, that should be moved to new buckets.\n         */\n        void updateBuckets(Set<V> vertices)\n        {\n            Set<Bucket> visitedBuckets = new HashSet<>();\n            for (V vertex : vertices) {\n                Bucket bucket = bucketMap.get(vertex);\n                if (visitedBuckets.contains(bucket)) {\n                    bucket.prev.addVertex(vertex);\n                    bucketMap.put(vertex, bucket.prev);\n                } else {\n                    visitedBuckets.add(bucket);\n                    Bucket newBucket = new Bucket(vertex);\n                    newBucket.insertBefore(bucket);\n                    bucketMap.put(vertex, newBucket);\n                    if (head == bucket) {\n                        head = newBucket;\n                    }\n                }\n                bucket.removeVertex(vertex);\n                if (bucket.isEmpty()) {\n                    visitedBuckets.remove(bucket);\n                    bucket.removeSelf();\n                }\n            }\n        }\n\n        /**\n         * Plays the role of the container of vertices. All vertices stored in a bucket have\n         * identical label. Labels aren't used explicitly.\n         * <p>\n         * Encapsulates operations of addition and removal of vertices from the bucket and removal\n         * of a bucket from the data structure.\n         */\n        private class Bucket\n        {\n            /**\n             * Reference of the bucket with lexicographically smaller label.\n             */\n            private Bucket next;\n            /**\n             * Reference of the bucket with lexicographically larger label.\n             */\n            private Bucket prev;\n            /**\n             * Set of vertices currently stored in this bucket.\n             */\n            private Set<V> vertices;\n\n            /**\n             * Creates a new bucket with all {@code vertices} stored in it.\n             *\n             * @param vertices vertices to store in this bucket.\n             */\n            Bucket(Collection<V> vertices)\n            {\n                this.vertices = new LinkedHashSet<>(vertices);\n            }\n\n            /**\n             * Creates a new Bucket with a single {@code vertex} in it.\n             *\n             * @param vertex the vertex to store in this bucket.\n             */\n            Bucket(V vertex)\n            {\n                this.vertices = new LinkedHashSet<>();\n                vertices.add(vertex);\n            }\n\n            /**\n             * Removes the {@code vertex} from this bucket.\n             *\n             * @param vertex the vertex to remove.\n             */\n            void removeVertex(V vertex)\n            {\n                vertices.remove(vertex);\n            }\n\n            /**\n             * Removes this bucket from the data structure.\n             */\n            void removeSelf()\n            {\n                if (next != null) {\n                    next.prev = prev;\n                }\n                if (prev != null) {\n                    prev.next = next;\n                }\n            }\n\n            /**\n             * Inserts this bucket in the data structure before the {@code bucket}.\n             *\n             * @param bucket the bucket, that will be the next to this bucket.\n             */\n            void insertBefore(Bucket bucket)\n            {\n                this.next = bucket;\n                if (bucket != null) {\n                    this.prev = bucket.prev;\n                    if (bucket.prev != null) {\n                        bucket.prev.next = this;\n                    }\n                    bucket.prev = this;\n                } else {\n                    this.prev = null;\n                }\n            }\n\n            /**\n             * Adds the {@code vertex} to this bucket.\n             *\n             * @param vertex the vertex to add.\n             */\n            void addVertex(V vertex)\n            {\n                vertices.add(vertex);\n            }\n\n            /**\n             * Retrieves one vertex from this bucket.\n             *\n             * @return vertex, that was removed from this bucket, null if the bucket was empty.\n             */\n            V poll()\n            {\n                if (vertices.isEmpty()) {\n                    return null;\n                } else {\n                    V vertex = vertices.iterator().next();\n                    vertices.remove(vertex);\n                    return vertex;\n                }\n            }\n\n            /**\n             * Checks whether this bucket is empty.\n             *\n             * @return <tt>true</tt> if this bucket doesn't contain any elements, otherwise false.\n             */\n            boolean isEmpty()\n            {\n                return vertices.size() == 0;\n            }\n        }\n    }\n}\n",
      "file_name": "LexBreadthFirstIterator.java",
      "human_label": "Insert this bucket in the data structure before the given bucket.",
      "level": "class_runnable",
      "lineno": "358",
      "name": "insertBefore",
      "oracle_context": "{ \"apis\" : \"[Bucket, next]\", \"classes\" : \"[bucket.prev]\", \"vars\" : \"[prev, next]\" }",
      "package": "org.jgrapht.traverse",
      "project": "jgrapht-master"
    },
    {
      "_id": "636766f11a6d9265ec017641",
      "all_context": "{ \"class_level\" : \"import java.io.*;\\nReader reader;\\nByteArrayOutputStream byteArrayOut;\\nWriter writer;\\nchar[] chars;\\nbyte[] buffer;\\nint index;\\nint length;\\nReaderInputStream(String readerString);\\nReaderInputStream(Reader reader);\\nReaderInputStream(Reader reader,String encoding);\\nfillBuffer();\\nread(byte[] data,int off,int len);\\navailable();\\nclose();\\nread();\\n\", \"repo_level\" : \"\" }",
      "class_name": "ReaderInputStream",
      "code": "@Override public int available() throws IOException {\n  return this.index < this.length ? this.length - this.index : this.length >= 0 && this.reader.ready() ? 1 : 0;\n}\n",
      "docstring": "/** \n * @see InputStream#available() \n */\n",
      "end_lineno": "117",
      "file_content": "/*\n * Copyright 2008-2009 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.io.input;\nimport java.io.*;\n\n/**\n * 使用InputStream读取Reader的工具类\n * @version 2009-5-13\n * @author 网络收集\n */\npublic class ReaderInputStream extends InputStream {\n    private Reader                reader        = null;\n    private ByteArrayOutputStream byteArrayOut  = null;\n    private Writer                writer        = null;\n    private char[]                chars         = null;\n    private byte[]                buffer        = null;\n    private int                   index, length = 0;\n    //========================================================================================\n\n    /**\n     * 带Reader参数构造函数\n     * @param readerString - 要阅读的字符串。\n     */\n    public ReaderInputStream(final String readerString) {\n        this.reader = new StringReader(readerString);\n        this.byteArrayOut = new ByteArrayOutputStream();\n        this.writer = new OutputStreamWriter(this.byteArrayOut);\n        this.chars = new char[1024];\n    }\n\n    /**\n     * 带Reader参数构造函数\n     * @param reader - InputStream使用的Reader\n     */\n    public ReaderInputStream(final Reader reader) {\n        this.reader = reader;\n        this.byteArrayOut = new ByteArrayOutputStream();\n        this.writer = new OutputStreamWriter(this.byteArrayOut);\n        this.chars = new char[1024];\n    }\n\n    /**\n     * 带Reader和字符编码格式参数的构造函数\n     * @param reader   - InputStream使用的Reader\n     * @param encoding - InputStream使用的字符编码格式.\n     * @throws UnsupportedEncodingException 如果字符编码格式不支持,则抛 UnsupportedEncodingException 异常\n     */\n    public ReaderInputStream(final Reader reader, final String encoding) throws UnsupportedEncodingException {\n        this.reader = reader;\n        this.byteArrayOut = new ByteArrayOutputStream();\n        this.writer = new OutputStreamWriter(this.byteArrayOut, encoding);\n        this.chars = new char[1024];\n    }\n    //========================================================================================\n\n    /** @see InputStream#read() */\n    @Override\n    public int read() throws IOException {\n        if (this.index >= this.length) {\n            this.fillBuffer();\n        }\n        if (this.index >= this.length) {\n            return -1;\n        }\n        return 0xff & this.buffer[this.index++];\n    }\n\n    private void fillBuffer() throws IOException {\n        if (this.length < 0) {\n            return;\n        }\n        int numChars = this.reader.read(this.chars);\n        if (numChars < 0) {\n            this.length = -1;\n        } else {\n            this.byteArrayOut.reset();\n            this.writer.write(this.chars, 0, numChars);\n            this.writer.flush();\n            this.buffer = this.byteArrayOut.toByteArray();\n            this.length = this.buffer.length;\n            this.index = 0;\n        }\n    }\n\n    /** @see InputStream#read(byte[], int, int) */\n    @Override\n    public int read(final byte[] data, final int off, final int len) throws IOException {\n        if (this.index >= this.length) {\n            this.fillBuffer();\n        }\n        if (this.index >= this.length) {\n            return -1;\n        }\n        int amount = Math.min(len, this.length - this.index);\n        System.arraycopy(this.buffer, this.index, data, off, amount);\n        this.index += amount;\n        return amount;\n    }\n\n    /** @see InputStream#available() */\n    @Override\n    public int available() throws IOException {\n        return this.index < this.length ? this.length - this.index : this.length >= 0 && this.reader.ready() ? 1 : 0;\n    }\n\n    /** @see InputStream#close() */\n    @Override\n    public void close() throws IOException {\n        this.reader.close();\n    }\n}\n",
      "file_name": "ReaderInputStream.java",
      "human_label": "Check the available space of this InputStream according to the index.",
      "level": "class_runnable",
      "lineno": "113",
      "name": "available",
      "oracle_context": "{ \"apis\" : \"[ready]\", \"classes\" : \"[]\", \"vars\" : \"[index, length, reader]\" }",
      "package": "net.hasor.utils.io.input",
      "project": "hasor-master"
    },
    {
      "_id": "636767de1a6d9265ec018706",
      "all_context": "{ \"class_level\" : \"import java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.Objects;\\nimport java.util.stream.Collectors;\\nimport org.apache.skywalking.library.elasticsearch.response.Mappings;\\nimport org.apache.skywalking.oap.server.library.client.elasticsearch.ElasticSearchClient;\\nMap<String,Fields> structures;\\nMap<String,Object> properties;\\nMappings.Source source;\\nIndexStructures();\\ngetMapping(String tableName);\\ndiffStructure(String tableName,Mappings mappings);\\ncontainsStructure(String tableName,Mappings mappings);\\nFields(Mappings mapping);\\ncontainsAllFields(Fields fields);\\nappendNewFields(Fields fields);\\ndiffFields(Fields fields);\\nputStructure(String tableName,Mappings mapping);\\n\", \"repo_level\" : \"public interface Mappings { }\\npublic interface ElasticSearchClient {public void connect();\\npublic void shutdown();\\npublic void registerChecker(HealthChecker healthChecker);\\npublic boolean createIndex(String indexName);\\npublic boolean createIndex(String indexName,Mappings mappings,Map settings);\\npublic boolean updateIndexMapping(String indexName,Mappings mapping);\\npublic Optional<Index> getIndex(String indexName);\\npublic Collection<String> retrievalIndexByAliases(String alias);\\npublic boolean deleteByIndexName(String indexName);\\npublic boolean isExistsIndex(String indexName);\\npublic Optional<IndexTemplate> getTemplate(String name);\\npublic boolean isExistsTemplate(String indexName);\\npublic boolean createOrUpdateTemplate(String indexName,Map settings,Mappings mapping,int order);\\npublic boolean deleteTemplate(String indexName);\\npublic SearchResponse search(Supplier indices,Search search);\\npublic SearchResponse search(String indexName,Search search);\\npublic SearchResponse search(String indexName,Search search,SearchParams params);\\npublic SearchResponse scroll(Duration contextRetention,String scrollId);\\npublic boolean deleteScrollContextQuietly(String scrollId);\\npublic Optional<Document> get(String indexName,String id);\\npublic boolean existDoc(String indexName,String id);\\npublic Optional<Documents> ids(Map indexIds);\\npublic SearchResponse searchIDs(String indexName,Iterable ids);\\npublic void forceInsert(String indexName,String id,Map source);\\npublic void forceUpdate(String indexName,String id,Map source);\\npublic IndexRequestWrapper prepareInsert(String indexName,String id,Map source);\\npublic UpdateRequestWrapper prepareUpdate(String indexName,String id,Map source);\\npublic BulkProcessor createBulkProcessor(int bulkActions,int flushInterval,int concurrentRequests);\\npublic String formatIndexName(String indexName);\\n }\\n\" }",
      "class_name": "IndexStructures",
      "code": "public Mappings diffStructure(String tableName,Mappings mappings){\n  if (!structures.containsKey(tableName)) {\n    return new Mappings();\n  }\n  Map<String,Object> properties=mappings.getProperties();\n  Map<String,Object> diffProperties=structures.get(tableName).diffFields(new Fields(mappings));\n  return Mappings.builder().type(ElasticSearchClient.TYPE).properties(diffProperties).build();\n}\n",
      "docstring": "/** \n * Returns mappings with fields that not exist in the input mappings. The input mappings should be history mapping from current index. Do not return _source config to avoid current index update conflict.\n */\n",
      "end_lineno": "83",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage org.apache.skywalking.oap.server.storage.plugin.elasticsearch.base;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\nimport org.apache.skywalking.library.elasticsearch.response.Mappings;\nimport org.apache.skywalking.oap.server.library.client.elasticsearch.ElasticSearchClient;\n\npublic class IndexStructures {\n    private final Map<String, Fields> structures;\n\n    public IndexStructures() {\n        this.structures = new HashMap<>();\n    }\n\n    public Mappings getMapping(String tableName) {\n        Map<String, Object> properties =\n            structures.containsKey(tableName) ?\n                structures.get(tableName).properties : new HashMap<>();\n        Mappings.Source source =\n                    structures.containsKey(tableName) ?\n                        structures.get(tableName).source : new Mappings.Source();\n        return Mappings.builder()\n                       .type(ElasticSearchClient.TYPE)\n                       .properties(properties)\n                       .source(source)\n                       .build();\n    }\n\n    /**\n     * Add or append field when the current structures don't contain the input structure or having\n     * new fields in it.\n     */\n    public void putStructure(String tableName, Mappings mapping) {\n        if (Objects.isNull(mapping)\n            || Objects.isNull(mapping.getProperties())\n            || mapping.getProperties().isEmpty()) {\n            return;\n        }\n        Fields fields = new Fields(mapping);\n        if (structures.containsKey(tableName)) {\n            structures.get(tableName).appendNewFields(fields);\n        } else {\n            structures.put(tableName, fields);\n        }\n    }\n\n    /**\n     * Returns mappings with fields that not exist in the input mappings.\n     * The input mappings should be history mapping from current index.\n     * Do not return _source config to avoid current index update conflict.\n     */\n    public Mappings diffStructure(String tableName, Mappings mappings) {\n        if (!structures.containsKey(tableName)) {\n            return new Mappings();\n        }\n        Map<String, Object> properties = mappings.getProperties();\n        Map<String, Object> diffProperties =\n            structures.get(tableName).diffFields(new Fields(mappings));\n        return Mappings.builder()\n                       .type(ElasticSearchClient.TYPE)\n                       .properties(diffProperties)\n                       .build();\n    }\n\n    /**\n     * Returns true when the current structures already contains the properties of the input\n     * mappings.\n     */\n    public boolean containsStructure(String tableName, Mappings mappings) {\n        if (Objects.isNull(mappings) ||\n            Objects.isNull(mappings.getProperties()) ||\n            mappings.getProperties().isEmpty()) {\n            return true;\n        }\n        return structures.containsKey(tableName)\n            && structures.get(tableName)\n                         .containsAllFields(new Fields(mappings));\n    }\n\n    /**\n     * The properties of the template or index.\n     */\n    public static class Fields {\n        private final Map<String, Object> properties;\n        private Mappings.Source source;\n\n        private Fields(Mappings mapping) {\n            this.properties = mapping.getProperties();\n            this.source = mapping.getSource();\n        }\n\n        /**\n         * Returns ture when the input fields have already been stored in the properties.\n         */\n        private boolean containsAllFields(Fields fields) {\n            if (this.properties.size() < fields.properties.size()) {\n                return false;\n            }\n            boolean isContains = fields.properties.entrySet().stream()\n                    .allMatch(item -> Objects.equals(properties.get(item.getKey()), item.getValue()));\n            if (!isContains) {\n                return false;\n            }\n            return fields.source.getExcludes().containsAll(this.source.getExcludes());\n        }\n\n        /**\n         * Append new fields and update.\n         * Properties combine input and exist, update property's attribute, won't remove old one.\n         * Source will be updated to the input.\n         */\n        private void appendNewFields(Fields fields) {\n            properties.putAll(fields.properties);\n            source = fields.source;\n        }\n\n        /**\n         * Returns the properties that not exist in the input fields.\n         */\n        private Map<String, Object> diffFields(Fields fields) {\n            return this.properties.entrySet().stream()\n                                  .filter(e -> !fields.properties.containsKey(e.getKey()))\n                                  .collect(Collectors.toMap(\n                                      Map.Entry::getKey,\n                                      Map.Entry::getValue\n                                  ));\n        }\n    }\n}\n",
      "file_name": "IndexStructures.java",
      "human_label": "Return mappings with fields that do not exist in the input mappings. The input mappings should be history mapping from the current index.",
      "level": "plib_runnable",
      "lineno": "67",
      "name": "diffStructure",
      "oracle_context": "{ \"apis\" : \"[containsKey, getProperties, diffFields, get, build, type, builder, Fields]\", \"classes\" : \"[Map<String,Object>, ElasticSearchClient]\", \"vars\" : \"[TYPE, structures]\" }",
      "package": "org.apache.skywalking.oap.server.storage.plugin.elasticsearch.base",
      "project": "skywalking-master"
    },
    {
      "_id": "636767dd1a6d9265ec0186e5",
      "all_context": "{ \"class_level\" : \"import java.util.ArrayList;\\nimport java.util.List;\\nimport org.apache.skywalking.oap.server.library.datacarrier.buffer.Channels;\\nimport org.apache.skywalking.oap.server.library.datacarrier.buffer.QueueBuffer;\\nboolean running;\\nArrayList<Group> consumeTargets;\\nlong size;\\nlong consumeCycle;\\nChannels channels;\\nIConsumer consumer;\\nMultipleChannelsConsumer(String threadName,long consumeCycle);\\nrun();\\nconsume(Group target,List consumeList);\\nsize();\\nshutdown();\\nGroup(Channels channels,IConsumer consumer);\\n\", \"repo_level\" : \"public interface Channels {public boolean save(T data);\\npublic void setPartitioner(IDataPartitioner dataPartitioner);\\npublic void setStrategy(BufferStrategy strategy);\\npublic int getChannelSize();\\npublic long size();\\npublic QueueBuffer<T> getBuffer(int index);\\n }\\npublic interface QueueBuffer { boolean save(T data);\\n void setStrategy(BufferStrategy strategy);\\n void obtain(List consumeList);\\n int getBufferSize();\\n }\\n\" }",
      "class_name": "MultipleChannelsConsumer",
      "code": "public void addNewTarget(Channels channels,IConsumer consumer){\n  Group group=new Group(channels,consumer);\n  ArrayList<Group> newList=new ArrayList<Group>();\n  for (  Group target : consumeTargets) {\n    newList.add(target);\n  }\n  newList.add(group);\n  consumeTargets=newList;\n  size+=channels.size();\n}\n",
      "docstring": "/** \n * Add a new target channels.\n */\n",
      "end_lineno": "105",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage org.apache.skywalking.oap.server.library.datacarrier.consumer;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.skywalking.oap.server.library.datacarrier.buffer.Channels;\nimport org.apache.skywalking.oap.server.library.datacarrier.buffer.QueueBuffer;\n\n/**\n * MultipleChannelsConsumer represent a single consumer thread, but support multiple channels with their {@link\n * IConsumer}s\n */\npublic class MultipleChannelsConsumer extends Thread {\n    private volatile boolean running;\n    private volatile ArrayList<Group> consumeTargets;\n    @SuppressWarnings(\"NonAtomicVolatileUpdate\")\n    private volatile long size;\n    private final long consumeCycle;\n\n    public MultipleChannelsConsumer(String threadName, long consumeCycle) {\n        super(threadName);\n        this.consumeTargets = new ArrayList<>();\n        this.consumeCycle = consumeCycle;\n    }\n\n    @Override\n    public void run() {\n        running = true;\n\n        final List consumeList = new ArrayList(2000);\n        while (running) {\n            boolean hasData = false;\n            for (Group target : consumeTargets) {\n                boolean consumed = consume(target, consumeList);\n                hasData = hasData || consumed;\n            }\n\n            if (!hasData) {\n                try {\n                    Thread.sleep(consumeCycle);\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n\n        // consumer thread is going to stop\n        // consume the last time\n        for (Group target : consumeTargets) {\n            consume(target, consumeList);\n\n            target.consumer.onExit();\n        }\n    }\n\n    private boolean consume(Group target, List consumeList) {\n        for (int i = 0; i < target.channels.getChannelSize(); i++) {\n            QueueBuffer buffer = target.channels.getBuffer(i);\n            buffer.obtain(consumeList);\n        }\n\n        if (!consumeList.isEmpty()) {\n            try {\n                target.consumer.consume(consumeList);\n            } catch (Throwable t) {\n                target.consumer.onError(consumeList, t);\n            } finally {\n                consumeList.clear();\n            }\n            return true;\n        }\n        target.consumer.nothingToConsume();\n        return false;\n    }\n\n    /**\n     * Add a new target channels.\n     */\n    public void addNewTarget(Channels channels, IConsumer consumer) {\n        Group group = new Group(channels, consumer);\n        // Recreate the new list to avoid change list while the list is used in consuming.\n        ArrayList<Group> newList = new ArrayList<Group>();\n        for (Group target : consumeTargets) {\n            newList.add(target);\n        }\n        newList.add(group);\n        consumeTargets = newList;\n        size += channels.size();\n    }\n\n    public long size() {\n        return size;\n    }\n\n    void shutdown() {\n        running = false;\n    }\n\n    private static class Group {\n        private Channels channels;\n        private IConsumer consumer;\n\n        public Group(Channels channels, IConsumer consumer) {\n            this.channels = channels;\n            this.consumer = consumer;\n        }\n    }\n}\n",
      "file_name": "MultipleChannelsConsumer.java",
      "human_label": "Add the given target channels to the consumeTargets.",
      "level": "plib_runnable",
      "lineno": "92",
      "name": "addNewTarget",
      "oracle_context": "{ \"apis\" : \"[add, size, Group]\", \"classes\" : \"[Group, ArrayList<Group>]\", \"vars\" : \"[consumeTargets, size]\" }",
      "package": "org.apache.skywalking.oap.server.library.datacarrier.consumer",
      "project": "skywalking-master"
    },
    {
      "_id": "636767871a6d9265ec01846d",
      "all_context": "{ \"class_level\" : \"import java.io.BufferedInputStream;\\nimport java.io.File;\\nimport java.io.FileInputStream;\\nimport java.io.FileNotFoundException;\\nimport java.io.FileOutputStream;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.io.ObjectInputStream;\\nimport java.io.ObjectOutputStream;\\nimport java.net.URL;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nString CONFIG_FILE_NAME;\\nint DEFAULT_MAX_SIZE;\\nint _maxSize;\\nLinkedList _mruFileList;\\nMRUFileManager();\\nMRUFileManager(int maxSize);\\nsize();\\ngetFile(int index);\\ngetInputStream(int index);\\nset(File file);\\nset(URL url);\\ngetMRUFileList();\\nmoveToTop(int index);\\ncreateConfigurationDirectory();\\ngetInputStream(File file);\\ngetInputStream(URL url);\\nsetMRU(Object o);\\nload();\\ngetFilename();\\nsetMaxSize(int maxSize);\\nsave();\\n\", \"repo_level\" : \"\" }",
      "class_name": "MRUFileManager",
      "code": "public static void createConfigurationDirectory(){\n  String home=System.getProperty(\"user.home\");\n  String sep=System.getProperty(\"file.separator\");\n  File f=new File(home + sep + \"lf5\");\n  if (!f.exists()) {\n    try {\n      f.mkdir();\n    }\n catch (    SecurityException e) {\n      e.printStackTrace();\n    }\n  }\n}\n",
      "docstring": "/** \n * Creates the directory where the MRU file list will be written. The \"lf5\" directory is created in the Documents and Settings directory on Windows 2000 machines and where ever the user.home variable points on all other platforms.\n */\n",
      "end_lineno": "194",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.log4j.lf5.viewer.configure;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.LinkedList;\n\n\n/**\n * <p>MRUFileManager handles the storage and retrival the most\n * recently opened log files.\n *\n * @author Brad Marlborough\n * @author Richard Hurst\n */\n\n// Contributed by ThoughtWorks Inc.\n\npublic class MRUFileManager {\n  //--------------------------------------------------------------------------\n  //   Constants:\n  //--------------------------------------------------------------------------\n  private static final String CONFIG_FILE_NAME = \"mru_file_manager\";\n  private static final int DEFAULT_MAX_SIZE = 3;\n\n  //--------------------------------------------------------------------------\n  //   Protected Variables:\n  //--------------------------------------------------------------------------\n\n  //--------------------------------------------------------------------------\n  //   Private Variables:\n  //--------------------------------------------------------------------------\n  private int _maxSize = 0;\n  private LinkedList _mruFileList;\n\n  //--------------------------------------------------------------------------\n  //   Constructors:\n  //--------------------------------------------------------------------------\n  public MRUFileManager() {\n    load();\n    setMaxSize(DEFAULT_MAX_SIZE);\n  }\n\n  public MRUFileManager(int maxSize) {\n    load();\n    setMaxSize(maxSize);\n  }\n  //--------------------------------------------------------------------------\n  //   Public Methods:\n  //--------------------------------------------------------------------------\n\n  /**\n   * Saves a list of MRU files out to a file.\n   */\n  public void save() {\n    File file = new File(getFilename());\n\n    try {\n      ObjectOutputStream oos = new ObjectOutputStream(new\n          FileOutputStream(file));\n      oos.writeObject(_mruFileList);\n      oos.flush();\n      oos.close();\n    } catch (Exception e) {\n      // do nothing\n      e.printStackTrace();\n    }\n  }\n\n  /**\n   * Gets the size of the MRU file list.\n   */\n  public int size() {\n    return _mruFileList.size();\n  }\n\n  /**\n   * Returns a particular file name stored in a MRU file\n   * list based on an index value.\n   */\n  public Object getFile(int index) {\n    if (index < size()) {\n      return _mruFileList.get(index);\n    }\n\n    return null;\n  }\n\n  /**\n   * Returns a input stream to the resource at the specified index\n   */\n  public InputStream getInputStream(int index) throws IOException,\n      FileNotFoundException {\n    if (index < size()) {\n      Object o = getFile(index);\n      if (o instanceof File) {\n        return getInputStream((File) o);\n      } else {\n        return getInputStream((URL) o);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Adds a file name to the MRU file list.\n   */\n  public void set(File file) {\n    setMRU(file);\n  }\n\n  /**\n   * Adds a url to the MRU file list.\n   */\n  public void set(URL url) {\n    setMRU(url);\n  }\n\n  /**\n   * Gets the list of files stored in the MRU file list.\n   */\n  public String[] getMRUFileList() {\n    if (size() == 0) {\n      return null;\n    }\n\n    String[] ss = new String[size()];\n\n    for (int i = 0; i < size(); i++) {\n      Object o = getFile(i);\n      if (o instanceof File) {\n        ss[i] = ((File) o).getAbsolutePath();\n      } else // must be a url\n      {\n        ss[i] = o.toString();\n      }\n\n    }\n\n    return ss;\n  }\n\n  /**\n   * Moves the the index to the top of the MRU List\n   *\n   * @param index The index to be first in the mru list\n   */\n  public void moveToTop(int index) {\n    _mruFileList.add(0, _mruFileList.remove(index));\n  }\n\n  /**\n   * Creates the directory where the MRU file list will be written.\n   * The \"lf5\" directory is created in the Documents and Settings\n   * directory on Windows 2000 machines and where ever the user.home\n   * variable points on all other platforms.\n   */\n  public static void createConfigurationDirectory() {\n    String home = System.getProperty(\"user.home\");\n    String sep = System.getProperty(\"file.separator\");\n    File f = new File(home + sep + \"lf5\");\n    if (!f.exists()) {\n      try {\n        f.mkdir();\n      } catch (SecurityException e) {\n        e.printStackTrace();\n      }\n    }\n\n  }\n  //--------------------------------------------------------------------------\n  //   Protected Methods:\n  //--------------------------------------------------------------------------\n  /**\n   * Gets an input stream for the corresponding file.\n   *\n   * @param file The file to create the input stream from.\n   * @return InputStream\n   */\n  protected InputStream getInputStream(File file) throws IOException,\n      FileNotFoundException {\n    BufferedInputStream reader =\n        new BufferedInputStream(new FileInputStream(file));\n\n    return reader;\n  }\n\n  /**\n   * Gets an input stream for the corresponding URL.\n   *\n   * @param url The url to create the input stream from.\n   * @return InputStream\n   */\n  protected InputStream getInputStream(URL url) throws IOException {\n    return url.openStream();\n  }\n\n  /**\n   * Adds an object to the mru.\n   */\n  protected void setMRU(Object o) {\n    int index = _mruFileList.indexOf(o);\n\n    if (index == -1) {\n      _mruFileList.add(0, o);\n      setMaxSize(_maxSize);\n    } else {\n      moveToTop(index);\n    }\n  }\n\n  /**\n   * Loads the MRU file list in from a file and stores it in a LinkedList.\n   * If no file exists, a new LinkedList is created.\n   */\n  protected void load() {\n    createConfigurationDirectory();\n    File file = new File(getFilename());\n    if (file.exists()) {\n      try {\n        ObjectInputStream ois = new ObjectInputStream(\n            new FileInputStream(file));\n        _mruFileList = (LinkedList) ois.readObject();\n        ois.close();\n\n        // check that only files and url are in linked list\n        Iterator it = _mruFileList.iterator();\n        while (it.hasNext()) {\n          Object o = it.next();\n          if (!(o instanceof File) && !(o instanceof URL)) {\n            it.remove();\n          }\n        }\n      } catch (Exception e) {\n        _mruFileList = new LinkedList();\n      }\n    } else {\n      _mruFileList = new LinkedList();\n    }\n\n  }\n\n  protected String getFilename() {\n    String home = System.getProperty(\"user.home\");\n    String sep = System.getProperty(\"file.separator\");\n\n    return home + sep + \"lf5\" + sep + CONFIG_FILE_NAME;\n  }\n\n  /**\n   * Ensures that the MRU list will have a MaxSize.\n   */\n  protected void setMaxSize(int maxSize) {\n    if (maxSize < _mruFileList.size()) {\n      for (int i = 0; i < _mruFileList.size() - maxSize; i++) {\n        _mruFileList.removeLast();\n      }\n    }\n\n    _maxSize = maxSize;\n  }\n  //--------------------------------------------------------------------------\n  //   Private Methods:\n  //--------------------------------------------------------------------------\n\n  //--------------------------------------------------------------------------\n  //   Nested Top-Level Classes or Interfaces\n  //--------------------------------------------------------------------------\n}",
      "file_name": "MRUFileManager.java",
      "human_label": "Create the \"lf5\" directory in the Documents and Settings directory on Windows machines, or the user.home variable points on all other platforms.",
      "level": "slib_runnable",
      "lineno": "176",
      "name": "createConfigurationDirectory",
      "oracle_context": "{ \"apis\" : \"[getProperty, exists, mkdir, printStackTrace]\", \"classes\" : \"[String, File]\", \"vars\" : \"[]\" }",
      "package": "org.apache.log4j.lf5.viewer.configure",
      "project": "logging-log4j1-main"
    },
    {
      "_id": "636766f81a6d9265ec01775b",
      "all_context": "{ \"class_level\" : \"import java.io.ByteArrayOutputStream;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nint SKIP_CODE;\\nint SKIP_DEBUG;\\nint SKIP_FRAMES;\\nint EXPAND_FRAMES;\\nint EXPAND_ASM_INSNS;\\nint INPUT_STREAM_DATA_CHUNK_SIZE;\\nbyte[] b;\\nbyte[] classFileBuffer;\\nint[] cpInfoOffsets;\\nString[] constantUtf8Values;\\nConstantDynamic[] constantDynamicValues;\\nint[] bootstrapMethodOffsets;\\nint maxStringLength;\\nint header;\\nClassReader(byte[] classFile);\\nClassReader(byte[] classFileBuffer,int classFileOffset,int classFileLength);\\nClassReader(byte[] classFileBuffer,int classFileOffset,boolean checkClassVersion);\\nClassReader(InputStream inputStream);\\nClassReader(String className);\\ngetAccess();\\ngetClassName();\\ngetSuperName();\\ngetInterfaces();\\naccept(ClassVisitor classVisitor,int parsingOptions);\\naccept(ClassVisitor classVisitor,Attribute[] attributePrototypes,int parsingOptions);\\nreadModuleAttributes(ClassVisitor classVisitor,Context context,int moduleOffset,int modulePackagesOffset,String moduleMainClass);\\nreadRecordComponent(ClassVisitor classVisitor,Context context,int recordComponentOffset);\\nreadField(ClassVisitor classVisitor,Context context,int fieldInfoOffset);\\nreadMethod(ClassVisitor classVisitor,Context context,int methodInfoOffset);\\nreadCode(MethodVisitor methodVisitor,Context context,int codeOffset);\\nreadLabel(int bytecodeOffset,Label[] labels);\\ncreateLabel(int bytecodeOffset,Label[] labels);\\ncreateDebugLabel(int bytecodeOffset,Label[] labels);\\nreadTypeAnnotations(MethodVisitor methodVisitor,Context context,int runtimeTypeAnnotationsOffset,boolean visible);\\ngetTypeAnnotationBytecodeOffset(int[] typeAnnotationOffsets,int typeAnnotationIndex);\\nreadTypeAnnotationTarget(Context context,int typeAnnotationOffset);\\nreadParameterAnnotations(MethodVisitor methodVisitor,Context context,int runtimeParameterAnnotationsOffset,boolean visible);\\nreadElementValues(AnnotationVisitor annotationVisitor,int annotationOffset,boolean named,char[] charBuffer);\\nreadElementValue(AnnotationVisitor annotationVisitor,int elementValueOffset,String elementName,char[] charBuffer);\\ncomputeImplicitFrame(Context context);\\nreadStackMapFrame(int stackMapFrameOffset,boolean compressed,boolean expand,Context context);\\nreadVerificationTypeInfo(int verificationTypeInfoOffset,Object[] frame,int index,char[] charBuffer,Label[] labels);\\ngetFirstAttributeOffset();\\nreadBootstrapMethodsAttribute(int maxStringLength);\\nreadAttribute(Attribute[] attributePrototypes,String type,int offset,int length,char[] charBuffer,int codeAttributeOffset,Label[] labels);\\ngetItemCount();\\ngetItem(int constantPoolEntryIndex);\\ngetMaxStringLength();\\nreadByte(int offset);\\nreadUnsignedShort(int offset);\\nreadShort(int offset);\\nreadInt(int offset);\\nreadLong(int offset);\\nreadUTF8(int offset,char[] charBuffer);\\nreadUtf(int constantPoolEntryIndex,char[] charBuffer);\\nreadUtf(int utfOffset,int utfLength,char[] charBuffer);\\nreadStringish(int offset,char[] charBuffer);\\nreadClass(int offset,char[] charBuffer);\\nreadModule(int offset,char[] charBuffer);\\nreadPackage(int offset,char[] charBuffer);\\nreadConstantDynamic(int constantPoolEntryIndex,char[] charBuffer);\\nreadConst(int constantPoolEntryIndex,char[] charBuffer);\\nreadStream(InputStream inputStream,boolean close);\\n\", \"repo_level\" : \"\" }",
      "class_name": "ClassReader",
      "code": "public long readLong(final int offset){\n  long l1=readInt(offset);\n  long l0=readInt(offset + 4) & 0xFFFFFFFFL;\n  return (l1 << 32) | l0;\n}\n",
      "docstring": "/** \n * Reads a signed long value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\n * @return the read value.\n */\n",
      "end_lineno": "3134",
      "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage net.hasor.utils.asm;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * A parser to make a {@link ClassVisitor} visit a ClassFile structure, as defined in the Java\n * Virtual Machine Specification (JVMS). This class parses the ClassFile content and calls the\n * appropriate visit methods of a given {@link ClassVisitor} for each field, method and bytecode\n * instruction encountered.\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html\">JVMS 4</a>\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic class ClassReader {\n    /**\n     * A flag to skip the Code attributes. If this flag is set the Code attributes are neither parsed\n     * nor visited.\n     */\n    public static final  int               SKIP_CODE                    = 1;\n    /**\n     * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable,\n     * LocalVariableTypeTable, LineNumberTable and MethodParameters attributes. If this flag is set\n     * these attributes are neither parsed nor visited (i.e. {@link ClassVisitor#visitSource}, {@link\n     * MethodVisitor#visitLocalVariable}, {@link MethodVisitor#visitLineNumber} and {@link\n     * MethodVisitor#visitParameter} are not called).\n     */\n    public static final  int               SKIP_DEBUG                   = 2;\n    /**\n     * A flag to skip the StackMap and StackMapTable attributes. If this flag is set these attributes\n     * are neither parsed nor visited (i.e. {@link MethodVisitor#visitFrame} is not called). This flag\n     * is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is used: it avoids visiting frames\n     * that will be ignored and recomputed from scratch.\n     */\n    public static final  int               SKIP_FRAMES                  = 4;\n    /**\n     * A flag to expand the stack map frames. By default stack map frames are visited in their\n     * original format (i.e. \"expanded\" for classes whose version is less than V1_6, and \"compressed\"\n     * for the other classes). If this flag is set, stack map frames are always visited in expanded\n     * format (this option adds a decompression/compression step in ClassReader and ClassWriter which\n     * degrades performance quite a lot).\n     */\n    public static final  int               EXPAND_FRAMES                = 8;\n    /**\n     * A flag to expand the ASM specific instructions into an equivalent sequence of standard bytecode\n     * instructions. When resolving a forward jump it may happen that the signed 2 bytes offset\n     * reserved for it is not sufficient to store the bytecode offset. In this case the jump\n     * instruction is replaced with a temporary ASM specific instruction using an unsigned 2 bytes\n     * offset (see {@link Label#resolve}). This internal flag is used to re-read classes containing\n     * such instructions, in order to replace them with standard instructions. In addition, when this\n     * flag is used, goto_w and jsr_w are <i>not</i> converted into goto and jsr, to make sure that\n     * infinite loops where a goto_w is replaced with a goto in ClassReader and converted back to a\n     * goto_w in ClassWriter cannot occur.\n     */\n    static final         int               EXPAND_ASM_INSNS             = 256;\n    /** The size of the temporary byte array used to read class input streams chunk by chunk. */\n    private static final int               INPUT_STREAM_DATA_CHUNK_SIZE = 4096;\n    /**\n     * A byte array containing the JVMS ClassFile structure to be parsed.\n     *\n     * @deprecated Use {@link #readByte(int)} and the other read methods instead. This field will\n     *     eventually be deleted.\n     */\n    @Deprecated\n    // DontCheck(MemberName): can't be renamed (for backward binary compatibility).\n    public final         byte[]            b;\n    /**\n     * A byte array containing the JVMS ClassFile structure to be parsed. <i>The content of this array\n     * must not be modified. This field is intended for {@link Attribute} sub classes, and is normally\n     * not needed by class visitors.</i>\n     *\n     * <p>NOTE: the ClassFile structure can start at any offset within this array, i.e. it does not\n     * necessarily start at offset 0. Use {@link #getItem} and {@link #header} to get correct\n     * ClassFile element offsets within this byte array.\n     */\n    final                byte[]            classFileBuffer;\n    /**\n     * The offset in bytes, in {@link #classFileBuffer}, of each cp_info entry of the ClassFile's\n     * constant_pool array, <i>plus one</i>. In other words, the offset of constant pool entry i is\n     * given by cpInfoOffsets[i] - 1, i.e. its cp_info's tag field is given by b[cpInfoOffsets[i] -\n     * 1].\n     */\n    private final        int[]             cpInfoOffsets;\n    /**\n     * The String objects corresponding to the CONSTANT_Utf8 constant pool items. This cache avoids\n     * multiple parsing of a given CONSTANT_Utf8 constant pool item.\n     */\n    private final        String[]          constantUtf8Values;\n    /**\n     * The ConstantDynamic objects corresponding to the CONSTANT_Dynamic constant pool items. This\n     * cache avoids multiple parsing of a given CONSTANT_Dynamic constant pool item.\n     */\n    private final        ConstantDynamic[] constantDynamicValues;\n    /**\n     * The start offsets in {@link #classFileBuffer} of each element of the bootstrap_methods array\n     * (in the BootstrapMethods attribute).\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23\">JVMS\n     *     4.7.23</a>\n     */\n    private final        int[]             bootstrapMethodOffsets;\n    /**\n     * A conservative estimate of the maximum length of the strings contained in the constant pool of\n     * the class.\n     */\n    private final        int               maxStringLength;\n    /** The offset in bytes of the ClassFile's access_flags field. */\n    public final         int               header;\n    // -----------------------------------------------------------------------------------------------\n    // Constructors\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param classFile the JVMS ClassFile structure to be read.\n     */\n    public ClassReader(final byte[] classFile) {\n        this(classFile, 0, classFile.length);\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.\n     * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.\n     * @param classFileLength the length in bytes of the ClassFile to be read.\n     */\n    public ClassReader(final byte[] classFileBuffer, final int classFileOffset, final int classFileLength) { // NOPMD(UnusedFormalParameter) used for backward compatibility.\n        this(classFileBuffer, classFileOffset, /* checkClassVersion = */ true);\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object. <i>This internal constructor must not be exposed\n     * as a public API</i>.\n     *\n     * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.\n     * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.\n     * @param checkClassVersion whether to check the class version or not.\n     */\n    ClassReader(final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {\n        this.classFileBuffer = classFileBuffer;\n        this.b = classFileBuffer;\n        // Check the class' major_version. This field is after the magic and minor_version fields, which\n        // use 4 and 2 bytes respectively.\n        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V15) {\n            throw new IllegalArgumentException(\"Unsupported class file major version \" + readShort(classFileOffset + 6));\n        }\n        // Create the constant pool arrays. The constant_pool_count field is after the magic,\n        // minor_version and major_version fields, which use 4, 2 and 2 bytes respectively.\n        int constantPoolCount = readUnsignedShort(classFileOffset + 8);\n        cpInfoOffsets = new int[constantPoolCount];\n        constantUtf8Values = new String[constantPoolCount];\n        // Compute the offset of each constant pool entry, as well as a conservative estimate of the\n        // maximum length of the constant pool strings. The first constant pool entry is after the\n        // magic, minor_version, major_version and constant_pool_count fields, which use 4, 2, 2 and 2\n        // bytes respectively.\n        int currentCpInfoIndex = 1;\n        int currentCpInfoOffset = classFileOffset + 10;\n        int currentMaxStringLength = 0;\n        boolean hasBootstrapMethods = false;\n        boolean hasConstantDynamic = false;\n        // The offset of the other entries depend on the total size of all the previous entries.\n        while (currentCpInfoIndex < constantPoolCount) {\n            cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;\n            int cpInfoSize;\n            switch (classFileBuffer[currentCpInfoOffset]) {\n            case Symbol.CONSTANT_FIELDREF_TAG:\n            case Symbol.CONSTANT_METHODREF_TAG:\n            case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n            case Symbol.CONSTANT_INTEGER_TAG:\n            case Symbol.CONSTANT_FLOAT_TAG:\n            case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n                cpInfoSize = 5;\n                break;\n            case Symbol.CONSTANT_DYNAMIC_TAG:\n                cpInfoSize = 5;\n                hasBootstrapMethods = true;\n                hasConstantDynamic = true;\n                break;\n            case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n                cpInfoSize = 5;\n                hasBootstrapMethods = true;\n                break;\n            case Symbol.CONSTANT_LONG_TAG:\n            case Symbol.CONSTANT_DOUBLE_TAG:\n                cpInfoSize = 9;\n                currentCpInfoIndex++;\n                break;\n            case Symbol.CONSTANT_UTF8_TAG:\n                cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);\n                if (cpInfoSize > currentMaxStringLength) {\n                    // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate\n                    // of the length in characters of the corresponding string, and is much cheaper to\n                    // compute than this exact length.\n                    currentMaxStringLength = cpInfoSize;\n                }\n                break;\n            case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n                cpInfoSize = 4;\n                break;\n            case Symbol.CONSTANT_CLASS_TAG:\n            case Symbol.CONSTANT_STRING_TAG:\n            case Symbol.CONSTANT_METHOD_TYPE_TAG:\n            case Symbol.CONSTANT_PACKAGE_TAG:\n            case Symbol.CONSTANT_MODULE_TAG:\n                cpInfoSize = 3;\n                break;\n            default:\n                throw new IllegalArgumentException();\n            }\n            currentCpInfoOffset += cpInfoSize;\n        }\n        maxStringLength = currentMaxStringLength;\n        // The Classfile's access_flags field is just after the last constant pool entry.\n        header = currentCpInfoOffset;\n        // Allocate the cache of ConstantDynamic values, if there is at least one.\n        constantDynamicValues = hasConstantDynamic ? new ConstantDynamic[constantPoolCount] : null;\n        // Read the BootstrapMethods attribute, if any (only get the offset of each method).\n        bootstrapMethodOffsets = hasBootstrapMethods ? readBootstrapMethodsAttribute(currentMaxStringLength) : null;\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param inputStream an input stream of the JVMS ClassFile structure to be read. This input\n     *     stream must contain nothing more than the ClassFile structure itself. It is read from its\n     *     current position to its end.\n     * @throws IOException if a problem occurs during reading.\n     */\n    public ClassReader(final InputStream inputStream) throws IOException {\n        this(readStream(inputStream, false));\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param className the fully qualified name of the class to be read. The ClassFile structure is\n     *     retrieved with the current class loader's {@link ClassLoader#getSystemResourceAsStream}.\n     * @throws IOException if an exception occurs during reading.\n     */\n    public ClassReader(final String className) throws IOException {\n        this(readStream(ClassLoader.getSystemResourceAsStream(className.replace('.', '/') + \".class\"), true));\n    }\n\n    /**\n     * Reads the given input stream and returns its content as a byte array.\n     *\n     * @param inputStream an input stream.\n     * @param close true to close the input stream after reading.\n     * @return the content of the given input stream.\n     * @throws IOException if a problem occurs during reading.\n     */\n    private static byte[] readStream(final InputStream inputStream, final boolean close) throws IOException {\n        if (inputStream == null) {\n            throw new IOException(\"Class not found\");\n        }\n        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n            byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {\n                outputStream.write(data, 0, bytesRead);\n            }\n            outputStream.flush();\n            return outputStream.toByteArray();\n        } finally {\n            if (close) {\n                inputStream.close();\n            }\n        }\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Accessors\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the class's access flags (see {@link Opcodes}). This value may not reflect Deprecated\n     * and Synthetic flags when bytecode is before 1.5 and those flags are represented by attributes.\n     *\n     * @return the class access flags.\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public int getAccess() {\n        return readUnsignedShort(header);\n    }\n\n    /**\n     * Returns the internal name of the class (see {@link Type#getInternalName()}).\n     *\n     * @return the internal class name.\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getClassName() {\n        // this_class is just after the access_flags field (using 2 bytes).\n        return readClass(header + 2, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal of name of the super class (see {@link Type#getInternalName()}). For\n     * interfaces, the super class is {@link Object}.\n     *\n     * @return the internal name of the super class, or {@literal null} for {@link Object} class.\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getSuperName() {\n        // super_class is after the access_flags and this_class fields (2 bytes each).\n        return readClass(header + 4, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal names of the implemented interfaces (see {@link Type#getInternalName()}).\n     *\n     * @return the internal names of the directly implemented interfaces. Inherited implemented\n     *     interfaces are not returned.\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String[] getInterfaces() {\n        // interfaces_count is after the access_flags, this_class and super_class fields (2 bytes each).\n        int currentOffset = header + 6;\n        int interfacesCount = readUnsignedShort(currentOffset);\n        String[] interfaces = new String[interfacesCount];\n        if (interfacesCount > 0) {\n            char[] charBuffer = new char[maxStringLength];\n            for (int i = 0; i < interfacesCount; ++i) {\n                currentOffset += 2;\n                interfaces[i] = readClass(currentOffset, charBuffer);\n            }\n        }\n        return interfaces;\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Public methods\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this\n     * {@link ClassReader}.\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param parsingOptions the options to use to parse this class. One or more of {@link\n     *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.\n     */\n    public void accept(final ClassVisitor classVisitor, final int parsingOptions) {\n        accept(classVisitor, new Attribute[0], parsingOptions);\n    }\n\n    /**\n     * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this\n     * {@link ClassReader}.\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of\n     *     the class. Any attribute whose type is not equal to the type of one the prototypes will not\n     *     be parsed: its byte array value will be passed unchanged to the ClassWriter. <i>This may\n     *     corrupt it if this value contains references to the constant pool, or has syntactic or\n     *     semantic links with a class element that has been transformed by a class adapter between\n     *     the reader and the writer</i>.\n     * @param parsingOptions the options to use to parse this class. One or more of {@link\n     *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.\n     */\n    public void accept(final ClassVisitor classVisitor, final Attribute[] attributePrototypes, final int parsingOptions) {\n        Context context = new Context();\n        context.attributePrototypes = attributePrototypes;\n        context.parsingOptions = parsingOptions;\n        context.charBuffer = new char[maxStringLength];\n        // Read the access_flags, this_class, super_class, interface_count and interfaces fields.\n        char[] charBuffer = context.charBuffer;\n        int currentOffset = header;\n        int accessFlags = readUnsignedShort(currentOffset);\n        String thisClass = readClass(currentOffset + 2, charBuffer);\n        String superClass = readClass(currentOffset + 4, charBuffer);\n        String[] interfaces = new String[readUnsignedShort(currentOffset + 6)];\n        currentOffset += 8;\n        for (int i = 0; i < interfaces.length; ++i) {\n            interfaces[i] = readClass(currentOffset, charBuffer);\n            currentOffset += 2;\n        }\n        // Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).\n        // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n        // - The offset of the InnerClasses attribute, or 0.\n        int innerClassesOffset = 0;\n        // - The offset of the EnclosingMethod attribute, or 0.\n        int enclosingMethodOffset = 0;\n        // - The string corresponding to the Signature attribute, or null.\n        String signature = null;\n        // - The string corresponding to the SourceFile attribute, or null.\n        String sourceFile = null;\n        // - The string corresponding to the SourceDebugExtension attribute, or null.\n        String sourceDebugExtension = null;\n        // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n        int runtimeVisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n        int runtimeInvisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n        int runtimeVisibleTypeAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n        int runtimeInvisibleTypeAnnotationsOffset = 0;\n        // - The offset of the Module attribute, or 0.\n        int moduleOffset = 0;\n        // - The offset of the ModulePackages attribute, or 0.\n        int modulePackagesOffset = 0;\n        // - The string corresponding to the ModuleMainClass attribute, or null.\n        String moduleMainClass = null;\n        // - The string corresponding to the NestHost attribute, or null.\n        String nestHostClass = null;\n        // - The offset of the NestMembers attribute, or 0.\n        int nestMembersOffset = 0;\n        // - The offset of the PermittedSubtypes attribute, or 0\n        int permittedSubtypesOffset = 0;\n        // - The offset of the Record attribute, or 0.\n        int recordOffset = 0;\n        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n        Attribute attributes = null;\n        int currentAttributeOffset = getFirstAttributeOffset();\n        for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentAttributeOffset, charBuffer);\n            int attributeLength = readInt(currentAttributeOffset + 2);\n            currentAttributeOffset += 6;\n            // The tests are sorted in decreasing frequency order (based on frequencies observed on\n            // typical classes).\n            if (Constants.SOURCE_FILE.equals(attributeName)) {\n                sourceFile = readUTF8(currentAttributeOffset, charBuffer);\n            } else if (Constants.INNER_CLASSES.equals(attributeName)) {\n                innerClassesOffset = currentAttributeOffset;\n            } else if (Constants.ENCLOSING_METHOD.equals(attributeName)) {\n                enclosingMethodOffset = currentAttributeOffset;\n            } else if (Constants.NEST_HOST.equals(attributeName)) {\n                nestHostClass = readClass(currentAttributeOffset, charBuffer);\n            } else if (Constants.NEST_MEMBERS.equals(attributeName)) {\n                nestMembersOffset = currentAttributeOffset;\n            } else if (Constants.PERMITTED_SUBTYPES.equals(attributeName)) {\n                permittedSubtypesOffset = currentAttributeOffset;\n            } else if (Constants.SIGNATURE.equals(attributeName)) {\n                signature = readUTF8(currentAttributeOffset, charBuffer);\n            } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleAnnotationsOffset = currentAttributeOffset;\n            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;\n            } else if (Constants.DEPRECATED.equals(attributeName)) {\n                accessFlags |= Opcodes.ACC_DEPRECATED;\n            } else if (Constants.SYNTHETIC.equals(attributeName)) {\n                accessFlags |= Opcodes.ACC_SYNTHETIC;\n            } else if (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {\n                sourceDebugExtension = readUtf(currentAttributeOffset, attributeLength, new char[attributeLength]);\n            } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleAnnotationsOffset = currentAttributeOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;\n            } else if (Constants.RECORD.equals(attributeName)) {\n                recordOffset = currentAttributeOffset;\n            } else if (Constants.MODULE.equals(attributeName)) {\n                moduleOffset = currentAttributeOffset;\n            } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {\n                moduleMainClass = readClass(currentAttributeOffset, charBuffer);\n            } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {\n                modulePackagesOffset = currentAttributeOffset;\n            } else if (!Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n                // The BootstrapMethods attribute is read in the constructor.\n                Attribute attribute = readAttribute(attributePrototypes, attributeName, currentAttributeOffset, attributeLength, charBuffer, -1, null);\n                attribute.nextAttribute = attributes;\n                attributes = attribute;\n            }\n            currentAttributeOffset += attributeLength;\n        }\n        // Visit the class declaration. The minor_version and major_version fields start 6 bytes before\n        // the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).\n        classVisitor.visit(readInt(cpInfoOffsets[1] - 7), accessFlags, thisClass, signature, superClass, interfaces);\n        // Visit the SourceFile and SourceDebugExtenstion attributes.\n        if ((parsingOptions & SKIP_DEBUG) == 0 && (sourceFile != null || sourceDebugExtension != null)) {\n            classVisitor.visitSource(sourceFile, sourceDebugExtension);\n        }\n        // Visit the Module, ModulePackages and ModuleMainClass attributes.\n        if (moduleOffset != 0) {\n            readModuleAttributes(classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);\n        }\n        // Visit the NestHost attribute.\n        if (nestHostClass != null) {\n            classVisitor.visitNestHost(nestHostClass);\n        }\n        // Visit the EnclosingMethod attribute.\n        if (enclosingMethodOffset != 0) {\n            String className = readClass(enclosingMethodOffset, charBuffer);\n            int methodIndex = readUnsignedShort(enclosingMethodOffset + 2);\n            String name = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex], charBuffer);\n            String type = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex] + 2, charBuffer);\n            classVisitor.visitOuterClass(className, name, type);\n        }\n        // Visit the RuntimeVisibleAnnotations attribute.\n        if (runtimeVisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleAnnotations attribute.\n        if (runtimeInvisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeVisibleTypeAnnotations attribute.\n        if (runtimeVisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(classVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleTypeAnnotations attribute.\n        if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(classVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the non standard attributes.\n        while (attributes != null) {\n            // Copy and reset the nextAttribute field so that it can also be used in ClassWriter.\n            Attribute nextAttribute = attributes.nextAttribute;\n            attributes.nextAttribute = null;\n            classVisitor.visitAttribute(attributes);\n            attributes = nextAttribute;\n        }\n        // Visit the NestedMembers attribute.\n        if (nestMembersOffset != 0) {\n            int numberOfNestMembers = readUnsignedShort(nestMembersOffset);\n            int currentNestMemberOffset = nestMembersOffset + 2;\n            while (numberOfNestMembers-- > 0) {\n                classVisitor.visitNestMember(readClass(currentNestMemberOffset, charBuffer));\n                currentNestMemberOffset += 2;\n            }\n        }\n        // Visit the PermittedSubtypes attribute.\n        if (permittedSubtypesOffset != 0) {\n            int numberOfPermittedSubtypes = readUnsignedShort(permittedSubtypesOffset);\n            int currentPermittedSubtypeOffset = permittedSubtypesOffset + 2;\n            while (numberOfPermittedSubtypes-- > 0) {\n                classVisitor.visitPermittedSubtypeExperimental(readClass(currentPermittedSubtypeOffset, charBuffer));\n                currentPermittedSubtypeOffset += 2;\n            }\n        }\n        // Visit the InnerClasses attribute.\n        if (innerClassesOffset != 0) {\n            int numberOfClasses = readUnsignedShort(innerClassesOffset);\n            int currentClassesOffset = innerClassesOffset + 2;\n            while (numberOfClasses-- > 0) {\n                classVisitor.visitInnerClass(readClass(currentClassesOffset, charBuffer), readClass(currentClassesOffset + 2, charBuffer), readUTF8(currentClassesOffset + 4, charBuffer), readUnsignedShort(currentClassesOffset + 6));\n                currentClassesOffset += 8;\n            }\n        }\n        // Visit Record components.\n        if (recordOffset != 0) {\n            int recordComponentsCount = readUnsignedShort(recordOffset);\n            recordOffset += 2;\n            while (recordComponentsCount-- > 0) {\n                recordOffset = readRecordComponent(classVisitor, context, recordOffset);\n            }\n        }\n        // Visit the fields and methods.\n        int fieldsCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (fieldsCount-- > 0) {\n            currentOffset = readField(classVisitor, context, currentOffset);\n        }\n        int methodsCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (methodsCount-- > 0) {\n            currentOffset = readMethod(classVisitor, context, currentOffset);\n        }\n        // Visit the end of the class.\n        classVisitor.visitEnd();\n    }\n    // ----------------------------------------------------------------------------------------------\n    // Methods to parse modules, fields and methods\n    // ----------------------------------------------------------------------------------------------\n\n    /**\n     * Reads the Module, ModulePackages and ModuleMainClass attributes and visit them.\n     *\n     * @param classVisitor the current class visitor\n     * @param context information about the class being parsed.\n     * @param moduleOffset the offset of the Module attribute (excluding the attribute_info's\n     *     attribute_name_index and attribute_length fields).\n     * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the\n     *     attribute_info's attribute_name_index and attribute_length fields), or 0.\n     * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or {@literal\n     *     null}.\n     */\n    private void readModuleAttributes(final ClassVisitor classVisitor, final Context context, final int moduleOffset, final int modulePackagesOffset, final String moduleMainClass) {\n        char[] buffer = context.charBuffer;\n        // Read the module_name_index, module_flags and module_version_index fields and visit them.\n        int currentOffset = moduleOffset;\n        String moduleName = readModule(currentOffset, buffer);\n        int moduleFlags = readUnsignedShort(currentOffset + 2);\n        String moduleVersion = readUTF8(currentOffset + 4, buffer);\n        currentOffset += 6;\n        ModuleVisitor moduleVisitor = classVisitor.visitModule(moduleName, moduleFlags, moduleVersion);\n        if (moduleVisitor == null) {\n            return;\n        }\n        // Visit the ModuleMainClass attribute.\n        if (moduleMainClass != null) {\n            moduleVisitor.visitMainClass(moduleMainClass);\n        }\n        // Visit the ModulePackages attribute.\n        if (modulePackagesOffset != 0) {\n            int packageCount = readUnsignedShort(modulePackagesOffset);\n            int currentPackageOffset = modulePackagesOffset + 2;\n            while (packageCount-- > 0) {\n                moduleVisitor.visitPackage(readPackage(currentPackageOffset, buffer));\n                currentPackageOffset += 2;\n            }\n        }\n        // Read the 'requires_count' and 'requires' fields.\n        int requiresCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (requiresCount-- > 0) {\n            // Read the requires_index, requires_flags and requires_version fields and visit them.\n            String requires = readModule(currentOffset, buffer);\n            int requiresFlags = readUnsignedShort(currentOffset + 2);\n            String requiresVersion = readUTF8(currentOffset + 4, buffer);\n            currentOffset += 6;\n            moduleVisitor.visitRequire(requires, requiresFlags, requiresVersion);\n        }\n        // Read the 'exports_count' and 'exports' fields.\n        int exportsCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (exportsCount-- > 0) {\n            // Read the exports_index, exports_flags, exports_to_count and exports_to_index fields\n            // and visit them.\n            String exports = readPackage(currentOffset, buffer);\n            int exportsFlags = readUnsignedShort(currentOffset + 2);\n            int exportsToCount = readUnsignedShort(currentOffset + 4);\n            currentOffset += 6;\n            String[] exportsTo = null;\n            if (exportsToCount != 0) {\n                exportsTo = new String[exportsToCount];\n                for (int i = 0; i < exportsToCount; ++i) {\n                    exportsTo[i] = readModule(currentOffset, buffer);\n                    currentOffset += 2;\n                }\n            }\n            moduleVisitor.visitExport(exports, exportsFlags, exportsTo);\n        }\n        // Reads the 'opens_count' and 'opens' fields.\n        int opensCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (opensCount-- > 0) {\n            // Read the opens_index, opens_flags, opens_to_count and opens_to_index fields and visit them.\n            String opens = readPackage(currentOffset, buffer);\n            int opensFlags = readUnsignedShort(currentOffset + 2);\n            int opensToCount = readUnsignedShort(currentOffset + 4);\n            currentOffset += 6;\n            String[] opensTo = null;\n            if (opensToCount != 0) {\n                opensTo = new String[opensToCount];\n                for (int i = 0; i < opensToCount; ++i) {\n                    opensTo[i] = readModule(currentOffset, buffer);\n                    currentOffset += 2;\n                }\n            }\n            moduleVisitor.visitOpen(opens, opensFlags, opensTo);\n        }\n        // Read the 'uses_count' and 'uses' fields.\n        int usesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (usesCount-- > 0) {\n            moduleVisitor.visitUse(readClass(currentOffset, buffer));\n            currentOffset += 2;\n        }\n        // Read the  'provides_count' and 'provides' fields.\n        int providesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (providesCount-- > 0) {\n            // Read the provides_index, provides_with_count and provides_with_index fields and visit them.\n            String provides = readClass(currentOffset, buffer);\n            int providesWithCount = readUnsignedShort(currentOffset + 2);\n            currentOffset += 4;\n            String[] providesWith = new String[providesWithCount];\n            for (int i = 0; i < providesWithCount; ++i) {\n                providesWith[i] = readClass(currentOffset, buffer);\n                currentOffset += 2;\n            }\n            moduleVisitor.visitProvide(provides, providesWith);\n        }\n        // Visit the end of the module attributes.\n        moduleVisitor.visitEnd();\n    }\n\n    /**\n     * Reads a record component and visit it.\n     *\n     * @param classVisitor the current class visitor\n     * @param context information about the class being parsed.\n     * @param recordComponentOffset the offset of the current record component.\n     * @return the offset of the first byte following the record component.\n     */\n    private int readRecordComponent(final ClassVisitor classVisitor, final Context context, final int recordComponentOffset) {\n        char[] charBuffer = context.charBuffer;\n        int currentOffset = recordComponentOffset;\n        String name = readUTF8(currentOffset, charBuffer);\n        String descriptor = readUTF8(currentOffset + 2, charBuffer);\n        currentOffset += 4;\n        // Read the record component attributes (the variables are ordered as in Section 4.7 of the\n        // JVMS).\n        int accessFlags = 0;\n        // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n        // - The string corresponding to the Signature attribute, or null.\n        String signature = null;\n        // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n        int runtimeVisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n        int runtimeInvisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n        int runtimeVisibleTypeAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n        int runtimeInvisibleTypeAnnotationsOffset = 0;\n        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n        Attribute attributes = null;\n        int attributesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (attributesCount-- > 0) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentOffset, charBuffer);\n            int attributeLength = readInt(currentOffset + 2);\n            currentOffset += 6;\n            // The tests are sorted in decreasing frequency order (based on frequencies observed on\n            // typical classes).\n            if (Constants.SIGNATURE.equals(attributeName)) {\n                signature = readUTF8(currentOffset, charBuffer);\n            } else if (Constants.DEPRECATED.equals(attributeName)) {\n                accessFlags |= Opcodes.ACC_DEPRECATED;\n            } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleTypeAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleTypeAnnotationsOffset = currentOffset;\n            } else {\n                Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, -1, null);\n                attribute.nextAttribute = attributes;\n                attributes = attribute;\n            }\n            currentOffset += attributeLength;\n        }\n        RecordComponentVisitor recordComponentVisitor = classVisitor.visitRecordComponentExperimental(accessFlags, name, descriptor, signature);\n        if (recordComponentVisitor == null) {\n            return currentOffset;\n        }\n        // Visit the RuntimeVisibleAnnotations attribute.\n        if (runtimeVisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(recordComponentVisitor.visitAnnotationExperimental(annotationDescriptor, /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleAnnotations attribute.\n        if (runtimeInvisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(recordComponentVisitor.visitAnnotationExperimental(annotationDescriptor, /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeVisibleTypeAnnotations attribute.\n        if (runtimeVisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(recordComponentVisitor.visitTypeAnnotationExperimental(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleTypeAnnotations attribute.\n        if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(recordComponentVisitor.visitTypeAnnotationExperimental(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the non standard attributes.\n        while (attributes != null) {\n            // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.\n            Attribute nextAttribute = attributes.nextAttribute;\n            attributes.nextAttribute = null;\n            recordComponentVisitor.visitAttributeExperimental(attributes);\n            attributes = nextAttribute;\n        }\n        // Visit the end of the field.\n        recordComponentVisitor.visitEndExperimental();\n        return currentOffset;\n    }\n\n    /**\n     * Reads a JVMS field_info structure and makes the given visitor visit it.\n     *\n     * @param classVisitor the visitor that must visit the field.\n     * @param context information about the class being parsed.\n     * @param fieldInfoOffset the start offset of the field_info structure.\n     * @return the offset of the first byte following the field_info structure.\n     */\n    private int readField(final ClassVisitor classVisitor, final Context context, final int fieldInfoOffset) {\n        char[] charBuffer = context.charBuffer;\n        // Read the access_flags, name_index and descriptor_index fields.\n        int currentOffset = fieldInfoOffset;\n        int accessFlags = readUnsignedShort(currentOffset);\n        String name = readUTF8(currentOffset + 2, charBuffer);\n        String descriptor = readUTF8(currentOffset + 4, charBuffer);\n        currentOffset += 6;\n        // Read the field attributes (the variables are ordered as in Section 4.7 of the JVMS).\n        // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n        // - The value corresponding to the ConstantValue attribute, or null.\n        Object constantValue = null;\n        // - The string corresponding to the Signature attribute, or null.\n        String signature = null;\n        // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n        int runtimeVisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n        int runtimeInvisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n        int runtimeVisibleTypeAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n        int runtimeInvisibleTypeAnnotationsOffset = 0;\n        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n        Attribute attributes = null;\n        int attributesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (attributesCount-- > 0) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentOffset, charBuffer);\n            int attributeLength = readInt(currentOffset + 2);\n            currentOffset += 6;\n            // The tests are sorted in decreasing frequency order (based on frequencies observed on\n            // typical classes).\n            if (Constants.CONSTANT_VALUE.equals(attributeName)) {\n                int constantvalueIndex = readUnsignedShort(currentOffset);\n                constantValue = constantvalueIndex == 0 ? null : readConst(constantvalueIndex, charBuffer);\n            } else if (Constants.SIGNATURE.equals(attributeName)) {\n                signature = readUTF8(currentOffset, charBuffer);\n            } else if (Constants.DEPRECATED.equals(attributeName)) {\n                accessFlags |= Opcodes.ACC_DEPRECATED;\n            } else if (Constants.SYNTHETIC.equals(attributeName)) {\n                accessFlags |= Opcodes.ACC_SYNTHETIC;\n            } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleTypeAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleTypeAnnotationsOffset = currentOffset;\n            } else {\n                Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, -1, null);\n                attribute.nextAttribute = attributes;\n                attributes = attribute;\n            }\n            currentOffset += attributeLength;\n        }\n        // Visit the field declaration.\n        FieldVisitor fieldVisitor = classVisitor.visitField(accessFlags, name, descriptor, signature, constantValue);\n        if (fieldVisitor == null) {\n            return currentOffset;\n        }\n        // Visit the RuntimeVisibleAnnotations attribute.\n        if (runtimeVisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(fieldVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleAnnotations attribute.\n        if (runtimeInvisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(fieldVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeVisibleTypeAnnotations attribute.\n        if (runtimeVisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(fieldVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleTypeAnnotations attribute.\n        if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(fieldVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the non standard attributes.\n        while (attributes != null) {\n            // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.\n            Attribute nextAttribute = attributes.nextAttribute;\n            attributes.nextAttribute = null;\n            fieldVisitor.visitAttribute(attributes);\n            attributes = nextAttribute;\n        }\n        // Visit the end of the field.\n        fieldVisitor.visitEnd();\n        return currentOffset;\n    }\n\n    /**\n     * Reads a JVMS method_info structure and makes the given visitor visit it.\n     *\n     * @param classVisitor the visitor that must visit the method.\n     * @param context information about the class being parsed.\n     * @param methodInfoOffset the start offset of the method_info structure.\n     * @return the offset of the first byte following the method_info structure.\n     */\n    private int readMethod(final ClassVisitor classVisitor, final Context context, final int methodInfoOffset) {\n        char[] charBuffer = context.charBuffer;\n        // Read the access_flags, name_index and descriptor_index fields.\n        int currentOffset = methodInfoOffset;\n        context.currentMethodAccessFlags = readUnsignedShort(currentOffset);\n        context.currentMethodName = readUTF8(currentOffset + 2, charBuffer);\n        context.currentMethodDescriptor = readUTF8(currentOffset + 4, charBuffer);\n        currentOffset += 6;\n        // Read the method attributes (the variables are ordered as in Section 4.7 of the JVMS).\n        // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n        // - The offset of the Code attribute, or 0.\n        int codeOffset = 0;\n        // - The offset of the Exceptions attribute, or 0.\n        int exceptionsOffset = 0;\n        // - The strings corresponding to the Exceptions attribute, or null.\n        String[] exceptions = null;\n        // - Whether the method has a Synthetic attribute.\n        boolean synthetic = false;\n        // - The constant pool index contained in the Signature attribute, or 0.\n        int signatureIndex = 0;\n        // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n        int runtimeVisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n        int runtimeInvisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeVisibleParameterAnnotations attribute, or 0.\n        int runtimeVisibleParameterAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleParameterAnnotations attribute, or 0.\n        int runtimeInvisibleParameterAnnotationsOffset = 0;\n        // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n        int runtimeVisibleTypeAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n        int runtimeInvisibleTypeAnnotationsOffset = 0;\n        // - The offset of the AnnotationDefault attribute, or 0.\n        int annotationDefaultOffset = 0;\n        // - The offset of the MethodParameters attribute, or 0.\n        int methodParametersOffset = 0;\n        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n        Attribute attributes = null;\n        int attributesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (attributesCount-- > 0) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentOffset, charBuffer);\n            int attributeLength = readInt(currentOffset + 2);\n            currentOffset += 6;\n            // The tests are sorted in decreasing frequency order (based on frequencies observed on\n            // typical classes).\n            if (Constants.CODE.equals(attributeName)) {\n                if ((context.parsingOptions & SKIP_CODE) == 0) {\n                    codeOffset = currentOffset;\n                }\n            } else if (Constants.EXCEPTIONS.equals(attributeName)) {\n                exceptionsOffset = currentOffset;\n                exceptions = new String[readUnsignedShort(exceptionsOffset)];\n                int currentExceptionOffset = exceptionsOffset + 2;\n                for (int i = 0; i < exceptions.length; ++i) {\n                    exceptions[i] = readClass(currentExceptionOffset, charBuffer);\n                    currentExceptionOffset += 2;\n                }\n            } else if (Constants.SIGNATURE.equals(attributeName)) {\n                signatureIndex = readUnsignedShort(currentOffset);\n            } else if (Constants.DEPRECATED.equals(attributeName)) {\n                context.currentMethodAccessFlags |= Opcodes.ACC_DEPRECATED;\n            } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleTypeAnnotationsOffset = currentOffset;\n            } else if (Constants.ANNOTATION_DEFAULT.equals(attributeName)) {\n                annotationDefaultOffset = currentOffset;\n            } else if (Constants.SYNTHETIC.equals(attributeName)) {\n                synthetic = true;\n                context.currentMethodAccessFlags |= Opcodes.ACC_SYNTHETIC;\n            } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleTypeAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleParameterAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleParameterAnnotationsOffset = currentOffset;\n            } else if (Constants.METHOD_PARAMETERS.equals(attributeName)) {\n                methodParametersOffset = currentOffset;\n            } else {\n                Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, -1, null);\n                attribute.nextAttribute = attributes;\n                attributes = attribute;\n            }\n            currentOffset += attributeLength;\n        }\n        // Visit the method declaration.\n        MethodVisitor methodVisitor = classVisitor.visitMethod(context.currentMethodAccessFlags, context.currentMethodName, context.currentMethodDescriptor, signatureIndex == 0 ? null : readUtf(signatureIndex, charBuffer), exceptions);\n        if (methodVisitor == null) {\n            return currentOffset;\n        }\n        // If the returned MethodVisitor is in fact a MethodWriter, it means there is no method\n        // adapter between the reader and the writer. In this case, it might be possible to copy\n        // the method attributes directly into the writer. If so, return early without visiting\n        // the content of these attributes.\n        if (methodVisitor instanceof MethodWriter) {\n            MethodWriter methodWriter = (MethodWriter) methodVisitor;\n            if (methodWriter.canCopyMethodAttributes(this, synthetic, (context.currentMethodAccessFlags & Opcodes.ACC_DEPRECATED) != 0, readUnsignedShort(methodInfoOffset + 4), signatureIndex, exceptionsOffset)) {\n                methodWriter.setMethodAttributesSource(methodInfoOffset, currentOffset - methodInfoOffset);\n                return currentOffset;\n            }\n        }\n        // Visit the MethodParameters attribute.\n        if (methodParametersOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {\n            int parametersCount = readByte(methodParametersOffset);\n            int currentParameterOffset = methodParametersOffset + 1;\n            while (parametersCount-- > 0) {\n                // Read the name_index and access_flags fields and visit them.\n                methodVisitor.visitParameter(readUTF8(currentParameterOffset, charBuffer), readUnsignedShort(currentParameterOffset + 2));\n                currentParameterOffset += 4;\n            }\n        }\n        // Visit the AnnotationDefault attribute.\n        if (annotationDefaultOffset != 0) {\n            AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();\n            readElementValue(annotationVisitor, annotationDefaultOffset, null, charBuffer);\n            if (annotationVisitor != null) {\n                annotationVisitor.visitEnd();\n            }\n        }\n        // Visit the RuntimeVisibleAnnotations attribute.\n        if (runtimeVisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(methodVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleAnnotations attribute.\n        if (runtimeInvisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(methodVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeVisibleTypeAnnotations attribute.\n        if (runtimeVisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(methodVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleTypeAnnotations attribute.\n        if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(methodVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeVisibleParameterAnnotations attribute.\n        if (runtimeVisibleParameterAnnotationsOffset != 0) {\n            readParameterAnnotations(methodVisitor, context, runtimeVisibleParameterAnnotationsOffset, /* visible = */ true);\n        }\n        // Visit the RuntimeInvisibleParameterAnnotations attribute.\n        if (runtimeInvisibleParameterAnnotationsOffset != 0) {\n            readParameterAnnotations(methodVisitor, context, runtimeInvisibleParameterAnnotationsOffset,\n                    /* visible = */ false);\n        }\n        // Visit the non standard attributes.\n        while (attributes != null) {\n            // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.\n            Attribute nextAttribute = attributes.nextAttribute;\n            attributes.nextAttribute = null;\n            methodVisitor.visitAttribute(attributes);\n            attributes = nextAttribute;\n        }\n        // Visit the Code attribute.\n        if (codeOffset != 0) {\n            methodVisitor.visitCode();\n            readCode(methodVisitor, context, codeOffset);\n        }\n        // Visit the end of the method.\n        methodVisitor.visitEnd();\n        return currentOffset;\n    }\n    // ----------------------------------------------------------------------------------------------\n    // Methods to parse a Code attribute\n    // ----------------------------------------------------------------------------------------------\n\n    /**\n     * Reads a JVMS 'Code' attribute and makes the given visitor visit it.\n     *\n     * @param methodVisitor the visitor that must visit the Code attribute.\n     * @param context information about the class being parsed.\n     * @param codeOffset the start offset in {@link #classFileBuffer} of the Code attribute, excluding\n     *     its attribute_name_index and attribute_length fields.\n     */\n    private void readCode(final MethodVisitor methodVisitor, final Context context, final int codeOffset) {\n        int currentOffset = codeOffset;\n        // Read the max_stack, max_locals and code_length fields.\n        final byte[] classBuffer = classFileBuffer;\n        final char[] charBuffer = context.charBuffer;\n        final int maxStack = readUnsignedShort(currentOffset);\n        final int maxLocals = readUnsignedShort(currentOffset + 2);\n        final int codeLength = readInt(currentOffset + 4);\n        currentOffset += 8;\n        // Read the bytecode 'code' array to create a label for each referenced instruction.\n        final int bytecodeStartOffset = currentOffset;\n        final int bytecodeEndOffset = currentOffset + codeLength;\n        final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];\n        while (currentOffset < bytecodeEndOffset) {\n            final int bytecodeOffset = currentOffset - bytecodeStartOffset;\n            final int opcode = classBuffer[currentOffset] & 0xFF;\n            switch (opcode) {\n            case Constants.NOP:\n            case Constants.ACONST_NULL:\n            case Constants.ICONST_M1:\n            case Constants.ICONST_0:\n            case Constants.ICONST_1:\n            case Constants.ICONST_2:\n            case Constants.ICONST_3:\n            case Constants.ICONST_4:\n            case Constants.ICONST_5:\n            case Constants.LCONST_0:\n            case Constants.LCONST_1:\n            case Constants.FCONST_0:\n            case Constants.FCONST_1:\n            case Constants.FCONST_2:\n            case Constants.DCONST_0:\n            case Constants.DCONST_1:\n            case Constants.IALOAD:\n            case Constants.LALOAD:\n            case Constants.FALOAD:\n            case Constants.DALOAD:\n            case Constants.AALOAD:\n            case Constants.BALOAD:\n            case Constants.CALOAD:\n            case Constants.SALOAD:\n            case Constants.IASTORE:\n            case Constants.LASTORE:\n            case Constants.FASTORE:\n            case Constants.DASTORE:\n            case Constants.AASTORE:\n            case Constants.BASTORE:\n            case Constants.CASTORE:\n            case Constants.SASTORE:\n            case Constants.POP:\n            case Constants.POP2:\n            case Constants.DUP:\n            case Constants.DUP_X1:\n            case Constants.DUP_X2:\n            case Constants.DUP2:\n            case Constants.DUP2_X1:\n            case Constants.DUP2_X2:\n            case Constants.SWAP:\n            case Constants.IADD:\n            case Constants.LADD:\n            case Constants.FADD:\n            case Constants.DADD:\n            case Constants.ISUB:\n            case Constants.LSUB:\n            case Constants.FSUB:\n            case Constants.DSUB:\n            case Constants.IMUL:\n            case Constants.LMUL:\n            case Constants.FMUL:\n            case Constants.DMUL:\n            case Constants.IDIV:\n            case Constants.LDIV:\n            case Constants.FDIV:\n            case Constants.DDIV:\n            case Constants.IREM:\n            case Constants.LREM:\n            case Constants.FREM:\n            case Constants.DREM:\n            case Constants.INEG:\n            case Constants.LNEG:\n            case Constants.FNEG:\n            case Constants.DNEG:\n            case Constants.ISHL:\n            case Constants.LSHL:\n            case Constants.ISHR:\n            case Constants.LSHR:\n            case Constants.IUSHR:\n            case Constants.LUSHR:\n            case Constants.IAND:\n            case Constants.LAND:\n            case Constants.IOR:\n            case Constants.LOR:\n            case Constants.IXOR:\n            case Constants.LXOR:\n            case Constants.I2L:\n            case Constants.I2F:\n            case Constants.I2D:\n            case Constants.L2I:\n            case Constants.L2F:\n            case Constants.L2D:\n            case Constants.F2I:\n            case Constants.F2L:\n            case Constants.F2D:\n            case Constants.D2I:\n            case Constants.D2L:\n            case Constants.D2F:\n            case Constants.I2B:\n            case Constants.I2C:\n            case Constants.I2S:\n            case Constants.LCMP:\n            case Constants.FCMPL:\n            case Constants.FCMPG:\n            case Constants.DCMPL:\n            case Constants.DCMPG:\n            case Constants.IRETURN:\n            case Constants.LRETURN:\n            case Constants.FRETURN:\n            case Constants.DRETURN:\n            case Constants.ARETURN:\n            case Constants.RETURN:\n            case Constants.ARRAYLENGTH:\n            case Constants.ATHROW:\n            case Constants.MONITORENTER:\n            case Constants.MONITOREXIT:\n            case Constants.ILOAD_0:\n            case Constants.ILOAD_1:\n            case Constants.ILOAD_2:\n            case Constants.ILOAD_3:\n            case Constants.LLOAD_0:\n            case Constants.LLOAD_1:\n            case Constants.LLOAD_2:\n            case Constants.LLOAD_3:\n            case Constants.FLOAD_0:\n            case Constants.FLOAD_1:\n            case Constants.FLOAD_2:\n            case Constants.FLOAD_3:\n            case Constants.DLOAD_0:\n            case Constants.DLOAD_1:\n            case Constants.DLOAD_2:\n            case Constants.DLOAD_3:\n            case Constants.ALOAD_0:\n            case Constants.ALOAD_1:\n            case Constants.ALOAD_2:\n            case Constants.ALOAD_3:\n            case Constants.ISTORE_0:\n            case Constants.ISTORE_1:\n            case Constants.ISTORE_2:\n            case Constants.ISTORE_3:\n            case Constants.LSTORE_0:\n            case Constants.LSTORE_1:\n            case Constants.LSTORE_2:\n            case Constants.LSTORE_3:\n            case Constants.FSTORE_0:\n            case Constants.FSTORE_1:\n            case Constants.FSTORE_2:\n            case Constants.FSTORE_3:\n            case Constants.DSTORE_0:\n            case Constants.DSTORE_1:\n            case Constants.DSTORE_2:\n            case Constants.DSTORE_3:\n            case Constants.ASTORE_0:\n            case Constants.ASTORE_1:\n            case Constants.ASTORE_2:\n            case Constants.ASTORE_3:\n                currentOffset += 1;\n                break;\n            case Constants.IFEQ:\n            case Constants.IFNE:\n            case Constants.IFLT:\n            case Constants.IFGE:\n            case Constants.IFGT:\n            case Constants.IFLE:\n            case Constants.IF_ICMPEQ:\n            case Constants.IF_ICMPNE:\n            case Constants.IF_ICMPLT:\n            case Constants.IF_ICMPGE:\n            case Constants.IF_ICMPGT:\n            case Constants.IF_ICMPLE:\n            case Constants.IF_ACMPEQ:\n            case Constants.IF_ACMPNE:\n            case Constants.GOTO:\n            case Constants.JSR:\n            case Constants.IFNULL:\n            case Constants.IFNONNULL:\n                createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);\n                currentOffset += 3;\n                break;\n            case Constants.ASM_IFEQ:\n            case Constants.ASM_IFNE:\n            case Constants.ASM_IFLT:\n            case Constants.ASM_IFGE:\n            case Constants.ASM_IFGT:\n            case Constants.ASM_IFLE:\n            case Constants.ASM_IF_ICMPEQ:\n            case Constants.ASM_IF_ICMPNE:\n            case Constants.ASM_IF_ICMPLT:\n            case Constants.ASM_IF_ICMPGE:\n            case Constants.ASM_IF_ICMPGT:\n            case Constants.ASM_IF_ICMPLE:\n            case Constants.ASM_IF_ACMPEQ:\n            case Constants.ASM_IF_ACMPNE:\n            case Constants.ASM_GOTO:\n            case Constants.ASM_JSR:\n            case Constants.ASM_IFNULL:\n            case Constants.ASM_IFNONNULL:\n                createLabel(bytecodeOffset + readUnsignedShort(currentOffset + 1), labels);\n                currentOffset += 3;\n                break;\n            case Constants.GOTO_W:\n            case Constants.JSR_W:\n            case Constants.ASM_GOTO_W:\n                createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);\n                currentOffset += 5;\n                break;\n            case Constants.WIDE:\n                switch (classBuffer[currentOffset + 1] & 0xFF) {\n                case Constants.ILOAD:\n                case Constants.FLOAD:\n                case Constants.ALOAD:\n                case Constants.LLOAD:\n                case Constants.DLOAD:\n                case Constants.ISTORE:\n                case Constants.FSTORE:\n                case Constants.ASTORE:\n                case Constants.LSTORE:\n                case Constants.DSTORE:\n                case Constants.RET:\n                    currentOffset += 4;\n                    break;\n                case Constants.IINC:\n                    currentOffset += 6;\n                    break;\n                default:\n                    throw new IllegalArgumentException();\n                }\n                break;\n            case Constants.TABLESWITCH:\n                // Skip 0 to 3 padding bytes.\n                currentOffset += 4 - (bytecodeOffset & 3);\n                // Read the default label and the number of table entries.\n                createLabel(bytecodeOffset + readInt(currentOffset), labels);\n                int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;\n                currentOffset += 12;\n                // Read the table labels.\n                while (numTableEntries-- > 0) {\n                    createLabel(bytecodeOffset + readInt(currentOffset), labels);\n                    currentOffset += 4;\n                }\n                break;\n            case Constants.LOOKUPSWITCH:\n                // Skip 0 to 3 padding bytes.\n                currentOffset += 4 - (bytecodeOffset & 3);\n                // Read the default label and the number of switch cases.\n                createLabel(bytecodeOffset + readInt(currentOffset), labels);\n                int numSwitchCases = readInt(currentOffset + 4);\n                currentOffset += 8;\n                // Read the switch labels.\n                while (numSwitchCases-- > 0) {\n                    createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);\n                    currentOffset += 8;\n                }\n                break;\n            case Constants.ILOAD:\n            case Constants.LLOAD:\n            case Constants.FLOAD:\n            case Constants.DLOAD:\n            case Constants.ALOAD:\n            case Constants.ISTORE:\n            case Constants.LSTORE:\n            case Constants.FSTORE:\n            case Constants.DSTORE:\n            case Constants.ASTORE:\n            case Constants.RET:\n            case Constants.BIPUSH:\n            case Constants.NEWARRAY:\n            case Constants.LDC:\n                currentOffset += 2;\n                break;\n            case Constants.SIPUSH:\n            case Constants.LDC_W:\n            case Constants.LDC2_W:\n            case Constants.GETSTATIC:\n            case Constants.PUTSTATIC:\n            case Constants.GETFIELD:\n            case Constants.PUTFIELD:\n            case Constants.INVOKEVIRTUAL:\n            case Constants.INVOKESPECIAL:\n            case Constants.INVOKESTATIC:\n            case Constants.NEW:\n            case Constants.ANEWARRAY:\n            case Constants.CHECKCAST:\n            case Constants.INSTANCEOF:\n            case Constants.IINC:\n                currentOffset += 3;\n                break;\n            case Constants.INVOKEINTERFACE:\n            case Constants.INVOKEDYNAMIC:\n                currentOffset += 5;\n                break;\n            case Constants.MULTIANEWARRAY:\n                currentOffset += 4;\n                break;\n            default:\n                throw new IllegalArgumentException();\n            }\n        }\n        // Read the 'exception_table_length' and 'exception_table' field to create a label for each\n        // referenced instruction, and to make methodVisitor visit the corresponding try catch blocks.\n        int exceptionTableLength = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (exceptionTableLength-- > 0) {\n            Label start = createLabel(readUnsignedShort(currentOffset), labels);\n            Label end = createLabel(readUnsignedShort(currentOffset + 2), labels);\n            Label handler = createLabel(readUnsignedShort(currentOffset + 4), labels);\n            String catchType = readUTF8(cpInfoOffsets[readUnsignedShort(currentOffset + 6)], charBuffer);\n            currentOffset += 8;\n            methodVisitor.visitTryCatchBlock(start, end, handler, catchType);\n        }\n        // Read the Code attributes to create a label for each referenced instruction (the variables\n        // are ordered as in Section 4.7 of the JVMS). Attribute offsets exclude the\n        // attribute_name_index and attribute_length fields.\n        // - The offset of the current 'stack_map_frame' in the StackMap[Table] attribute, or 0.\n        // Initially, this is the offset of the first 'stack_map_frame' entry. Then this offset is\n        // updated after each stack_map_frame is read.\n        int stackMapFrameOffset = 0;\n        // - The end offset of the StackMap[Table] attribute, or 0.\n        int stackMapTableEndOffset = 0;\n        // - Whether the stack map frames are compressed (i.e. in a StackMapTable) or not.\n        boolean compressedFrames = true;\n        // - The offset of the LocalVariableTable attribute, or 0.\n        int localVariableTableOffset = 0;\n        // - The offset of the LocalVariableTypeTable attribute, or 0.\n        int localVariableTypeTableOffset = 0;\n        // - The offset of each 'type_annotation' entry in the RuntimeVisibleTypeAnnotations\n        // attribute, or null.\n        int[] visibleTypeAnnotationOffsets = null;\n        // - The offset of each 'type_annotation' entry in the RuntimeInvisibleTypeAnnotations\n        // attribute, or null.\n        int[] invisibleTypeAnnotationOffsets = null;\n        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n        Attribute attributes = null;\n        int attributesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (attributesCount-- > 0) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentOffset, charBuffer);\n            int attributeLength = readInt(currentOffset + 2);\n            currentOffset += 6;\n            if (Constants.LOCAL_VARIABLE_TABLE.equals(attributeName)) {\n                if ((context.parsingOptions & SKIP_DEBUG) == 0) {\n                    localVariableTableOffset = currentOffset;\n                    // Parse the attribute to find the corresponding (debug only) labels.\n                    int currentLocalVariableTableOffset = currentOffset;\n                    int localVariableTableLength = readUnsignedShort(currentLocalVariableTableOffset);\n                    currentLocalVariableTableOffset += 2;\n                    while (localVariableTableLength-- > 0) {\n                        int startPc = readUnsignedShort(currentLocalVariableTableOffset);\n                        createDebugLabel(startPc, labels);\n                        int length = readUnsignedShort(currentLocalVariableTableOffset + 2);\n                        createDebugLabel(startPc + length, labels);\n                        // Skip the name_index, descriptor_index and index fields (2 bytes each).\n                        currentLocalVariableTableOffset += 10;\n                    }\n                }\n            } else if (Constants.LOCAL_VARIABLE_TYPE_TABLE.equals(attributeName)) {\n                localVariableTypeTableOffset = currentOffset;\n                // Here we do not extract the labels corresponding to the attribute content. We assume they\n                // are the same or a subset of those of the LocalVariableTable attribute.\n            } else if (Constants.LINE_NUMBER_TABLE.equals(attributeName)) {\n                if ((context.parsingOptions & SKIP_DEBUG) == 0) {\n                    // Parse the attribute to find the corresponding (debug only) labels.\n                    int currentLineNumberTableOffset = currentOffset;\n                    int lineNumberTableLength = readUnsignedShort(currentLineNumberTableOffset);\n                    currentLineNumberTableOffset += 2;\n                    while (lineNumberTableLength-- > 0) {\n                        int startPc = readUnsignedShort(currentLineNumberTableOffset);\n                        int lineNumber = readUnsignedShort(currentLineNumberTableOffset + 2);\n                        currentLineNumberTableOffset += 4;\n                        createDebugLabel(startPc, labels);\n                        labels[startPc].addLineNumber(lineNumber);\n                    }\n                }\n            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                visibleTypeAnnotationOffsets = readTypeAnnotations(methodVisitor, context, currentOffset, /* visible = */ true);\n                // Here we do not extract the labels corresponding to the attribute content. This would\n                // require a full parsing of the attribute, which would need to be repeated when parsing\n                // the bytecode instructions (see below). Instead, the content of the attribute is read one\n                // type annotation at a time (i.e. after a type annotation has been visited, the next type\n                // annotation is read), and the labels it contains are also extracted one annotation at a\n                // time. This assumes that type annotations are ordered by increasing bytecode offset.\n            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                invisibleTypeAnnotationOffsets = readTypeAnnotations(methodVisitor, context, currentOffset, /* visible = */ false);\n                // Same comment as above for the RuntimeVisibleTypeAnnotations attribute.\n            } else if (Constants.STACK_MAP_TABLE.equals(attributeName)) {\n                if ((context.parsingOptions & SKIP_FRAMES) == 0) {\n                    stackMapFrameOffset = currentOffset + 2;\n                    stackMapTableEndOffset = currentOffset + attributeLength;\n                }\n                // Here we do not extract the labels corresponding to the attribute content. This would\n                // require a full parsing of the attribute, which would need to be repeated when parsing\n                // the bytecode instructions (see below). Instead, the content of the attribute is read one\n                // frame at a time (i.e. after a frame has been visited, the next frame is read), and the\n                // labels it contains are also extracted one frame at a time. Thanks to the ordering of\n                // frames, having only a \"one frame lookahead\" is not a problem, i.e. it is not possible to\n                // see an offset smaller than the offset of the current instruction and for which no Label\n                // exist. Except for UNINITIALIZED type offsets. We solve this by parsing the stack map\n                // table without a full decoding (see below).\n            } else if (\"StackMap\".equals(attributeName)) {\n                if ((context.parsingOptions & SKIP_FRAMES) == 0) {\n                    stackMapFrameOffset = currentOffset + 2;\n                    stackMapTableEndOffset = currentOffset + attributeLength;\n                    compressedFrames = false;\n                }\n                // IMPORTANT! Here we assume that the frames are ordered, as in the StackMapTable attribute,\n                // although this is not guaranteed by the attribute format. This allows an incremental\n                // extraction of the labels corresponding to this attribute (see the comment above for the\n                // StackMapTable attribute).\n            } else {\n                Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, codeOffset, labels);\n                attribute.nextAttribute = attributes;\n                attributes = attribute;\n            }\n            currentOffset += attributeLength;\n        }\n        // Initialize the context fields related to stack map frames, and generate the first\n        // (implicit) stack map frame, if needed.\n        final boolean expandFrames = (context.parsingOptions & EXPAND_FRAMES) != 0;\n        if (stackMapFrameOffset != 0) {\n            // The bytecode offset of the first explicit frame is not offset_delta + 1 but only\n            // offset_delta. Setting the implicit frame offset to -1 allows us to use of the\n            // \"offset_delta + 1\" rule in all cases.\n            context.currentFrameOffset = -1;\n            context.currentFrameType = 0;\n            context.currentFrameLocalCount = 0;\n            context.currentFrameLocalCountDelta = 0;\n            context.currentFrameLocalTypes = new Object[maxLocals];\n            context.currentFrameStackCount = 0;\n            context.currentFrameStackTypes = new Object[maxStack];\n            if (expandFrames) {\n                computeImplicitFrame(context);\n            }\n            // Find the labels for UNINITIALIZED frame types. Instead of decoding each element of the\n            // stack map table, we look for 3 consecutive bytes that \"look like\" an UNINITIALIZED type\n            // (tag ITEM_Uninitialized, offset within bytecode bounds, NEW instruction at this offset).\n            // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,\n            // and the only consequence will be the creation of an unneeded label. This is better than\n            // creating a label for each NEW instruction, and faster than fully decoding the whole stack\n            // map table.\n            for (int offset = stackMapFrameOffset; offset < stackMapTableEndOffset - 2; ++offset) {\n                if (classBuffer[offset] == Frame.ITEM_UNINITIALIZED) {\n                    int potentialBytecodeOffset = readUnsignedShort(offset + 1);\n                    if (potentialBytecodeOffset >= 0 && potentialBytecodeOffset < codeLength && (classBuffer[bytecodeStartOffset + potentialBytecodeOffset] & 0xFF) == Opcodes.NEW) {\n                        createLabel(potentialBytecodeOffset, labels);\n                    }\n                }\n            }\n        }\n        if (expandFrames && (context.parsingOptions & EXPAND_ASM_INSNS) != 0) {\n            // Expanding the ASM specific instructions can introduce F_INSERT frames, even if the method\n            // does not currently have any frame. These inserted frames must be computed by simulating the\n            // effect of the bytecode instructions, one by one, starting from the implicit first frame.\n            // For this, MethodWriter needs to know maxLocals before the first instruction is visited. To\n            // ensure this, we visit the implicit first frame here (passing only maxLocals - the rest is\n            // computed in MethodWriter).\n            methodVisitor.visitFrame(Opcodes.F_NEW, maxLocals, null, 0, null);\n        }\n        // Visit the bytecode instructions. First, introduce state variables for the incremental parsing\n        // of the type annotations.\n        // Index of the next runtime visible type annotation to read (in the\n        // visibleTypeAnnotationOffsets array).\n        int currentVisibleTypeAnnotationIndex = 0;\n        // The bytecode offset of the next runtime visible type annotation to read, or -1.\n        int currentVisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, 0);\n        // Index of the next runtime invisible type annotation to read (in the\n        // invisibleTypeAnnotationOffsets array).\n        int currentInvisibleTypeAnnotationIndex = 0;\n        // The bytecode offset of the next runtime invisible type annotation to read, or -1.\n        int currentInvisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, 0);\n        // Whether a F_INSERT stack map frame must be inserted before the current instruction.\n        boolean insertFrame = false;\n        // The delta to subtract from a goto_w or jsr_w opcode to get the corresponding goto or jsr\n        // opcode, or 0 if goto_w and jsr_w must be left unchanged (i.e. when expanding ASM specific\n        // instructions).\n        final int wideJumpOpcodeDelta = (context.parsingOptions & EXPAND_ASM_INSNS) == 0 ? Constants.WIDE_JUMP_OPCODE_DELTA : 0;\n        currentOffset = bytecodeStartOffset;\n        while (currentOffset < bytecodeEndOffset) {\n            final int currentBytecodeOffset = currentOffset - bytecodeStartOffset;\n            // Visit the label and the line number(s) for this bytecode offset, if any.\n            Label currentLabel = labels[currentBytecodeOffset];\n            if (currentLabel != null) {\n                currentLabel.accept(methodVisitor, (context.parsingOptions & SKIP_DEBUG) == 0);\n            }\n            // Visit the stack map frame for this bytecode offset, if any.\n            while (stackMapFrameOffset != 0 && (context.currentFrameOffset == currentBytecodeOffset || context.currentFrameOffset == -1)) {\n                // If there is a stack map frame for this offset, make methodVisitor visit it, and read the\n                // next stack map frame if there is one.\n                if (context.currentFrameOffset != -1) {\n                    if (!compressedFrames || expandFrames) {\n                        methodVisitor.visitFrame(Opcodes.F_NEW, context.currentFrameLocalCount, context.currentFrameLocalTypes, context.currentFrameStackCount, context.currentFrameStackTypes);\n                    } else {\n                        methodVisitor.visitFrame(context.currentFrameType, context.currentFrameLocalCountDelta, context.currentFrameLocalTypes, context.currentFrameStackCount, context.currentFrameStackTypes);\n                    }\n                    // Since there is already a stack map frame for this bytecode offset, there is no need to\n                    // insert a new one.\n                    insertFrame = false;\n                }\n                if (stackMapFrameOffset < stackMapTableEndOffset) {\n                    stackMapFrameOffset = readStackMapFrame(stackMapFrameOffset, compressedFrames, expandFrames, context);\n                } else {\n                    stackMapFrameOffset = 0;\n                }\n            }\n            // Insert a stack map frame for this bytecode offset, if requested by setting insertFrame to\n            // true during the previous iteration. The actual frame content is computed in MethodWriter.\n            if (insertFrame) {\n                if ((context.parsingOptions & EXPAND_FRAMES) != 0) {\n                    methodVisitor.visitFrame(Constants.F_INSERT, 0, null, 0, null);\n                }\n                insertFrame = false;\n            }\n            // Visit the instruction at this bytecode offset.\n            int opcode = classBuffer[currentOffset] & 0xFF;\n            switch (opcode) {\n            case Constants.NOP:\n            case Constants.ACONST_NULL:\n            case Constants.ICONST_M1:\n            case Constants.ICONST_0:\n            case Constants.ICONST_1:\n            case Constants.ICONST_2:\n            case Constants.ICONST_3:\n            case Constants.ICONST_4:\n            case Constants.ICONST_5:\n            case Constants.LCONST_0:\n            case Constants.LCONST_1:\n            case Constants.FCONST_0:\n            case Constants.FCONST_1:\n            case Constants.FCONST_2:\n            case Constants.DCONST_0:\n            case Constants.DCONST_1:\n            case Constants.IALOAD:\n            case Constants.LALOAD:\n            case Constants.FALOAD:\n            case Constants.DALOAD:\n            case Constants.AALOAD:\n            case Constants.BALOAD:\n            case Constants.CALOAD:\n            case Constants.SALOAD:\n            case Constants.IASTORE:\n            case Constants.LASTORE:\n            case Constants.FASTORE:\n            case Constants.DASTORE:\n            case Constants.AASTORE:\n            case Constants.BASTORE:\n            case Constants.CASTORE:\n            case Constants.SASTORE:\n            case Constants.POP:\n            case Constants.POP2:\n            case Constants.DUP:\n            case Constants.DUP_X1:\n            case Constants.DUP_X2:\n            case Constants.DUP2:\n            case Constants.DUP2_X1:\n            case Constants.DUP2_X2:\n            case Constants.SWAP:\n            case Constants.IADD:\n            case Constants.LADD:\n            case Constants.FADD:\n            case Constants.DADD:\n            case Constants.ISUB:\n            case Constants.LSUB:\n            case Constants.FSUB:\n            case Constants.DSUB:\n            case Constants.IMUL:\n            case Constants.LMUL:\n            case Constants.FMUL:\n            case Constants.DMUL:\n            case Constants.IDIV:\n            case Constants.LDIV:\n            case Constants.FDIV:\n            case Constants.DDIV:\n            case Constants.IREM:\n            case Constants.LREM:\n            case Constants.FREM:\n            case Constants.DREM:\n            case Constants.INEG:\n            case Constants.LNEG:\n            case Constants.FNEG:\n            case Constants.DNEG:\n            case Constants.ISHL:\n            case Constants.LSHL:\n            case Constants.ISHR:\n            case Constants.LSHR:\n            case Constants.IUSHR:\n            case Constants.LUSHR:\n            case Constants.IAND:\n            case Constants.LAND:\n            case Constants.IOR:\n            case Constants.LOR:\n            case Constants.IXOR:\n            case Constants.LXOR:\n            case Constants.I2L:\n            case Constants.I2F:\n            case Constants.I2D:\n            case Constants.L2I:\n            case Constants.L2F:\n            case Constants.L2D:\n            case Constants.F2I:\n            case Constants.F2L:\n            case Constants.F2D:\n            case Constants.D2I:\n            case Constants.D2L:\n            case Constants.D2F:\n            case Constants.I2B:\n            case Constants.I2C:\n            case Constants.I2S:\n            case Constants.LCMP:\n            case Constants.FCMPL:\n            case Constants.FCMPG:\n            case Constants.DCMPL:\n            case Constants.DCMPG:\n            case Constants.IRETURN:\n            case Constants.LRETURN:\n            case Constants.FRETURN:\n            case Constants.DRETURN:\n            case Constants.ARETURN:\n            case Constants.RETURN:\n            case Constants.ARRAYLENGTH:\n            case Constants.ATHROW:\n            case Constants.MONITORENTER:\n            case Constants.MONITOREXIT:\n                methodVisitor.visitInsn(opcode);\n                currentOffset += 1;\n                break;\n            case Constants.ILOAD_0:\n            case Constants.ILOAD_1:\n            case Constants.ILOAD_2:\n            case Constants.ILOAD_3:\n            case Constants.LLOAD_0:\n            case Constants.LLOAD_1:\n            case Constants.LLOAD_2:\n            case Constants.LLOAD_3:\n            case Constants.FLOAD_0:\n            case Constants.FLOAD_1:\n            case Constants.FLOAD_2:\n            case Constants.FLOAD_3:\n            case Constants.DLOAD_0:\n            case Constants.DLOAD_1:\n            case Constants.DLOAD_2:\n            case Constants.DLOAD_3:\n            case Constants.ALOAD_0:\n            case Constants.ALOAD_1:\n            case Constants.ALOAD_2:\n            case Constants.ALOAD_3:\n                opcode -= Constants.ILOAD_0;\n                methodVisitor.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\n                currentOffset += 1;\n                break;\n            case Constants.ISTORE_0:\n            case Constants.ISTORE_1:\n            case Constants.ISTORE_2:\n            case Constants.ISTORE_3:\n            case Constants.LSTORE_0:\n            case Constants.LSTORE_1:\n            case Constants.LSTORE_2:\n            case Constants.LSTORE_3:\n            case Constants.FSTORE_0:\n            case Constants.FSTORE_1:\n            case Constants.FSTORE_2:\n            case Constants.FSTORE_3:\n            case Constants.DSTORE_0:\n            case Constants.DSTORE_1:\n            case Constants.DSTORE_2:\n            case Constants.DSTORE_3:\n            case Constants.ASTORE_0:\n            case Constants.ASTORE_1:\n            case Constants.ASTORE_2:\n            case Constants.ASTORE_3:\n                opcode -= Constants.ISTORE_0;\n                methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);\n                currentOffset += 1;\n                break;\n            case Constants.IFEQ:\n            case Constants.IFNE:\n            case Constants.IFLT:\n            case Constants.IFGE:\n            case Constants.IFGT:\n            case Constants.IFLE:\n            case Constants.IF_ICMPEQ:\n            case Constants.IF_ICMPNE:\n            case Constants.IF_ICMPLT:\n            case Constants.IF_ICMPGE:\n            case Constants.IF_ICMPGT:\n            case Constants.IF_ICMPLE:\n            case Constants.IF_ACMPEQ:\n            case Constants.IF_ACMPNE:\n            case Constants.GOTO:\n            case Constants.JSR:\n            case Constants.IFNULL:\n            case Constants.IFNONNULL:\n                methodVisitor.visitJumpInsn(opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);\n                currentOffset += 3;\n                break;\n            case Constants.GOTO_W:\n            case Constants.JSR_W:\n                methodVisitor.visitJumpInsn(opcode - wideJumpOpcodeDelta, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);\n                currentOffset += 5;\n                break;\n            case Constants.ASM_IFEQ:\n            case Constants.ASM_IFNE:\n            case Constants.ASM_IFLT:\n            case Constants.ASM_IFGE:\n            case Constants.ASM_IFGT:\n            case Constants.ASM_IFLE:\n            case Constants.ASM_IF_ICMPEQ:\n            case Constants.ASM_IF_ICMPNE:\n            case Constants.ASM_IF_ICMPLT:\n            case Constants.ASM_IF_ICMPGE:\n            case Constants.ASM_IF_ICMPGT:\n            case Constants.ASM_IF_ICMPLE:\n            case Constants.ASM_IF_ACMPEQ:\n            case Constants.ASM_IF_ACMPNE:\n            case Constants.ASM_GOTO:\n            case Constants.ASM_JSR:\n            case Constants.ASM_IFNULL:\n            case Constants.ASM_IFNONNULL: {\n                // A forward jump with an offset > 32767. In this case we automatically replace ASM_GOTO\n                // with GOTO_W, ASM_JSR with JSR_W and ASM_IFxxx <l> with IFNOTxxx <L> GOTO_W <l> L:...,\n                // where IFNOTxxx is the \"opposite\" opcode of ASMS_IFxxx (e.g. IFNE for ASM_IFEQ) and\n                // where <L> designates the instruction just after the GOTO_W.\n                // First, change the ASM specific opcodes ASM_IFEQ ... ASM_JSR, ASM_IFNULL and\n                // ASM_IFNONNULL to IFEQ ... JSR, IFNULL and IFNONNULL.\n                opcode = opcode < Constants.ASM_IFNULL ? opcode - Constants.ASM_OPCODE_DELTA : opcode - Constants.ASM_IFNULL_OPCODE_DELTA;\n                Label target = labels[currentBytecodeOffset + readUnsignedShort(currentOffset + 1)];\n                if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {\n                    // Replace GOTO with GOTO_W and JSR with JSR_W.\n                    methodVisitor.visitJumpInsn(opcode + Constants.WIDE_JUMP_OPCODE_DELTA, target);\n                } else {\n                    // Compute the \"opposite\" of opcode. This can be done by flipping the least\n                    // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ\n                    // (with a pre and post offset by 1).\n                    opcode = opcode < Opcodes.GOTO ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1;\n                    Label endif = createLabel(currentBytecodeOffset + 3, labels);\n                    methodVisitor.visitJumpInsn(opcode, endif);\n                    methodVisitor.visitJumpInsn(Constants.GOTO_W, target);\n                    // endif designates the instruction just after GOTO_W, and is visited as part of the\n                    // next instruction. Since it is a jump target, we need to insert a frame here.\n                    insertFrame = true;\n                }\n                currentOffset += 3;\n                break;\n            }\n            case Constants.ASM_GOTO_W:\n                // Replace ASM_GOTO_W with GOTO_W.\n                methodVisitor.visitJumpInsn(Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);\n                // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns\n                // IFNOTxxx <L> ASM_GOTO_W <l> L:..., see MethodWriter), so we need to insert a frame\n                // here.\n                insertFrame = true;\n                currentOffset += 5;\n                break;\n            case Constants.WIDE:\n                opcode = classBuffer[currentOffset + 1] & 0xFF;\n                if (opcode == Opcodes.IINC) {\n                    methodVisitor.visitIincInsn(readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));\n                    currentOffset += 6;\n                } else {\n                    methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));\n                    currentOffset += 4;\n                }\n                break;\n            case Constants.TABLESWITCH: {\n                // Skip 0 to 3 padding bytes.\n                currentOffset += 4 - (currentBytecodeOffset & 3);\n                // Read the instruction.\n                Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];\n                int low = readInt(currentOffset + 4);\n                int high = readInt(currentOffset + 8);\n                currentOffset += 12;\n                Label[] table = new Label[high - low + 1];\n                for (int i = 0; i < table.length; ++i) {\n                    table[i] = labels[currentBytecodeOffset + readInt(currentOffset)];\n                    currentOffset += 4;\n                }\n                methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);\n                break;\n            }\n            case Constants.LOOKUPSWITCH: {\n                // Skip 0 to 3 padding bytes.\n                currentOffset += 4 - (currentBytecodeOffset & 3);\n                // Read the instruction.\n                Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];\n                int numPairs = readInt(currentOffset + 4);\n                currentOffset += 8;\n                int[] keys = new int[numPairs];\n                Label[] values = new Label[numPairs];\n                for (int i = 0; i < numPairs; ++i) {\n                    keys[i] = readInt(currentOffset);\n                    values[i] = labels[currentBytecodeOffset + readInt(currentOffset + 4)];\n                    currentOffset += 8;\n                }\n                methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);\n                break;\n            }\n            case Constants.ILOAD:\n            case Constants.LLOAD:\n            case Constants.FLOAD:\n            case Constants.DLOAD:\n            case Constants.ALOAD:\n            case Constants.ISTORE:\n            case Constants.LSTORE:\n            case Constants.FSTORE:\n            case Constants.DSTORE:\n            case Constants.ASTORE:\n            case Constants.RET:\n                methodVisitor.visitVarInsn(opcode, classBuffer[currentOffset + 1] & 0xFF);\n                currentOffset += 2;\n                break;\n            case Constants.BIPUSH:\n            case Constants.NEWARRAY:\n                methodVisitor.visitIntInsn(opcode, classBuffer[currentOffset + 1]);\n                currentOffset += 2;\n                break;\n            case Constants.SIPUSH:\n                methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));\n                currentOffset += 3;\n                break;\n            case Constants.LDC:\n                methodVisitor.visitLdcInsn(readConst(classBuffer[currentOffset + 1] & 0xFF, charBuffer));\n                currentOffset += 2;\n                break;\n            case Constants.LDC_W:\n            case Constants.LDC2_W:\n                methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));\n                currentOffset += 3;\n                break;\n            case Constants.GETSTATIC:\n            case Constants.PUTSTATIC:\n            case Constants.GETFIELD:\n            case Constants.PUTFIELD:\n            case Constants.INVOKEVIRTUAL:\n            case Constants.INVOKESPECIAL:\n            case Constants.INVOKESTATIC:\n            case Constants.INVOKEINTERFACE: {\n                int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];\n                int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\n                String owner = readClass(cpInfoOffset, charBuffer);\n                String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\n                String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\n                if (opcode < Opcodes.INVOKEVIRTUAL) {\n                    methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);\n                } else {\n                    boolean isInterface = classBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;\n                    methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n                }\n                if (opcode == Opcodes.INVOKEINTERFACE) {\n                    currentOffset += 5;\n                } else {\n                    currentOffset += 3;\n                }\n                break;\n            }\n            case Constants.INVOKEDYNAMIC: {\n                int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];\n                int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\n                String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\n                String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\n                int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];\n                Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\n                Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];\n                bootstrapMethodOffset += 4;\n                for (int i = 0; i < bootstrapMethodArguments.length; i++) {\n                    bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\n                    bootstrapMethodOffset += 2;\n                }\n                methodVisitor.visitInvokeDynamicInsn(name, descriptor, handle, bootstrapMethodArguments);\n                currentOffset += 5;\n                break;\n            }\n            case Constants.NEW:\n            case Constants.ANEWARRAY:\n            case Constants.CHECKCAST:\n            case Constants.INSTANCEOF:\n                methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));\n                currentOffset += 3;\n                break;\n            case Constants.IINC:\n                methodVisitor.visitIincInsn(classBuffer[currentOffset + 1] & 0xFF, classBuffer[currentOffset + 2]);\n                currentOffset += 3;\n                break;\n            case Constants.MULTIANEWARRAY:\n                methodVisitor.visitMultiANewArrayInsn(readClass(currentOffset + 1, charBuffer), classBuffer[currentOffset + 3] & 0xFF);\n                currentOffset += 4;\n                break;\n            default:\n                throw new AssertionError();\n            }\n            // Visit the runtime visible instruction annotations, if any.\n            while (visibleTypeAnnotationOffsets != null && currentVisibleTypeAnnotationIndex < visibleTypeAnnotationOffsets.length && currentVisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {\n                if (currentVisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {\n                    // Parse the target_type, target_info and target_path fields.\n                    int currentAnnotationOffset = readTypeAnnotationTarget(context, visibleTypeAnnotationOffsets[currentVisibleTypeAnnotationIndex]);\n                    // Parse the type_index field.\n                    String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                    currentAnnotationOffset += 2;\n                    // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                    readElementValues(methodVisitor.visitInsnAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                            /* visible = */ true), currentAnnotationOffset,\n                            /* named = */ true, charBuffer);\n                }\n                currentVisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, ++currentVisibleTypeAnnotationIndex);\n            }\n            // Visit the runtime invisible instruction annotations, if any.\n            while (invisibleTypeAnnotationOffsets != null && currentInvisibleTypeAnnotationIndex < invisibleTypeAnnotationOffsets.length && currentInvisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {\n                if (currentInvisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {\n                    // Parse the target_type, target_info and target_path fields.\n                    int currentAnnotationOffset = readTypeAnnotationTarget(context, invisibleTypeAnnotationOffsets[currentInvisibleTypeAnnotationIndex]);\n                    // Parse the type_index field.\n                    String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                    currentAnnotationOffset += 2;\n                    // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                    readElementValues(methodVisitor.visitInsnAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                            /* visible = */ false), currentAnnotationOffset,\n                            /* named = */ true, charBuffer);\n                }\n                currentInvisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, ++currentInvisibleTypeAnnotationIndex);\n            }\n        }\n        if (labels[codeLength] != null) {\n            methodVisitor.visitLabel(labels[codeLength]);\n        }\n        // Visit LocalVariableTable and LocalVariableTypeTable attributes.\n        if (localVariableTableOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {\n            // The (start_pc, index, signature_index) fields of each entry of the LocalVariableTypeTable.\n            int[] typeTable = null;\n            if (localVariableTypeTableOffset != 0) {\n                typeTable = new int[readUnsignedShort(localVariableTypeTableOffset) * 3];\n                currentOffset = localVariableTypeTableOffset + 2;\n                int typeTableIndex = typeTable.length;\n                while (typeTableIndex > 0) {\n                    // Store the offset of 'signature_index', and the value of 'index' and 'start_pc'.\n                    typeTable[--typeTableIndex] = currentOffset + 6;\n                    typeTable[--typeTableIndex] = readUnsignedShort(currentOffset + 8);\n                    typeTable[--typeTableIndex] = readUnsignedShort(currentOffset);\n                    currentOffset += 10;\n                }\n            }\n            int localVariableTableLength = readUnsignedShort(localVariableTableOffset);\n            currentOffset = localVariableTableOffset + 2;\n            while (localVariableTableLength-- > 0) {\n                int startPc = readUnsignedShort(currentOffset);\n                int length = readUnsignedShort(currentOffset + 2);\n                String name = readUTF8(currentOffset + 4, charBuffer);\n                String descriptor = readUTF8(currentOffset + 6, charBuffer);\n                int index = readUnsignedShort(currentOffset + 8);\n                currentOffset += 10;\n                String signature = null;\n                if (typeTable != null) {\n                    for (int i = 0; i < typeTable.length; i += 3) {\n                        if (typeTable[i] == startPc && typeTable[i + 1] == index) {\n                            signature = readUTF8(typeTable[i + 2], charBuffer);\n                            break;\n                        }\n                    }\n                }\n                methodVisitor.visitLocalVariable(name, descriptor, signature, labels[startPc], labels[startPc + length], index);\n            }\n        }\n        // Visit the local variable type annotations of the RuntimeVisibleTypeAnnotations attribute.\n        if (visibleTypeAnnotationOffsets != null) {\n            for (int typeAnnotationOffset : visibleTypeAnnotationOffsets) {\n                int targetType = readByte(typeAnnotationOffset);\n                if (targetType == TypeReference.LOCAL_VARIABLE || targetType == TypeReference.RESOURCE_VARIABLE) {\n                    // Parse the target_type, target_info and target_path fields.\n                    currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);\n                    // Parse the type_index field.\n                    String annotationDescriptor = readUTF8(currentOffset, charBuffer);\n                    currentOffset += 2;\n                    // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                    readElementValues(methodVisitor.visitLocalVariableAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, context.currentLocalVariableAnnotationRangeStarts, context.currentLocalVariableAnnotationRangeEnds, context.currentLocalVariableAnnotationRangeIndices, annotationDescriptor,\n                            /* visible = */ true), currentOffset,\n                            /* named = */ true, charBuffer);\n                }\n            }\n        }\n        // Visit the local variable type annotations of the RuntimeInvisibleTypeAnnotations attribute.\n        if (invisibleTypeAnnotationOffsets != null) {\n            for (int typeAnnotationOffset : invisibleTypeAnnotationOffsets) {\n                int targetType = readByte(typeAnnotationOffset);\n                if (targetType == TypeReference.LOCAL_VARIABLE || targetType == TypeReference.RESOURCE_VARIABLE) {\n                    // Parse the target_type, target_info and target_path fields.\n                    currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);\n                    // Parse the type_index field.\n                    String annotationDescriptor = readUTF8(currentOffset, charBuffer);\n                    currentOffset += 2;\n                    // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                    readElementValues(methodVisitor.visitLocalVariableAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, context.currentLocalVariableAnnotationRangeStarts, context.currentLocalVariableAnnotationRangeEnds, context.currentLocalVariableAnnotationRangeIndices, annotationDescriptor,\n                            /* visible = */ false), currentOffset,\n                            /* named = */ true, charBuffer);\n                }\n            }\n        }\n        // Visit the non standard attributes.\n        while (attributes != null) {\n            // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.\n            Attribute nextAttribute = attributes.nextAttribute;\n            attributes.nextAttribute = null;\n            methodVisitor.visitAttribute(attributes);\n            attributes = nextAttribute;\n        }\n        // Visit the max stack and max locals values.\n        methodVisitor.visitMaxs(maxStack, maxLocals);\n    }\n\n    /**\n     * Returns the label corresponding to the given bytecode offset. The default implementation of\n     * this method creates a label for the given offset if it has not been already created.\n     *\n     * @param bytecodeOffset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset. If a label already exists\n     *     for bytecodeOffset this method must not create a new one. Otherwise it must store the new\n     *     label in this array.\n     * @return a non null Label, which must be equal to labels[bytecodeOffset].\n     */\n    protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n        if (labels[bytecodeOffset] == null) {\n            labels[bytecodeOffset] = new Label();\n        }\n        return labels[bytecodeOffset];\n    }\n\n    /**\n     * Creates a label without the {@link Label#FLAG_DEBUG_ONLY} flag set, for the given bytecode\n     * offset. The label is created with a call to {@link #readLabel} and its {@link\n     * Label#FLAG_DEBUG_ONLY} flag is cleared.\n     *\n     * @param bytecodeOffset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset.\n     * @return a Label without the {@link Label#FLAG_DEBUG_ONLY} flag set.\n     */\n    private Label createLabel(final int bytecodeOffset, final Label[] labels) {\n        Label label = readLabel(bytecodeOffset, labels);\n        label.flags &= ~Label.FLAG_DEBUG_ONLY;\n        return label;\n    }\n\n    /**\n     * Creates a label with the {@link Label#FLAG_DEBUG_ONLY} flag set, if there is no already\n     * existing label for the given bytecode offset (otherwise does nothing). The label is created\n     * with a call to {@link #readLabel}.\n     *\n     * @param bytecodeOffset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset.\n     */\n    private void createDebugLabel(final int bytecodeOffset, final Label[] labels) {\n        if (labels[bytecodeOffset] == null) {\n            readLabel(bytecodeOffset, labels).flags |= Label.FLAG_DEBUG_ONLY;\n        }\n    }\n    // ----------------------------------------------------------------------------------------------\n    // Methods to parse annotations, type annotations and parameter annotations\n    // ----------------------------------------------------------------------------------------------\n\n    /**\n     * Parses a Runtime[In]VisibleTypeAnnotations attribute to find the offset of each type_annotation\n     * entry it contains, to find the corresponding labels, and to visit the try catch block\n     * annotations.\n     *\n     * @param methodVisitor the method visitor to be used to visit the try catch block annotations.\n     * @param context information about the class being parsed.\n     * @param runtimeTypeAnnotationsOffset the start offset of a Runtime[In]VisibleTypeAnnotations\n     *     attribute, excluding the attribute_info's attribute_name_index and attribute_length fields.\n     * @param visible true if the attribute to parse is a RuntimeVisibleTypeAnnotations attribute,\n     *     false it is a RuntimeInvisibleTypeAnnotations attribute.\n     * @return the start offset of each entry of the Runtime[In]VisibleTypeAnnotations_attribute's\n     *     'annotations' array field.\n     */\n    private int[] readTypeAnnotations(final MethodVisitor methodVisitor, final Context context, final int runtimeTypeAnnotationsOffset, final boolean visible) {\n        char[] charBuffer = context.charBuffer;\n        int currentOffset = runtimeTypeAnnotationsOffset;\n        // Read the num_annotations field and create an array to store the type_annotation offsets.\n        int[] typeAnnotationsOffsets = new int[readUnsignedShort(currentOffset)];\n        currentOffset += 2;\n        // Parse the 'annotations' array field.\n        for (int i = 0; i < typeAnnotationsOffsets.length; ++i) {\n            typeAnnotationsOffsets[i] = currentOffset;\n            // Parse the type_annotation's target_type and the target_info fields. The size of the\n            // target_info field depends on the value of target_type.\n            int targetType = readInt(currentOffset);\n            switch (targetType >>> 24) {\n            case TypeReference.LOCAL_VARIABLE:\n            case TypeReference.RESOURCE_VARIABLE:\n                // A localvar_target has a variable size, which depends on the value of their table_length\n                // field. It also references bytecode offsets, for which we need labels.\n                int tableLength = readUnsignedShort(currentOffset + 1);\n                currentOffset += 3;\n                while (tableLength-- > 0) {\n                    int startPc = readUnsignedShort(currentOffset);\n                    int length = readUnsignedShort(currentOffset + 2);\n                    // Skip the index field (2 bytes).\n                    currentOffset += 6;\n                    createLabel(startPc, context.currentMethodLabels);\n                    createLabel(startPc + length, context.currentMethodLabels);\n                }\n                break;\n            case TypeReference.CAST:\n            case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\n            case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:\n            case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\n            case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:\n                currentOffset += 4;\n                break;\n            case TypeReference.CLASS_EXTENDS:\n            case TypeReference.CLASS_TYPE_PARAMETER_BOUND:\n            case TypeReference.METHOD_TYPE_PARAMETER_BOUND:\n            case TypeReference.THROWS:\n            case TypeReference.EXCEPTION_PARAMETER:\n            case TypeReference.INSTANCEOF:\n            case TypeReference.NEW:\n            case TypeReference.CONSTRUCTOR_REFERENCE:\n            case TypeReference.METHOD_REFERENCE:\n                currentOffset += 3;\n                break;\n            case TypeReference.CLASS_TYPE_PARAMETER:\n            case TypeReference.METHOD_TYPE_PARAMETER:\n            case TypeReference.METHOD_FORMAL_PARAMETER:\n            case TypeReference.FIELD:\n            case TypeReference.METHOD_RETURN:\n            case TypeReference.METHOD_RECEIVER:\n            default:\n                // TypeReference type which can't be used in Code attribute, or which is unknown.\n                throw new IllegalArgumentException();\n            }\n            // Parse the rest of the type_annotation structure, starting with the target_path structure\n            // (whose size depends on its path_length field).\n            int pathLength = readByte(currentOffset);\n            if ((targetType >>> 24) == TypeReference.EXCEPTION_PARAMETER) {\n                // Parse the target_path structure and create a corresponding TypePath.\n                TypePath path = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);\n                currentOffset += 1 + 2 * pathLength;\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentOffset, charBuffer);\n                currentOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentOffset = readElementValues(methodVisitor.visitTryCatchAnnotation(targetType & 0xFFFFFF00, path, annotationDescriptor, visible), currentOffset,\n                        /* named = */ true, charBuffer);\n            } else {\n                // We don't want to visit the other target_type annotations, so we just skip them (which\n                // requires some parsing because the element_value_pairs array has a variable size). First,\n                // skip the target_path structure:\n                currentOffset += 3 + 2 * pathLength;\n                // Then skip the num_element_value_pairs and element_value_pairs fields (by reading them\n                // with a null AnnotationVisitor).\n                currentOffset = readElementValues(\n                        /* annotationVisitor = */ null, currentOffset, /* named = */ true, charBuffer);\n            }\n        }\n        return typeAnnotationsOffsets;\n    }\n\n    /**\n     * Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or\n     * -1 if there is no such type_annotation of if it does not have a bytecode offset.\n     *\n     * @param typeAnnotationOffsets the offset of each 'type_annotation' entry in a\n     *     Runtime[In]VisibleTypeAnnotations attribute, or {@literal null}.\n     * @param typeAnnotationIndex the index a 'type_annotation' entry in typeAnnotationOffsets.\n     * @return bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or -1\n     *     if there is no such type_annotation of if it does not have a bytecode offset.\n     */\n    private int getTypeAnnotationBytecodeOffset(final int[] typeAnnotationOffsets, final int typeAnnotationIndex) {\n        if (typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets.length || readByte(typeAnnotationOffsets[typeAnnotationIndex]) < TypeReference.INSTANCEOF) {\n            return -1;\n        }\n        return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1);\n    }\n\n    /**\n     * Parses the header of a JVMS type_annotation structure to extract its target_type, target_info\n     * and target_path (the result is stored in the given context), and returns the start offset of\n     * the rest of the type_annotation structure.\n     *\n     * @param context information about the class being parsed. This is where the extracted\n     *     target_type and target_path must be stored.\n     * @param typeAnnotationOffset the start offset of a type_annotation structure.\n     * @return the start offset of the rest of the type_annotation structure.\n     */\n    private int readTypeAnnotationTarget(final Context context, final int typeAnnotationOffset) {\n        int currentOffset = typeAnnotationOffset;\n        // Parse and store the target_type structure.\n        int targetType = readInt(typeAnnotationOffset);\n        switch (targetType >>> 24) {\n        case TypeReference.CLASS_TYPE_PARAMETER:\n        case TypeReference.METHOD_TYPE_PARAMETER:\n        case TypeReference.METHOD_FORMAL_PARAMETER:\n            targetType &= 0xFFFF0000;\n            currentOffset += 2;\n            break;\n        case TypeReference.FIELD:\n        case TypeReference.METHOD_RETURN:\n        case TypeReference.METHOD_RECEIVER:\n            targetType &= 0xFF000000;\n            currentOffset += 1;\n            break;\n        case TypeReference.LOCAL_VARIABLE:\n        case TypeReference.RESOURCE_VARIABLE:\n            targetType &= 0xFF000000;\n            int tableLength = readUnsignedShort(currentOffset + 1);\n            currentOffset += 3;\n            context.currentLocalVariableAnnotationRangeStarts = new Label[tableLength];\n            context.currentLocalVariableAnnotationRangeEnds = new Label[tableLength];\n            context.currentLocalVariableAnnotationRangeIndices = new int[tableLength];\n            for (int i = 0; i < tableLength; ++i) {\n                int startPc = readUnsignedShort(currentOffset);\n                int length = readUnsignedShort(currentOffset + 2);\n                int index = readUnsignedShort(currentOffset + 4);\n                currentOffset += 6;\n                context.currentLocalVariableAnnotationRangeStarts[i] = createLabel(startPc, context.currentMethodLabels);\n                context.currentLocalVariableAnnotationRangeEnds[i] = createLabel(startPc + length, context.currentMethodLabels);\n                context.currentLocalVariableAnnotationRangeIndices[i] = index;\n            }\n            break;\n        case TypeReference.CAST:\n        case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\n        case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:\n        case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\n        case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:\n            targetType &= 0xFF0000FF;\n            currentOffset += 4;\n            break;\n        case TypeReference.CLASS_EXTENDS:\n        case TypeReference.CLASS_TYPE_PARAMETER_BOUND:\n        case TypeReference.METHOD_TYPE_PARAMETER_BOUND:\n        case TypeReference.THROWS:\n        case TypeReference.EXCEPTION_PARAMETER:\n            targetType &= 0xFFFFFF00;\n            currentOffset += 3;\n            break;\n        case TypeReference.INSTANCEOF:\n        case TypeReference.NEW:\n        case TypeReference.CONSTRUCTOR_REFERENCE:\n        case TypeReference.METHOD_REFERENCE:\n            targetType &= 0xFF000000;\n            currentOffset += 3;\n            break;\n        default:\n            throw new IllegalArgumentException();\n        }\n        context.currentTypeAnnotationTarget = targetType;\n        // Parse and store the target_path structure.\n        int pathLength = readByte(currentOffset);\n        context.currentTypeAnnotationTargetPath = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);\n        // Return the start offset of the rest of the type_annotation structure.\n        return currentOffset + 1 + 2 * pathLength;\n    }\n\n    /**\n     * Reads a Runtime[In]VisibleParameterAnnotations attribute and makes the given visitor visit it.\n     *\n     * @param methodVisitor the visitor that must visit the parameter annotations.\n     * @param context information about the class being parsed.\n     * @param runtimeParameterAnnotationsOffset the start offset of a\n     *     Runtime[In]VisibleParameterAnnotations attribute, excluding the attribute_info's\n     *     attribute_name_index and attribute_length fields.\n     * @param visible true if the attribute to parse is a RuntimeVisibleParameterAnnotations\n     *     attribute, false it is a RuntimeInvisibleParameterAnnotations attribute.\n     */\n    private void readParameterAnnotations(final MethodVisitor methodVisitor, final Context context, final int runtimeParameterAnnotationsOffset, final boolean visible) {\n        int currentOffset = runtimeParameterAnnotationsOffset;\n        int numParameters = classFileBuffer[currentOffset++] & 0xFF;\n        methodVisitor.visitAnnotableParameterCount(numParameters, visible);\n        char[] charBuffer = context.charBuffer;\n        for (int i = 0; i < numParameters; ++i) {\n            int numAnnotations = readUnsignedShort(currentOffset);\n            currentOffset += 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentOffset, charBuffer);\n                currentOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentOffset = readElementValues(methodVisitor.visitParameterAnnotation(i, annotationDescriptor, visible), currentOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n    }\n\n    /**\n     * Reads the element values of a JVMS 'annotation' structure and makes the given visitor visit\n     * them. This method can also be used to read the values of the JVMS 'array_value' field of an\n     * annotation's 'element_value'.\n     *\n     * @param annotationVisitor the visitor that must visit the values.\n     * @param annotationOffset the start offset of an 'annotation' structure (excluding its type_index\n     *     field) or of an 'array_value' structure.\n     * @param named if the annotation values are named or not. This should be true to parse the values\n     *     of a JVMS 'annotation' structure, and false to parse the JVMS 'array_value' of an\n     *     annotation's element_value.\n     * @param charBuffer the buffer used to read strings in the constant pool.\n     * @return the end offset of the JVMS 'annotation' or 'array_value' structure.\n     */\n    private int readElementValues(final AnnotationVisitor annotationVisitor, final int annotationOffset, final boolean named, final char[] charBuffer) {\n        int currentOffset = annotationOffset;\n        // Read the num_element_value_pairs field (or num_values field for an array_value).\n        int numElementValuePairs = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        if (named) {\n            // Parse the element_value_pairs array.\n            while (numElementValuePairs-- > 0) {\n                String elementName = readUTF8(currentOffset, charBuffer);\n                currentOffset = readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer);\n            }\n        } else {\n            // Parse the array_value array.\n            while (numElementValuePairs-- > 0) {\n                currentOffset = readElementValue(annotationVisitor, currentOffset, /* named = */ null, charBuffer);\n            }\n        }\n        if (annotationVisitor != null) {\n            annotationVisitor.visitEnd();\n        }\n        return currentOffset;\n    }\n\n    /**\n     * Reads a JVMS 'element_value' structure and makes the given visitor visit it.\n     *\n     * @param annotationVisitor the visitor that must visit the element_value structure.\n     * @param elementValueOffset the start offset in {@link #classFileBuffer} of the element_value\n     *     structure to be read.\n     * @param elementName the name of the element_value structure to be read, or {@literal null}.\n     * @param charBuffer the buffer used to read strings in the constant pool.\n     * @return the end offset of the JVMS 'element_value' structure.\n     */\n    private int readElementValue(final AnnotationVisitor annotationVisitor, final int elementValueOffset, final String elementName, final char[] charBuffer) {\n        int currentOffset = elementValueOffset;\n        if (annotationVisitor == null) {\n            switch (classFileBuffer[currentOffset] & 0xFF) {\n            case 'e': // enum_const_value\n                return currentOffset + 5;\n            case '@': // annotation_value\n                return readElementValues(null, currentOffset + 3, /* named = */ true, charBuffer);\n            case '[': // array_value\n                return readElementValues(null, currentOffset + 1, /* named = */ false, charBuffer);\n            default:\n                return currentOffset + 3;\n            }\n        }\n        switch (classFileBuffer[currentOffset++] & 0xFF) {\n        case 'B': // const_value_index, CONSTANT_Integer\n            annotationVisitor.visit(elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\n            currentOffset += 2;\n            break;\n        case 'C': // const_value_index, CONSTANT_Integer\n            annotationVisitor.visit(elementName, (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\n            currentOffset += 2;\n            break;\n        case 'D': // const_value_index, CONSTANT_Double\n        case 'F': // const_value_index, CONSTANT_Float\n        case 'I': // const_value_index, CONSTANT_Integer\n        case 'J': // const_value_index, CONSTANT_Long\n            annotationVisitor.visit(elementName, readConst(readUnsignedShort(currentOffset), charBuffer));\n            currentOffset += 2;\n            break;\n        case 'S': // const_value_index, CONSTANT_Integer\n            annotationVisitor.visit(elementName, (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\n            currentOffset += 2;\n            break;\n        case 'Z': // const_value_index, CONSTANT_Integer\n            annotationVisitor.visit(elementName, readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\n            currentOffset += 2;\n            break;\n        case 's': // const_value_index, CONSTANT_Utf8\n            annotationVisitor.visit(elementName, readUTF8(currentOffset, charBuffer));\n            currentOffset += 2;\n            break;\n        case 'e': // enum_const_value\n            annotationVisitor.visitEnum(elementName, readUTF8(currentOffset, charBuffer), readUTF8(currentOffset + 2, charBuffer));\n            currentOffset += 4;\n            break;\n        case 'c': // class_info\n            annotationVisitor.visit(elementName, Type.getType(readUTF8(currentOffset, charBuffer)));\n            currentOffset += 2;\n            break;\n        case '@': // annotation_value\n            currentOffset = readElementValues(annotationVisitor.visitAnnotation(elementName, readUTF8(currentOffset, charBuffer)), currentOffset + 2, true, charBuffer);\n            break;\n        case '[': // array_value\n            int numValues = readUnsignedShort(currentOffset);\n            currentOffset += 2;\n            if (numValues == 0) {\n                return readElementValues(annotationVisitor.visitArray(elementName), currentOffset - 2,\n                        /* named = */ false, charBuffer);\n            }\n            switch (classFileBuffer[currentOffset] & 0xFF) {\n            case 'B':\n                byte[] byteValues = new byte[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, byteValues);\n                break;\n            case 'Z':\n                boolean[] booleanValues = new boolean[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    booleanValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]) != 0;\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, booleanValues);\n                break;\n            case 'S':\n                short[] shortValues = new short[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    shortValues[i] = (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, shortValues);\n                break;\n            case 'C':\n                char[] charValues = new char[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    charValues[i] = (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, charValues);\n                break;\n            case 'I':\n                int[] intValues = new int[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    intValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, intValues);\n                break;\n            case 'J':\n                long[] longValues = new long[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    longValues[i] = readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, longValues);\n                break;\n            case 'F':\n                float[] floatValues = new float[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    floatValues[i] = Float.intBitsToFloat(readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, floatValues);\n                break;\n            case 'D':\n                double[] doubleValues = new double[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    doubleValues[i] = Double.longBitsToDouble(readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, doubleValues);\n                break;\n            default:\n                currentOffset = readElementValues(annotationVisitor.visitArray(elementName), currentOffset - 2,\n                        /* named = */ false, charBuffer);\n                break;\n            }\n            break;\n        default:\n            throw new IllegalArgumentException();\n        }\n        return currentOffset;\n    }\n    // ----------------------------------------------------------------------------------------------\n    // Methods to parse stack map frames\n    // ----------------------------------------------------------------------------------------------\n\n    /**\n     * Computes the implicit frame of the method currently being parsed (as defined in the given\n     * {@link Context}) and stores it in the given context.\n     *\n     * @param context information about the class being parsed.\n     */\n    private void computeImplicitFrame(final Context context) {\n        String methodDescriptor = context.currentMethodDescriptor;\n        Object[] locals = context.currentFrameLocalTypes;\n        int numLocal = 0;\n        if ((context.currentMethodAccessFlags & Opcodes.ACC_STATIC) == 0) {\n            if (\"<init>\".equals(context.currentMethodName)) {\n                locals[numLocal++] = Opcodes.UNINITIALIZED_THIS;\n            } else {\n                locals[numLocal++] = readClass(header + 2, context.charBuffer);\n            }\n        }\n        // Parse the method descriptor, one argument type descriptor at each iteration. Start by\n        // skipping the first method descriptor character, which is always '('.\n        int currentMethodDescritorOffset = 1;\n        while (true) {\n            int currentArgumentDescriptorStartOffset = currentMethodDescritorOffset;\n            switch (methodDescriptor.charAt(currentMethodDescritorOffset++)) {\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                locals[numLocal++] = Opcodes.INTEGER;\n                break;\n            case 'F':\n                locals[numLocal++] = Opcodes.FLOAT;\n                break;\n            case 'J':\n                locals[numLocal++] = Opcodes.LONG;\n                break;\n            case 'D':\n                locals[numLocal++] = Opcodes.DOUBLE;\n                break;\n            case '[':\n                while (methodDescriptor.charAt(currentMethodDescritorOffset) == '[') {\n                    ++currentMethodDescritorOffset;\n                }\n                if (methodDescriptor.charAt(currentMethodDescritorOffset) == 'L') {\n                    ++currentMethodDescritorOffset;\n                    while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {\n                        ++currentMethodDescritorOffset;\n                    }\n                }\n                locals[numLocal++] = methodDescriptor.substring(currentArgumentDescriptorStartOffset, ++currentMethodDescritorOffset);\n                break;\n            case 'L':\n                while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {\n                    ++currentMethodDescritorOffset;\n                }\n                locals[numLocal++] = methodDescriptor.substring(currentArgumentDescriptorStartOffset + 1, currentMethodDescritorOffset++);\n                break;\n            default:\n                context.currentFrameLocalCount = numLocal;\n                return;\n            }\n        }\n    }\n\n    /**\n     * Reads a JVMS 'stack_map_frame' structure and stores the result in the given {@link Context}\n     * object. This method can also be used to read a full_frame structure, excluding its frame_type\n     * field (this is used to parse the legacy StackMap attributes).\n     *\n     * @param stackMapFrameOffset the start offset in {@link #classFileBuffer} of the\n     *     stack_map_frame_value structure to be read, or the start offset of a full_frame structure\n     *     (excluding its frame_type field).\n     * @param compressed true to read a 'stack_map_frame' structure, false to read a 'full_frame'\n     *     structure without its frame_type field.\n     * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.\n     * @param context where the parsed stack map frame must be stored.\n     * @return the end offset of the JVMS 'stack_map_frame' or 'full_frame' structure.\n     */\n    private int readStackMapFrame(final int stackMapFrameOffset, final boolean compressed, final boolean expand, final Context context) {\n        int currentOffset = stackMapFrameOffset;\n        final char[] charBuffer = context.charBuffer;\n        final Label[] labels = context.currentMethodLabels;\n        int frameType;\n        if (compressed) {\n            // Read the frame_type field.\n            frameType = classFileBuffer[currentOffset++] & 0xFF;\n        } else {\n            frameType = Frame.FULL_FRAME;\n            context.currentFrameOffset = -1;\n        }\n        int offsetDelta;\n        context.currentFrameLocalCountDelta = 0;\n        if (frameType < Frame.SAME_LOCALS_1_STACK_ITEM_FRAME) {\n            offsetDelta = frameType;\n            context.currentFrameType = Opcodes.F_SAME;\n            context.currentFrameStackCount = 0;\n        } else if (frameType < Frame.RESERVED) {\n            offsetDelta = frameType - Frame.SAME_LOCALS_1_STACK_ITEM_FRAME;\n            currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);\n            context.currentFrameType = Opcodes.F_SAME1;\n            context.currentFrameStackCount = 1;\n        } else if (frameType >= Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n            offsetDelta = readUnsignedShort(currentOffset);\n            currentOffset += 2;\n            if (frameType == Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n                currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);\n                context.currentFrameType = Opcodes.F_SAME1;\n                context.currentFrameStackCount = 1;\n            } else if (frameType >= Frame.CHOP_FRAME && frameType < Frame.SAME_FRAME_EXTENDED) {\n                context.currentFrameType = Opcodes.F_CHOP;\n                context.currentFrameLocalCountDelta = Frame.SAME_FRAME_EXTENDED - frameType;\n                context.currentFrameLocalCount -= context.currentFrameLocalCountDelta;\n                context.currentFrameStackCount = 0;\n            } else if (frameType == Frame.SAME_FRAME_EXTENDED) {\n                context.currentFrameType = Opcodes.F_SAME;\n                context.currentFrameStackCount = 0;\n            } else if (frameType < Frame.FULL_FRAME) {\n                int local = expand ? context.currentFrameLocalCount : 0;\n                for (int k = frameType - Frame.SAME_FRAME_EXTENDED; k > 0; k--) {\n                    currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameLocalTypes, local++, charBuffer, labels);\n                }\n                context.currentFrameType = Opcodes.F_APPEND;\n                context.currentFrameLocalCountDelta = frameType - Frame.SAME_FRAME_EXTENDED;\n                context.currentFrameLocalCount += context.currentFrameLocalCountDelta;\n                context.currentFrameStackCount = 0;\n            } else {\n                final int numberOfLocals = readUnsignedShort(currentOffset);\n                currentOffset += 2;\n                context.currentFrameType = Opcodes.F_FULL;\n                context.currentFrameLocalCountDelta = numberOfLocals;\n                context.currentFrameLocalCount = numberOfLocals;\n                for (int local = 0; local < numberOfLocals; ++local) {\n                    currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameLocalTypes, local, charBuffer, labels);\n                }\n                final int numberOfStackItems = readUnsignedShort(currentOffset);\n                currentOffset += 2;\n                context.currentFrameStackCount = numberOfStackItems;\n                for (int stack = 0; stack < numberOfStackItems; ++stack) {\n                    currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, stack, charBuffer, labels);\n                }\n            }\n        } else {\n            throw new IllegalArgumentException();\n        }\n        context.currentFrameOffset += offsetDelta + 1;\n        createLabel(context.currentFrameOffset, labels);\n        return currentOffset;\n    }\n\n    /**\n     * Reads a JVMS 'verification_type_info' structure and stores it at the given index in the given\n     * array.\n     *\n     * @param verificationTypeInfoOffset the start offset of the 'verification_type_info' structure to\n     *     read.\n     * @param frame the array where the parsed type must be stored.\n     * @param index the index in 'frame' where the parsed type must be stored.\n     * @param charBuffer the buffer used to read strings in the constant pool.\n     * @param labels the labels of the method currently being parsed, indexed by their offset. If the\n     *     parsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is\n     *     stored in this array if it does not already exist.\n     * @return the end offset of the JVMS 'verification_type_info' structure.\n     */\n    private int readVerificationTypeInfo(final int verificationTypeInfoOffset, final Object[] frame, final int index, final char[] charBuffer, final Label[] labels) {\n        int currentOffset = verificationTypeInfoOffset;\n        int tag = classFileBuffer[currentOffset++] & 0xFF;\n        switch (tag) {\n        case Frame.ITEM_TOP:\n            frame[index] = Opcodes.TOP;\n            break;\n        case Frame.ITEM_INTEGER:\n            frame[index] = Opcodes.INTEGER;\n            break;\n        case Frame.ITEM_FLOAT:\n            frame[index] = Opcodes.FLOAT;\n            break;\n        case Frame.ITEM_DOUBLE:\n            frame[index] = Opcodes.DOUBLE;\n            break;\n        case Frame.ITEM_LONG:\n            frame[index] = Opcodes.LONG;\n            break;\n        case Frame.ITEM_NULL:\n            frame[index] = Opcodes.NULL;\n            break;\n        case Frame.ITEM_UNINITIALIZED_THIS:\n            frame[index] = Opcodes.UNINITIALIZED_THIS;\n            break;\n        case Frame.ITEM_OBJECT:\n            frame[index] = readClass(currentOffset, charBuffer);\n            currentOffset += 2;\n            break;\n        case Frame.ITEM_UNINITIALIZED:\n            frame[index] = createLabel(readUnsignedShort(currentOffset), labels);\n            currentOffset += 2;\n            break;\n        default:\n            throw new IllegalArgumentException();\n        }\n        return currentOffset;\n    }\n    // ----------------------------------------------------------------------------------------------\n    // Methods to parse attributes\n    // ----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array\n     * field entry.\n     *\n     * @return the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array\n     *     field entry.\n     */\n    final int getFirstAttributeOffset() {\n        // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes\n        // each), as well as the interfaces array field (2 bytes per interface).\n        int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;\n        // Read the fields_count field.\n        int fieldsCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        // Skip the 'fields' array field.\n        while (fieldsCount-- > 0) {\n            // Invariant: currentOffset is the offset of a field_info structure.\n            // Skip the access_flags, name_index and descriptor_index fields (2 bytes each), and read the\n            // attributes_count field.\n            int attributesCount = readUnsignedShort(currentOffset + 6);\n            currentOffset += 8;\n            // Skip the 'attributes' array field.\n            while (attributesCount-- > 0) {\n                // Invariant: currentOffset is the offset of an attribute_info structure.\n                // Read the attribute_length field (2 bytes after the start of the attribute_info) and skip\n                // this many bytes, plus 6 for the attribute_name_index and attribute_length fields\n                // (yielding the total size of the attribute_info structure).\n                currentOffset += 6 + readInt(currentOffset + 2);\n            }\n        }\n        // Skip the methods_count and 'methods' fields, using the same method as above.\n        int methodsCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (methodsCount-- > 0) {\n            int attributesCount = readUnsignedShort(currentOffset + 6);\n            currentOffset += 8;\n            while (attributesCount-- > 0) {\n                currentOffset += 6 + readInt(currentOffset + 2);\n            }\n        }\n        // Skip the ClassFile's attributes_count field.\n        return currentOffset + 2;\n    }\n\n    /**\n     * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.\n     *\n     * @param maxStringLength a conservative estimate of the maximum length of the strings contained\n     *     in the constant pool of the class.\n     * @return the offsets of the bootstrap methods.\n     */\n    private int[] readBootstrapMethodsAttribute(final int maxStringLength) {\n        char[] charBuffer = new char[maxStringLength];\n        int currentAttributeOffset = getFirstAttributeOffset();\n        int[] currentBootstrapMethodOffsets = null;\n        for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentAttributeOffset, charBuffer);\n            int attributeLength = readInt(currentAttributeOffset + 2);\n            currentAttributeOffset += 6;\n            if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n                // Read the num_bootstrap_methods field and create an array of this size.\n                currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];\n                // Compute and store the offset of each 'bootstrap_methods' array field entry.\n                int currentBootstrapMethodOffset = currentAttributeOffset + 2;\n                for (int j = 0; j < currentBootstrapMethodOffsets.length; ++j) {\n                    currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;\n                    // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),\n                    // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).\n                    currentBootstrapMethodOffset += 4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;\n                }\n                return currentBootstrapMethodOffsets;\n            }\n            currentAttributeOffset += attributeLength;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    /**\n     * Reads a non standard JVMS 'attribute' structure in {@link #classFileBuffer}.\n     *\n     * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of\n     *     the class. Any attribute whose type is not equal to the type of one the prototypes will not\n     *     be parsed: its byte array value will be passed unchanged to the ClassWriter.\n     * @param type the type of the attribute.\n     * @param offset the start offset of the JVMS 'attribute' structure in {@link #classFileBuffer}.\n     *     The 6 attribute header bytes (attribute_name_index and attribute_length) are not taken into\n     *     account here.\n     * @param length the length of the attribute's content (excluding the 6 attribute header bytes).\n     * @param charBuffer the buffer to be used to read strings in the constant pool.\n     * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link\n     *     #classFileBuffer}, or -1 if the attribute to be read is not a code attribute. The 6\n     *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\n     *     account here.\n     * @param labels the labels of the method's code, or {@literal null} if the attribute to be read\n     *     is not a code attribute.\n     * @return the attribute that has been read.\n     */\n    private Attribute readAttribute(final Attribute[] attributePrototypes, final String type, final int offset, final int length, final char[] charBuffer, final int codeAttributeOffset, final Label[] labels) {\n        for (Attribute attributePrototype : attributePrototypes) {\n            if (attributePrototype.type.equals(type)) {\n                return attributePrototype.read(this, offset, length, charBuffer, codeAttributeOffset, labels);\n            }\n        }\n        return new Attribute(type).read(this, offset, length, null, -1, null);\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Utility methods: low level parsing\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the number of entries in the class's constant pool table.\n     *\n     * @return the number of entries in the class's constant pool table.\n     */\n    public int getItemCount() {\n        return cpInfoOffsets.length;\n    }\n\n    /**\n     * Returns the start offset in this {@link ClassReader} of a JVMS 'cp_info' structure (i.e. a\n     * constant pool entry), plus one. <i>This method is intended for {@link Attribute} sub classes,\n     * and is normally not needed by class generators or adapters.</i>\n     *\n     * @param constantPoolEntryIndex the index a constant pool entry in the class's constant pool\n     *     table.\n     * @return the start offset in this {@link ClassReader} of the corresponding JVMS 'cp_info'\n     *     structure, plus one.\n     */\n    public int getItem(final int constantPoolEntryIndex) {\n        return cpInfoOffsets[constantPoolEntryIndex];\n    }\n\n    /**\n     * Returns a conservative estimate of the maximum length of the strings contained in the class's\n     * constant pool table.\n     *\n     * @return a conservative estimate of the maximum length of the strings contained in the class's\n     *     constant pool table.\n     */\n    public int getMaxStringLength() {\n        return maxStringLength;\n    }\n\n    /**\n     * Reads a byte value in this {@link ClassReader}. <i>This method is intended for {@link\n     * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n     *\n     * @param offset the start offset of the value to be read in this {@link ClassReader}.\n     * @return the read value.\n     */\n    public int readByte(final int offset) {\n        return classFileBuffer[offset] & 0xFF;\n    }\n\n    /**\n     * Reads an unsigned short value in this {@link ClassReader}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n     *\n     * @param offset the start index of the value to be read in this {@link ClassReader}.\n     * @return the read value.\n     */\n    public int readUnsignedShort(final int offset) {\n        byte[] classBuffer = classFileBuffer;\n        return ((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF);\n    }\n\n    /**\n     * Reads a signed short value in this {@link ClassReader}. <i>This method is intended for {@link\n     * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n     *\n     * @param offset the start offset of the value to be read in this {@link ClassReader}.\n     * @return the read value.\n     */\n    public short readShort(final int offset) {\n        byte[] classBuffer = classFileBuffer;\n        return (short) (((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF));\n    }\n\n    /**\n     * Reads a signed int value in this {@link ClassReader}. <i>This method is intended for {@link\n     * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n     *\n     * @param offset the start offset of the value to be read in this {@link ClassReader}.\n     * @return the read value.\n     */\n    public int readInt(final int offset) {\n        byte[] classBuffer = classFileBuffer;\n        return ((classBuffer[offset] & 0xFF) << 24) | ((classBuffer[offset + 1] & 0xFF) << 16) | ((classBuffer[offset + 2] & 0xFF) << 8) | (classBuffer[offset + 3] & 0xFF);\n    }\n\n    /**\n     * Reads a signed long value in this {@link ClassReader}. <i>This method is intended for {@link\n     * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n     *\n     * @param offset the start offset of the value to be read in this {@link ClassReader}.\n     * @return the read value.\n     */\n    public long readLong(final int offset) {\n        long l1 = readInt(offset);\n        long l0 = readInt(offset + 4) & 0xFFFFFFFFL;\n        return (l1 << 32) | l0;\n    }\n\n    /**\n     * Reads a CONSTANT_Utf8 constant pool entry in this {@link ClassReader}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n     *     value is the index of a CONSTANT_Utf8 entry in the class's constant pool table.\n     * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified CONSTANT_Utf8 entry.\n     */\n    // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\n    public String readUTF8(final int offset, final char[] charBuffer) {\n        int constantPoolEntryIndex = readUnsignedShort(offset);\n        if (offset == 0 || constantPoolEntryIndex == 0) {\n            return null;\n        }\n        return readUtf(constantPoolEntryIndex, charBuffer);\n    }\n\n    /**\n     * Reads a CONSTANT_Utf8 constant pool entry in {@link #classFileBuffer}.\n     *\n     * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pool\n     *     table.\n     * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified CONSTANT_Utf8 entry.\n     */\n    final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n        String value = constantUtf8Values[constantPoolEntryIndex];\n        if (value != null) {\n            return value;\n        }\n        int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\n        return constantUtf8Values[constantPoolEntryIndex] = readUtf(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);\n    }\n\n    /**\n     * Reads an UTF8 string in {@link #classFileBuffer}.\n     *\n     * @param utfOffset the start offset of the UTF8 string to be read.\n     * @param utfLength the length of the UTF8 string to be read.\n     * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 string.\n     */\n    private String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {\n        int currentOffset = utfOffset;\n        int endOffset = currentOffset + utfLength;\n        int strLength = 0;\n        byte[] classBuffer = classFileBuffer;\n        while (currentOffset < endOffset) {\n            int currentByte = classBuffer[currentOffset++];\n            if ((currentByte & 0x80) == 0) {\n                charBuffer[strLength++] = (char) (currentByte & 0x7F);\n            } else if ((currentByte & 0xE0) == 0xC0) {\n                charBuffer[strLength++] = (char) (((currentByte & 0x1F) << 6) + (classBuffer[currentOffset++] & 0x3F));\n            } else {\n                charBuffer[strLength++] = (char) (((currentByte & 0xF) << 12) + ((classBuffer[currentOffset++] & 0x3F) << 6) + (classBuffer[currentOffset++] & 0x3F));\n            }\n        }\n        return new String(charBuffer, 0, strLength);\n    }\n\n    /**\n     * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or\n     * CONSTANT_Package constant pool entry in {@link #classFileBuffer}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param offset the start offset of an unsigned short value in {@link #classFileBuffer}, whose\n     *     value is the index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,\n     *     CONSTANT_Module or CONSTANT_Package entry in class's constant pool table.\n     * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified constant pool entry.\n     */\n    private String readStringish(final int offset, final char[] charBuffer) {\n        // Get the start offset of the cp_info structure (plus one), and read the CONSTANT_Utf8 entry\n        // designated by the first two bytes of this cp_info.\n        return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);\n    }\n\n    /**\n     * Reads a CONSTANT_Class constant pool entry in this {@link ClassReader}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n     *     value is the index of a CONSTANT_Class entry in class's constant pool table.\n     * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified CONSTANT_Class entry.\n     */\n    public String readClass(final int offset, final char[] charBuffer) {\n        return readStringish(offset, charBuffer);\n    }\n\n    /**\n     * Reads a CONSTANT_Module constant pool entry in this {@link ClassReader}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n     *     value is the index of a CONSTANT_Module entry in class's constant pool table.\n     * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified CONSTANT_Module entry.\n     */\n    public String readModule(final int offset, final char[] charBuffer) {\n        return readStringish(offset, charBuffer);\n    }\n\n    /**\n     * Reads a CONSTANT_Package constant pool entry in this {@link ClassReader}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n     *     value is the index of a CONSTANT_Package entry in class's constant pool table.\n     * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified CONSTANT_Package entry.\n     */\n    public String readPackage(final int offset, final char[] charBuffer) {\n        return readStringish(offset, charBuffer);\n    }\n\n    /**\n     * Reads a CONSTANT_Dynamic constant pool entry in {@link #classFileBuffer}.\n     *\n     * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class's constant\n     *     pool table.\n     * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the ConstantDynamic corresponding to the specified CONSTANT_Dynamic entry.\n     */\n    private ConstantDynamic readConstantDynamic(final int constantPoolEntryIndex, final char[] charBuffer) {\n        ConstantDynamic constantDynamic = constantDynamicValues[constantPoolEntryIndex];\n        if (constantDynamic != null) {\n            return constantDynamic;\n        }\n        int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\n        int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\n        String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\n        String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\n        int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];\n        Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\n        Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];\n        bootstrapMethodOffset += 4;\n        for (int i = 0; i < bootstrapMethodArguments.length; i++) {\n            bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\n            bootstrapMethodOffset += 2;\n        }\n        return constantDynamicValues[constantPoolEntryIndex] = new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);\n    }\n\n    /**\n     * Reads a numeric or string constant pool entry in this {@link ClassReader}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,\n     *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,\n     *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class's constant pool.\n     * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String},\n     *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified\n     *     constant pool entry.\n     */\n    public Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {\n        int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\n        switch (classFileBuffer[cpInfoOffset - 1]) {\n        case Symbol.CONSTANT_INTEGER_TAG:\n            return readInt(cpInfoOffset);\n        case Symbol.CONSTANT_FLOAT_TAG:\n            return Float.intBitsToFloat(readInt(cpInfoOffset));\n        case Symbol.CONSTANT_LONG_TAG:\n            return readLong(cpInfoOffset);\n        case Symbol.CONSTANT_DOUBLE_TAG:\n            return Double.longBitsToDouble(readLong(cpInfoOffset));\n        case Symbol.CONSTANT_CLASS_TAG:\n            return Type.getObjectType(readUTF8(cpInfoOffset, charBuffer));\n        case Symbol.CONSTANT_STRING_TAG:\n            return readUTF8(cpInfoOffset, charBuffer);\n        case Symbol.CONSTANT_METHOD_TYPE_TAG:\n            return Type.getMethodType(readUTF8(cpInfoOffset, charBuffer));\n        case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n            int referenceKind = readByte(cpInfoOffset);\n            int referenceCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 1)];\n            int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];\n            String owner = readClass(referenceCpInfoOffset, charBuffer);\n            String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\n            String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\n            boolean isInterface = classFileBuffer[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;\n            return new Handle(referenceKind, owner, name, descriptor, isInterface);\n        case Symbol.CONSTANT_DYNAMIC_TAG:\n            return readConstantDynamic(constantPoolEntryIndex, charBuffer);\n        default:\n            throw new IllegalArgumentException();\n        }\n    }\n}\n",
      "file_name": "ClassReader.java",
      "human_label": "Read a signed long value.",
      "level": "class_runnable",
      "lineno": "3123",
      "name": "readLong",
      "oracle_context": "{ \"apis\" : \"[readInt]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
      "package": "net.hasor.utils.asm",
      "project": "hasor-master"
    },
    {
      "_id": "636767a51a6d9265ec01859d",
      "all_context": "{ \"class_level\" : \"import static io.protostuff.StringSerializer.STRING;\\nimport java.io.DataOutput;\\nimport java.io.IOException;\\nimport java.io.OutputStream;\\nimport java.io.UnsupportedEncodingException;\\nimport java.nio.ByteBuffer;\\nbyte[] bytes;\\nString EMPTY_STRING;\\nbyte[] EMPTY_BYTE_ARRAY;\\nByteString EMPTY;\\nint hash;\\nwrap(byte[] bytes);\\ngetBytes();\\nwriteTo(DataOutput out,ByteString bs);\\nwriteTo(Output output,ByteString bs,int fieldNumber,boolean repeated);\\ntoString();\\nByteString(byte[] bytes);\\nbyteAt(int index);\\nsize();\\nisEmpty();\\ncopyFrom(byte[] bytes,int offset,int size);\\ncopyFrom(byte[] bytes);\\ncopyFrom(String text,String charsetName);\\ncopyFromUtf8(String text);\\ncopyTo(byte[] target,int offset);\\ncopyTo(byte[] target,int sourceOffset,int targetOffset,int size);\\ntoByteArray();\\nasReadOnlyByteBuffer();\\ntoStringUtf8();\\nequals(Object o);\\nequals(ByteString bs,ByteString other,boolean checkHash);\\nequals(byte[] data);\\nequals(byte[] data,int offset,int len);\\nhashCode();\\nstringDefaultValue(String bytes);\\nbytesDefaultValue(String bytes);\\nbyteArrayDefaultValue(String bytes);\\nwriteTo(OutputStream out,ByteString bs);\\n\", \"repo_level\" : \"\" }",
      "class_name": "ByteString",
      "code": "public boolean equals(final byte[] data,int offset,final int len){\n  final byte[] bytes=this.bytes;\n  if (len != bytes.length)   return false;\n  for (int i=0; i < len; ) {\n    if (bytes[i++] != data[offset++]) {\n      return false;\n    }\n  }\n  return true;\n}\n",
      "docstring": "/** \n * Returns true if the contents of the internal array and the provided array match.\n */\n",
      "end_lineno": "353",
      "file_content": "//========================================================================\n//Copyright 2007-2009 David Yu dyuproject@gmail.com\n//------------------------------------------------------------------------\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at \n//http://www.apache.org/licenses/LICENSE-2.0\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//========================================================================\n\n// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// http://code.google.com/p/protobuf/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npackage io.protostuff;\n\nimport static io.protostuff.StringSerializer.STRING;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.ByteBuffer;\n\n/**\n * Immutable array of bytes.\n * \n * @author crazybob@google.com Bob Lee\n * @author kenton@google.com Kenton Varda\n * @author David Yu\n */\npublic final class ByteString\n{\n    // START EXTRA\n    // internal package access to avoid double memory allocation\n    static ByteString wrap(byte[] bytes)\n    {\n        return new ByteString(bytes);\n    }\n\n    // internal package access to avoid double memory allocation\n    byte[] getBytes()\n    {\n        return bytes;\n    }\n\n    /**\n     * Writes the bytes to the {@link OutputStream}.\n     */\n    public static void writeTo(OutputStream out, ByteString bs) throws IOException\n    {\n        out.write(bs.bytes);\n    }\n\n    /**\n     * Writes the bytes to the {@link DataOutput}.\n     */\n    public static void writeTo(DataOutput out, ByteString bs) throws IOException\n    {\n        out.write(bs.bytes);\n    }\n\n    /**\n     * Writes the bytes to the {@link Output}.\n     */\n    public static void writeTo(Output output, ByteString bs, int fieldNumber,\n            boolean repeated) throws IOException\n    {\n        output.writeByteArray(fieldNumber, bs.bytes, repeated);\n    }\n\n    @Override\n    public String toString()\n    {\n        return String.format(\"<ByteString@%s size=%d>\",\n                Integer.toHexString(System.identityHashCode(this)), size());\n    }\n\n    // END EXTRA\n    private final byte[] bytes;\n\n    private ByteString(final byte[] bytes)\n    {\n        this.bytes = bytes;\n    }\n\n    /**\n     * Gets the byte at the given index.\n     * \n     * @throws ArrayIndexOutOfBoundsException\n     *             {@code index} is &lt; 0 or &gt;= size\n     */\n    public byte byteAt(final int index)\n    {\n        return bytes[index];\n    }\n\n    /**\n     * Gets the number of bytes.\n     */\n    public int size()\n    {\n        return bytes.length;\n    }\n\n    /**\n     * Returns {@code true} if the size is {@code 0}, {@code false} otherwise.\n     */\n    public boolean isEmpty()\n    {\n        return bytes.length == 0;\n    }\n\n    // =================================================================\n    // byte[] -> ByteString\n\n    /**\n     * Empty String.\n     */\n    public static final String EMPTY_STRING = \"\";\n\n    /**\n     * Empty byte array.\n     */\n    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n\n    /**\n     * Empty ByteString.\n     */\n    public static final ByteString EMPTY = new ByteString(EMPTY_BYTE_ARRAY);\n\n    /**\n     * Copies the given bytes into a {@code ByteString}.\n     */\n    public static ByteString copyFrom(final byte[] bytes, final int offset,\n            final int size)\n    {\n        final byte[] copy = new byte[size];\n        System.arraycopy(bytes, offset, copy, 0, size);\n        return new ByteString(copy);\n    }\n\n    /**\n     * Copies the given bytes into a {@code ByteString}.\n     */\n    public static ByteString copyFrom(final byte[] bytes)\n    {\n        return copyFrom(bytes, 0, bytes.length);\n    }\n\n    /**\n     * Encodes {@code text} into a sequence of bytes using the named charset and returns the result as a\n     * {@code ByteString}.\n     */\n    public static ByteString copyFrom(final String text, final String charsetName)\n    {\n        try\n        {\n            return new ByteString(text.getBytes(charsetName));\n        }\n        catch (UnsupportedEncodingException e)\n        {\n            throw new RuntimeException(charsetName + \" not supported?\", e);\n        }\n    }\n\n    /**\n     * Encodes {@code text} into a sequence of UTF-8 bytes and returns the result as a {@code ByteString}.\n     */\n    public static ByteString copyFromUtf8(final String text)\n    {\n        return new ByteString(STRING.ser(text));\n        /*\n         * @try { return new ByteString(text.getBytes(\"UTF-8\")); } catch (UnsupportedEncodingException e) { throw new\n         * RuntimeException(\"UTF-8 not supported?\", e); }\n         */\n    }\n\n    // =================================================================\n    // ByteString -> byte[]\n\n    /**\n     * Copies bytes into a buffer at the given offset.\n     * \n     * @param target\n     *            buffer to copy into\n     * @param offset\n     *            in the target buffer\n     */\n    public void copyTo(final byte[] target, final int offset)\n    {\n        System.arraycopy(bytes, 0, target, offset, bytes.length);\n    }\n\n    /**\n     * Copies bytes into a buffer.\n     * \n     * @param target\n     *            buffer to copy into\n     * @param sourceOffset\n     *            offset within these bytes\n     * @param targetOffset\n     *            offset within the target buffer\n     * @param size\n     *            number of bytes to copy\n     */\n    public void copyTo(final byte[] target, final int sourceOffset,\n            final int targetOffset,\n            final int size)\n    {\n        System.arraycopy(bytes, sourceOffset, target, targetOffset, size);\n    }\n\n    /**\n     * Copies bytes to a {@code byte[]}.\n     */\n    public byte[] toByteArray()\n    {\n        final int size = bytes.length;\n        final byte[] copy = new byte[size];\n        System.arraycopy(bytes, 0, copy, 0, size);\n        return copy;\n    }\n\n    /**\n     * Constructs a new read-only {@code java.nio.ByteBuffer} with the same backing byte array.\n     */\n    public ByteBuffer asReadOnlyByteBuffer()\n    {\n        final ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n        return byteBuffer.asReadOnlyBuffer();\n    }\n\n    /*\n     * @ Constructs a new {@code String} by decoding the bytes using the specified charset.\n     */\n    /*\n     * @public String unsignedIntToString(final String charsetName) throws UnsupportedEncodingException { return new String(bytes,\n     * charsetName); }\n     */\n\n    /**\n     * Constructs a new {@code String} by decoding the bytes as UTF-8.\n     */\n    public String toStringUtf8()\n    {\n        return STRING.deser(bytes);\n        /*\n         * @try { return new String(bytes, \"UTF-8\"); } catch (UnsupportedEncodingException e) { throw new\n         * RuntimeException(\"UTF-8 not supported?\", e); }\n         */\n    }\n\n    // =================================================================\n    // equals() and hashCode()\n\n    @Override\n    public boolean equals(final Object o)\n    {\n        return o == this || (o instanceof ByteString && equals(this, (ByteString) o, false));\n    }\n\n    /**\n     * Returns true if the contents of both match.\n     */\n    public static boolean equals(ByteString bs, ByteString other, boolean checkHash)\n    {\n        final int size = bs.bytes.length;\n        if (size != other.bytes.length)\n        {\n            return false;\n        }\n\n        if (checkHash)\n        {\n            // volatile reads\n            final int h1 = bs.hash, h2 = other.hash;\n            if (h1 != 0 && h2 != 0 && h1 != h2)\n            {\n                return false;\n            }\n        }\n\n        final byte[] thisBytes = bs.bytes;\n        final byte[] otherBytes = other.bytes;\n        for (int i = 0; i < size; i++)\n        {\n            if (thisBytes[i] != otherBytes[i])\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns true if the contents of the internal array and the provided array match.\n     */\n    public boolean equals(final byte[] data)\n    {\n        return equals(data, 0, data.length);\n    }\n\n    /**\n     * Returns true if the contents of the internal array and the provided array match.\n     */\n    public boolean equals(final byte[] data, int offset, final int len)\n    {\n        final byte[] bytes = this.bytes;\n        if (len != bytes.length)\n            return false;\n\n        for (int i = 0; i < len;)\n        {\n            if (bytes[i++] != data[offset++])\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private volatile int hash = 0;\n\n    @Override\n    public int hashCode()\n    {\n        int h = hash;\n\n        if (h == 0)\n        {\n            final byte[] thisBytes = bytes;\n            final int size = bytes.length;\n\n            h = size;\n            for (int i = 0; i < size; i++)\n            {\n                h = h * 31 + thisBytes[i];\n            }\n            if (h == 0)\n            {\n                h = 1;\n            }\n\n            hash = h;\n        }\n\n        return h;\n    }\n\n    // =================================================================\n    // Input stream\n\n    /*\n     * @ Creates an {@code InputStream} which can be used to read the bytes.\n     */\n    /*\n     * @public InputStream newInput() { return new ByteArrayInputStream(bytes); }\n     */\n\n    /*\n     * @ Creates a {@link CodedInputStream} which can be used to read the bytes. Using this is more efficient than\n     * creating a {@link CodedInputStream} wrapping the result of {@link #newInput()}.\n     */\n    /*\n     * @public CodedInputStream newCodedInput() { // We trust CodedInputStream not to modify the bytes, or to give\n     * anyone // else access to them. return CodedInputStream.newInstance(bytes); }\n     */\n\n    // =================================================================\n    // Output stream\n\n    /*\n     * @ Creates a new {@link Output} with the given initial capacity.\n     */\n    /*\n     * @public static Output newOutput(final int initialCapacity) { return new Output(new\n     * ByteArrayOutputStream(initialCapacity)); }\n     */\n\n    /*\n     * @ Creates a new {@link Output}.\n     */\n    /*\n     * @public static Output newOutput() { return newOutput(32); }\n     */\n\n    /*\n     * @ Outputs to a {@code ByteString} instance. Call {@link #toByteString()} to create the {@code ByteString}\n     * instance.\n     */\n    /*\n     * @public static final class Output extends FilterOutputStream { private final ByteArrayOutputStream bout;\n     * \n     * /** Constructs a new output with the given initial capacity.\n     * \n     * @ private Output(final ByteArrayOutputStream bout) { super(bout); this.bout = bout; }\n     * \n     * /** Creates a {@code ByteString} instance from this {@code Output}.\n     * \n     * @ public ByteString toByteString() { final byte[] byteArray = bout.toByteArray(); return new\n     * ByteString(byteArray); } }\n     * \n     * /** Constructs a new ByteString builder, which allows you to efficiently construct a {@code ByteString} by\n     * writing to a {@link CodedOutputStream}. Using this is much more efficient than calling {@code newOutput()} and\n     * wrapping that in a {@code CodedOutputStream}.\n     * \n     * <p>This is package-private because it's a somewhat confusing interface. Users can call {@link\n     * Message#toByteString()} instead of calling this directly.\n     * \n     * @param size The target byte size of the {@code ByteString}. You must write exactly this many bytes before\n     * building the result.\n     * \n     * @ static CodedBuilder newCodedBuilder(final int size) { return new CodedBuilder(size); }\n     * \n     * /** See {@link ByteString#newCodedBuilder(int)}. *@ static final class CodedBuilder { private final\n     * CodedOutputStream output; private final byte[] buffer;\n     * \n     * private CodedBuilder(final int size) { buffer = new byte[size]; output = CodedOutputStream.newInstance(buffer); }\n     * \n     * public ByteString build() { output.checkNoSpaceLeft();\n     * \n     * // We can be confident that the CodedOutputStream will not modify the // underlying bytes anymore because it\n     * already wrote all of them. So, // no need to make a copy. return new ByteString(buffer); }\n     * \n     * public CodedOutputStream getCodedOutput() { return output; } }\n     */\n\n    // moved from Internal.java\n\n    /**\n     * Helper called by generated code to construct default values for string fields.\n     * <p>\n     * The protocol compiler does not actually contain a UTF-8 decoder -- it just pushes UTF-8-encoded text around\n     * without touching it. The one place where this presents a problem is when generating Java string literals. Unicode\n     * characters in the string literal would normally need to be encoded using a Unicode escape sequence, which would\n     * require decoding them. To get around this, protoc instead embeds the UTF-8 bytes into the generated code and\n     * leaves it to the runtime library to decode them.\n     * <p>\n     * It gets worse, though. If protoc just generated a byte array, like: new byte[] {0x12, 0x34, 0x56, 0x78} Java\n     * actually generates *code* which allocates an array and then fills in each value. This is much less efficient than\n     * just embedding the bytes directly into the bytecode. To get around this, we need another work-around. String\n     * literals are embedded directly, so protoc actually generates a string literal corresponding to the bytes. The\n     * easiest way to do this is to use the ISO-8859-1 character set, which corresponds to the first 256 characters of\n     * the Unicode range. Protoc can then use good old CEscape to generate the string.\n     * <p>\n     * So we have a string literal which represents a set of bytes which represents another string. This function --\n     * stringDefaultValue -- converts from the generated string to the string we actually want. The generated code calls\n     * this automatically.\n     */\n    public static String stringDefaultValue(String bytes)\n    {\n        try\n        {\n            return new String(bytes.getBytes(\"ISO-8859-1\"), \"UTF-8\");\n        }\n        catch (UnsupportedEncodingException e)\n        {\n            // This should never happen since all JVMs are required to implement\n            // both of the above character sets.\n            throw new IllegalStateException(\n                    \"Java VM does not support a standard character set.\", e);\n        }\n    }\n\n    /**\n     * Helper called by generated code to construct default values for bytes fields.\n     * <p>\n     * This is a lot like {@link #stringDefaultValue}, but for bytes fields. In this case we only need the second of the\n     * two hacks -- allowing us to embed raw bytes as a string literal with ISO-8859-1 encoding.\n     */\n    public static ByteString bytesDefaultValue(String bytes)\n    {\n        return new ByteString(byteArrayDefaultValue(bytes));\n    }\n\n    /**\n     * Helper called by generated code to construct default values for byte array fields.\n     * <p>\n     * This is a lot like {@link #stringDefaultValue}, but for bytes fields. In this case we only need the second of the\n     * two hacks -- allowing us to embed raw bytes as a string literal with ISO-8859-1 encoding.\n     */\n    public static byte[] byteArrayDefaultValue(String bytes)\n    {\n        try\n        {\n            return bytes.getBytes(\"ISO-8859-1\");\n        }\n        catch (UnsupportedEncodingException e)\n        {\n            // This should never happen since all JVMs are required to implement\n            // ISO-8859-1.\n            throw new IllegalStateException(\n                    \"Java VM does not support a standard character set.\", e);\n        }\n    }\n}\n",
      "file_name": "ByteString.java",
      "human_label": "Return true if the contents of the internal array bytes and the provided array data match.",
      "level": "class_runnable",
      "lineno": "335",
      "name": "equals",
      "oracle_context": "{ \"apis\" : \"[]\", \"classes\" : \"[byte[]]\", \"vars\" : \"[length]\" }",
      "package": "io.protostuff",
      "project": "protostuff-master"
    },
    {
      "_id": "6367670b1a6d9265ec0179ff",
      "all_context": "{ \"class_level\" : \"import java.lang.reflect.Array;\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.Map.Entry;\\nObject[] EMPTY_OBJECT_ARRAY;\\nClass<?>[] EMPTY_CLASS_ARRAY;\\nString[] EMPTY_STRING_ARRAY;\\nlong[] EMPTY_LONG_ARRAY;\\nLong[] EMPTY_LONG_OBJECT_ARRAY;\\nint[] EMPTY_INT_ARRAY;\\nInteger[] EMPTY_INTEGER_OBJECT_ARRAY;\\nshort[] EMPTY_SHORT_ARRAY;\\nShort[] EMPTY_SHORT_OBJECT_ARRAY;\\nbyte[] EMPTY_BYTE_ARRAY;\\nByte[] EMPTY_BYTE_OBJECT_ARRAY;\\ndouble[] EMPTY_DOUBLE_ARRAY;\\nDouble[] EMPTY_DOUBLE_OBJECT_ARRAY;\\nfloat[] EMPTY_FLOAT_ARRAY;\\nFloat[] EMPTY_FLOAT_OBJECT_ARRAY;\\nboolean[] EMPTY_BOOLEAN_ARRAY;\\nBoolean[] EMPTY_BOOLEAN_OBJECT_ARRAY;\\nchar[] EMPTY_CHAR_ARRAY;\\nCharacter[] EMPTY_CHARACTER_OBJECT_ARRAY;\\nint INDEX_NOT_FOUND;\\nArrayUtils();\\nclone(Object[] array);\\nclone(long[] array);\\nclone(int[] array);\\nclone(short[] array);\\nclone(char[] array);\\nclone(byte[] array);\\nclone(double[] array);\\nclone(float[] array);\\nclone(boolean[] array);\\nclone(String[] array);\\nnullToEmpty(Object[] array);\\nnullToEmpty(String[] array);\\nnullToEmpty(long[] array);\\nnullToEmpty(int[] array);\\nnullToEmpty(short[] array);\\nnullToEmpty(char[] array);\\nnullToEmpty(byte[] array);\\nnullToEmpty(double[] array);\\nnullToEmpty(float[] array);\\nnullToEmpty(boolean[] array);\\nnullToEmpty(Long[] array);\\nnullToEmpty(Integer[] array);\\nnullToEmpty(Short[] array);\\nnullToEmpty(Character[] array);\\nnullToEmpty(Byte[] array);\\nnullToEmpty(Double[] array);\\nnullToEmpty(Float[] array);\\nnullToEmpty(Boolean[] array);\\nsubarray(Object[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(long[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(int[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(short[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(char[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(byte[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(double[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(float[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(boolean[] array,int startIndexInclusive,int endIndexExclusive);\\nisSameLength(Object[] array1,Object[] array2);\\nisSameLength(long[] array1,long[] array2);\\nisSameLength(int[] array1,int[] array2);\\nisSameLength(short[] array1,short[] array2);\\nisSameLength(char[] array1,char[] array2);\\nisSameLength(byte[] array1,byte[] array2);\\nisSameLength(double[] array1,double[] array2);\\nisSameLength(float[] array1,float[] array2);\\nisSameLength(boolean[] array1,boolean[] array2);\\ngetLength(Object array);\\nisSameType(Object array1,Object array2);\\nreverse(Object[] array);\\nreverse(long[] array);\\nreverse(int[] array);\\nreverse(short[] array);\\nreverse(char[] array);\\nreverse(byte[] array);\\nreverse(double[] array);\\nreverse(float[] array);\\nreverse(boolean[] array);\\nindexOf(Object[] array,Object objectToFind);\\nindexOf(Object[] array,Object objectToFind,int startIndex);\\nlastIndexOf(Object[] array,Object objectToFind);\\nlastIndexOf(Object[] array,Object objectToFind,int startIndex);\\ncontains(Object[] array,Object objectToFind);\\nindexOf(long[] array,long valueToFind);\\nindexOf(long[] array,long valueToFind,int startIndex);\\nlastIndexOf(long[] array,long valueToFind);\\nlastIndexOf(long[] array,long valueToFind,int startIndex);\\ncontains(long[] array,long valueToFind);\\nindexOf(int[] array,int valueToFind);\\nindexOf(int[] array,int valueToFind,int startIndex);\\nlastIndexOf(int[] array,int valueToFind);\\nlastIndexOf(int[] array,int valueToFind,int startIndex);\\ncontains(int[] array,int valueToFind);\\nindexOf(short[] array,short valueToFind);\\nindexOf(short[] array,short valueToFind,int startIndex);\\nlastIndexOf(short[] array,short valueToFind);\\nlastIndexOf(short[] array,short valueToFind,int startIndex);\\ncontains(short[] array,short valueToFind);\\nindexOf(char[] array,char valueToFind);\\nindexOf(char[] array,char valueToFind,int startIndex);\\nlastIndexOf(char[] array,char valueToFind);\\nlastIndexOf(char[] array,char valueToFind,int startIndex);\\ncontains(char[] array,char valueToFind);\\nindexOf(byte[] array,byte valueToFind);\\nindexOf(byte[] array,byte valueToFind,int startIndex);\\nlastIndexOf(byte[] array,byte valueToFind);\\nlastIndexOf(byte[] array,byte valueToFind,int startIndex);\\ncontains(byte[] array,byte valueToFind);\\nindexOf(double[] array,double valueToFind);\\nindexOf(double[] array,double valueToFind,double tolerance);\\nindexOf(double[] array,double valueToFind,int startIndex);\\nindexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\nlastIndexOf(double[] array,double valueToFind);\\nlastIndexOf(double[] array,double valueToFind,double tolerance);\\nlastIndexOf(double[] array,double valueToFind,int startIndex);\\nlastIndexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\ncontains(double[] array,double valueToFind);\\ncontains(double[] array,double valueToFind,double tolerance);\\nindexOf(float[] array,float valueToFind);\\nindexOf(float[] array,float valueToFind,int startIndex);\\nlastIndexOf(float[] array,float valueToFind);\\nlastIndexOf(float[] array,float valueToFind,int startIndex);\\ncontains(float[] array,float valueToFind);\\nindexOf(boolean[] array,boolean valueToFind);\\nindexOf(boolean[] array,boolean valueToFind,int startIndex);\\nlastIndexOf(boolean[] array,boolean valueToFind);\\nlastIndexOf(boolean[] array,boolean valueToFind,int startIndex);\\ncontains(boolean[] array,boolean valueToFind);\\ntoPrimitive(Character[] array);\\ntoPrimitive(Character[] array,char valueForNull);\\ntoObject(char[] array);\\ntoPrimitive(Long[] array);\\ntoPrimitive(Long[] array,long valueForNull);\\ntoObject(long[] array);\\ntoPrimitive(Integer[] array);\\ntoPrimitive(Integer[] array,int valueForNull);\\ntoObject(int[] array);\\ntoPrimitive(Short[] array);\\ntoPrimitive(Short[] array,short valueForNull);\\ntoObject(short[] array);\\ntoPrimitive(Byte[] array);\\ntoPrimitive(Byte[] array,byte valueForNull);\\ntoObject(byte[] array);\\ntoPrimitive(Double[] array);\\ntoPrimitive(Double[] array,double valueForNull);\\ntoObject(double[] array);\\ntoPrimitive(Float[] array);\\ntoPrimitive(Float[] array,float valueForNull);\\ntoObject(float[] array);\\ntoPrimitive(Boolean[] array);\\ntoPrimitive(Boolean[] array,boolean valueForNull);\\ntoObject(boolean[] array);\\nisEmpty(Object[] array);\\nisEmpty(long[] array);\\nisEmpty(int[] array);\\nisEmpty(short[] array);\\nisEmpty(char[] array);\\nisEmpty(byte[] array);\\nisEmpty(double[] array);\\nisEmpty(float[] array);\\nisEmpty(boolean[] array);\\nisNotEmpty(Object[] array);\\nisNotEmpty(long[] array);\\nisNotEmpty(int[] array);\\nisNotEmpty(short[] array);\\nisNotEmpty(char[] array);\\nisNotEmpty(byte[] array);\\nisNotEmpty(double[] array);\\nisNotEmpty(float[] array);\\nisNotEmpty(boolean[] array);\\naddAll(Object[] array1,Object[] array2);\\naddAll(boolean[] array1,boolean[] array2);\\naddAll(char[] array1,char[] array2);\\naddAll(byte[] array1,byte[] array2);\\naddAll(short[] array1,short[] array2);\\naddAll(int[] array1,int[] array2);\\naddAll(long[] array1,long[] array2);\\naddAll(float[] array1,float[] array2);\\naddAll(double[] array1,double[] array2);\\naddAll(String[] array1,String[] array2);\\nadd(T[] array,T element);\\nadd(boolean[] array,boolean element);\\nadd(byte[] array,byte element);\\nadd(char[] array,char element);\\nadd(double[] array,double element);\\nadd(float[] array,float element);\\nadd(int[] array,int element);\\nadd(long[] array,long element);\\nadd(short[] array,short element);\\ncopyArrayGrow1(Object array,Class newArrayComponentType);\\nadd(Object[] array,int index,Object element);\\nadd(boolean[] array,int index,boolean element);\\nadd(char[] array,int index,char element);\\nadd(byte[] array,int index,byte element);\\nadd(short[] array,int index,short element);\\nadd(int[] array,int index,int element);\\nadd(long[] array,int index,long element);\\nadd(float[] array,int index,float element);\\nadd(double[] array,int index,double element);\\nadd(Object array,int index,Object element,Class clss);\\nremove(Object[] array,int index);\\nremoveElement(Object[] array,Object element);\\nremove(boolean[] array,int index);\\nremoveElement(boolean[] array,boolean element);\\nremove(byte[] array,int index);\\nremoveElement(byte[] array,byte element);\\nremove(char[] array,int index);\\nremoveElement(char[] array,char element);\\nremove(double[] array,int index);\\nremoveElement(double[] array,double element);\\nremove(float[] array,int index);\\nremoveElement(float[] array,float element);\\nremove(int[] array,int index);\\nremoveElement(int[] array,int element);\\nremove(long[] array,int index);\\nremoveElement(long[] array,long element);\\nremove(short[] array,int index);\\nremoveElement(short[] array,short element);\\nremove(Object array,int index);\\nclearNull(Object[] arr);\\ntoMap(Object[] array);\\n\", \"repo_level\" : \"\" }",
      "class_name": "ArrayUtils",
      "code": "public static Byte[] nullToEmpty(final Byte[] array){\n  if (array == null || array.length == 0) {\n    return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}\n",
      "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n",
      "end_lineno": "617",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils;\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * <p>Operations on arrays, primitive arrays (like <code>int[]</code>) and\n * primitive wrapper arrays (like <code>Integer[]</code>).</p>\n *\n * <p>This class tries to handle <code>null</code> input gracefully.\n * An exception will not be thrown for a <code>null</code>\n * array input. However, an Object array that contains a <code>null</code>\n * element may throw an exception. Each method documents its behaviour.</p>\n *\n * <p>#ThreadSafe#</p>\n * @author Apache Software Foundation\n * @author Moritz Petersen\n * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n * @author Nikolay Metchev\n * @author Matthew Hawthorne\n * @author Tim O'Brien\n * @author Pete Gieser\n * @author Gary Gregory\n * @author <a href=\"mailto:equinus100@hotmail.com\">Ashwin S</a>\n * @author Maarten Coene\n * @since 2.0\n * @version $Id: ArrayUtils.java 1056988 2011-01-09 17:58:53Z niallp $\n */\npublic class ArrayUtils {\n    /** An empty immutable <code>Object</code> array. */\n    public static final Object[]    EMPTY_OBJECT_ARRAY           = new Object[0];\n    /** An empty immutable <code>Class</code> array. */\n    public static final Class<?>[]  EMPTY_CLASS_ARRAY            = new Class[0];\n    /** An empty immutable <code>String</code> array. */\n    public static final String[]    EMPTY_STRING_ARRAY           = new String[0];\n    /** An empty immutable <code>long</code> array. */\n    public static final long[]      EMPTY_LONG_ARRAY             = new long[0];\n    /** An empty immutable <code>Long</code> array. */\n    public static final Long[]      EMPTY_LONG_OBJECT_ARRAY      = new Long[0];\n    /** An empty immutable <code>int</code> array. */\n    public static final int[]       EMPTY_INT_ARRAY              = new int[0];\n    /** An empty immutable <code>Integer</code> array. */\n    public static final Integer[]   EMPTY_INTEGER_OBJECT_ARRAY   = new Integer[0];\n    /** An empty immutable <code>short</code> array. */\n    public static final short[]     EMPTY_SHORT_ARRAY            = new short[0];\n    /** An empty immutable <code>Short</code> array. */\n    public static final Short[]     EMPTY_SHORT_OBJECT_ARRAY     = new Short[0];\n    /** An empty immutable <code>byte</code> array. */\n    public static final byte[]      EMPTY_BYTE_ARRAY             = new byte[0];\n    /** An empty immutable <code>Byte</code> array. */\n    public static final Byte[]      EMPTY_BYTE_OBJECT_ARRAY      = new Byte[0];\n    /** An empty immutable <code>double</code> array. */\n    public static final double[]    EMPTY_DOUBLE_ARRAY           = new double[0];\n    /** An empty immutable <code>Double</code> array. */\n    public static final Double[]    EMPTY_DOUBLE_OBJECT_ARRAY    = new Double[0];\n    /** An empty immutable <code>float</code> array. */\n    public static final float[]     EMPTY_FLOAT_ARRAY            = new float[0];\n    /** An empty immutable <code>Float</code> array. */\n    public static final Float[]     EMPTY_FLOAT_OBJECT_ARRAY     = new Float[0];\n    /** An empty immutable <code>boolean</code> array. */\n    public static final boolean[]   EMPTY_BOOLEAN_ARRAY          = new boolean[0];\n    /** An empty immutable <code>Boolean</code> array. */\n    public static final Boolean[]   EMPTY_BOOLEAN_OBJECT_ARRAY   = new Boolean[0];\n    /** An empty immutable <code>char</code> array. */\n    public static final char[]      EMPTY_CHAR_ARRAY             = new char[0];\n    /** An empty immutable <code>Character</code> array. */\n    public static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n    /**\n     * The index value when an element is not found in a list or array: <code>-1</code>.\n     * This value is returned by methods in this class and can also be used in comparisons with values returned by\n     * various method from {@link java.util.List}.\n     */\n    public static final int         INDEX_NOT_FOUND              = -1;\n\n    /**\n     * <p>ArrayUtils instances should NOT be constructed in standard programming.\n     * Instead, the class should be used as <code>ArrayUtils.clone(new int[] {2})</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     */\n    public ArrayUtils() {\n        super();\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts the given array into a {@link Map}. Each element of the array\n     * must be either a {@link Entry} or an Array, containing at least two\n     * elements, where the first element is used as key and the second as\n     * value.</p>\n     *\n     * <p>This method can be used to initialize:</p>\n     * <pre>\n     * // Create a Map mapping colors.\n     * Map colorMap = ArrayUtils.toMap(new String[][] {{\n     *     {\"RED\", \"#FF0000\"},\n     *     {\"GREEN\", \"#00FF00\"},\n     *     {\"BLUE\", \"#0000FF\"}});\n     * </pre>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  an array whose elements are either a {@link Entry} or\n     *  an Array containing at least two elements, may be <code>null</code>\n     * @return a <code>Map</code> that was created from the array\n     * @throws IllegalArgumentException  if one element of this Array is\n     *  itself an Array containing less then two elements\n     * @throws IllegalArgumentException  if the array contains elements other\n     *  than {@link Entry} and an Array\n     */\n    public static Map toMap(final Object[] array) {\n        if (array == null) {\n            return null;\n        }\n        final Map map = new HashMap((int) (array.length * 1.5));\n        for (int i = 0; i < array.length; i++) {\n            Object object = array[i];\n            if (object instanceof Entry) {\n                Entry entry = (Entry) object;\n                map.put(entry.getKey(), entry.getValue());\n            } else if (object instanceof Object[]) {\n                Object[] entry = (Object[]) object;\n                if (entry.length < 2) {\n                    throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', has a length less than 2\");\n                }\n                map.put(entry[0], entry[1]);\n            } else {\n                throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', is neither of type Map.Entry nor an Array\");\n            }\n        }\n        return map;\n    }\n    // Clone\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Shallow clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>The objects in the array are not cloned, thus there is no special\n     * handling for multi-dimensional arrays.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to shallow clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static Object[] clone(final Object[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static long[] clone(final long[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static int[] clone(final int[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static short[] clone(final short[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static char[] clone(final char[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static byte[] clone(final byte[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static double[] clone(final double[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static float[] clone(final float[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static boolean[] clone(final boolean[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static String[] clone(final String[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n    // nullToEmpty\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Object[] nullToEmpty(final Object[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static String[] nullToEmpty(final String[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static long[] nullToEmpty(final long[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static int[] nullToEmpty(final int[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static short[] nullToEmpty(final short[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static char[] nullToEmpty(final char[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static byte[] nullToEmpty(final byte[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static double[] nullToEmpty(final double[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static float[] nullToEmpty(final float[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static boolean[] nullToEmpty(final boolean[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Long[] nullToEmpty(final Long[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Integer[] nullToEmpty(final Integer[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Short[] nullToEmpty(final Short[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Character[] nullToEmpty(final Character[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Byte[] nullToEmpty(final Byte[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Double[] nullToEmpty(final Double[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Float[] nullToEmpty(final Float[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Boolean[] nullToEmpty(final Boolean[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;\n        }\n        return array;\n    }\n    // Subarrays\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Produces a new array containing the elements between\n     * the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * <p>The component type of the subarray is always the same as\n     * that of the input array. Thus, if the input is an array of type\n     * <code>Date</code>, the following usage is envisaged:</p>\n     *\n     * <pre>\n     * Date[] someDates = (Date[])ArrayUtils.subarray(allDates, 2, 5);\n     * </pre>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static Object[] subarray(final Object[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        Class<?> type = array.getClass().getComponentType();\n        if (newSize <= 0) {\n            return (Object[]) Array.newInstance(type, 0);\n        }\n        Object[] subarray = (Object[]) Array.newInstance(type, newSize);\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>long</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        long[] subarray = new long[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>int</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        int[] subarray = new int[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>short</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        short[] subarray = new short[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>char</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        char[] subarray = new char[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>byte</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        byte[] subarray = new byte[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>double</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] subarray = new double[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>float</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        float[] subarray = new float[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>boolean</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        boolean[] subarray = new boolean[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n    // Is same length\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.\n     *\n     * <p>Any multi-dimensional aspects of the arrays are ignored.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final Object[] array1, final Object[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final long[] array1, final long[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final int[] array1, final int[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final short[] array1, final short[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final char[] array1, final char[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final double[] array1, final double[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final float[] array1, final float[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Returns the length of the specified array.\n     * This method can deal with <code>Object</code> arrays and with primitive arrays.</p>\n     *\n     * <p>If the input array is <code>null</code>, <code>0</code> is returned.</p>\n     *\n     * <pre>\n     * ArrayUtils.getLength(null)            = 0\n     * ArrayUtils.getLength([])              = 0\n     * ArrayUtils.getLength([null])          = 1\n     * ArrayUtils.getLength([true, false])   = 2\n     * ArrayUtils.getLength([1, 2, 3])       = 3\n     * ArrayUtils.getLength([\"a\", \"b\", \"c\"]) = 3\n     * </pre>\n     *\n     * @param array  the array to retrieve the length from, may be null\n     * @return The length of the array, or <code>0</code> if the array is <code>null</code>\n     * @throws IllegalArgumentException if the object arguement is not an array.\n     * @since 2.1\n     */\n    public static int getLength(final Object array) {\n        if (array == null) {\n            return 0;\n        }\n        return Array.getLength(array);\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same type taking into account\n     * multi-dimensional arrays.</p>\n     *\n     * @param array1 the first array, must not be <code>null</code>\n     * @param array2 the second array, must not be <code>null</code>\n     * @return <code>true</code> if type of arrays matches\n     * @throws IllegalArgumentException if either array is <code>null</code>\n     */\n    public static boolean isSameType(final Object array1, final Object array2) {\n        if (array1 == null || array2 == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        return array1.getClass().getName().equals(array2.getClass().getName());\n    }\n    // Reverse\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>There is no special handling for multi-dimensional arrays.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final Object[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        Object tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final long[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        long tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final int[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        int tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final short[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        short tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final char[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        char tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final byte[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        byte tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final double[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        double tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final float[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        float tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final boolean[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        boolean tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n    // IndexOf search\n    // ----------------------------------------------------------------------\n    // Object IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given object in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @return the index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final Object[] array, final Object objectToFind) {\n        return ArrayUtils.indexOf(array, objectToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given object in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @param startIndex  the index to start searching at\n     * @return the index of the object within the array starting at the index,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given object within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @return the last index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final Object[] array, final Object objectToFind) {\n        return ArrayUtils.lastIndexOf(array, objectToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given object in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n     * the array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i >= 0; i--) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n            for (int i = startIndex; i >= 0; i--) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the object is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param objectToFind  the object to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final Object[] array, final Object objectToFind) {\n        return ArrayUtils.indexOf(array, objectToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // long IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final long[] array, final long valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final long[] array, final long valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final long[] array, final long valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final long[] array, final long valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // int IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final int[] array, final int valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final int[] array, final int valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final int[] array, final int valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final int[] array, final int valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // short IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final short[] array, final short valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final short[] array, final short valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final short[] array, final short valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final short[] array, final short valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final short[] array, final short valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // char IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int indexOf(final char[] array, final char valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int indexOf(final char[] array, final char valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int lastIndexOf(final char[] array, final char valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int lastIndexOf(final char[] array, final char valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     * @since 2.1\n     */\n    public static boolean contains(final char[] array, final char valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // byte IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final byte[] array, final byte valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final byte[] array, final byte valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final byte[] array, final byte valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // double IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value within a given tolerance in the array.\n     * This method will return the index of the first value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind, final double tolerance) {\n        return ArrayUtils.indexOf(array, valueToFind, 0, tolerance);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.\n     * This method will return the index of the first value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        double min = valueToFind - tolerance;\n        double max = valueToFind + tolerance;\n        for (int i = startIndex; i < array.length; i++) {\n            if (array[i] >= min && array[i] <= max) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value within a given tolerance in the array.\n     * This method will return the index of the last value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.\n     * This method will return the index of the last value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @param tolerance  search for value within plus/minus this amount\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        double min = valueToFind - tolerance;\n        double max = valueToFind + tolerance;\n        for (int i = startIndex; i >= 0; i--) {\n            if (array[i] >= min && array[i] <= max) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final double[] array, final double valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if a value falling within the given tolerance is in the\n     * given array.  If the array contains a value within the inclusive range\n     * defined by (value - tolerance) to (value + tolerance).</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array\n     * is passed in.</p>\n     *\n     * @param array  the array to search\n     * @param valueToFind  the value to find\n     * @param tolerance  the array contains the tolerance of the search\n     * @return true if value falling within tolerance is in array\n     */\n    public static boolean contains(final double[] array, final double valueToFind, final double tolerance) {\n        return ArrayUtils.indexOf(array, valueToFind, 0, tolerance) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // float IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final float[] array, final float valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final float[] array, final float valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final float[] array, final float valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final float[] array, final float valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // boolean IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final boolean[] array, final boolean valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code>\n     *  array input\n     */\n    public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) if\n     * <code>null</code> array input.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final boolean[] array, final boolean valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n     * the array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final boolean[] array, final boolean valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // Primitive/Object array converters\n    // ----------------------------------------------------------------------\n    // Character array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Characters to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Character</code> array, may be <code>null</code>\n     * @return a <code>char</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static char[] toPrimitive(final Character[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].charValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Character to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Character</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>char</code> array, <code>null</code> if null array input\n     */\n    public static char[] toPrimitive(final Character[] array, final char valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Character b = array[i];\n            result[i] = b == null ? valueForNull : b.charValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive chars to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array a <code>char</code> array\n     * @return a <code>Character</code> array, <code>null</code> if null array input\n     */\n    public static Character[] toObject(final char[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY;\n        }\n        final Character[] result = new Character[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Character(array[i]);\n        }\n        return result;\n    }\n    // Long array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Longs to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Long</code> array, may be <code>null</code>\n     * @return a <code>long</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static long[] toPrimitive(final Long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].longValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Long to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Long</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>long</code> array, <code>null</code> if null array input\n     */\n    public static long[] toPrimitive(final Long[] array, final long valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Long b = array[i];\n            result[i] = b == null ? valueForNull : b.longValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive longs to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>long</code> array\n     * @return a <code>Long</code> array, <code>null</code> if null array input\n     */\n    public static Long[] toObject(final long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_OBJECT_ARRAY;\n        }\n        final Long[] result = new Long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Long(array[i]);\n        }\n        return result;\n    }\n    // Int array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Integers to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Integer</code> array, may be <code>null</code>\n     * @return an <code>int</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static int[] toPrimitive(final Integer[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].intValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Integer to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Integer</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return an <code>int</code> array, <code>null</code> if null array input\n     */\n    public static int[] toPrimitive(final Integer[] array, final int valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Integer b = array[i];\n            result[i] = b == null ? valueForNull : b.intValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive ints to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  an <code>int</code> array\n     * @return an <code>Integer</code> array, <code>null</code> if null array input\n     */\n    public static Integer[] toObject(final int[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        final Integer[] result = new Integer[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Integer(array[i]);\n        }\n        return result;\n    }\n    // Short array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Shorts to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Short</code> array, may be <code>null</code>\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static short[] toPrimitive(final Short[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        final short[] result = new short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].shortValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Short to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Short</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     */\n    public static short[] toPrimitive(final Short[] array, final short valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        final short[] result = new short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Short b = array[i];\n            result[i] = b == null ? valueForNull : b.shortValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive shorts to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>short</code> array\n     * @return a <code>Short</code> array, <code>null</code> if null array input\n     */\n    public static Short[] toObject(final short[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;\n        }\n        final Short[] result = new Short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Short(array[i]);\n        }\n        return result;\n    }\n    // Byte array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Bytes to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Byte</code> array, may be <code>null</code>\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static byte[] toPrimitive(final Byte[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        final byte[] result = new byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].byteValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Bytes to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Byte</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     */\n    public static byte[] toPrimitive(final Byte[] array, final byte valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        final byte[] result = new byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Byte b = array[i];\n            result[i] = b == null ? valueForNull : b.byteValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive bytes to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>byte</code> array\n     * @return a <code>Byte</code> array, <code>null</code> if null array input\n     */\n    public static Byte[] toObject(final byte[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;\n        }\n        final Byte[] result = new Byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Byte(array[i]);\n        }\n        return result;\n    }\n    // Double array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Doubles to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Double</code> array, may be <code>null</code>\n     * @return a <code>double</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static double[] toPrimitive(final Double[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        final double[] result = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].doubleValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Doubles to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Double</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>double</code> array, <code>null</code> if null array input\n     */\n    public static double[] toPrimitive(final Double[] array, final double valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        final double[] result = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Double b = array[i];\n            result[i] = b == null ? valueForNull : b.doubleValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive doubles to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>double</code> array\n     * @return a <code>Double</code> array, <code>null</code> if null array input\n     */\n    public static Double[] toObject(final double[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;\n        }\n        final Double[] result = new Double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Double(array[i]);\n        }\n        return result;\n    }\n    //   Float array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Floats to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Float</code> array, may be <code>null</code>\n     * @return a <code>float</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static float[] toPrimitive(final Float[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        final float[] result = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].floatValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Floats to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Float</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>float</code> array, <code>null</code> if null array input\n     */\n    public static float[] toPrimitive(final Float[] array, final float valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        final float[] result = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Float b = array[i];\n            result[i] = b == null ? valueForNull : b.floatValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive floats to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>float</code> array\n     * @return a <code>Float</code> array, <code>null</code> if null array input\n     */\n    public static Float[] toObject(final float[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY;\n        }\n        final Float[] result = new Float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Float(array[i]);\n        }\n        return result;\n    }\n    // Boolean array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Booleans to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n     * @return a <code>boolean</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static boolean[] toPrimitive(final Boolean[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        final boolean[] result = new boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].booleanValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Booleans to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>boolean</code> array, <code>null</code> if null array input\n     */\n    public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        final boolean[] result = new boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Boolean b = array[i];\n            result[i] = b == null ? valueForNull : b.booleanValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive booleans to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>boolean</code> array\n     * @return a <code>Boolean</code> array, <code>null</code> if null array input\n     */\n    public static Boolean[] toObject(final boolean[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;\n        }\n        final Boolean[] result = new Boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE;\n        }\n        return result;\n    }\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if an array of Objects is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final Object[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive longs is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final long[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive ints is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final int[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive shorts is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final short[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive chars is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final char[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive bytes is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final byte[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final double[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive floats is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final float[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive booleans is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final boolean[] array) {\n        return array == null || array.length == 0;\n    }\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if an array of Objects is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final Object[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive longs is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final long[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive ints is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final int[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive shorts is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final short[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive chars is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final char[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive bytes is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final byte[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive doubles is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final double[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive floats is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final float[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive booleans is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final boolean[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(null, null)     = null\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * ArrayUtils.addAll([null], [null]) = [null, null]\n     * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array, may be <code>null</code>\n     * @param array2  the second array whose elements are added to the new array, may be <code>null</code>\n     * @return The new array, <code>null</code> if both arrays are <code>null</code>.\n     *      The type of the new array is the type of the first array,\n     *      unless the first array is null, in which case the type is the same as the second array.\n     * @since 2.1\n     * @throws IllegalArgumentException if the array types are incompatible\n     */\n    public static Object[] addAll(final Object[] array1, final Object[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        Object[] joinedArray = (Object[]) Array.newInstance(array1.getClass().getComponentType(), array1.length + array2.length);\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        try {\n            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        } catch (ArrayStoreException ase) {\n            // Check if problem was due to incompatible types\n            /*\n             * We do this here, rather than before the copy because:\n             * - it would be a wasted check most of the time\n             * - safer, in case check turns out to be too strict\n             */\n            final Class<?> type1 = array1.getClass().getComponentType();\n            final Class<?> type2 = array2.getClass().getComponentType();\n            if (!type1.isAssignableFrom(type2)) {\n                throw new IllegalArgumentException(\"Cannot store \" + type2.getName() + \" in an array of \" + type1.getName());\n            }\n            throw ase; // No, so rethrow original\n        }\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new boolean[] array.\n     * @since 2.1\n     */\n    public static boolean[] addAll(final boolean[] array1, final boolean[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        boolean[] joinedArray = new boolean[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new char[] array.\n     * @since 2.1\n     */\n    public static char[] addAll(final char[] array1, final char[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        char[] joinedArray = new char[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new byte[] array.\n     * @since 2.1\n     */\n    public static byte[] addAll(final byte[] array1, final byte[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        byte[] joinedArray = new byte[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new short[] array.\n     * @since 2.1\n     */\n    public static short[] addAll(final short[] array1, final short[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        short[] joinedArray = new short[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new int[] array.\n     * @since 2.1\n     */\n    public static int[] addAll(final int[] array1, final int[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        int[] joinedArray = new int[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new long[] array.\n     * @since 2.1\n     */\n    public static long[] addAll(final long[] array1, final long[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        long[] joinedArray = new long[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new float[] array.\n     * @since 2.1\n     */\n    public static float[] addAll(final float[] array1, final float[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        float[] joinedArray = new float[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new double[] array.\n     * @since 2.1\n     */\n    public static double[] addAll(final double[] array1, final double[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        double[] joinedArray = new double[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new String[] array.\n     * @since 2.1\n     */\n    public static String[] addAll(final String[] array1, final String[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        String[] joinedArray = new String[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element, unless the element itself is null,\n     *  in which case the return type is Object[]</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, null)      = [null]\n     * ArrayUtils.add(null, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to \"add\" the element to, may be <code>null</code>\n     * @param element  the object to add, may be <code>null</code>\n     * @return A new array containing the existing elements plus the new element\n     * The returned array type will be that of the input array (unless null),\n     * in which case it will have the same type as the element.\n     * @since 2.1\n     */\n    public static <T> T[] add(final T[] array, final T element) {\n        Class<?> type;\n        if (array != null) {\n            type = array.getClass();\n        } else if (element != null) {\n            type = element.getClass();\n        } else {\n            type = Object.class;\n        }\n        T[] newArray = (T[]) ArrayUtils.copyArrayGrow1(array, type);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, true)          = [true]\n     * ArrayUtils.add([true], false)       = [true, false]\n     * ArrayUtils.add([true, false], true) = [true, false, true]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static boolean[] add(final boolean[] array, final boolean element) {\n        boolean[] newArray = (boolean[]) ArrayUtils.copyArrayGrow1(array, Boolean.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static byte[] add(final byte[] array, final byte element) {\n        byte[] newArray = (byte[]) ArrayUtils.copyArrayGrow1(array, Byte.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, '0')       = ['0']\n     * ArrayUtils.add(['1'], '0')      = ['1', '0']\n     * ArrayUtils.add(['1', '0'], '1') = ['1', '0', '1']\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static char[] add(final char[] array, final char element) {\n        char[] newArray = (char[]) ArrayUtils.copyArrayGrow1(array, Character.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static double[] add(final double[] array, final double element) {\n        double[] newArray = (double[]) ArrayUtils.copyArrayGrow1(array, Double.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static float[] add(final float[] array, final float element) {\n        float[] newArray = (float[]) ArrayUtils.copyArrayGrow1(array, Float.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static int[] add(final int[] array, final int element) {\n        int[] newArray = (int[]) ArrayUtils.copyArrayGrow1(array, Integer.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static long[] add(final long[] array, final long element) {\n        long[] newArray = (long[]) ArrayUtils.copyArrayGrow1(array, Long.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static short[] add(final short[] array, final short element) {\n        short[] newArray = (short[]) ArrayUtils.copyArrayGrow1(array, Short.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * Returns a copy of the given array of size 1 greater than the argument.\n     * The last value of the array is left to the default value.\n     *\n     * @param array The array to copy, must not be <code>null</code>.\n     * @param newArrayComponentType If <code>array</code> is <code>null</code>, create a\n     * size 1 array of this type.\n     * @return A new copy of the array of size 1 greater than the input.\n     */\n    private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n        if (array != null) {\n            int arrayLength = Array.getLength(array);\n            Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n            System.arraycopy(array, 0, newArray, 0, arrayLength);\n            return newArray;\n        }\n        return Array.newInstance(newArrayComponentType, 1);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, null)      = [null]\n     * ArrayUtils.add(null, 0, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], 1, null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], 1, \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], 3, \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > array.length).\n     */\n    public static Object[] add(final Object[] array, final int index, final Object element) {\n        Class<?> clss = null;\n        if (array != null) {\n            clss = array.getClass().getComponentType();\n        } else if (element != null) {\n            clss = element.getClass();\n        } else {\n            return new Object[] { null };\n        }\n        return (Object[]) ArrayUtils.add(array, index, element, clss);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, true)          = [true]\n     * ArrayUtils.add([true], 0, false)       = [false, true]\n     * ArrayUtils.add([false], 1, true)       = [false, true]\n     * ArrayUtils.add([true, false], 1, true) = [true, true, false]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static boolean[] add(final boolean[] array, final int index, final boolean element) {\n        Boolean booElement = element ? Boolean.TRUE : Boolean.FALSE;\n        return (boolean[]) ArrayUtils.add(array, index, booElement, Boolean.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, 'a')            = ['a']\n     * ArrayUtils.add(['a'], 0, 'b')           = ['b', 'a']\n     * ArrayUtils.add(['a', 'b'], 0, 'c')      = ['c', 'a', 'b']\n     * ArrayUtils.add(['a', 'b'], 1, 'k')      = ['a', 'k', 'b']\n     * ArrayUtils.add(['a', 'b', 'c'], 1, 't') = ['a', 't', 'b', 'c']\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static char[] add(final char[] array, final int index, final char element) {\n        return (char[]) ArrayUtils.add(array, index, new Character(element), Character.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 3)      = [2, 6, 3]\n     * ArrayUtils.add([2, 6], 0, 1)      = [1, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static byte[] add(final byte[] array, final int index, final byte element) {\n        return (byte[]) ArrayUtils.add(array, index, new Byte(element), Byte.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static short[] add(final short[] array, final int index, final short element) {\n        return (short[]) ArrayUtils.add(array, index, new Short(element), Short.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static int[] add(final int[] array, final int index, final int element) {\n        return (int[]) ArrayUtils.add(array, index, new Integer(element), Integer.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1L], 0, 2L)           = [2L, 1L]\n     * ArrayUtils.add([2L, 6L], 2, 10L)      = [2L, 6L, 10L]\n     * ArrayUtils.add([2L, 6L], 0, -4L)      = [-4L, 2L, 6L]\n     * ArrayUtils.add([2L, 6L, 3L], 2, 1L)   = [2L, 6L, 1L, 3L]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static long[] add(final long[] array, final int index, final long element) {\n        return (long[]) ArrayUtils.add(array, index, new Long(element), Long.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1.1f], 0, 2.2f)               = [2.2f, 1.1f]\n     * ArrayUtils.add([2.3f, 6.4f], 2, 10.5f)        = [2.3f, 6.4f, 10.5f]\n     * ArrayUtils.add([2.6f, 6.7f], 0, -4.8f)        = [-4.8f, 2.6f, 6.7f]\n     * ArrayUtils.add([2.9f, 6.0f, 0.3f], 2, 1.0f)   = [2.9f, 6.0f, 1.0f, 0.3f]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static float[] add(final float[] array, final int index, final float element) {\n        return (float[]) ArrayUtils.add(array, index, new Float(element), Float.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1.1], 0, 2.2)              = [2.2, 1.1]\n     * ArrayUtils.add([2.3, 6.4], 2, 10.5)        = [2.3, 6.4, 10.5]\n     * ArrayUtils.add([2.6, 6.7], 0, -4.8)        = [-4.8, 2.6, 6.7]\n     * ArrayUtils.add([2.9, 6.0, 0.3], 2, 1.0)    = [2.9, 6.0, 1.0, 0.3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static double[] add(final double[] array, final int index, final double element) {\n        return (double[]) ArrayUtils.add(array, index, new Double(element), Double.TYPE);\n    }\n\n    /**\n     * Underlying implementation of add(array, index, element) methods.\n     * The last parameter is the class, which may not equal element.getClass\n     * for primitives.\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @param clss the type of the element being added\n     * @return A new array containing the existing elements and the new element\n     */\n    private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {\n        if (array == null) {\n            if (index != 0) {\n                throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n            }\n            Object joinedArray = Array.newInstance(clss, 1);\n            Array.set(joinedArray, 0, element);\n            return joinedArray;\n        }\n        int length = Array.getLength(array);\n        if (index > length || index < 0) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n        }\n        Object result = Array.newInstance(clss, length + 1);\n        System.arraycopy(array, 0, result, 0, index);\n        Array.set(result, index, element);\n        if (index < length) {\n            System.arraycopy(array, index, result, index + 1, length - index);\n        }\n        return result;\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([\"a\"], 0)           = []\n     * ArrayUtils.remove([\"a\", \"b\"], 0)      = [\"b\"]\n     * ArrayUtils.remove([\"a\", \"b\"], 1)      = [\"a\"]\n     * ArrayUtils.remove([\"a\", \"b\", \"c\"], 1) = [\"a\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static Object[] remove(final Object[] array, final int index) {\n        return (Object[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, \"a\")            = null\n     * ArrayUtils.removeElement([], \"a\")              = []\n     * ArrayUtils.removeElement([\"a\"], \"b\")           = [\"a\"]\n     * ArrayUtils.removeElement([\"a\", \"b\"], \"a\")      = [\"b\"]\n     * ArrayUtils.removeElement([\"a\", \"b\", \"a\"], \"a\") = [\"b\", \"a\"]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static Object[] removeElement(final Object[] array, final Object element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([true], 0)              = []\n     * ArrayUtils.remove([true, false], 0)       = [false]\n     * ArrayUtils.remove([true, false], 1)       = [true]\n     * ArrayUtils.remove([true, true, false], 1) = [true, false]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static boolean[] remove(final boolean[] array, final int index) {\n        return (boolean[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, true)                = null\n     * ArrayUtils.removeElement([], true)                  = []\n     * ArrayUtils.removeElement([true], false)             = [true]\n     * ArrayUtils.removeElement([true, false], false)      = [true]\n     * ArrayUtils.removeElement([true, false, true], true) = [false, true]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static boolean[] removeElement(final boolean[] array, final boolean element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)          = []\n     * ArrayUtils.remove([1, 0], 0)       = [0]\n     * ArrayUtils.remove([1, 0], 1)       = [1]\n     * ArrayUtils.remove([1, 0, 1], 1)    = [1, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static byte[] remove(final byte[] array, final int index) {\n        return (byte[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)        = null\n     * ArrayUtils.removeElement([], 1)          = []\n     * ArrayUtils.removeElement([1], 0)         = [1]\n     * ArrayUtils.removeElement([1, 0], 0)      = [1]\n     * ArrayUtils.removeElement([1, 0, 1], 1)   = [0, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static byte[] removeElement(final byte[] array, final byte element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove(['a'], 0)           = []\n     * ArrayUtils.remove(['a', 'b'], 0)      = ['b']\n     * ArrayUtils.remove(['a', 'b'], 1)      = ['a']\n     * ArrayUtils.remove(['a', 'b', 'c'], 1) = ['a', 'c']\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static char[] remove(final char[] array, final int index) {\n        return (char[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 'a')            = null\n     * ArrayUtils.removeElement([], 'a')              = []\n     * ArrayUtils.removeElement(['a'], 'b')           = ['a']\n     * ArrayUtils.removeElement(['a', 'b'], 'a')      = ['b']\n     * ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static char[] removeElement(final char[] array, final char element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1.1], 0)           = []\n     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static double[] remove(final double[] array, final int index) {\n        return (double[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1.1)            = null\n     * ArrayUtils.removeElement([], 1.1)              = []\n     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static double[] removeElement(final double[] array, final double element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1.1], 0)           = []\n     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static float[] remove(final float[] array, final int index) {\n        return (float[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1.1)            = null\n     * ArrayUtils.removeElement([], 1.1)              = []\n     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static float[] removeElement(final float[] array, final float element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static int[] remove(final int[] array, final int index) {\n        return (int[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static int[] removeElement(final int[] array, final int element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static long[] remove(final long[] array, final int index) {\n        return (long[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static long[] removeElement(final long[] array, final long element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static short[] remove(final short[] array, final int index) {\n        return (short[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static short[] removeElement(final short[] array, final short element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    private static Object remove(final Object array, final int index) {\n        int length = ArrayUtils.getLength(array);\n        if (index < 0 || index >= length) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n        }\n        Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);\n        System.arraycopy(array, 0, result, 0, index);\n        if (index < length - 1) {\n            System.arraycopy(array, index + 1, result, index, length - index - 1);\n        }\n        return result;\n    }\n\n    /**删除数组中空元素*/\n    public static Object[] clearNull(final Object[] arr) {\n        ArrayList<Object> list = new ArrayList<Object>();\n        if (arr != null) {\n            for (Object item : arr) {\n                if (item != null) {\n                    list.add(item);\n                }\n            }\n        }\n        return list.toArray();\n    }\n}\n",
      "file_name": "ArrayUtils.java",
      "human_label": "Return an EMPTY_BYTE_OBJECT_ARRAY array for a null or empty input array.",
      "level": "self_contained",
      "lineno": "599",
      "name": "nullToEmpty",
      "oracle_context": "{ \"apis\" : \"[ArrayUtils]\", \"classes\" : \"[ArrayUtils]\", \"vars\" : \"[length, EMPTY_BYTE_OBJECT_ARRAY]\" }",
      "package": "net.hasor.utils",
      "project": "hasor-master"
    },
    {
      "_id": "6367677f1a6d9265ec018347",
      "all_context": "{ \"class_level\" : \"import org.apache.log4j.AppenderSkeleton;\\nimport org.apache.log4j.helpers.LogLog;\\nimport org.apache.log4j.spi.LoggingEvent;\\nimport java.io.IOException;\\nimport java.io.PrintWriter;\\nimport java.io.InterruptedIOException;\\nimport java.net.ServerSocket;\\nimport java.net.Socket;\\nimport java.util.Enumeration;\\nimport java.util.Iterator;\\nimport java.util.Vector;\\nSocketHandler sh;\\nint port;\\nVector writers;\\nVector connections;\\nServerSocket serverSocket;\\nint MAX_CONNECTIONS;\\nactivateOptions();\\ngetPort();\\nsetPort(int port);\\nclose();\\nappend(LoggingEvent event);\\nfinalize();\\nsend(String message);\\nrun();\\nSocketHandler(int port);\\nrequiresLayout();\\n\", \"repo_level\" : \"public interface AppenderSkeleton {public void activateOptions();\\npublic void addFilter(Filter newFilter);\\nprotected void append(LoggingEvent event);\\npublic void clearFilters();\\npublic void finalize();\\npublic ErrorHandler getErrorHandler();\\npublic Filter getFilter();\\nfinal Filter getFirstFilter();\\npublic Layout getLayout();\\nfinal String getName();\\npublic Priority getThreshold();\\npublic boolean isAsSevereAsThreshold(Priority priority);\\nsynchronized void doAppend(LoggingEvent event);\\nsynchronized void setErrorHandler(ErrorHandler eh);\\npublic void setLayout(Layout layout);\\npublic void setName(String name);\\npublic void setThreshold(Priority threshold);\\n }\\npublic interface LogLog {public void setInternalDebugging(boolean enabled);\\nstatic void debug(String msg);\\nstatic void debug(String msg,Throwable t);\\nstatic void error(String msg);\\nstatic void error(String msg,Throwable t);\\nstatic void setQuietMode(boolean quietMode);\\nstatic void warn(String msg);\\nstatic void warn(String msg,Throwable t);\\n }\\npublic interface LoggingEvent {public LocationInfo getLocationInformation();\\npublic Level getLevel();\\npublic String getLoggerName();\\npublic Category getLogger();\\npublic Object getMessage();\\npublic String getNDC();\\npublic Object getMDC(String key);\\npublic void getMDCCopy();\\npublic String getRenderedMessage();\\nstatic long getStartTime();\\npublic String getThreadName();\\npublic ThrowableInformation getThrowableInformation();\\npublic String[] getThrowableStrRep();\\nfinal void setProperty(String propName,String propValue);\\nfinal String getProperty(String key);\\nfinal boolean locationInformationExists();\\nfinal long getTimeStamp();\\npublic Set getPropertyKeySet();\\npublic Map getProperties();\\npublic String getFQNOfLoggerClass();\\npublic Object removeProperty(String propName);\\n }\\n\" }",
      "class_name": "TelnetAppender",
      "code": "public synchronized void send(final String message){\n  Iterator ce=connections.iterator();\n  for (Iterator e=writers.iterator(); e.hasNext(); ) {\n    ce.next();\n    PrintWriter writer=(PrintWriter)e.next();\n    writer.print(message);\n    if (writer.checkError()) {\n      ce.remove();\n      e.remove();\n    }\n  }\n}\n",
      "docstring": "/** \n * sends a message to each of the clients in telnet-friendly output. \n */\n",
      "end_lineno": "187",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j.net;\n\nimport org.apache.log4j.AppenderSkeleton;\nimport org.apache.log4j.helpers.LogLog;\nimport org.apache.log4j.spi.LoggingEvent;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.InterruptedIOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.Vector;\n\n/**\n  <p>The TelnetAppender is a log4j appender that specializes in\n  writing to a read-only socket.  The output is provided in a\n  telnet-friendly way so that a log can be monitored over TCP/IP.\n  Clients using telnet connect to the socket and receive log data.\n  This is handy for remote monitoring, especially when monitoring a\n  servlet.\n\n  <p>Here is a list of the available configuration options:\n\n  <table border=1>\n   <tr>\n   <th>Name</th>\n   <th>Requirement</th>\n   <th>Description</th>\n   <th>Sample Value</th>\n   </tr>\n\n   <tr>\n   <td>Port</td>\n   <td>optional</td>\n   <td>This parameter determines the port to use for announcing log events.  The default port is 23 (telnet).</td>\n   <td>5875</td>\n   </table>\n\n   @author <a HREF=\"mailto:jay@v-wave.com\">Jay Funnell</a>\n*/\n\npublic class TelnetAppender extends AppenderSkeleton {\n\n  private SocketHandler sh;\n  private int port = 23;\n\n  /** \n      This appender requires a layout to format the text to the\n      attached client(s). */\n  public boolean requiresLayout() {\n    return true;\n  }\n\n  /** all of the options have been set, create the socket handler and\n      wait for connections. */\n  public void activateOptions() {\n    try {\n      sh = new SocketHandler(port);\n      sh.start();\n    }\n    catch(InterruptedIOException e) {\n      Thread.currentThread().interrupt();\n      e.printStackTrace();\n    } catch(IOException e) {\n      e.printStackTrace();\n    } catch(RuntimeException e) {\n      e.printStackTrace();\n    }\n    super.activateOptions();\n  }\n\n  public\n  int getPort() {\n    return port;\n  }\n\n  public\n  void setPort(int port) {\n    this.port = port;\n  }\n\n\n  /** shuts down the appender. */\n  public void close() {\n    if (sh != null) {\n        sh.close();\n        try {\n            sh.join();\n        } catch(InterruptedException ex) {\n            Thread.currentThread().interrupt();\n        }\n    }\n  }\n\n  /** Handles a log event.  For this appender, that means writing the\n    message to each connected client.  */\n  protected void append(LoggingEvent event) {\n      if(sh != null) {\n        sh.send(layout.format(event));\n        if(layout.ignoresThrowable()) {\n            String[] s = event.getThrowableStrRep();\n            if (s != null) {\n                StringBuffer buf = new StringBuffer();\n                for(int i = 0; i < s.length; i++) {\n                    buf.append(s[i]);\n                    buf.append(\"\\r\\n\");\n                }\n                sh.send(buf.toString());\n            }\n        }\n      }\n  }\n\n  //---------------------------------------------------------- SocketHandler:\n\n  /** The SocketHandler class is used to accept connections from\n      clients.  It is threaded so that clients can connect/disconnect\n      asynchronously. */\n  protected class SocketHandler extends Thread {\n\n    private Vector writers = new Vector();\n    private Vector connections = new Vector();\n    private ServerSocket serverSocket;\n    private int MAX_CONNECTIONS = 20;\n\n    public void finalize() {\n        close();\n    }\n      \n    /** \n    * make sure we close all network connections when this handler is destroyed.\n    * @since 1.2.15 \n    */\n    public void close() {\n      synchronized(this) {\n        for(Enumeration e = connections.elements();e.hasMoreElements();) {\n            try {\n                ((Socket)e.nextElement()).close();\n            } catch(InterruptedIOException ex) {\n                Thread.currentThread().interrupt();\n            } catch(IOException ex) {\n            } catch(RuntimeException ex) {\n            }\n        }\n      }\n\n      try {\n        serverSocket.close();\n      } catch(InterruptedIOException ex) {\n          Thread.currentThread().interrupt();\n      } catch(IOException ex) {\n      } catch(RuntimeException ex) {\n      }\n    }\n\n    /** sends a message to each of the clients in telnet-friendly output. */\n    public synchronized void send(final String message) {\n      Iterator ce = connections.iterator();\n      for(Iterator e = writers.iterator();e.hasNext();) {\n        ce.next();\n        PrintWriter writer = (PrintWriter)e.next();\n        writer.print(message);\n        if(writer.checkError()) {\n          ce.remove();\n          e.remove();\n        }\n      }\n    }\n\n    /** \n\tContinually accepts client connections.  Client connections\n        are refused when MAX_CONNECTIONS is reached. \n    */\n    public void run() {\n      while(!serverSocket.isClosed()) {\n        try {\n          Socket newClient = serverSocket.accept();\n          PrintWriter pw = new PrintWriter(newClient.getOutputStream());\n          if(connections.size() < MAX_CONNECTIONS) {\n            synchronized(this) {\n                connections.addElement(newClient);\n                writers.addElement(pw);\n                pw.print(\"TelnetAppender v1.0 (\" + connections.size()\n\t\t            + \" active connections)\\r\\n\\r\\n\");\n                pw.flush();\n            }\n          } else {\n            pw.print(\"Too many connections.\\r\\n\");\n            pw.flush();\n            newClient.close();\n          }\n        } catch(Exception e) {\n          if (e instanceof InterruptedIOException || e instanceof InterruptedException) {\n              Thread.currentThread().interrupt();\n          }\n          if (!serverSocket.isClosed()) {\n            LogLog.error(\"Encountered error while in SocketHandler loop.\", e);\n          }\n          break;\n        }\n      }\n\n      try {\n          serverSocket.close();\n      } catch(InterruptedIOException ex) {\n          Thread.currentThread().interrupt();\n      } catch(IOException ex) {\n      }\n    }\n\n    public SocketHandler(int port) throws IOException {\n      serverSocket = new ServerSocket(port);\n      setName(\"TelnetAppender-\" + getName() + \"-\" + port);\n    }\n\n  }\n}\n",
      "file_name": "TelnetAppender.java",
      "human_label": "Send a message to each of the connections in telnet-friendly output. ",
      "level": "class_runnable",
      "lineno": "175",
      "name": "send",
      "oracle_context": "{ \"apis\" : \"[iterator, hasNext, next, print, checkError, remove]\", \"classes\" : \"[Iterator, PrintWriter]\", \"vars\" : \"[connections, writers]\" }",
      "package": "org.apache.log4j.net",
      "project": "logging-log4j1-main"
    },
    {
      "_id": "6367670a1a6d9265ec0179e8",
      "all_context": "{ \"class_level\" : \"import java.lang.reflect.Array;\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.Map.Entry;\\nObject[] EMPTY_OBJECT_ARRAY;\\nClass<?>[] EMPTY_CLASS_ARRAY;\\nString[] EMPTY_STRING_ARRAY;\\nlong[] EMPTY_LONG_ARRAY;\\nLong[] EMPTY_LONG_OBJECT_ARRAY;\\nint[] EMPTY_INT_ARRAY;\\nInteger[] EMPTY_INTEGER_OBJECT_ARRAY;\\nshort[] EMPTY_SHORT_ARRAY;\\nShort[] EMPTY_SHORT_OBJECT_ARRAY;\\nbyte[] EMPTY_BYTE_ARRAY;\\nByte[] EMPTY_BYTE_OBJECT_ARRAY;\\ndouble[] EMPTY_DOUBLE_ARRAY;\\nDouble[] EMPTY_DOUBLE_OBJECT_ARRAY;\\nfloat[] EMPTY_FLOAT_ARRAY;\\nFloat[] EMPTY_FLOAT_OBJECT_ARRAY;\\nboolean[] EMPTY_BOOLEAN_ARRAY;\\nBoolean[] EMPTY_BOOLEAN_OBJECT_ARRAY;\\nchar[] EMPTY_CHAR_ARRAY;\\nCharacter[] EMPTY_CHARACTER_OBJECT_ARRAY;\\nint INDEX_NOT_FOUND;\\nArrayUtils();\\nclone(Object[] array);\\nclone(long[] array);\\nclone(int[] array);\\nclone(short[] array);\\nclone(char[] array);\\nclone(byte[] array);\\nclone(double[] array);\\nclone(float[] array);\\nclone(boolean[] array);\\nclone(String[] array);\\nnullToEmpty(Object[] array);\\nnullToEmpty(String[] array);\\nnullToEmpty(long[] array);\\nnullToEmpty(int[] array);\\nnullToEmpty(short[] array);\\nnullToEmpty(char[] array);\\nnullToEmpty(byte[] array);\\nnullToEmpty(double[] array);\\nnullToEmpty(float[] array);\\nnullToEmpty(boolean[] array);\\nnullToEmpty(Long[] array);\\nnullToEmpty(Integer[] array);\\nnullToEmpty(Short[] array);\\nnullToEmpty(Character[] array);\\nnullToEmpty(Byte[] array);\\nnullToEmpty(Double[] array);\\nnullToEmpty(Float[] array);\\nnullToEmpty(Boolean[] array);\\nsubarray(Object[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(long[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(int[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(short[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(char[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(byte[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(double[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(float[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(boolean[] array,int startIndexInclusive,int endIndexExclusive);\\nisSameLength(Object[] array1,Object[] array2);\\nisSameLength(long[] array1,long[] array2);\\nisSameLength(int[] array1,int[] array2);\\nisSameLength(short[] array1,short[] array2);\\nisSameLength(char[] array1,char[] array2);\\nisSameLength(byte[] array1,byte[] array2);\\nisSameLength(double[] array1,double[] array2);\\nisSameLength(float[] array1,float[] array2);\\nisSameLength(boolean[] array1,boolean[] array2);\\ngetLength(Object array);\\nisSameType(Object array1,Object array2);\\nreverse(Object[] array);\\nreverse(long[] array);\\nreverse(int[] array);\\nreverse(short[] array);\\nreverse(char[] array);\\nreverse(byte[] array);\\nreverse(double[] array);\\nreverse(float[] array);\\nreverse(boolean[] array);\\nindexOf(Object[] array,Object objectToFind);\\nindexOf(Object[] array,Object objectToFind,int startIndex);\\nlastIndexOf(Object[] array,Object objectToFind);\\nlastIndexOf(Object[] array,Object objectToFind,int startIndex);\\ncontains(Object[] array,Object objectToFind);\\nindexOf(long[] array,long valueToFind);\\nindexOf(long[] array,long valueToFind,int startIndex);\\nlastIndexOf(long[] array,long valueToFind);\\nlastIndexOf(long[] array,long valueToFind,int startIndex);\\ncontains(long[] array,long valueToFind);\\nindexOf(int[] array,int valueToFind);\\nindexOf(int[] array,int valueToFind,int startIndex);\\nlastIndexOf(int[] array,int valueToFind);\\nlastIndexOf(int[] array,int valueToFind,int startIndex);\\ncontains(int[] array,int valueToFind);\\nindexOf(short[] array,short valueToFind);\\nindexOf(short[] array,short valueToFind,int startIndex);\\nlastIndexOf(short[] array,short valueToFind);\\nlastIndexOf(short[] array,short valueToFind,int startIndex);\\ncontains(short[] array,short valueToFind);\\nindexOf(char[] array,char valueToFind);\\nindexOf(char[] array,char valueToFind,int startIndex);\\nlastIndexOf(char[] array,char valueToFind);\\nlastIndexOf(char[] array,char valueToFind,int startIndex);\\ncontains(char[] array,char valueToFind);\\nindexOf(byte[] array,byte valueToFind);\\nindexOf(byte[] array,byte valueToFind,int startIndex);\\nlastIndexOf(byte[] array,byte valueToFind);\\nlastIndexOf(byte[] array,byte valueToFind,int startIndex);\\ncontains(byte[] array,byte valueToFind);\\nindexOf(double[] array,double valueToFind);\\nindexOf(double[] array,double valueToFind,double tolerance);\\nindexOf(double[] array,double valueToFind,int startIndex);\\nindexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\nlastIndexOf(double[] array,double valueToFind);\\nlastIndexOf(double[] array,double valueToFind,double tolerance);\\nlastIndexOf(double[] array,double valueToFind,int startIndex);\\nlastIndexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\ncontains(double[] array,double valueToFind);\\ncontains(double[] array,double valueToFind,double tolerance);\\nindexOf(float[] array,float valueToFind);\\nindexOf(float[] array,float valueToFind,int startIndex);\\nlastIndexOf(float[] array,float valueToFind);\\nlastIndexOf(float[] array,float valueToFind,int startIndex);\\ncontains(float[] array,float valueToFind);\\nindexOf(boolean[] array,boolean valueToFind);\\nindexOf(boolean[] array,boolean valueToFind,int startIndex);\\nlastIndexOf(boolean[] array,boolean valueToFind);\\nlastIndexOf(boolean[] array,boolean valueToFind,int startIndex);\\ncontains(boolean[] array,boolean valueToFind);\\ntoPrimitive(Character[] array);\\ntoPrimitive(Character[] array,char valueForNull);\\ntoObject(char[] array);\\ntoPrimitive(Long[] array);\\ntoPrimitive(Long[] array,long valueForNull);\\ntoObject(long[] array);\\ntoPrimitive(Integer[] array);\\ntoPrimitive(Integer[] array,int valueForNull);\\ntoObject(int[] array);\\ntoPrimitive(Short[] array);\\ntoPrimitive(Short[] array,short valueForNull);\\ntoObject(short[] array);\\ntoPrimitive(Byte[] array);\\ntoPrimitive(Byte[] array,byte valueForNull);\\ntoObject(byte[] array);\\ntoPrimitive(Double[] array);\\ntoPrimitive(Double[] array,double valueForNull);\\ntoObject(double[] array);\\ntoPrimitive(Float[] array);\\ntoPrimitive(Float[] array,float valueForNull);\\ntoObject(float[] array);\\ntoPrimitive(Boolean[] array);\\ntoPrimitive(Boolean[] array,boolean valueForNull);\\ntoObject(boolean[] array);\\nisEmpty(Object[] array);\\nisEmpty(long[] array);\\nisEmpty(int[] array);\\nisEmpty(short[] array);\\nisEmpty(char[] array);\\nisEmpty(byte[] array);\\nisEmpty(double[] array);\\nisEmpty(float[] array);\\nisEmpty(boolean[] array);\\nisNotEmpty(Object[] array);\\nisNotEmpty(long[] array);\\nisNotEmpty(int[] array);\\nisNotEmpty(short[] array);\\nisNotEmpty(char[] array);\\nisNotEmpty(byte[] array);\\nisNotEmpty(double[] array);\\nisNotEmpty(float[] array);\\nisNotEmpty(boolean[] array);\\naddAll(Object[] array1,Object[] array2);\\naddAll(boolean[] array1,boolean[] array2);\\naddAll(char[] array1,char[] array2);\\naddAll(byte[] array1,byte[] array2);\\naddAll(short[] array1,short[] array2);\\naddAll(int[] array1,int[] array2);\\naddAll(long[] array1,long[] array2);\\naddAll(float[] array1,float[] array2);\\naddAll(double[] array1,double[] array2);\\naddAll(String[] array1,String[] array2);\\nadd(T[] array,T element);\\nadd(boolean[] array,boolean element);\\nadd(byte[] array,byte element);\\nadd(char[] array,char element);\\nadd(double[] array,double element);\\nadd(float[] array,float element);\\nadd(int[] array,int element);\\nadd(long[] array,long element);\\nadd(short[] array,short element);\\ncopyArrayGrow1(Object array,Class newArrayComponentType);\\nadd(Object[] array,int index,Object element);\\nadd(boolean[] array,int index,boolean element);\\nadd(char[] array,int index,char element);\\nadd(byte[] array,int index,byte element);\\nadd(short[] array,int index,short element);\\nadd(int[] array,int index,int element);\\nadd(long[] array,int index,long element);\\nadd(float[] array,int index,float element);\\nadd(double[] array,int index,double element);\\nadd(Object array,int index,Object element,Class clss);\\nremove(Object[] array,int index);\\nremoveElement(Object[] array,Object element);\\nremove(boolean[] array,int index);\\nremoveElement(boolean[] array,boolean element);\\nremove(byte[] array,int index);\\nremoveElement(byte[] array,byte element);\\nremove(char[] array,int index);\\nremoveElement(char[] array,char element);\\nremove(double[] array,int index);\\nremoveElement(double[] array,double element);\\nremove(float[] array,int index);\\nremoveElement(float[] array,float element);\\nremove(int[] array,int index);\\nremoveElement(int[] array,int element);\\nremove(long[] array,int index);\\nremoveElement(long[] array,long element);\\nremove(short[] array,int index);\\nremoveElement(short[] array,short element);\\nremove(Object array,int index);\\nclearNull(Object[] arr);\\ntoMap(Object[] array);\\n\", \"repo_level\" : \"\" }",
      "class_name": "ArrayUtils",
      "code": "public static Boolean[] nullToEmpty(final Boolean[] array){\n  if (array == null || array.length == 0) {\n    return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}\n",
      "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n",
      "end_lineno": "677",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils;\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * <p>Operations on arrays, primitive arrays (like <code>int[]</code>) and\n * primitive wrapper arrays (like <code>Integer[]</code>).</p>\n *\n * <p>This class tries to handle <code>null</code> input gracefully.\n * An exception will not be thrown for a <code>null</code>\n * array input. However, an Object array that contains a <code>null</code>\n * element may throw an exception. Each method documents its behaviour.</p>\n *\n * <p>#ThreadSafe#</p>\n * @author Apache Software Foundation\n * @author Moritz Petersen\n * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n * @author Nikolay Metchev\n * @author Matthew Hawthorne\n * @author Tim O'Brien\n * @author Pete Gieser\n * @author Gary Gregory\n * @author <a href=\"mailto:equinus100@hotmail.com\">Ashwin S</a>\n * @author Maarten Coene\n * @since 2.0\n * @version $Id: ArrayUtils.java 1056988 2011-01-09 17:58:53Z niallp $\n */\npublic class ArrayUtils {\n    /** An empty immutable <code>Object</code> array. */\n    public static final Object[]    EMPTY_OBJECT_ARRAY           = new Object[0];\n    /** An empty immutable <code>Class</code> array. */\n    public static final Class<?>[]  EMPTY_CLASS_ARRAY            = new Class[0];\n    /** An empty immutable <code>String</code> array. */\n    public static final String[]    EMPTY_STRING_ARRAY           = new String[0];\n    /** An empty immutable <code>long</code> array. */\n    public static final long[]      EMPTY_LONG_ARRAY             = new long[0];\n    /** An empty immutable <code>Long</code> array. */\n    public static final Long[]      EMPTY_LONG_OBJECT_ARRAY      = new Long[0];\n    /** An empty immutable <code>int</code> array. */\n    public static final int[]       EMPTY_INT_ARRAY              = new int[0];\n    /** An empty immutable <code>Integer</code> array. */\n    public static final Integer[]   EMPTY_INTEGER_OBJECT_ARRAY   = new Integer[0];\n    /** An empty immutable <code>short</code> array. */\n    public static final short[]     EMPTY_SHORT_ARRAY            = new short[0];\n    /** An empty immutable <code>Short</code> array. */\n    public static final Short[]     EMPTY_SHORT_OBJECT_ARRAY     = new Short[0];\n    /** An empty immutable <code>byte</code> array. */\n    public static final byte[]      EMPTY_BYTE_ARRAY             = new byte[0];\n    /** An empty immutable <code>Byte</code> array. */\n    public static final Byte[]      EMPTY_BYTE_OBJECT_ARRAY      = new Byte[0];\n    /** An empty immutable <code>double</code> array. */\n    public static final double[]    EMPTY_DOUBLE_ARRAY           = new double[0];\n    /** An empty immutable <code>Double</code> array. */\n    public static final Double[]    EMPTY_DOUBLE_OBJECT_ARRAY    = new Double[0];\n    /** An empty immutable <code>float</code> array. */\n    public static final float[]     EMPTY_FLOAT_ARRAY            = new float[0];\n    /** An empty immutable <code>Float</code> array. */\n    public static final Float[]     EMPTY_FLOAT_OBJECT_ARRAY     = new Float[0];\n    /** An empty immutable <code>boolean</code> array. */\n    public static final boolean[]   EMPTY_BOOLEAN_ARRAY          = new boolean[0];\n    /** An empty immutable <code>Boolean</code> array. */\n    public static final Boolean[]   EMPTY_BOOLEAN_OBJECT_ARRAY   = new Boolean[0];\n    /** An empty immutable <code>char</code> array. */\n    public static final char[]      EMPTY_CHAR_ARRAY             = new char[0];\n    /** An empty immutable <code>Character</code> array. */\n    public static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n    /**\n     * The index value when an element is not found in a list or array: <code>-1</code>.\n     * This value is returned by methods in this class and can also be used in comparisons with values returned by\n     * various method from {@link java.util.List}.\n     */\n    public static final int         INDEX_NOT_FOUND              = -1;\n\n    /**\n     * <p>ArrayUtils instances should NOT be constructed in standard programming.\n     * Instead, the class should be used as <code>ArrayUtils.clone(new int[] {2})</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     */\n    public ArrayUtils() {\n        super();\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts the given array into a {@link Map}. Each element of the array\n     * must be either a {@link Entry} or an Array, containing at least two\n     * elements, where the first element is used as key and the second as\n     * value.</p>\n     *\n     * <p>This method can be used to initialize:</p>\n     * <pre>\n     * // Create a Map mapping colors.\n     * Map colorMap = ArrayUtils.toMap(new String[][] {{\n     *     {\"RED\", \"#FF0000\"},\n     *     {\"GREEN\", \"#00FF00\"},\n     *     {\"BLUE\", \"#0000FF\"}});\n     * </pre>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  an array whose elements are either a {@link Entry} or\n     *  an Array containing at least two elements, may be <code>null</code>\n     * @return a <code>Map</code> that was created from the array\n     * @throws IllegalArgumentException  if one element of this Array is\n     *  itself an Array containing less then two elements\n     * @throws IllegalArgumentException  if the array contains elements other\n     *  than {@link Entry} and an Array\n     */\n    public static Map toMap(final Object[] array) {\n        if (array == null) {\n            return null;\n        }\n        final Map map = new HashMap((int) (array.length * 1.5));\n        for (int i = 0; i < array.length; i++) {\n            Object object = array[i];\n            if (object instanceof Entry) {\n                Entry entry = (Entry) object;\n                map.put(entry.getKey(), entry.getValue());\n            } else if (object instanceof Object[]) {\n                Object[] entry = (Object[]) object;\n                if (entry.length < 2) {\n                    throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', has a length less than 2\");\n                }\n                map.put(entry[0], entry[1]);\n            } else {\n                throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', is neither of type Map.Entry nor an Array\");\n            }\n        }\n        return map;\n    }\n    // Clone\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Shallow clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>The objects in the array are not cloned, thus there is no special\n     * handling for multi-dimensional arrays.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to shallow clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static Object[] clone(final Object[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static long[] clone(final long[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static int[] clone(final int[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static short[] clone(final short[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static char[] clone(final char[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static byte[] clone(final byte[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static double[] clone(final double[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static float[] clone(final float[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static boolean[] clone(final boolean[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static String[] clone(final String[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n    // nullToEmpty\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Object[] nullToEmpty(final Object[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static String[] nullToEmpty(final String[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static long[] nullToEmpty(final long[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static int[] nullToEmpty(final int[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static short[] nullToEmpty(final short[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static char[] nullToEmpty(final char[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static byte[] nullToEmpty(final byte[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static double[] nullToEmpty(final double[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static float[] nullToEmpty(final float[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static boolean[] nullToEmpty(final boolean[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Long[] nullToEmpty(final Long[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Integer[] nullToEmpty(final Integer[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Short[] nullToEmpty(final Short[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Character[] nullToEmpty(final Character[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Byte[] nullToEmpty(final Byte[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Double[] nullToEmpty(final Double[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Float[] nullToEmpty(final Float[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Boolean[] nullToEmpty(final Boolean[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;\n        }\n        return array;\n    }\n    // Subarrays\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Produces a new array containing the elements between\n     * the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * <p>The component type of the subarray is always the same as\n     * that of the input array. Thus, if the input is an array of type\n     * <code>Date</code>, the following usage is envisaged:</p>\n     *\n     * <pre>\n     * Date[] someDates = (Date[])ArrayUtils.subarray(allDates, 2, 5);\n     * </pre>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static Object[] subarray(final Object[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        Class<?> type = array.getClass().getComponentType();\n        if (newSize <= 0) {\n            return (Object[]) Array.newInstance(type, 0);\n        }\n        Object[] subarray = (Object[]) Array.newInstance(type, newSize);\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>long</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        long[] subarray = new long[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>int</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        int[] subarray = new int[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>short</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        short[] subarray = new short[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>char</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        char[] subarray = new char[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>byte</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        byte[] subarray = new byte[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>double</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] subarray = new double[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>float</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        float[] subarray = new float[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>boolean</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        boolean[] subarray = new boolean[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n    // Is same length\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.\n     *\n     * <p>Any multi-dimensional aspects of the arrays are ignored.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final Object[] array1, final Object[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final long[] array1, final long[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final int[] array1, final int[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final short[] array1, final short[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final char[] array1, final char[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final double[] array1, final double[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final float[] array1, final float[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Returns the length of the specified array.\n     * This method can deal with <code>Object</code> arrays and with primitive arrays.</p>\n     *\n     * <p>If the input array is <code>null</code>, <code>0</code> is returned.</p>\n     *\n     * <pre>\n     * ArrayUtils.getLength(null)            = 0\n     * ArrayUtils.getLength([])              = 0\n     * ArrayUtils.getLength([null])          = 1\n     * ArrayUtils.getLength([true, false])   = 2\n     * ArrayUtils.getLength([1, 2, 3])       = 3\n     * ArrayUtils.getLength([\"a\", \"b\", \"c\"]) = 3\n     * </pre>\n     *\n     * @param array  the array to retrieve the length from, may be null\n     * @return The length of the array, or <code>0</code> if the array is <code>null</code>\n     * @throws IllegalArgumentException if the object arguement is not an array.\n     * @since 2.1\n     */\n    public static int getLength(final Object array) {\n        if (array == null) {\n            return 0;\n        }\n        return Array.getLength(array);\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same type taking into account\n     * multi-dimensional arrays.</p>\n     *\n     * @param array1 the first array, must not be <code>null</code>\n     * @param array2 the second array, must not be <code>null</code>\n     * @return <code>true</code> if type of arrays matches\n     * @throws IllegalArgumentException if either array is <code>null</code>\n     */\n    public static boolean isSameType(final Object array1, final Object array2) {\n        if (array1 == null || array2 == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        return array1.getClass().getName().equals(array2.getClass().getName());\n    }\n    // Reverse\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>There is no special handling for multi-dimensional arrays.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final Object[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        Object tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final long[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        long tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final int[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        int tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final short[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        short tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final char[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        char tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final byte[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        byte tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final double[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        double tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final float[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        float tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final boolean[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        boolean tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n    // IndexOf search\n    // ----------------------------------------------------------------------\n    // Object IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given object in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @return the index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final Object[] array, final Object objectToFind) {\n        return ArrayUtils.indexOf(array, objectToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given object in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @param startIndex  the index to start searching at\n     * @return the index of the object within the array starting at the index,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given object within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @return the last index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final Object[] array, final Object objectToFind) {\n        return ArrayUtils.lastIndexOf(array, objectToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given object in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n     * the array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i >= 0; i--) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n            for (int i = startIndex; i >= 0; i--) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the object is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param objectToFind  the object to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final Object[] array, final Object objectToFind) {\n        return ArrayUtils.indexOf(array, objectToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // long IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final long[] array, final long valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final long[] array, final long valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final long[] array, final long valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final long[] array, final long valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // int IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final int[] array, final int valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final int[] array, final int valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final int[] array, final int valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final int[] array, final int valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // short IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final short[] array, final short valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final short[] array, final short valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final short[] array, final short valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final short[] array, final short valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final short[] array, final short valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // char IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int indexOf(final char[] array, final char valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int indexOf(final char[] array, final char valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int lastIndexOf(final char[] array, final char valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int lastIndexOf(final char[] array, final char valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     * @since 2.1\n     */\n    public static boolean contains(final char[] array, final char valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // byte IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final byte[] array, final byte valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final byte[] array, final byte valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final byte[] array, final byte valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // double IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value within a given tolerance in the array.\n     * This method will return the index of the first value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind, final double tolerance) {\n        return ArrayUtils.indexOf(array, valueToFind, 0, tolerance);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.\n     * This method will return the index of the first value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        double min = valueToFind - tolerance;\n        double max = valueToFind + tolerance;\n        for (int i = startIndex; i < array.length; i++) {\n            if (array[i] >= min && array[i] <= max) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value within a given tolerance in the array.\n     * This method will return the index of the last value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.\n     * This method will return the index of the last value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @param tolerance  search for value within plus/minus this amount\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        double min = valueToFind - tolerance;\n        double max = valueToFind + tolerance;\n        for (int i = startIndex; i >= 0; i--) {\n            if (array[i] >= min && array[i] <= max) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final double[] array, final double valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if a value falling within the given tolerance is in the\n     * given array.  If the array contains a value within the inclusive range\n     * defined by (value - tolerance) to (value + tolerance).</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array\n     * is passed in.</p>\n     *\n     * @param array  the array to search\n     * @param valueToFind  the value to find\n     * @param tolerance  the array contains the tolerance of the search\n     * @return true if value falling within tolerance is in array\n     */\n    public static boolean contains(final double[] array, final double valueToFind, final double tolerance) {\n        return ArrayUtils.indexOf(array, valueToFind, 0, tolerance) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // float IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final float[] array, final float valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final float[] array, final float valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final float[] array, final float valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final float[] array, final float valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // boolean IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final boolean[] array, final boolean valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code>\n     *  array input\n     */\n    public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) if\n     * <code>null</code> array input.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final boolean[] array, final boolean valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n     * the array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final boolean[] array, final boolean valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // Primitive/Object array converters\n    // ----------------------------------------------------------------------\n    // Character array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Characters to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Character</code> array, may be <code>null</code>\n     * @return a <code>char</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static char[] toPrimitive(final Character[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].charValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Character to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Character</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>char</code> array, <code>null</code> if null array input\n     */\n    public static char[] toPrimitive(final Character[] array, final char valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Character b = array[i];\n            result[i] = b == null ? valueForNull : b.charValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive chars to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array a <code>char</code> array\n     * @return a <code>Character</code> array, <code>null</code> if null array input\n     */\n    public static Character[] toObject(final char[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY;\n        }\n        final Character[] result = new Character[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Character(array[i]);\n        }\n        return result;\n    }\n    // Long array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Longs to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Long</code> array, may be <code>null</code>\n     * @return a <code>long</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static long[] toPrimitive(final Long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].longValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Long to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Long</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>long</code> array, <code>null</code> if null array input\n     */\n    public static long[] toPrimitive(final Long[] array, final long valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Long b = array[i];\n            result[i] = b == null ? valueForNull : b.longValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive longs to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>long</code> array\n     * @return a <code>Long</code> array, <code>null</code> if null array input\n     */\n    public static Long[] toObject(final long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_OBJECT_ARRAY;\n        }\n        final Long[] result = new Long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Long(array[i]);\n        }\n        return result;\n    }\n    // Int array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Integers to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Integer</code> array, may be <code>null</code>\n     * @return an <code>int</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static int[] toPrimitive(final Integer[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].intValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Integer to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Integer</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return an <code>int</code> array, <code>null</code> if null array input\n     */\n    public static int[] toPrimitive(final Integer[] array, final int valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Integer b = array[i];\n            result[i] = b == null ? valueForNull : b.intValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive ints to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  an <code>int</code> array\n     * @return an <code>Integer</code> array, <code>null</code> if null array input\n     */\n    public static Integer[] toObject(final int[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        final Integer[] result = new Integer[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Integer(array[i]);\n        }\n        return result;\n    }\n    // Short array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Shorts to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Short</code> array, may be <code>null</code>\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static short[] toPrimitive(final Short[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        final short[] result = new short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].shortValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Short to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Short</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     */\n    public static short[] toPrimitive(final Short[] array, final short valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        final short[] result = new short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Short b = array[i];\n            result[i] = b == null ? valueForNull : b.shortValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive shorts to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>short</code> array\n     * @return a <code>Short</code> array, <code>null</code> if null array input\n     */\n    public static Short[] toObject(final short[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;\n        }\n        final Short[] result = new Short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Short(array[i]);\n        }\n        return result;\n    }\n    // Byte array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Bytes to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Byte</code> array, may be <code>null</code>\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static byte[] toPrimitive(final Byte[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        final byte[] result = new byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].byteValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Bytes to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Byte</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     */\n    public static byte[] toPrimitive(final Byte[] array, final byte valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        final byte[] result = new byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Byte b = array[i];\n            result[i] = b == null ? valueForNull : b.byteValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive bytes to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>byte</code> array\n     * @return a <code>Byte</code> array, <code>null</code> if null array input\n     */\n    public static Byte[] toObject(final byte[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;\n        }\n        final Byte[] result = new Byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Byte(array[i]);\n        }\n        return result;\n    }\n    // Double array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Doubles to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Double</code> array, may be <code>null</code>\n     * @return a <code>double</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static double[] toPrimitive(final Double[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        final double[] result = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].doubleValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Doubles to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Double</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>double</code> array, <code>null</code> if null array input\n     */\n    public static double[] toPrimitive(final Double[] array, final double valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        final double[] result = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Double b = array[i];\n            result[i] = b == null ? valueForNull : b.doubleValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive doubles to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>double</code> array\n     * @return a <code>Double</code> array, <code>null</code> if null array input\n     */\n    public static Double[] toObject(final double[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;\n        }\n        final Double[] result = new Double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Double(array[i]);\n        }\n        return result;\n    }\n    //   Float array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Floats to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Float</code> array, may be <code>null</code>\n     * @return a <code>float</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static float[] toPrimitive(final Float[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        final float[] result = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].floatValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Floats to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Float</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>float</code> array, <code>null</code> if null array input\n     */\n    public static float[] toPrimitive(final Float[] array, final float valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        final float[] result = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Float b = array[i];\n            result[i] = b == null ? valueForNull : b.floatValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive floats to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>float</code> array\n     * @return a <code>Float</code> array, <code>null</code> if null array input\n     */\n    public static Float[] toObject(final float[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY;\n        }\n        final Float[] result = new Float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Float(array[i]);\n        }\n        return result;\n    }\n    // Boolean array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Booleans to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n     * @return a <code>boolean</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static boolean[] toPrimitive(final Boolean[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        final boolean[] result = new boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].booleanValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Booleans to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>boolean</code> array, <code>null</code> if null array input\n     */\n    public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        final boolean[] result = new boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Boolean b = array[i];\n            result[i] = b == null ? valueForNull : b.booleanValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive booleans to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>boolean</code> array\n     * @return a <code>Boolean</code> array, <code>null</code> if null array input\n     */\n    public static Boolean[] toObject(final boolean[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;\n        }\n        final Boolean[] result = new Boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE;\n        }\n        return result;\n    }\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if an array of Objects is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final Object[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive longs is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final long[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive ints is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final int[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive shorts is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final short[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive chars is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final char[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive bytes is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final byte[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final double[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive floats is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final float[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive booleans is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final boolean[] array) {\n        return array == null || array.length == 0;\n    }\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if an array of Objects is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final Object[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive longs is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final long[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive ints is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final int[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive shorts is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final short[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive chars is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final char[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive bytes is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final byte[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive doubles is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final double[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive floats is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final float[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive booleans is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final boolean[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(null, null)     = null\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * ArrayUtils.addAll([null], [null]) = [null, null]\n     * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array, may be <code>null</code>\n     * @param array2  the second array whose elements are added to the new array, may be <code>null</code>\n     * @return The new array, <code>null</code> if both arrays are <code>null</code>.\n     *      The type of the new array is the type of the first array,\n     *      unless the first array is null, in which case the type is the same as the second array.\n     * @since 2.1\n     * @throws IllegalArgumentException if the array types are incompatible\n     */\n    public static Object[] addAll(final Object[] array1, final Object[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        Object[] joinedArray = (Object[]) Array.newInstance(array1.getClass().getComponentType(), array1.length + array2.length);\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        try {\n            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        } catch (ArrayStoreException ase) {\n            // Check if problem was due to incompatible types\n            /*\n             * We do this here, rather than before the copy because:\n             * - it would be a wasted check most of the time\n             * - safer, in case check turns out to be too strict\n             */\n            final Class<?> type1 = array1.getClass().getComponentType();\n            final Class<?> type2 = array2.getClass().getComponentType();\n            if (!type1.isAssignableFrom(type2)) {\n                throw new IllegalArgumentException(\"Cannot store \" + type2.getName() + \" in an array of \" + type1.getName());\n            }\n            throw ase; // No, so rethrow original\n        }\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new boolean[] array.\n     * @since 2.1\n     */\n    public static boolean[] addAll(final boolean[] array1, final boolean[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        boolean[] joinedArray = new boolean[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new char[] array.\n     * @since 2.1\n     */\n    public static char[] addAll(final char[] array1, final char[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        char[] joinedArray = new char[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new byte[] array.\n     * @since 2.1\n     */\n    public static byte[] addAll(final byte[] array1, final byte[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        byte[] joinedArray = new byte[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new short[] array.\n     * @since 2.1\n     */\n    public static short[] addAll(final short[] array1, final short[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        short[] joinedArray = new short[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new int[] array.\n     * @since 2.1\n     */\n    public static int[] addAll(final int[] array1, final int[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        int[] joinedArray = new int[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new long[] array.\n     * @since 2.1\n     */\n    public static long[] addAll(final long[] array1, final long[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        long[] joinedArray = new long[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new float[] array.\n     * @since 2.1\n     */\n    public static float[] addAll(final float[] array1, final float[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        float[] joinedArray = new float[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new double[] array.\n     * @since 2.1\n     */\n    public static double[] addAll(final double[] array1, final double[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        double[] joinedArray = new double[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new String[] array.\n     * @since 2.1\n     */\n    public static String[] addAll(final String[] array1, final String[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        String[] joinedArray = new String[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element, unless the element itself is null,\n     *  in which case the return type is Object[]</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, null)      = [null]\n     * ArrayUtils.add(null, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to \"add\" the element to, may be <code>null</code>\n     * @param element  the object to add, may be <code>null</code>\n     * @return A new array containing the existing elements plus the new element\n     * The returned array type will be that of the input array (unless null),\n     * in which case it will have the same type as the element.\n     * @since 2.1\n     */\n    public static <T> T[] add(final T[] array, final T element) {\n        Class<?> type;\n        if (array != null) {\n            type = array.getClass();\n        } else if (element != null) {\n            type = element.getClass();\n        } else {\n            type = Object.class;\n        }\n        T[] newArray = (T[]) ArrayUtils.copyArrayGrow1(array, type);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, true)          = [true]\n     * ArrayUtils.add([true], false)       = [true, false]\n     * ArrayUtils.add([true, false], true) = [true, false, true]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static boolean[] add(final boolean[] array, final boolean element) {\n        boolean[] newArray = (boolean[]) ArrayUtils.copyArrayGrow1(array, Boolean.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static byte[] add(final byte[] array, final byte element) {\n        byte[] newArray = (byte[]) ArrayUtils.copyArrayGrow1(array, Byte.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, '0')       = ['0']\n     * ArrayUtils.add(['1'], '0')      = ['1', '0']\n     * ArrayUtils.add(['1', '0'], '1') = ['1', '0', '1']\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static char[] add(final char[] array, final char element) {\n        char[] newArray = (char[]) ArrayUtils.copyArrayGrow1(array, Character.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static double[] add(final double[] array, final double element) {\n        double[] newArray = (double[]) ArrayUtils.copyArrayGrow1(array, Double.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static float[] add(final float[] array, final float element) {\n        float[] newArray = (float[]) ArrayUtils.copyArrayGrow1(array, Float.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static int[] add(final int[] array, final int element) {\n        int[] newArray = (int[]) ArrayUtils.copyArrayGrow1(array, Integer.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static long[] add(final long[] array, final long element) {\n        long[] newArray = (long[]) ArrayUtils.copyArrayGrow1(array, Long.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static short[] add(final short[] array, final short element) {\n        short[] newArray = (short[]) ArrayUtils.copyArrayGrow1(array, Short.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * Returns a copy of the given array of size 1 greater than the argument.\n     * The last value of the array is left to the default value.\n     *\n     * @param array The array to copy, must not be <code>null</code>.\n     * @param newArrayComponentType If <code>array</code> is <code>null</code>, create a\n     * size 1 array of this type.\n     * @return A new copy of the array of size 1 greater than the input.\n     */\n    private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n        if (array != null) {\n            int arrayLength = Array.getLength(array);\n            Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n            System.arraycopy(array, 0, newArray, 0, arrayLength);\n            return newArray;\n        }\n        return Array.newInstance(newArrayComponentType, 1);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, null)      = [null]\n     * ArrayUtils.add(null, 0, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], 1, null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], 1, \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], 3, \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > array.length).\n     */\n    public static Object[] add(final Object[] array, final int index, final Object element) {\n        Class<?> clss = null;\n        if (array != null) {\n            clss = array.getClass().getComponentType();\n        } else if (element != null) {\n            clss = element.getClass();\n        } else {\n            return new Object[] { null };\n        }\n        return (Object[]) ArrayUtils.add(array, index, element, clss);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, true)          = [true]\n     * ArrayUtils.add([true], 0, false)       = [false, true]\n     * ArrayUtils.add([false], 1, true)       = [false, true]\n     * ArrayUtils.add([true, false], 1, true) = [true, true, false]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static boolean[] add(final boolean[] array, final int index, final boolean element) {\n        Boolean booElement = element ? Boolean.TRUE : Boolean.FALSE;\n        return (boolean[]) ArrayUtils.add(array, index, booElement, Boolean.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, 'a')            = ['a']\n     * ArrayUtils.add(['a'], 0, 'b')           = ['b', 'a']\n     * ArrayUtils.add(['a', 'b'], 0, 'c')      = ['c', 'a', 'b']\n     * ArrayUtils.add(['a', 'b'], 1, 'k')      = ['a', 'k', 'b']\n     * ArrayUtils.add(['a', 'b', 'c'], 1, 't') = ['a', 't', 'b', 'c']\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static char[] add(final char[] array, final int index, final char element) {\n        return (char[]) ArrayUtils.add(array, index, new Character(element), Character.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 3)      = [2, 6, 3]\n     * ArrayUtils.add([2, 6], 0, 1)      = [1, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static byte[] add(final byte[] array, final int index, final byte element) {\n        return (byte[]) ArrayUtils.add(array, index, new Byte(element), Byte.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static short[] add(final short[] array, final int index, final short element) {\n        return (short[]) ArrayUtils.add(array, index, new Short(element), Short.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static int[] add(final int[] array, final int index, final int element) {\n        return (int[]) ArrayUtils.add(array, index, new Integer(element), Integer.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1L], 0, 2L)           = [2L, 1L]\n     * ArrayUtils.add([2L, 6L], 2, 10L)      = [2L, 6L, 10L]\n     * ArrayUtils.add([2L, 6L], 0, -4L)      = [-4L, 2L, 6L]\n     * ArrayUtils.add([2L, 6L, 3L], 2, 1L)   = [2L, 6L, 1L, 3L]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static long[] add(final long[] array, final int index, final long element) {\n        return (long[]) ArrayUtils.add(array, index, new Long(element), Long.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1.1f], 0, 2.2f)               = [2.2f, 1.1f]\n     * ArrayUtils.add([2.3f, 6.4f], 2, 10.5f)        = [2.3f, 6.4f, 10.5f]\n     * ArrayUtils.add([2.6f, 6.7f], 0, -4.8f)        = [-4.8f, 2.6f, 6.7f]\n     * ArrayUtils.add([2.9f, 6.0f, 0.3f], 2, 1.0f)   = [2.9f, 6.0f, 1.0f, 0.3f]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static float[] add(final float[] array, final int index, final float element) {\n        return (float[]) ArrayUtils.add(array, index, new Float(element), Float.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1.1], 0, 2.2)              = [2.2, 1.1]\n     * ArrayUtils.add([2.3, 6.4], 2, 10.5)        = [2.3, 6.4, 10.5]\n     * ArrayUtils.add([2.6, 6.7], 0, -4.8)        = [-4.8, 2.6, 6.7]\n     * ArrayUtils.add([2.9, 6.0, 0.3], 2, 1.0)    = [2.9, 6.0, 1.0, 0.3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static double[] add(final double[] array, final int index, final double element) {\n        return (double[]) ArrayUtils.add(array, index, new Double(element), Double.TYPE);\n    }\n\n    /**\n     * Underlying implementation of add(array, index, element) methods.\n     * The last parameter is the class, which may not equal element.getClass\n     * for primitives.\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @param clss the type of the element being added\n     * @return A new array containing the existing elements and the new element\n     */\n    private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {\n        if (array == null) {\n            if (index != 0) {\n                throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n            }\n            Object joinedArray = Array.newInstance(clss, 1);\n            Array.set(joinedArray, 0, element);\n            return joinedArray;\n        }\n        int length = Array.getLength(array);\n        if (index > length || index < 0) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n        }\n        Object result = Array.newInstance(clss, length + 1);\n        System.arraycopy(array, 0, result, 0, index);\n        Array.set(result, index, element);\n        if (index < length) {\n            System.arraycopy(array, index, result, index + 1, length - index);\n        }\n        return result;\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([\"a\"], 0)           = []\n     * ArrayUtils.remove([\"a\", \"b\"], 0)      = [\"b\"]\n     * ArrayUtils.remove([\"a\", \"b\"], 1)      = [\"a\"]\n     * ArrayUtils.remove([\"a\", \"b\", \"c\"], 1) = [\"a\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static Object[] remove(final Object[] array, final int index) {\n        return (Object[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, \"a\")            = null\n     * ArrayUtils.removeElement([], \"a\")              = []\n     * ArrayUtils.removeElement([\"a\"], \"b\")           = [\"a\"]\n     * ArrayUtils.removeElement([\"a\", \"b\"], \"a\")      = [\"b\"]\n     * ArrayUtils.removeElement([\"a\", \"b\", \"a\"], \"a\") = [\"b\", \"a\"]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static Object[] removeElement(final Object[] array, final Object element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([true], 0)              = []\n     * ArrayUtils.remove([true, false], 0)       = [false]\n     * ArrayUtils.remove([true, false], 1)       = [true]\n     * ArrayUtils.remove([true, true, false], 1) = [true, false]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static boolean[] remove(final boolean[] array, final int index) {\n        return (boolean[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, true)                = null\n     * ArrayUtils.removeElement([], true)                  = []\n     * ArrayUtils.removeElement([true], false)             = [true]\n     * ArrayUtils.removeElement([true, false], false)      = [true]\n     * ArrayUtils.removeElement([true, false, true], true) = [false, true]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static boolean[] removeElement(final boolean[] array, final boolean element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)          = []\n     * ArrayUtils.remove([1, 0], 0)       = [0]\n     * ArrayUtils.remove([1, 0], 1)       = [1]\n     * ArrayUtils.remove([1, 0, 1], 1)    = [1, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static byte[] remove(final byte[] array, final int index) {\n        return (byte[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)        = null\n     * ArrayUtils.removeElement([], 1)          = []\n     * ArrayUtils.removeElement([1], 0)         = [1]\n     * ArrayUtils.removeElement([1, 0], 0)      = [1]\n     * ArrayUtils.removeElement([1, 0, 1], 1)   = [0, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static byte[] removeElement(final byte[] array, final byte element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove(['a'], 0)           = []\n     * ArrayUtils.remove(['a', 'b'], 0)      = ['b']\n     * ArrayUtils.remove(['a', 'b'], 1)      = ['a']\n     * ArrayUtils.remove(['a', 'b', 'c'], 1) = ['a', 'c']\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static char[] remove(final char[] array, final int index) {\n        return (char[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 'a')            = null\n     * ArrayUtils.removeElement([], 'a')              = []\n     * ArrayUtils.removeElement(['a'], 'b')           = ['a']\n     * ArrayUtils.removeElement(['a', 'b'], 'a')      = ['b']\n     * ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static char[] removeElement(final char[] array, final char element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1.1], 0)           = []\n     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static double[] remove(final double[] array, final int index) {\n        return (double[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1.1)            = null\n     * ArrayUtils.removeElement([], 1.1)              = []\n     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static double[] removeElement(final double[] array, final double element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1.1], 0)           = []\n     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static float[] remove(final float[] array, final int index) {\n        return (float[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1.1)            = null\n     * ArrayUtils.removeElement([], 1.1)              = []\n     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static float[] removeElement(final float[] array, final float element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static int[] remove(final int[] array, final int index) {\n        return (int[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static int[] removeElement(final int[] array, final int element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static long[] remove(final long[] array, final int index) {\n        return (long[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static long[] removeElement(final long[] array, final long element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static short[] remove(final short[] array, final int index) {\n        return (short[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static short[] removeElement(final short[] array, final short element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    private static Object remove(final Object array, final int index) {\n        int length = ArrayUtils.getLength(array);\n        if (index < 0 || index >= length) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n        }\n        Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);\n        System.arraycopy(array, 0, result, 0, index);\n        if (index < length - 1) {\n            System.arraycopy(array, index + 1, result, index, length - index - 1);\n        }\n        return result;\n    }\n\n    /**删除数组中空元素*/\n    public static Object[] clearNull(final Object[] arr) {\n        ArrayList<Object> list = new ArrayList<Object>();\n        if (arr != null) {\n            for (Object item : arr) {\n                if (item != null) {\n                    list.add(item);\n                }\n            }\n        }\n        return list.toArray();\n    }\n}\n",
      "file_name": "ArrayUtils.java",
      "human_label": "Return an EMPTY_BOOLEAN_OBJECT_ARRAY array for a null or empty input array.",
      "level": "self_contained",
      "lineno": "659",
      "name": "nullToEmpty",
      "oracle_context": "{ \"apis\" : \"[ArrayUtils]\", \"classes\" : \"[ArrayUtils]\", \"vars\" : \"[length, EMPTY_BOOLEAN_OBJECT_ARRAY]\" }",
      "package": "net.hasor.utils",
      "project": "hasor-master"
    },
    {
      "_id": "6367677f1a6d9265ec01834b",
      "all_context": "{ \"class_level\" : \"import org.apache.log4j.spi.LoggingEvent;\\nLoggingEvent[] buf;\\nint numElements;\\nint first;\\nint next;\\nint maxSize;\\nBoundedFIFO(int maxSize);\\nget();\\ngetMaxSize();\\nisFull();\\nlength();\\nmin(int a,int b);\\nresize(int newSize);\\nwasEmpty();\\nwasFull();\\n\", \"repo_level\" : \"public interface LoggingEvent {public LocationInfo getLocationInformation();\\npublic Level getLevel();\\npublic String getLoggerName();\\npublic Category getLogger();\\npublic Object getMessage();\\npublic String getNDC();\\npublic Object getMDC(String key);\\npublic void getMDCCopy();\\npublic String getRenderedMessage();\\nstatic long getStartTime();\\npublic String getThreadName();\\npublic ThrowableInformation getThrowableInformation();\\npublic String[] getThrowableStrRep();\\nfinal void setProperty(String propName,String propValue);\\nfinal String getProperty(String key);\\nfinal boolean locationInformationExists();\\nfinal long getTimeStamp();\\npublic Set getPropertyKeySet();\\npublic Map getProperties();\\npublic String getFQNOfLoggerClass();\\npublic Object removeProperty(String propName);\\n }\\n\" }",
      "class_name": "BoundedFIFO",
      "code": "public void put(LoggingEvent o){\n  if (numElements != maxSize) {\n    buf[next]=o;\n    if (++next == maxSize) {\n      next=0;\n    }\n    numElements++;\n  }\n}\n",
      "docstring": "/** \n * Place a  {@link LoggingEvent} in the buffer. If the buffer is fullthen the event is <b>silently dropped</b>. It is the caller's responsability to make sure that the buffer has free space.  \n */\n",
      "end_lineno": "83",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Contributors:     Mathias Bogaert\n//                   joelr@viair.com\n\npackage org.apache.log4j.helpers;\n\nimport org.apache.log4j.spi.LoggingEvent;\n\n/**\n   <code>BoundedFIFO</code> serves as the bounded first-in-first-out\n   buffer heavily used by the {@link org.apache.log4j.AsyncAppender}.\n   \n   @author Ceki G&uuml;lc&uuml; \n   @since version 0.9.1 */\npublic class BoundedFIFO {\n  \n  LoggingEvent[] buf;\n  int numElements = 0;\n  int first = 0;\n  int next = 0;\n  int maxSize;\n\n  /**\n     Instantiate a new BoundedFIFO with a maximum size passed as argument.\n   */\n  public\n  BoundedFIFO(int maxSize) {\n   if(maxSize < 1) {\n      throw new IllegalArgumentException(\"The maxSize argument (\"+maxSize+\n\t\t\t    \") is not a positive integer.\");\n    }\n    this.maxSize = maxSize;\n    buf = new LoggingEvent[maxSize];\n  }\n  \n  /**\n     Get the first element in the buffer. Returns <code>null</code> if\n     there are no elements in the buffer.  */\n  public\n  LoggingEvent get() {\n    if(numElements == 0) \n      return null;\n    \n    LoggingEvent r = buf[first];\n    buf[first] = null; // help garbage collection\n\n    if(++first == maxSize) {\n\tfirst = 0;\n    }\n    numElements--;    \n    return r;    \n  }\n\n  /**\n     Place a {@link LoggingEvent} in the buffer. If the buffer is full\n     then the event is <b>silently dropped</b>. It is the caller's\n     responsability to make sure that the buffer has free space.  */\n  public \n  void put(LoggingEvent o) {\n    if(numElements != maxSize) {      \n      buf[next] = o;    \n      if(++next == maxSize) {\n\tnext = 0;\n      }\n      numElements++;\n    }\n  }\n\n  /**\n     Get the maximum size of the buffer.\n   */\n  public \n  int getMaxSize() {\n    return maxSize;\n  }\n\n  /**\n     Return <code>true</code> if the buffer is full, that is, whether\n     the number of elements in the buffer equals the buffer size. */\n  public \n  boolean isFull() {\n    return numElements == maxSize;\n  }\n\n  /**\n     Get the number of elements in the buffer. This number is\n     guaranteed to be in the range 0 to <code>maxSize</code>\n     (inclusive).\n  */\n  public\n  int length() {\n    return numElements;\n  } \n\n\n  int min(int a, int b) {\n    return a < b ? a : b;\n  }\n\n\n  /**\n     Resize the buffer to a new size. If the new size is smaller than\n     the old size events might be lost.\n     \n     @since 1.1\n   */\n  synchronized\n  public \n  void resize(int newSize) {\n    if(newSize == maxSize) \n      return;\n\n\n   LoggingEvent[] tmp = new LoggingEvent[newSize];\n\n   // we should not copy beyond the buf array\n   int len1 = maxSize - first;\n\n   // we should not copy beyond the tmp array\n   len1 = min(len1, newSize);\n\n   // er.. how much do we actually need to copy?\n   // We should not copy more than the actual number of elements.\n   len1 = min(len1, numElements);\n\n   // Copy from buf starting a first, to tmp, starting at position 0, len1 elements.\n   System.arraycopy(buf, first, tmp, 0, len1);\n   \n   // Are there any uncopied elements and is there still space in the new array?\n   int len2 = 0;\n   if((len1 < numElements) && (len1 < newSize)) {\n     len2 = numElements - len1;\n     len2 = min(len2, newSize - len1);\n     System.arraycopy(buf, 0, tmp, len1, len2);\n   }\n   \n   this.buf = tmp;\n   this.maxSize = newSize;    \n   this.first=0;   \n   this.numElements = len1+len2;\n   this.next = this.numElements;\n   if(this.next == this.maxSize) // this should never happen, but again, it just might.\n     this.next = 0;\n  }\n\n  \n  /**\n     Returns <code>true</code> if there is just one element in the\n     buffer. In other words, if there were no elements before the last\n     {@link #put} operation completed.  */\n  public\n  boolean wasEmpty() {\n    return numElements == 1;\n  }\n\n  /**\n      Returns <code>true</code> if the number of elements in the\n      buffer plus 1 equals the maximum buffer size, returns\n      <code>false</code> otherwise. */\n  public\n  boolean wasFull() {\n    return (numElements+1 == maxSize);\n  }\n\n}\n",
      "file_name": "BoundedFIFO.java",
      "human_label": "Place a  LoggingEvent in the buffer buf.",
      "level": "class_runnable",
      "lineno": "70",
      "name": "put",
      "oracle_context": "{ \"apis\" : \"[]\", \"classes\" : \"[]\", \"vars\" : \"[numElements, maxSize, buf, next]\" }",
      "package": "org.apache.log4j.helpers",
      "project": "logging-log4j1-main"
    },
    {
      "_id": "636767df1a6d9265ec018744",
      "all_context": "{ \"class_level\" : \"import lombok.Getter;\\nimport lombok.RequiredArgsConstructor;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.apache.skywalking.oap.server.core.profiling.ebpf.storage.EBPFProfilingDataRecord;\\nimport org.apache.skywalking.oap.server.core.query.type.EBPFProfilingAnalyzation;\\nimport org.apache.skywalking.oap.server.core.query.type.EBPFProfilingAnalyzeAggregateType;\\nimport org.apache.skywalking.oap.server.core.query.type.EBPFProfilingAnalyzeTimeRange;\\nimport org.apache.skywalking.oap.server.core.query.type.EBPFProfilingTree;\\nimport org.apache.skywalking.oap.server.core.storage.StorageModule;\\nimport org.apache.skywalking.oap.server.core.storage.profiling.ebpf.IEBPFProfilingDataDAO;\\nimport org.apache.skywalking.oap.server.library.module.ModuleManager;\\nimport org.apache.skywalking.oap.server.library.util.CollectionUtils;\\nimport java.io.IOException;\\nimport java.util.ArrayList;\\nimport java.util.Collection;\\nimport java.util.Collections;\\nimport java.util.List;\\nimport java.util.Objects;\\nimport java.util.concurrent.ExecutorService;\\nimport java.util.concurrent.Executors;\\nimport java.util.concurrent.TimeUnit;\\nimport java.util.stream.Collectors;\\nimport java.util.stream.Stream;\\nEBPFProfilingAnalyzeCollector ANALYZE_COLLECTOR;\\nLong FETCH_DATA_DURATION;\\nModuleManager moduleManager;\\nIEBPFProfilingDataDAO dataDAO;\\nlong maxQueryTimeoutInSecond;\\nExecutorService fetchDataThreadPool;\\nlong minTime;\\nlong maxTime;\\nEBPFProfilingAnalyzer(ModuleManager moduleManager,int maxDurationOfQuery,int fetchDataThreadPoolSize);\\ngenerateTrees(EBPFProfilingAnalyzation analyzation,Stream stackStream);\\nbuildTimeRanges(List timeRanges);\\nbuildTimeRanges(long start,long end);\\ngetDataDAO();\\nanalyze(List scheduleIdList,List ranges,EBPFProfilingAnalyzeAggregateType aggregateType);\\n\", \"repo_level\" : \"public interface EBPFProfilingDataRecord {public String id();\\npublic EBPFProfilingDataRecord storage2Entity(Convert2Entity converter);\\npublic void entity2Storage(EBPFProfilingDataRecord storageData,Convert2Storage converter);\\n }\\npublic interface EBPFProfilingAnalyzation { }\\npublic interface EBPFProfilingAnalyzeTimeRange { }\\npublic interface EBPFProfilingTree { }\\npublic interface StorageModule {public Class[] services();\\n }\\npublic interface IEBPFProfilingDataDAO { List<EBPFProfilingDataRecord> queryData(List scheduleIdList,long beginTime,long endTime);\\n }\\npublic interface ModuleManager {public void init(ApplicationConfiguration applicationConfiguration);\\npublic boolean has(String moduleName);\\npublic ModuleProviderHolder find(String moduleName);\\n }\\npublic interface CollectionUtils {static boolean isEmpty(Map map);\\nstatic boolean isEmpty(List list);\\nstatic boolean isEmpty(Set set);\\nstatic boolean isNotEmpty(List list);\\nstatic boolean isNotEmpty(Set set);\\nstatic boolean isNotEmpty(Map map);\\nstatic boolean isNotEmpty(T[] array);\\nstatic boolean isEmpty(byte[] array);\\nstatic boolean isNotEmpty(byte[] array);\\n }\\n\" }",
      "class_name": "EBPFProfilingAnalyzer",
      "code": "protected List<TimeRange> buildTimeRanges(long start,long end){\n  if (start >= end) {\n    return null;\n  }\n  end+=1;\n  final List<TimeRange> timeRanges=new ArrayList<>();\n  do {\n    long batchEnd=Math.min(start + FETCH_DATA_DURATION,end);\n    timeRanges.add(new TimeRange(start,batchEnd));\n    start=batchEnd;\n  }\n while (start < end);\n  return timeRanges;\n}\n",
      "docstring": "/** \n * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}\n */\n",
      "end_lineno": "138",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage org.apache.skywalking.oap.server.core.profiling.ebpf.analyze;\n\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.skywalking.oap.server.core.profiling.ebpf.storage.EBPFProfilingDataRecord;\nimport org.apache.skywalking.oap.server.core.query.type.EBPFProfilingAnalyzation;\nimport org.apache.skywalking.oap.server.core.query.type.EBPFProfilingAnalyzeAggregateType;\nimport org.apache.skywalking.oap.server.core.query.type.EBPFProfilingAnalyzeTimeRange;\nimport org.apache.skywalking.oap.server.core.query.type.EBPFProfilingTree;\nimport org.apache.skywalking.oap.server.core.storage.StorageModule;\nimport org.apache.skywalking.oap.server.core.storage.profiling.ebpf.IEBPFProfilingDataDAO;\nimport org.apache.skywalking.oap.server.library.module.ModuleManager;\nimport org.apache.skywalking.oap.server.library.util.CollectionUtils;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * eBPF Profiling Analyzer working on data query and combine them for generate the Flame Graph.\n */\n@Slf4j\npublic class EBPFProfilingAnalyzer {\n\n    private static final EBPFProfilingAnalyzeCollector ANALYZE_COLLECTOR = new EBPFProfilingAnalyzeCollector();\n    private static final Long FETCH_DATA_DURATION = TimeUnit.SECONDS.toMillis(10);\n\n    private final ModuleManager moduleManager;\n    protected IEBPFProfilingDataDAO dataDAO;\n    private long maxQueryTimeoutInSecond;\n    private final ExecutorService fetchDataThreadPool;\n\n    public EBPFProfilingAnalyzer(ModuleManager moduleManager, int maxDurationOfQuery, int fetchDataThreadPoolSize) {\n        this.moduleManager = moduleManager;\n        this.maxQueryTimeoutInSecond = maxDurationOfQuery;\n        this.fetchDataThreadPool = Executors.newFixedThreadPool(fetchDataThreadPoolSize);\n    }\n\n    /**\n     * search data and analyze\n     */\n    public EBPFProfilingAnalyzation analyze(List<String> scheduleIdList,\n                                            List<EBPFProfilingAnalyzeTimeRange> ranges,\n                                            EBPFProfilingAnalyzeAggregateType aggregateType) throws IOException {\n        EBPFProfilingAnalyzation analyzation = new EBPFProfilingAnalyzation();\n\n        // query data\n        long queryDataMaxTimestamp = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(maxQueryTimeoutInSecond);\n        final Stream<EBPFProfilingStack> stackStream = buildTimeRanges(ranges).parallelStream().map(r -> {\n            try {\n                return fetchDataThreadPool.submit(() -> getDataDAO().queryData(scheduleIdList, r.getMinTime(), r.getMaxTime()))\n                        .get(queryDataMaxTimestamp - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n            } catch (Exception e) {\n                log.warn(e.getMessage(), e);\n                return Collections.<EBPFProfilingDataRecord>emptyList();\n            }\n        }).flatMap(Collection::stream).map(e -> {\n            try {\n                return EBPFProfilingStack.deserialize(e, aggregateType);\n            } catch (Exception ex) {\n                log.warn(\"could not deserialize the stack\", ex);\n                return null;\n            }\n        }).filter(Objects::nonNull).distinct();\n\n        // analyze tree\n        generateTrees(analyzation, stackStream);\n\n        return analyzation;\n    }\n\n    public void generateTrees(EBPFProfilingAnalyzation analyzation, Stream<EBPFProfilingStack> stackStream) {\n        Collection<EBPFProfilingTree> stackTrees = stackStream\n                // stack list cannot be empty\n                .filter(s -> CollectionUtils.isNotEmpty(s.getSymbols()))\n                // analyze the symbol and combine as trees\n                .collect(Collectors.groupingBy(s -> s.getSymbols()\n                        .get(0), ANALYZE_COLLECTOR)).values();\n\n        analyzation.getTrees().addAll(stackTrees);\n    }\n\n    protected List<TimeRange> buildTimeRanges(List<EBPFProfilingAnalyzeTimeRange> timeRanges) {\n        return timeRanges.parallelStream()\n                .map(r -> buildTimeRanges(r.getStart(), r.getEnd()))\n                .filter(Objects::nonNull)\n                .flatMap(Collection::stream)\n                .collect(Collectors.toList());\n    }\n\n    /**\n     * Split time ranges to insure the start time and end time is small then {@link #FETCH_DATA_DURATION}\n     */\n    protected List<TimeRange> buildTimeRanges(long start, long end) {\n        if (start >= end) {\n            return null;\n        }\n\n        // include latest millisecond\n        end += 1;\n\n        final List<TimeRange> timeRanges = new ArrayList<>();\n        do {\n            long batchEnd = Math.min(start + FETCH_DATA_DURATION, end);\n            timeRanges.add(new TimeRange(start, batchEnd));\n            start = batchEnd;\n        }\n        while (start < end);\n\n        return timeRanges;\n    }\n\n    protected IEBPFProfilingDataDAO getDataDAO() {\n        if (dataDAO == null) {\n            dataDAO = moduleManager.find(StorageModule.NAME)\n                    .provider()\n                    .getService(IEBPFProfilingDataDAO.class);\n        }\n        return dataDAO;\n    }\n\n    /**\n     * Split the query time with {@link #FETCH_DATA_DURATION}\n     */\n    @Getter\n    @RequiredArgsConstructor\n    private static class TimeRange {\n        private final long minTime;\n        private final long maxTime;\n    }\n}",
      "file_name": "EBPFProfilingAnalyzer.java",
      "human_label": "Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.",
      "level": "self_contained",
      "lineno": "118",
      "name": "buildTimeRanges",
      "oracle_context": "{ \"apis\" : \"[min, add]\", \"classes\" : \"[List<TimeRange>]\", \"vars\" : \"[FETCH_DATA_DURATION]\" }",
      "package": "org.apache.skywalking.oap.server.core.profiling.ebpf.analyze",
      "project": "skywalking-master"
    },
    {
      "_id": "636767031a6d9265ec0178e6",
      "all_context": "{ \"class_level\" : \"import java.lang.reflect.Array;\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.Map.Entry;\\nObject[] EMPTY_OBJECT_ARRAY;\\nClass<?>[] EMPTY_CLASS_ARRAY;\\nString[] EMPTY_STRING_ARRAY;\\nlong[] EMPTY_LONG_ARRAY;\\nLong[] EMPTY_LONG_OBJECT_ARRAY;\\nint[] EMPTY_INT_ARRAY;\\nInteger[] EMPTY_INTEGER_OBJECT_ARRAY;\\nshort[] EMPTY_SHORT_ARRAY;\\nShort[] EMPTY_SHORT_OBJECT_ARRAY;\\nbyte[] EMPTY_BYTE_ARRAY;\\nByte[] EMPTY_BYTE_OBJECT_ARRAY;\\ndouble[] EMPTY_DOUBLE_ARRAY;\\nDouble[] EMPTY_DOUBLE_OBJECT_ARRAY;\\nfloat[] EMPTY_FLOAT_ARRAY;\\nFloat[] EMPTY_FLOAT_OBJECT_ARRAY;\\nboolean[] EMPTY_BOOLEAN_ARRAY;\\nBoolean[] EMPTY_BOOLEAN_OBJECT_ARRAY;\\nchar[] EMPTY_CHAR_ARRAY;\\nCharacter[] EMPTY_CHARACTER_OBJECT_ARRAY;\\nint INDEX_NOT_FOUND;\\nArrayUtils();\\nclone(Object[] array);\\nclone(long[] array);\\nclone(int[] array);\\nclone(short[] array);\\nclone(char[] array);\\nclone(byte[] array);\\nclone(double[] array);\\nclone(float[] array);\\nclone(boolean[] array);\\nclone(String[] array);\\nnullToEmpty(Object[] array);\\nnullToEmpty(String[] array);\\nnullToEmpty(long[] array);\\nnullToEmpty(int[] array);\\nnullToEmpty(short[] array);\\nnullToEmpty(char[] array);\\nnullToEmpty(byte[] array);\\nnullToEmpty(double[] array);\\nnullToEmpty(float[] array);\\nnullToEmpty(boolean[] array);\\nnullToEmpty(Long[] array);\\nnullToEmpty(Integer[] array);\\nnullToEmpty(Short[] array);\\nnullToEmpty(Character[] array);\\nnullToEmpty(Byte[] array);\\nnullToEmpty(Double[] array);\\nnullToEmpty(Float[] array);\\nnullToEmpty(Boolean[] array);\\nsubarray(Object[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(long[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(int[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(short[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(char[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(byte[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(double[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(float[] array,int startIndexInclusive,int endIndexExclusive);\\nsubarray(boolean[] array,int startIndexInclusive,int endIndexExclusive);\\nisSameLength(Object[] array1,Object[] array2);\\nisSameLength(long[] array1,long[] array2);\\nisSameLength(int[] array1,int[] array2);\\nisSameLength(short[] array1,short[] array2);\\nisSameLength(char[] array1,char[] array2);\\nisSameLength(byte[] array1,byte[] array2);\\nisSameLength(double[] array1,double[] array2);\\nisSameLength(float[] array1,float[] array2);\\nisSameLength(boolean[] array1,boolean[] array2);\\ngetLength(Object array);\\nisSameType(Object array1,Object array2);\\nreverse(Object[] array);\\nreverse(long[] array);\\nreverse(int[] array);\\nreverse(short[] array);\\nreverse(char[] array);\\nreverse(byte[] array);\\nreverse(double[] array);\\nreverse(float[] array);\\nreverse(boolean[] array);\\nindexOf(Object[] array,Object objectToFind);\\nindexOf(Object[] array,Object objectToFind,int startIndex);\\nlastIndexOf(Object[] array,Object objectToFind);\\nlastIndexOf(Object[] array,Object objectToFind,int startIndex);\\ncontains(Object[] array,Object objectToFind);\\nindexOf(long[] array,long valueToFind);\\nindexOf(long[] array,long valueToFind,int startIndex);\\nlastIndexOf(long[] array,long valueToFind);\\nlastIndexOf(long[] array,long valueToFind,int startIndex);\\ncontains(long[] array,long valueToFind);\\nindexOf(int[] array,int valueToFind);\\nindexOf(int[] array,int valueToFind,int startIndex);\\nlastIndexOf(int[] array,int valueToFind);\\nlastIndexOf(int[] array,int valueToFind,int startIndex);\\ncontains(int[] array,int valueToFind);\\nindexOf(short[] array,short valueToFind);\\nindexOf(short[] array,short valueToFind,int startIndex);\\nlastIndexOf(short[] array,short valueToFind);\\nlastIndexOf(short[] array,short valueToFind,int startIndex);\\ncontains(short[] array,short valueToFind);\\nindexOf(char[] array,char valueToFind);\\nindexOf(char[] array,char valueToFind,int startIndex);\\nlastIndexOf(char[] array,char valueToFind);\\nlastIndexOf(char[] array,char valueToFind,int startIndex);\\ncontains(char[] array,char valueToFind);\\nindexOf(byte[] array,byte valueToFind);\\nindexOf(byte[] array,byte valueToFind,int startIndex);\\nlastIndexOf(byte[] array,byte valueToFind);\\nlastIndexOf(byte[] array,byte valueToFind,int startIndex);\\ncontains(byte[] array,byte valueToFind);\\nindexOf(double[] array,double valueToFind);\\nindexOf(double[] array,double valueToFind,double tolerance);\\nindexOf(double[] array,double valueToFind,int startIndex);\\nindexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\nlastIndexOf(double[] array,double valueToFind);\\nlastIndexOf(double[] array,double valueToFind,double tolerance);\\nlastIndexOf(double[] array,double valueToFind,int startIndex);\\nlastIndexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\ncontains(double[] array,double valueToFind);\\ncontains(double[] array,double valueToFind,double tolerance);\\nindexOf(float[] array,float valueToFind);\\nindexOf(float[] array,float valueToFind,int startIndex);\\nlastIndexOf(float[] array,float valueToFind);\\nlastIndexOf(float[] array,float valueToFind,int startIndex);\\ncontains(float[] array,float valueToFind);\\nindexOf(boolean[] array,boolean valueToFind);\\nindexOf(boolean[] array,boolean valueToFind,int startIndex);\\nlastIndexOf(boolean[] array,boolean valueToFind);\\nlastIndexOf(boolean[] array,boolean valueToFind,int startIndex);\\ncontains(boolean[] array,boolean valueToFind);\\ntoPrimitive(Character[] array);\\ntoPrimitive(Character[] array,char valueForNull);\\ntoObject(char[] array);\\ntoPrimitive(Long[] array);\\ntoPrimitive(Long[] array,long valueForNull);\\ntoObject(long[] array);\\ntoPrimitive(Integer[] array);\\ntoPrimitive(Integer[] array,int valueForNull);\\ntoObject(int[] array);\\ntoPrimitive(Short[] array);\\ntoPrimitive(Short[] array,short valueForNull);\\ntoObject(short[] array);\\ntoPrimitive(Byte[] array);\\ntoPrimitive(Byte[] array,byte valueForNull);\\ntoObject(byte[] array);\\ntoPrimitive(Double[] array);\\ntoPrimitive(Double[] array,double valueForNull);\\ntoObject(double[] array);\\ntoPrimitive(Float[] array);\\ntoPrimitive(Float[] array,float valueForNull);\\ntoObject(float[] array);\\ntoPrimitive(Boolean[] array);\\ntoPrimitive(Boolean[] array,boolean valueForNull);\\ntoObject(boolean[] array);\\nisEmpty(Object[] array);\\nisEmpty(long[] array);\\nisEmpty(int[] array);\\nisEmpty(short[] array);\\nisEmpty(char[] array);\\nisEmpty(byte[] array);\\nisEmpty(double[] array);\\nisEmpty(float[] array);\\nisEmpty(boolean[] array);\\nisNotEmpty(Object[] array);\\nisNotEmpty(long[] array);\\nisNotEmpty(int[] array);\\nisNotEmpty(short[] array);\\nisNotEmpty(char[] array);\\nisNotEmpty(byte[] array);\\nisNotEmpty(double[] array);\\nisNotEmpty(float[] array);\\nisNotEmpty(boolean[] array);\\naddAll(Object[] array1,Object[] array2);\\naddAll(boolean[] array1,boolean[] array2);\\naddAll(char[] array1,char[] array2);\\naddAll(byte[] array1,byte[] array2);\\naddAll(short[] array1,short[] array2);\\naddAll(int[] array1,int[] array2);\\naddAll(long[] array1,long[] array2);\\naddAll(float[] array1,float[] array2);\\naddAll(double[] array1,double[] array2);\\naddAll(String[] array1,String[] array2);\\nadd(T[] array,T element);\\nadd(boolean[] array,boolean element);\\nadd(byte[] array,byte element);\\nadd(char[] array,char element);\\nadd(double[] array,double element);\\nadd(float[] array,float element);\\nadd(int[] array,int element);\\nadd(long[] array,long element);\\nadd(short[] array,short element);\\ncopyArrayGrow1(Object array,Class newArrayComponentType);\\nadd(Object[] array,int index,Object element);\\nadd(boolean[] array,int index,boolean element);\\nadd(char[] array,int index,char element);\\nadd(byte[] array,int index,byte element);\\nadd(short[] array,int index,short element);\\nadd(int[] array,int index,int element);\\nadd(long[] array,int index,long element);\\nadd(float[] array,int index,float element);\\nadd(double[] array,int index,double element);\\nadd(Object array,int index,Object element,Class clss);\\nremove(Object[] array,int index);\\nremoveElement(Object[] array,Object element);\\nremove(boolean[] array,int index);\\nremoveElement(boolean[] array,boolean element);\\nremove(byte[] array,int index);\\nremoveElement(byte[] array,byte element);\\nremove(char[] array,int index);\\nremoveElement(char[] array,char element);\\nremove(double[] array,int index);\\nremoveElement(double[] array,double element);\\nremove(float[] array,int index);\\nremoveElement(float[] array,float element);\\nremove(int[] array,int index);\\nremoveElement(int[] array,int element);\\nremove(long[] array,int index);\\nremoveElement(long[] array,long element);\\nremove(short[] array,int index);\\nremoveElement(short[] array,short element);\\nremove(Object array,int index);\\nclearNull(Object[] arr);\\ntoMap(Object[] array);\\n\", \"repo_level\" : \"\" }",
      "class_name": "ArrayUtils",
      "code": "public static byte[] toPrimitive(final Byte[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result=new byte[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=array[i].byteValue();\n  }\n  return result;\n}\n",
      "docstring": "/** \n * <p>Converts an array of object Bytes to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Byte</code> array, may be <code>null</code>\n * @return a <code>byte</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n",
      "end_lineno": "2804",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils;\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * <p>Operations on arrays, primitive arrays (like <code>int[]</code>) and\n * primitive wrapper arrays (like <code>Integer[]</code>).</p>\n *\n * <p>This class tries to handle <code>null</code> input gracefully.\n * An exception will not be thrown for a <code>null</code>\n * array input. However, an Object array that contains a <code>null</code>\n * element may throw an exception. Each method documents its behaviour.</p>\n *\n * <p>#ThreadSafe#</p>\n * @author Apache Software Foundation\n * @author Moritz Petersen\n * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n * @author Nikolay Metchev\n * @author Matthew Hawthorne\n * @author Tim O'Brien\n * @author Pete Gieser\n * @author Gary Gregory\n * @author <a href=\"mailto:equinus100@hotmail.com\">Ashwin S</a>\n * @author Maarten Coene\n * @since 2.0\n * @version $Id: ArrayUtils.java 1056988 2011-01-09 17:58:53Z niallp $\n */\npublic class ArrayUtils {\n    /** An empty immutable <code>Object</code> array. */\n    public static final Object[]    EMPTY_OBJECT_ARRAY           = new Object[0];\n    /** An empty immutable <code>Class</code> array. */\n    public static final Class<?>[]  EMPTY_CLASS_ARRAY            = new Class[0];\n    /** An empty immutable <code>String</code> array. */\n    public static final String[]    EMPTY_STRING_ARRAY           = new String[0];\n    /** An empty immutable <code>long</code> array. */\n    public static final long[]      EMPTY_LONG_ARRAY             = new long[0];\n    /** An empty immutable <code>Long</code> array. */\n    public static final Long[]      EMPTY_LONG_OBJECT_ARRAY      = new Long[0];\n    /** An empty immutable <code>int</code> array. */\n    public static final int[]       EMPTY_INT_ARRAY              = new int[0];\n    /** An empty immutable <code>Integer</code> array. */\n    public static final Integer[]   EMPTY_INTEGER_OBJECT_ARRAY   = new Integer[0];\n    /** An empty immutable <code>short</code> array. */\n    public static final short[]     EMPTY_SHORT_ARRAY            = new short[0];\n    /** An empty immutable <code>Short</code> array. */\n    public static final Short[]     EMPTY_SHORT_OBJECT_ARRAY     = new Short[0];\n    /** An empty immutable <code>byte</code> array. */\n    public static final byte[]      EMPTY_BYTE_ARRAY             = new byte[0];\n    /** An empty immutable <code>Byte</code> array. */\n    public static final Byte[]      EMPTY_BYTE_OBJECT_ARRAY      = new Byte[0];\n    /** An empty immutable <code>double</code> array. */\n    public static final double[]    EMPTY_DOUBLE_ARRAY           = new double[0];\n    /** An empty immutable <code>Double</code> array. */\n    public static final Double[]    EMPTY_DOUBLE_OBJECT_ARRAY    = new Double[0];\n    /** An empty immutable <code>float</code> array. */\n    public static final float[]     EMPTY_FLOAT_ARRAY            = new float[0];\n    /** An empty immutable <code>Float</code> array. */\n    public static final Float[]     EMPTY_FLOAT_OBJECT_ARRAY     = new Float[0];\n    /** An empty immutable <code>boolean</code> array. */\n    public static final boolean[]   EMPTY_BOOLEAN_ARRAY          = new boolean[0];\n    /** An empty immutable <code>Boolean</code> array. */\n    public static final Boolean[]   EMPTY_BOOLEAN_OBJECT_ARRAY   = new Boolean[0];\n    /** An empty immutable <code>char</code> array. */\n    public static final char[]      EMPTY_CHAR_ARRAY             = new char[0];\n    /** An empty immutable <code>Character</code> array. */\n    public static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n    /**\n     * The index value when an element is not found in a list or array: <code>-1</code>.\n     * This value is returned by methods in this class and can also be used in comparisons with values returned by\n     * various method from {@link java.util.List}.\n     */\n    public static final int         INDEX_NOT_FOUND              = -1;\n\n    /**\n     * <p>ArrayUtils instances should NOT be constructed in standard programming.\n     * Instead, the class should be used as <code>ArrayUtils.clone(new int[] {2})</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     */\n    public ArrayUtils() {\n        super();\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts the given array into a {@link Map}. Each element of the array\n     * must be either a {@link Entry} or an Array, containing at least two\n     * elements, where the first element is used as key and the second as\n     * value.</p>\n     *\n     * <p>This method can be used to initialize:</p>\n     * <pre>\n     * // Create a Map mapping colors.\n     * Map colorMap = ArrayUtils.toMap(new String[][] {{\n     *     {\"RED\", \"#FF0000\"},\n     *     {\"GREEN\", \"#00FF00\"},\n     *     {\"BLUE\", \"#0000FF\"}});\n     * </pre>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  an array whose elements are either a {@link Entry} or\n     *  an Array containing at least two elements, may be <code>null</code>\n     * @return a <code>Map</code> that was created from the array\n     * @throws IllegalArgumentException  if one element of this Array is\n     *  itself an Array containing less then two elements\n     * @throws IllegalArgumentException  if the array contains elements other\n     *  than {@link Entry} and an Array\n     */\n    public static Map toMap(final Object[] array) {\n        if (array == null) {\n            return null;\n        }\n        final Map map = new HashMap((int) (array.length * 1.5));\n        for (int i = 0; i < array.length; i++) {\n            Object object = array[i];\n            if (object instanceof Entry) {\n                Entry entry = (Entry) object;\n                map.put(entry.getKey(), entry.getValue());\n            } else if (object instanceof Object[]) {\n                Object[] entry = (Object[]) object;\n                if (entry.length < 2) {\n                    throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', has a length less than 2\");\n                }\n                map.put(entry[0], entry[1]);\n            } else {\n                throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', is neither of type Map.Entry nor an Array\");\n            }\n        }\n        return map;\n    }\n    // Clone\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Shallow clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>The objects in the array are not cloned, thus there is no special\n     * handling for multi-dimensional arrays.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to shallow clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static Object[] clone(final Object[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static long[] clone(final long[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static int[] clone(final int[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static short[] clone(final short[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static char[] clone(final char[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static byte[] clone(final byte[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static double[] clone(final double[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static float[] clone(final float[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static boolean[] clone(final boolean[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static String[] clone(final String[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n    // nullToEmpty\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Object[] nullToEmpty(final Object[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static String[] nullToEmpty(final String[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static long[] nullToEmpty(final long[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static int[] nullToEmpty(final int[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static short[] nullToEmpty(final short[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static char[] nullToEmpty(final char[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static byte[] nullToEmpty(final byte[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static double[] nullToEmpty(final double[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static float[] nullToEmpty(final float[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static boolean[] nullToEmpty(final boolean[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Long[] nullToEmpty(final Long[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Integer[] nullToEmpty(final Integer[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Short[] nullToEmpty(final Short[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Character[] nullToEmpty(final Character[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Byte[] nullToEmpty(final Byte[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Double[] nullToEmpty(final Double[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Float[] nullToEmpty(final Float[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY;\n        }\n        return array;\n    }\n\n    /**\n     * <p>Defensive programming technique to change a <code>null</code>\n     * reference to an empty one.</p>\n     *\n     * <p>This method returns an empty array for a <code>null</code> input array.</p>\n     *\n     * <p>As a memory optimizing technique an empty array passed in will be overridden with\n     * the empty <code>public static</code> references in this class.</p>\n     *\n     * @param array  the array to check for <code>null</code> or empty\n     * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n     * @since 2.5\n     */\n    public static Boolean[] nullToEmpty(final Boolean[] array) {\n        if (array == null || array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;\n        }\n        return array;\n    }\n    // Subarrays\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Produces a new array containing the elements between\n     * the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * <p>The component type of the subarray is always the same as\n     * that of the input array. Thus, if the input is an array of type\n     * <code>Date</code>, the following usage is envisaged:</p>\n     *\n     * <pre>\n     * Date[] someDates = (Date[])ArrayUtils.subarray(allDates, 2, 5);\n     * </pre>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static Object[] subarray(final Object[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        Class<?> type = array.getClass().getComponentType();\n        if (newSize <= 0) {\n            return (Object[]) Array.newInstance(type, 0);\n        }\n        Object[] subarray = (Object[]) Array.newInstance(type, newSize);\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>long</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        long[] subarray = new long[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>int</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        int[] subarray = new int[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>short</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        short[] subarray = new short[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>char</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        char[] subarray = new char[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>byte</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        byte[] subarray = new byte[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>double</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] subarray = new double[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>float</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        float[] subarray = new float[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>boolean</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        boolean[] subarray = new boolean[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n    // Is same length\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.\n     *\n     * <p>Any multi-dimensional aspects of the arrays are ignored.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final Object[] array1, final Object[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final long[] array1, final long[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final int[] array1, final int[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final short[] array1, final short[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final char[] array1, final char[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final double[] array1, final double[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final float[] array1, final float[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {\n        if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n            return false;\n        }\n        return true;\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Returns the length of the specified array.\n     * This method can deal with <code>Object</code> arrays and with primitive arrays.</p>\n     *\n     * <p>If the input array is <code>null</code>, <code>0</code> is returned.</p>\n     *\n     * <pre>\n     * ArrayUtils.getLength(null)            = 0\n     * ArrayUtils.getLength([])              = 0\n     * ArrayUtils.getLength([null])          = 1\n     * ArrayUtils.getLength([true, false])   = 2\n     * ArrayUtils.getLength([1, 2, 3])       = 3\n     * ArrayUtils.getLength([\"a\", \"b\", \"c\"]) = 3\n     * </pre>\n     *\n     * @param array  the array to retrieve the length from, may be null\n     * @return The length of the array, or <code>0</code> if the array is <code>null</code>\n     * @throws IllegalArgumentException if the object arguement is not an array.\n     * @since 2.1\n     */\n    public static int getLength(final Object array) {\n        if (array == null) {\n            return 0;\n        }\n        return Array.getLength(array);\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same type taking into account\n     * multi-dimensional arrays.</p>\n     *\n     * @param array1 the first array, must not be <code>null</code>\n     * @param array2 the second array, must not be <code>null</code>\n     * @return <code>true</code> if type of arrays matches\n     * @throws IllegalArgumentException if either array is <code>null</code>\n     */\n    public static boolean isSameType(final Object array1, final Object array2) {\n        if (array1 == null || array2 == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        return array1.getClass().getName().equals(array2.getClass().getName());\n    }\n    // Reverse\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>There is no special handling for multi-dimensional arrays.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final Object[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        Object tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final long[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        long tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final int[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        int tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final short[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        short tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final char[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        char tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final byte[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        byte tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final double[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        double tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final float[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        float tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(final boolean[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        boolean tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n    // IndexOf search\n    // ----------------------------------------------------------------------\n    // Object IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given object in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @return the index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final Object[] array, final Object objectToFind) {\n        return ArrayUtils.indexOf(array, objectToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given object in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @param startIndex  the index to start searching at\n     * @return the index of the object within the array starting at the index,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given object within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @return the last index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final Object[] array, final Object objectToFind) {\n        return ArrayUtils.lastIndexOf(array, objectToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given object in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n     * the array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i >= 0; i--) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n            for (int i = startIndex; i >= 0; i--) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the object is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param objectToFind  the object to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final Object[] array, final Object objectToFind) {\n        return ArrayUtils.indexOf(array, objectToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // long IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final long[] array, final long valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final long[] array, final long valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final long[] array, final long valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final long[] array, final long valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // int IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final int[] array, final int valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final int[] array, final int valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final int[] array, final int valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final int[] array, final int valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // short IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final short[] array, final short valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final short[] array, final short valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final short[] array, final short valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final short[] array, final short valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final short[] array, final short valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // char IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int indexOf(final char[] array, final char valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int indexOf(final char[] array, final char valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int lastIndexOf(final char[] array, final char valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int lastIndexOf(final char[] array, final char valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     * @since 2.1\n     */\n    public static boolean contains(final char[] array, final char valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // byte IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final byte[] array, final byte valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final byte[] array, final byte valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) {\n        if (array == null) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final byte[] array, final byte valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // double IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value within a given tolerance in the array.\n     * This method will return the index of the first value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind, final double tolerance) {\n        return ArrayUtils.indexOf(array, valueToFind, 0, tolerance);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.\n     * This method will return the index of the first value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        double min = valueToFind - tolerance;\n        double max = valueToFind + tolerance;\n        for (int i = startIndex; i < array.length; i++) {\n            if (array[i] >= min && array[i] <= max) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value within a given tolerance in the array.\n     * This method will return the index of the last value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.\n     * This method will return the index of the last value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @param tolerance  search for value within plus/minus this amount\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        double min = valueToFind - tolerance;\n        double max = valueToFind + tolerance;\n        for (int i = startIndex; i >= 0; i--) {\n            if (array[i] >= min && array[i] <= max) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final double[] array, final double valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if a value falling within the given tolerance is in the\n     * given array.  If the array contains a value within the inclusive range\n     * defined by (value - tolerance) to (value + tolerance).</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array\n     * is passed in.</p>\n     *\n     * @param array  the array to search\n     * @param valueToFind  the value to find\n     * @param tolerance  the array contains the tolerance of the search\n     * @return true if value falling within tolerance is in array\n     */\n    public static boolean contains(final double[] array, final double valueToFind, final double tolerance) {\n        return ArrayUtils.indexOf(array, valueToFind, 0, tolerance) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // float IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final float[] array, final float valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final float[] array, final float valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final float[] array, final float valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final float[] array, final float valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // boolean IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(final boolean[] array, final boolean valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code>\n     *  array input\n     */\n    public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) if\n     * <code>null</code> array input.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final boolean[] array, final boolean valueToFind) {\n        return ArrayUtils.lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n     * the array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return ArrayUtils.INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return ArrayUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(final boolean[] array, final boolean valueToFind) {\n        return ArrayUtils.indexOf(array, valueToFind) != ArrayUtils.INDEX_NOT_FOUND;\n    }\n    // Primitive/Object array converters\n    // ----------------------------------------------------------------------\n    // Character array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Characters to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Character</code> array, may be <code>null</code>\n     * @return a <code>char</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static char[] toPrimitive(final Character[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].charValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Character to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Character</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>char</code> array, <code>null</code> if null array input\n     */\n    public static char[] toPrimitive(final Character[] array, final char valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Character b = array[i];\n            result[i] = b == null ? valueForNull : b.charValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive chars to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array a <code>char</code> array\n     * @return a <code>Character</code> array, <code>null</code> if null array input\n     */\n    public static Character[] toObject(final char[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY;\n        }\n        final Character[] result = new Character[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Character(array[i]);\n        }\n        return result;\n    }\n    // Long array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Longs to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Long</code> array, may be <code>null</code>\n     * @return a <code>long</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static long[] toPrimitive(final Long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].longValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Long to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Long</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>long</code> array, <code>null</code> if null array input\n     */\n    public static long[] toPrimitive(final Long[] array, final long valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Long b = array[i];\n            result[i] = b == null ? valueForNull : b.longValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive longs to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>long</code> array\n     * @return a <code>Long</code> array, <code>null</code> if null array input\n     */\n    public static Long[] toObject(final long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_LONG_OBJECT_ARRAY;\n        }\n        final Long[] result = new Long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Long(array[i]);\n        }\n        return result;\n    }\n    // Int array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Integers to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Integer</code> array, may be <code>null</code>\n     * @return an <code>int</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static int[] toPrimitive(final Integer[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].intValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Integer to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Integer</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return an <code>int</code> array, <code>null</code> if null array input\n     */\n    public static int[] toPrimitive(final Integer[] array, final int valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Integer b = array[i];\n            result[i] = b == null ? valueForNull : b.intValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive ints to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  an <code>int</code> array\n     * @return an <code>Integer</code> array, <code>null</code> if null array input\n     */\n    public static Integer[] toObject(final int[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        final Integer[] result = new Integer[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Integer(array[i]);\n        }\n        return result;\n    }\n    // Short array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Shorts to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Short</code> array, may be <code>null</code>\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static short[] toPrimitive(final Short[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        final short[] result = new short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].shortValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Short to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Short</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     */\n    public static short[] toPrimitive(final Short[] array, final short valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_ARRAY;\n        }\n        final short[] result = new short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Short b = array[i];\n            result[i] = b == null ? valueForNull : b.shortValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive shorts to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>short</code> array\n     * @return a <code>Short</code> array, <code>null</code> if null array input\n     */\n    public static Short[] toObject(final short[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;\n        }\n        final Short[] result = new Short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Short(array[i]);\n        }\n        return result;\n    }\n    // Byte array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Bytes to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Byte</code> array, may be <code>null</code>\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static byte[] toPrimitive(final Byte[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        final byte[] result = new byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].byteValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Bytes to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Byte</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     */\n    public static byte[] toPrimitive(final Byte[] array, final byte valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_ARRAY;\n        }\n        final byte[] result = new byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Byte b = array[i];\n            result[i] = b == null ? valueForNull : b.byteValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive bytes to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>byte</code> array\n     * @return a <code>Byte</code> array, <code>null</code> if null array input\n     */\n    public static Byte[] toObject(final byte[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;\n        }\n        final Byte[] result = new Byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Byte(array[i]);\n        }\n        return result;\n    }\n    // Double array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Doubles to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Double</code> array, may be <code>null</code>\n     * @return a <code>double</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static double[] toPrimitive(final Double[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        final double[] result = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].doubleValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Doubles to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Double</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>double</code> array, <code>null</code> if null array input\n     */\n    public static double[] toPrimitive(final Double[] array, final double valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n        }\n        final double[] result = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Double b = array[i];\n            result[i] = b == null ? valueForNull : b.doubleValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive doubles to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>double</code> array\n     * @return a <code>Double</code> array, <code>null</code> if null array input\n     */\n    public static Double[] toObject(final double[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;\n        }\n        final Double[] result = new Double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Double(array[i]);\n        }\n        return result;\n    }\n    //   Float array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Floats to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Float</code> array, may be <code>null</code>\n     * @return a <code>float</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static float[] toPrimitive(final Float[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        final float[] result = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].floatValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Floats to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Float</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>float</code> array, <code>null</code> if null array input\n     */\n    public static float[] toPrimitive(final Float[] array, final float valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_ARRAY;\n        }\n        final float[] result = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Float b = array[i];\n            result[i] = b == null ? valueForNull : b.floatValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive floats to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>float</code> array\n     * @return a <code>Float</code> array, <code>null</code> if null array input\n     */\n    public static Float[] toObject(final float[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY;\n        }\n        final Float[] result = new Float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = new Float(array[i]);\n        }\n        return result;\n    }\n    // Boolean array converters\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an array of object Booleans to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n     * @return a <code>boolean</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static boolean[] toPrimitive(final Boolean[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        final boolean[] result = new boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].booleanValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Booleans to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>boolean</code> array, <code>null</code> if null array input\n     */\n    public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n        }\n        final boolean[] result = new boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Boolean b = array[i];\n            result[i] = b == null ? valueForNull : b.booleanValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive booleans to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>boolean</code> array\n     * @return a <code>Boolean</code> array, <code>null</code> if null array input\n     */\n    public static Boolean[] toObject(final boolean[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;\n        }\n        final Boolean[] result = new Boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE;\n        }\n        return result;\n    }\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if an array of Objects is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final Object[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive longs is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final long[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive ints is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final int[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive shorts is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final short[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive chars is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final char[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive bytes is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final byte[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final double[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive floats is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final float[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive booleans is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(final boolean[] array) {\n        return array == null || array.length == 0;\n    }\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if an array of Objects is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final Object[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive longs is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final long[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive ints is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final int[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive shorts is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final short[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive chars is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final char[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive bytes is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final byte[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive doubles is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final double[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive floats is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final float[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Checks if an array of primitive booleans is not empty or not <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is not empty or not <code>null</code>\n     * @since 2.5\n     */\n    public static boolean isNotEmpty(final boolean[] array) {\n        return array != null && array.length != 0;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(null, null)     = null\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * ArrayUtils.addAll([null], [null]) = [null, null]\n     * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array, may be <code>null</code>\n     * @param array2  the second array whose elements are added to the new array, may be <code>null</code>\n     * @return The new array, <code>null</code> if both arrays are <code>null</code>.\n     *      The type of the new array is the type of the first array,\n     *      unless the first array is null, in which case the type is the same as the second array.\n     * @since 2.1\n     * @throws IllegalArgumentException if the array types are incompatible\n     */\n    public static Object[] addAll(final Object[] array1, final Object[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        Object[] joinedArray = (Object[]) Array.newInstance(array1.getClass().getComponentType(), array1.length + array2.length);\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        try {\n            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        } catch (ArrayStoreException ase) {\n            // Check if problem was due to incompatible types\n            /*\n             * We do this here, rather than before the copy because:\n             * - it would be a wasted check most of the time\n             * - safer, in case check turns out to be too strict\n             */\n            final Class<?> type1 = array1.getClass().getComponentType();\n            final Class<?> type2 = array2.getClass().getComponentType();\n            if (!type1.isAssignableFrom(type2)) {\n                throw new IllegalArgumentException(\"Cannot store \" + type2.getName() + \" in an array of \" + type1.getName());\n            }\n            throw ase; // No, so rethrow original\n        }\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new boolean[] array.\n     * @since 2.1\n     */\n    public static boolean[] addAll(final boolean[] array1, final boolean[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        boolean[] joinedArray = new boolean[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new char[] array.\n     * @since 2.1\n     */\n    public static char[] addAll(final char[] array1, final char[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        char[] joinedArray = new char[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new byte[] array.\n     * @since 2.1\n     */\n    public static byte[] addAll(final byte[] array1, final byte[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        byte[] joinedArray = new byte[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new short[] array.\n     * @since 2.1\n     */\n    public static short[] addAll(final short[] array1, final short[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        short[] joinedArray = new short[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new int[] array.\n     * @since 2.1\n     */\n    public static int[] addAll(final int[] array1, final int[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        int[] joinedArray = new int[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new long[] array.\n     * @since 2.1\n     */\n    public static long[] addAll(final long[] array1, final long[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        long[] joinedArray = new long[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new float[] array.\n     * @since 2.1\n     */\n    public static float[] addAll(final float[] array1, final float[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        float[] joinedArray = new float[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new double[] array.\n     * @since 2.1\n     */\n    public static double[] addAll(final double[] array1, final double[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        double[] joinedArray = new double[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new String[] array.\n     * @since 2.1\n     */\n    public static String[] addAll(final String[] array1, final String[] array2) {\n        if (array1 == null) {\n            return ArrayUtils.clone(array2);\n        } else if (array2 == null) {\n            return ArrayUtils.clone(array1);\n        }\n        String[] joinedArray = new String[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element, unless the element itself is null,\n     *  in which case the return type is Object[]</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, null)      = [null]\n     * ArrayUtils.add(null, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to \"add\" the element to, may be <code>null</code>\n     * @param element  the object to add, may be <code>null</code>\n     * @return A new array containing the existing elements plus the new element\n     * The returned array type will be that of the input array (unless null),\n     * in which case it will have the same type as the element.\n     * @since 2.1\n     */\n    public static <T> T[] add(final T[] array, final T element) {\n        Class<?> type;\n        if (array != null) {\n            type = array.getClass();\n        } else if (element != null) {\n            type = element.getClass();\n        } else {\n            type = Object.class;\n        }\n        T[] newArray = (T[]) ArrayUtils.copyArrayGrow1(array, type);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, true)          = [true]\n     * ArrayUtils.add([true], false)       = [true, false]\n     * ArrayUtils.add([true, false], true) = [true, false, true]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static boolean[] add(final boolean[] array, final boolean element) {\n        boolean[] newArray = (boolean[]) ArrayUtils.copyArrayGrow1(array, Boolean.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static byte[] add(final byte[] array, final byte element) {\n        byte[] newArray = (byte[]) ArrayUtils.copyArrayGrow1(array, Byte.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, '0')       = ['0']\n     * ArrayUtils.add(['1'], '0')      = ['1', '0']\n     * ArrayUtils.add(['1', '0'], '1') = ['1', '0', '1']\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static char[] add(final char[] array, final char element) {\n        char[] newArray = (char[]) ArrayUtils.copyArrayGrow1(array, Character.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static double[] add(final double[] array, final double element) {\n        double[] newArray = (double[]) ArrayUtils.copyArrayGrow1(array, Double.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static float[] add(final float[] array, final float element) {\n        float[] newArray = (float[]) ArrayUtils.copyArrayGrow1(array, Float.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static int[] add(final int[] array, final int element) {\n        int[] newArray = (int[]) ArrayUtils.copyArrayGrow1(array, Integer.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static long[] add(final long[] array, final long element) {\n        long[] newArray = (long[]) ArrayUtils.copyArrayGrow1(array, Long.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static short[] add(final short[] array, final short element) {\n        short[] newArray = (short[]) ArrayUtils.copyArrayGrow1(array, Short.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * Returns a copy of the given array of size 1 greater than the argument.\n     * The last value of the array is left to the default value.\n     *\n     * @param array The array to copy, must not be <code>null</code>.\n     * @param newArrayComponentType If <code>array</code> is <code>null</code>, create a\n     * size 1 array of this type.\n     * @return A new copy of the array of size 1 greater than the input.\n     */\n    private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n        if (array != null) {\n            int arrayLength = Array.getLength(array);\n            Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n            System.arraycopy(array, 0, newArray, 0, arrayLength);\n            return newArray;\n        }\n        return Array.newInstance(newArrayComponentType, 1);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, null)      = [null]\n     * ArrayUtils.add(null, 0, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], 1, null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], 1, \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], 3, \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > array.length).\n     */\n    public static Object[] add(final Object[] array, final int index, final Object element) {\n        Class<?> clss = null;\n        if (array != null) {\n            clss = array.getClass().getComponentType();\n        } else if (element != null) {\n            clss = element.getClass();\n        } else {\n            return new Object[] { null };\n        }\n        return (Object[]) ArrayUtils.add(array, index, element, clss);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, true)          = [true]\n     * ArrayUtils.add([true], 0, false)       = [false, true]\n     * ArrayUtils.add([false], 1, true)       = [false, true]\n     * ArrayUtils.add([true, false], 1, true) = [true, true, false]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static boolean[] add(final boolean[] array, final int index, final boolean element) {\n        Boolean booElement = element ? Boolean.TRUE : Boolean.FALSE;\n        return (boolean[]) ArrayUtils.add(array, index, booElement, Boolean.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, 'a')            = ['a']\n     * ArrayUtils.add(['a'], 0, 'b')           = ['b', 'a']\n     * ArrayUtils.add(['a', 'b'], 0, 'c')      = ['c', 'a', 'b']\n     * ArrayUtils.add(['a', 'b'], 1, 'k')      = ['a', 'k', 'b']\n     * ArrayUtils.add(['a', 'b', 'c'], 1, 't') = ['a', 't', 'b', 'c']\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static char[] add(final char[] array, final int index, final char element) {\n        return (char[]) ArrayUtils.add(array, index, new Character(element), Character.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 3)      = [2, 6, 3]\n     * ArrayUtils.add([2, 6], 0, 1)      = [1, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static byte[] add(final byte[] array, final int index, final byte element) {\n        return (byte[]) ArrayUtils.add(array, index, new Byte(element), Byte.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static short[] add(final short[] array, final int index, final short element) {\n        return (short[]) ArrayUtils.add(array, index, new Short(element), Short.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static int[] add(final int[] array, final int index, final int element) {\n        return (int[]) ArrayUtils.add(array, index, new Integer(element), Integer.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1L], 0, 2L)           = [2L, 1L]\n     * ArrayUtils.add([2L, 6L], 2, 10L)      = [2L, 6L, 10L]\n     * ArrayUtils.add([2L, 6L], 0, -4L)      = [-4L, 2L, 6L]\n     * ArrayUtils.add([2L, 6L, 3L], 2, 1L)   = [2L, 6L, 1L, 3L]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static long[] add(final long[] array, final int index, final long element) {\n        return (long[]) ArrayUtils.add(array, index, new Long(element), Long.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1.1f], 0, 2.2f)               = [2.2f, 1.1f]\n     * ArrayUtils.add([2.3f, 6.4f], 2, 10.5f)        = [2.3f, 6.4f, 10.5f]\n     * ArrayUtils.add([2.6f, 6.7f], 0, -4.8f)        = [-4.8f, 2.6f, 6.7f]\n     * ArrayUtils.add([2.9f, 6.0f, 0.3f], 2, 1.0f)   = [2.9f, 6.0f, 1.0f, 0.3f]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static float[] add(final float[] array, final int index, final float element) {\n        return (float[]) ArrayUtils.add(array, index, new Float(element), Float.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1.1], 0, 2.2)              = [2.2, 1.1]\n     * ArrayUtils.add([2.3, 6.4], 2, 10.5)        = [2.3, 6.4, 10.5]\n     * ArrayUtils.add([2.6, 6.7], 0, -4.8)        = [-4.8, 2.6, 6.7]\n     * ArrayUtils.add([2.9, 6.0, 0.3], 2, 1.0)    = [2.9, 6.0, 1.0, 0.3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static double[] add(final double[] array, final int index, final double element) {\n        return (double[]) ArrayUtils.add(array, index, new Double(element), Double.TYPE);\n    }\n\n    /**\n     * Underlying implementation of add(array, index, element) methods.\n     * The last parameter is the class, which may not equal element.getClass\n     * for primitives.\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @param clss the type of the element being added\n     * @return A new array containing the existing elements and the new element\n     */\n    private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {\n        if (array == null) {\n            if (index != 0) {\n                throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n            }\n            Object joinedArray = Array.newInstance(clss, 1);\n            Array.set(joinedArray, 0, element);\n            return joinedArray;\n        }\n        int length = Array.getLength(array);\n        if (index > length || index < 0) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n        }\n        Object result = Array.newInstance(clss, length + 1);\n        System.arraycopy(array, 0, result, 0, index);\n        Array.set(result, index, element);\n        if (index < length) {\n            System.arraycopy(array, index, result, index + 1, length - index);\n        }\n        return result;\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([\"a\"], 0)           = []\n     * ArrayUtils.remove([\"a\", \"b\"], 0)      = [\"b\"]\n     * ArrayUtils.remove([\"a\", \"b\"], 1)      = [\"a\"]\n     * ArrayUtils.remove([\"a\", \"b\", \"c\"], 1) = [\"a\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static Object[] remove(final Object[] array, final int index) {\n        return (Object[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, \"a\")            = null\n     * ArrayUtils.removeElement([], \"a\")              = []\n     * ArrayUtils.removeElement([\"a\"], \"b\")           = [\"a\"]\n     * ArrayUtils.removeElement([\"a\", \"b\"], \"a\")      = [\"b\"]\n     * ArrayUtils.removeElement([\"a\", \"b\", \"a\"], \"a\") = [\"b\", \"a\"]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static Object[] removeElement(final Object[] array, final Object element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([true], 0)              = []\n     * ArrayUtils.remove([true, false], 0)       = [false]\n     * ArrayUtils.remove([true, false], 1)       = [true]\n     * ArrayUtils.remove([true, true, false], 1) = [true, false]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static boolean[] remove(final boolean[] array, final int index) {\n        return (boolean[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, true)                = null\n     * ArrayUtils.removeElement([], true)                  = []\n     * ArrayUtils.removeElement([true], false)             = [true]\n     * ArrayUtils.removeElement([true, false], false)      = [true]\n     * ArrayUtils.removeElement([true, false, true], true) = [false, true]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static boolean[] removeElement(final boolean[] array, final boolean element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)          = []\n     * ArrayUtils.remove([1, 0], 0)       = [0]\n     * ArrayUtils.remove([1, 0], 1)       = [1]\n     * ArrayUtils.remove([1, 0, 1], 1)    = [1, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static byte[] remove(final byte[] array, final int index) {\n        return (byte[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)        = null\n     * ArrayUtils.removeElement([], 1)          = []\n     * ArrayUtils.removeElement([1], 0)         = [1]\n     * ArrayUtils.removeElement([1, 0], 0)      = [1]\n     * ArrayUtils.removeElement([1, 0, 1], 1)   = [0, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static byte[] removeElement(final byte[] array, final byte element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove(['a'], 0)           = []\n     * ArrayUtils.remove(['a', 'b'], 0)      = ['b']\n     * ArrayUtils.remove(['a', 'b'], 1)      = ['a']\n     * ArrayUtils.remove(['a', 'b', 'c'], 1) = ['a', 'c']\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static char[] remove(final char[] array, final int index) {\n        return (char[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 'a')            = null\n     * ArrayUtils.removeElement([], 'a')              = []\n     * ArrayUtils.removeElement(['a'], 'b')           = ['a']\n     * ArrayUtils.removeElement(['a', 'b'], 'a')      = ['b']\n     * ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static char[] removeElement(final char[] array, final char element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1.1], 0)           = []\n     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static double[] remove(final double[] array, final int index) {\n        return (double[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1.1)            = null\n     * ArrayUtils.removeElement([], 1.1)              = []\n     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static double[] removeElement(final double[] array, final double element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1.1], 0)           = []\n     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static float[] remove(final float[] array, final int index) {\n        return (float[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1.1)            = null\n     * ArrayUtils.removeElement([], 1.1)              = []\n     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static float[] removeElement(final float[] array, final float element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static int[] remove(final int[] array, final int index) {\n        return (int[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static int[] removeElement(final int[] array, final int element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static long[] remove(final long[] array, final int index) {\n        return (long[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static long[] removeElement(final long[] array, final long element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static short[] remove(final short[] array, final int index) {\n        return (short[]) ArrayUtils.remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static short[] removeElement(final short[] array, final short element) {\n        int index = ArrayUtils.indexOf(array, element);\n        if (index == ArrayUtils.INDEX_NOT_FOUND) {\n            return ArrayUtils.clone(array);\n        }\n        return ArrayUtils.remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    private static Object remove(final Object array, final int index) {\n        int length = ArrayUtils.getLength(array);\n        if (index < 0 || index >= length) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n        }\n        Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);\n        System.arraycopy(array, 0, result, 0, index);\n        if (index < length - 1) {\n            System.arraycopy(array, index + 1, result, index, length - index - 1);\n        }\n        return result;\n    }\n\n    /**删除数组中空元素*/\n    public static Object[] clearNull(final Object[] arr) {\n        ArrayList<Object> list = new ArrayList<Object>();\n        if (arr != null) {\n            for (Object item : arr) {\n                if (item != null) {\n                    list.add(item);\n                }\n            }\n        }\n        return list.toArray();\n    }\n}\n",
      "file_name": "ArrayUtils.java",
      "human_label": "Convert an array of object Bytes to primitives, return null for a null input array.",
      "level": "self_contained",
      "lineno": "2784",
      "name": "toPrimitive",
      "oracle_context": "{ \"apis\" : \"[byteValue, ArrayUtils]\", \"classes\" : \"[byte[], ArrayUtils]\", \"vars\" : \"[length, EMPTY_BYTE_ARRAY]\" }",
      "package": "net.hasor.utils",
      "project": "hasor-master"
    },
    {
      "_id": "636767dc1a6d9265ec0186be",
      "all_context": "{ \"class_level\" : \"import java.util.ArrayList;\\nimport java.util.List;\\nimport lombok.Setter;\\nimport org.apache.skywalking.oap.server.core.Const;\\nimport org.apache.skywalking.oap.server.core.UnexpectedException;\\nimport org.apache.skywalking.oap.server.core.analysis.DownSampling;\\nimport org.apache.skywalking.oap.server.core.analysis.TimeBucket;\\nimport org.apache.skywalking.oap.server.core.query.enumeration.Step;\\nimport org.apache.skywalking.oap.server.core.storage.model.Model;\\nimport org.apache.skywalking.oap.server.library.util.StringUtil;\\nimport org.joda.time.DateTime;\\nimport org.joda.time.Days;\\nimport org.joda.time.format.DateTimeFormat;\\nimport org.joda.time.format.DateTimeFormatter;\\nDateTimeFormatter TIME_BUCKET_FORMATTER;\\nDateTime DAY_ONE;\\nint DAY_STEP;\\nint SUPER_DATASET_DAY_STEP;\\nlatestWriteIndexName(Model model);\\nqueryIndexName(String tableName,long pointOfTB,Step step,boolean isRecord,boolean isSuperDataSet);\\nwriteIndexName(Model model,long timeBucket);\\nisolateTimeFromIndexName(String indexName);\\ncompressTimeBucket(long timeBucket,int dayStep);\\ncompressDateTime(DateTime time,int dayStep);\\nsuperDatasetIndexNames(String indexName,long startSecondTB,long endSecondTB);\\n\", \"repo_level\" : \"public interface Const { }\\npublic interface UnexpectedException { }\\npublic interface TimeBucket {static long getRecordTimeBucket(long time);\\nstatic long getMinuteTimeBucket(long time);\\nstatic long getTimestamp(long timeBucket);\\nstatic boolean isSecondBucket(long timeBucket);\\nstatic boolean isMinuteBucket(long timeBucket);\\nstatic boolean isHourBucket(long timeBucket);\\nstatic boolean isDayBucket(long timeBucket);\\nstatic long getTimestamp(long timeBucket,DownSampling downsampling);\\nstatic long getTimeBucket(long timestamp,DownSampling downsampling);\\n }\\npublic interface Model { }\\npublic interface StringUtil {static boolean isEmpty(String str);\\nstatic boolean isNotEmpty(String str);\\nstatic boolean isBlank(String str);\\nstatic boolean isNotBlank(String str);\\nstatic void setIfPresent(String value,Consumer setter);\\nstatic String join(char delimiter,String strings);\\nstatic boolean substringMatch(CharSequence str,int index,CharSequence substring);\\nstatic String cut(String str,int threshold);\\nstatic String trim(String str,char ch);\\n }\\n\" }",
      "class_name": "TimeSeriesUtils",
      "code": "static long compressTimeBucket(long timeBucket,int dayStep){\n  if (dayStep > 1) {\n    DateTime time=TIME_BUCKET_FORMATTER.parseDateTime(\"\" + timeBucket);\n    int days=Days.daysBetween(DAY_ONE,time).getDays();\n    int groupBucketOffset=days % dayStep;\n    return Long.parseLong(time.minusDays(groupBucketOffset).toString(TIME_BUCKET_FORMATTER));\n  }\n else {\n    return timeBucket;\n  }\n}\n",
      "docstring": "/** \n * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123\n */\n",
      "end_lineno": "163",
      "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.skywalking.oap.server.storage.plugin.elasticsearch.base;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport lombok.Setter;\nimport org.apache.skywalking.oap.server.core.Const;\nimport org.apache.skywalking.oap.server.core.UnexpectedException;\nimport org.apache.skywalking.oap.server.core.analysis.DownSampling;\nimport org.apache.skywalking.oap.server.core.analysis.TimeBucket;\nimport org.apache.skywalking.oap.server.core.query.enumeration.Step;\nimport org.apache.skywalking.oap.server.core.storage.model.Model;\nimport org.apache.skywalking.oap.server.library.util.StringUtil;\nimport org.joda.time.DateTime;\nimport org.joda.time.Days;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\n\n/**\n * TimeSeriesUtils sets up and splits the time suffix of index name.\n */\npublic class TimeSeriesUtils {\n    private static DateTimeFormatter TIME_BUCKET_FORMATTER = DateTimeFormat.forPattern(\"yyyyMMdd\");\n    /**\n     * We are far from the first day of 2000, so we set it as the day one to make sure the index based on {@link\n     * #DAY_STEP} is consistently no matter whenever the OAP starts up.\n     */\n    private static final DateTime DAY_ONE = TIME_BUCKET_FORMATTER.parseDateTime(\"20000101\");\n    @Setter\n    private static int DAY_STEP = 1;\n    @Setter\n    private static int SUPER_DATASET_DAY_STEP = 1;\n\n    /**\n     * @return formatted latest index name, based on current timestamp.\n     */\n    public static String latestWriteIndexName(Model model) {\n        String tableName = IndexController.INSTANCE.getTableName(model);\n        long dayTimeBucket = TimeBucket.getTimeBucket(System.currentTimeMillis(), DownSampling.Day);\n        if (model.isRecord() && model.isSuperDataset()) {\n            return tableName + Const.LINE + compressTimeBucket(dayTimeBucket, SUPER_DATASET_DAY_STEP);\n        }\n        return tableName + Const.LINE + compressTimeBucket(dayTimeBucket, DAY_STEP);\n    }\n\n    /**\n     * @return Concrete index name for super dataset index\n     */\n    public static String[] superDatasetIndexNames(String indexName, long startSecondTB, long endSecondTB) {\n        if (startSecondTB == 0 || endSecondTB == 0) {\n            return new String[] {indexName};\n        }\n        DateTime startDateTime = TIME_BUCKET_FORMATTER.parseDateTime(startSecondTB / 1000000 + \"\");\n        DateTime endDateTime = TIME_BUCKET_FORMATTER.parseDateTime(endSecondTB / 1000000 + \"\");\n        List<DateTime> timeRanges = new ArrayList<>(16);\n        for (int i = 0; i <= Days.daysBetween(startDateTime, endDateTime).getDays(); i++) {\n            timeRanges.add(startDateTime.plusDays(i));\n        }\n        if (timeRanges.isEmpty()) {\n            return new String[] {indexName};\n        } else {\n            return timeRanges.stream()\n                             .map(item -> indexName + Const.LINE + compressDateTime(item, SUPER_DATASET_DAY_STEP))\n                             .distinct()\n                             .toArray(String[]::new);\n        }\n    }\n\n    public static String queryIndexName(String tableName,\n                                        long pointOfTB,\n                                        Step step,\n                                        boolean isRecord,\n                                        boolean isSuperDataSet) {\n        if (StringUtil.isBlank(tableName) || pointOfTB <= 0) {\n            throw new IllegalArgumentException(\n                \"Arguments [tableName]: \" + tableName + \" can not be blank and [pointOfTB]: \" + pointOfTB + \" can not <= 0\");\n        }\n        if (isRecord && isSuperDataSet) {\n            return tableName + Const.LINE + compressTimeBucket(pointOfTB / 1000000, SUPER_DATASET_DAY_STEP);\n        }\n        switch (step) {\n            case DAY:\n                return tableName + Const.LINE + compressTimeBucket(pointOfTB, DAY_STEP);\n            case HOUR:\n                return tableName + Const.LINE + compressTimeBucket(pointOfTB / 100, DAY_STEP);\n            case MINUTE:\n                return tableName + Const.LINE + compressTimeBucket(pointOfTB / 10000, DAY_STEP);\n            case SECOND:\n                return tableName + Const.LINE + compressTimeBucket(pointOfTB / 1000000, DAY_STEP);\n        }\n\n        throw new UnexpectedException(\"Failed to get the index name from tableName:\" + tableName + \", pointOfTB:\" + pointOfTB + \", step:\" + step.name());\n    }\n\n    /**\n     * @return index name based on model definition and given time bucket.\n     */\n    static String writeIndexName(Model model, long timeBucket) {\n        String tableName = IndexController.INSTANCE.getTableName(model);\n        if (model.isRecord() && model.isSuperDataset()) {\n            return tableName + Const.LINE + compressTimeBucket(timeBucket / 1000000, SUPER_DATASET_DAY_STEP);\n        } else {\n            switch (model.getDownsampling()) {\n                case None:\n                    return tableName;\n                case Hour:\n                    return tableName + Const.LINE + compressTimeBucket(timeBucket / 100, DAY_STEP);\n                case Minute:\n                    return tableName + Const.LINE + compressTimeBucket(timeBucket / 10000, DAY_STEP);\n                case Day:\n                    return tableName + Const.LINE + compressTimeBucket(timeBucket, DAY_STEP);\n                case Second:\n                    return tableName + Const.LINE + compressTimeBucket(timeBucket / 1000000, DAY_STEP);\n                default:\n                    throw new UnexpectedException(\"Unexpected down sampling value, \" + model.getDownsampling());\n            }\n        }\n    }\n\n    /**\n     * @return the index represented time, which is included in the index name.\n     */\n    static long isolateTimeFromIndexName(String indexName) {\n        return Long.parseLong(indexName.substring(indexName.lastIndexOf(Const.LINE) + 1));\n    }\n\n    /**\n     * Follow the dayStep to re-format the time bucket literal long value.\n     *\n     * Such as, in dayStep == 11,\n     *\n     * 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123\n     * re-formatted time bucket is 20000123\n     */\n    static long compressTimeBucket(long timeBucket, int dayStep) {\n        if (dayStep > 1) {\n            DateTime time = TIME_BUCKET_FORMATTER.parseDateTime(\"\" + timeBucket);\n            int days = Days.daysBetween(DAY_ONE, time).getDays();\n            int groupBucketOffset = days % dayStep;\n            return Long.parseLong(time.minusDays(groupBucketOffset).toString(TIME_BUCKET_FORMATTER));\n        } else {\n            /*\n             * No calculation required. dayStep is for lower traffic. For normally configuration, there is pointless to calculate.\n             */\n            return timeBucket;\n        }\n    }\n\n    static long compressDateTime(DateTime time, int dayStep) {\n        if (dayStep > 1) {\n            int days = Days.daysBetween(DAY_ONE, time).getDays();\n            int groupBucketOffset = days % dayStep;\n            return Long.parseLong(time.minusDays(groupBucketOffset).toString(TIME_BUCKET_FORMATTER));\n        } else {\n            /**\n             * No calculation required. dayStep is for lower traffic. For normally configuration, there is pointless to calculate.\n             */\n            return Long.parseLong(time.toString(TIME_BUCKET_FORMATTER));\n        }\n    }\n\n}\n",
      "file_name": "TimeSeriesUtils.java",
      "human_label": "Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.",
      "level": "project_runnable",
      "lineno": "143",
      "name": "compressTimeBucket",
      "oracle_context": "{ \"apis\" : \"[parseDateTime, getDays, daysBetween, parseLong, toString, minusDays]\", \"classes\" : \"[DateTime]\", \"vars\" : \"[TIME_BUCKET_FORMATTER, DAY_ONE]\" }",
      "package": "org.apache.skywalking.oap.server.storage.plugin.elasticsearch.base",
      "project": "skywalking-master"
    },
    {
      "_id": "636767a41a6d9265ec01856c",
      "all_context": "{ \"class_level\" : \"import java.io.UTFDataFormatException;\\nimport java.io.UnsupportedEncodingException;\\nimport static java.lang.Character.MIN_HIGH_SURROGATE;\\nimport static java.lang.Character.MIN_LOW_SURROGATE;\\nimport static java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT;\\nint[] sizeTable;\\nchar[] DigitTens;\\nchar[] DigitOnes;\\nchar[] digits;\\nbyte[] INT_MIN_VALUE;\\nbyte[] LONG_MIN_VALUE;\\nint TWO_BYTE_LOWER_LIMIT;\\nint ONE_BYTE_EXCLUSIVE;\\nint THREE_BYTE_LOWER_LIMIT;\\nint TWO_BYTE_EXCLUSIVE;\\nint FOUR_BYTE_LOWER_LIMIT;\\nint THREE_BYTE_EXCLUSIVE;\\nint FIVE_BYTE_LOWER_LIMIT;\\nint FOUR_BYTE_EXCLUSIVE;\\nboolean CESU8_COMPAT;\\nStringSerializer();\\nputBytesFromInt(int i,int offset,int size,byte[] buf);\\nputBytesFromLong(long i,int offset,int size,byte[] buf);\\nstringSize(int x);\\nstringSize(long x);\\nwriteLong(long value,WriteSession session,LinkedBuffer lb);\\nwriteFloat(float value,WriteSession session,LinkedBuffer lb);\\nwriteDouble(double value,WriteSession session,LinkedBuffer lb);\\ncomputeUTF8Size(CharSequence str,int index,int len);\\nwriteUTF8(CharSequence str,int i,int len,byte[] buffer,int offset,int limit,WriteSession session,LinkedBuffer lb);\\nwriteUTF8(CharSequence str,int i,int len,WriteSession session,LinkedBuffer lb);\\nwriteUTF8(CharSequence str,WriteSession session,LinkedBuffer lb);\\nwriteAscii(CharSequence str,WriteSession session,LinkedBuffer lb);\\nwriteFixed2ByteInt(int value,byte[] buffer,int offset,boolean littleEndian);\\nwriteUTF8FixedDelimited(CharSequence str,WriteSession session,LinkedBuffer lb);\\nwriteUTF8FixedDelimited(CharSequence str,boolean littleEndian,WriteSession session,LinkedBuffer lb);\\nwriteUTF8OneByteDelimited(CharSequence str,int index,int len,WriteSession session,LinkedBuffer lb);\\nwriteUTF8VarDelimited(CharSequence str,int index,int len,int lowerLimit,int expectedSize,WriteSession session,LinkedBuffer lb);\\nwriteUTF8VarDelimited(CharSequence str,WriteSession session,LinkedBuffer lb);\\nSTRING();\\ndeser(byte[] nonNullValue);\\ndeser(byte[] nonNullValue,int offset,int len);\\ndeserCustomOnly(byte[] nonNullValue);\\nser(String nonNullValue);\\nreadUTF(byte[] buffer,int offset,int len);\\nhighSurrogate(int codePoint);\\nlowSurrogate(int codePoint);\\nwriteInt(int value,WriteSession session,LinkedBuffer lb);\\n\", \"repo_level\" : \"\" }",
      "class_name": "StringSerializer",
      "code": "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n  int size=len;\n  for (int i=index; i < len; i++) {\n    final char c=str.charAt(i);\n    if (c < 0x0080)     continue;\n    if (c < 0x0800)     size++;\n else     size+=2;\n  }\n  return size;\n}\n",
      "docstring": "/** \n * Computes the size of the utf8 string beginning at the specified  {@code index} with the specified {@code length}.\n */\n",
      "end_lineno": "335",
      "file_content": "package io.protostuff;\r\n\r\nimport java.io.UTFDataFormatException;\r\nimport java.io.UnsupportedEncodingException;\r\n\r\nimport static java.lang.Character.MIN_HIGH_SURROGATE;\r\nimport static java.lang.Character.MIN_LOW_SURROGATE;\r\nimport static java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT;\r\n\r\n/**\r\n * UTF-8 String serialization\r\n *\r\n * @author David Yu\r\n * @created Feb 4, 2010\r\n */\r\npublic final class StringSerializer\r\n{\r\n\r\n    private StringSerializer()\r\n    {\r\n    }\r\n\r\n    /**\r\n     * From {@link java.lang.Integer#toString(int)}\r\n     */\r\n    static final int[] sizeTable = new int[] {\r\n            9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, Integer.MAX_VALUE\r\n    };\r\n\r\n    static final char[] DigitTens = {\r\n            '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\r\n            '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',\r\n            '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',\r\n            '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',\r\n            '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\r\n            '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',\r\n            '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',\r\n            '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',\r\n            '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',\r\n            '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',\r\n    };\r\n\r\n    static final char[] DigitOnes = {\r\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n    };\r\n\r\n    static final char[] digits = {\r\n            '0', '1', '2', '3', '4', '5',\r\n            '6', '7', '8', '9', 'a', 'b',\r\n            'c', 'd', 'e', 'f', 'g', 'h',\r\n            'i', 'j', 'k', 'l', 'm', 'n',\r\n            'o', 'p', 'q', 'r', 's', 't',\r\n            'u', 'v', 'w', 'x', 'y', 'z'\r\n    };\r\n\r\n    static final byte[] INT_MIN_VALUE = new byte[] {\r\n            (byte) '-',\r\n            (byte) '2',\r\n            (byte) '1', (byte) '4', (byte) '7',\r\n            (byte) '4', (byte) '8', (byte) '3',\r\n            (byte) '6', (byte) '4', (byte) '8'\r\n    };\r\n\r\n    static final byte[] LONG_MIN_VALUE = new byte[] {\r\n            (byte) '-',\r\n            (byte) '9',\r\n            (byte) '2', (byte) '2', (byte) '3',\r\n            (byte) '3', (byte) '7', (byte) '2',\r\n            (byte) '0', (byte) '3', (byte) '6',\r\n            (byte) '8', (byte) '5', (byte) '4',\r\n            (byte) '7', (byte) '7', (byte) '5',\r\n            (byte) '8', (byte) '0', (byte) '8'\r\n    };\r\n\r\n    static final int TWO_BYTE_LOWER_LIMIT = 1 << 7;\r\n\r\n    static final int ONE_BYTE_EXCLUSIVE = TWO_BYTE_LOWER_LIMIT / 3 + 1;\r\n\r\n    static final int THREE_BYTE_LOWER_LIMIT = 1 << 14;\r\n\r\n    static final int TWO_BYTE_EXCLUSIVE = THREE_BYTE_LOWER_LIMIT / 3 + 1;\r\n\r\n    static final int FOUR_BYTE_LOWER_LIMIT = 1 << 21;\r\n\r\n    static final int THREE_BYTE_EXCLUSIVE = FOUR_BYTE_LOWER_LIMIT / 3 + 1;\r\n\r\n    static final int FIVE_BYTE_LOWER_LIMIT = 1 << 28;\r\n\r\n    static final int FOUR_BYTE_EXCLUSIVE = FIVE_BYTE_LOWER_LIMIT / 3 + 1;\r\n\r\n    static void putBytesFromInt(int i, final int offset, final int size, final byte[] buf)\r\n    {\r\n        int q, r;\r\n        int charPos = offset + size;\r\n        char sign = 0;\r\n\r\n        if (i < 0)\r\n        {\r\n            sign = '-';\r\n            i = -i;\r\n        }\r\n\r\n        // Generate two digits per iteration\r\n        while (i >= 65536)\r\n        {\r\n            q = i / 100;\r\n            // really: r = i - (q * 100);\r\n            r = i - ((q << 6) + (q << 5) + (q << 2));\r\n            i = q;\r\n            buf[--charPos] = (byte) DigitOnes[r];\r\n            buf[--charPos] = (byte) DigitTens[r];\r\n        }\r\n\r\n        // Fall thru to fast mode for smaller numbers\r\n        // assert(i <= 65536, i);\r\n        for (;;)\r\n        {\r\n            q = (i * 52429) >>> (16 + 3);\r\n            r = i - ((q << 3) + (q << 1)); // r = i-(q*10) ...\r\n            buf[--charPos] = (byte) digits[r];\r\n            i = q;\r\n            if (i == 0)\r\n                break;\r\n        }\r\n        if (sign != 0)\r\n        {\r\n            buf[--charPos] = (byte) sign;\r\n        }\r\n    }\r\n\r\n    static void putBytesFromLong(long i, final int offset, int size, final byte[] buf)\r\n    {\r\n        long q;\r\n        int r;\r\n        int charPos = offset + size;\r\n        char sign = 0;\r\n\r\n        if (i < 0)\r\n        {\r\n            sign = '-';\r\n            i = -i;\r\n        }\r\n\r\n        // Get 2 digits/iteration using longs until quotient fits into an int\r\n        while (i > Integer.MAX_VALUE)\r\n        {\r\n            q = i / 100;\r\n            // really: r = i - (q * 100);\r\n            r = (int) (i - ((q << 6) + (q << 5) + (q << 2)));\r\n            i = q;\r\n            buf[--charPos] = (byte) DigitOnes[r];\r\n            buf[--charPos] = (byte) DigitTens[r];\r\n        }\r\n\r\n        // Get 2 digits/iteration using ints\r\n        int q2;\r\n        int i2 = (int) i;\r\n        while (i2 >= 65536)\r\n        {\r\n            q2 = i2 / 100;\r\n            // really: r = i2 - (q * 100);\r\n            r = i2 - ((q2 << 6) + (q2 << 5) + (q2 << 2));\r\n            i2 = q2;\r\n            buf[--charPos] = (byte) DigitOnes[r];\r\n            buf[--charPos] = (byte) DigitTens[r];\r\n        }\r\n\r\n        // Fall thru to fast mode for smaller numbers\r\n        // assert(i2 <= 65536, i2);\r\n        for (;;)\r\n        {\r\n            q2 = (i2 * 52429) >>> (16 + 3);\r\n            r = i2 - ((q2 << 3) + (q2 << 1)); // r = i2-(q2*10) ...\r\n            buf[--charPos] = (byte) digits[r];\r\n            i2 = q2;\r\n            if (i2 == 0)\r\n                break;\r\n        }\r\n        if (sign != 0)\r\n        {\r\n            buf[--charPos] = (byte) sign;\r\n        }\r\n    }\r\n\r\n    // Requires positive x\r\n    static int stringSize(int x)\r\n    {\r\n        for (int i = 0;; i++)\r\n        {\r\n            if (x <= sizeTable[i])\r\n                return i + 1;\r\n        }\r\n    }\r\n\r\n    // Requires positive x\r\n    static int stringSize(long x)\r\n    {\r\n        long p = 10;\r\n        for (int i = 1; i < 19; i++)\r\n        {\r\n            if (x < p)\r\n                return i;\r\n            p = 10 * p;\r\n        }\r\n        return 19;\r\n    }\r\n\r\n    /**\r\n     * Writes the stringified int into the {@link LinkedBuffer}.\r\n     */\r\n    public static LinkedBuffer writeInt(final int value, final WriteSession session,\r\n            LinkedBuffer lb)\r\n    {\r\n        if (value == Integer.MIN_VALUE)\r\n        {\r\n            final int valueLen = INT_MIN_VALUE.length;\r\n            if (lb.offset + valueLen > lb.buffer.length)\r\n            {\r\n                // not enough size\r\n                lb = new LinkedBuffer(session.nextBufferSize, lb);\r\n            }\r\n\r\n            System.arraycopy(INT_MIN_VALUE, 0, lb.buffer, lb.offset, valueLen);\r\n\r\n            lb.offset += valueLen;\r\n            session.size += valueLen;\r\n\r\n            return lb;\r\n        }\r\n\r\n        final int size = (value < 0) ? stringSize(-value) + 1 : stringSize(value);\r\n\r\n        if (lb.offset + size > lb.buffer.length)\r\n        {\r\n            // not enough size\r\n            lb = new LinkedBuffer(session.nextBufferSize, lb);\r\n        }\r\n\r\n        putBytesFromInt(value, lb.offset, size, lb.buffer);\r\n\r\n        lb.offset += size;\r\n        session.size += size;\r\n\r\n        return lb;\r\n    }\r\n\r\n    /**\r\n     * Writes the stringified long into the {@link LinkedBuffer}.\r\n     */\r\n    public static LinkedBuffer writeLong(final long value, final WriteSession session,\r\n            LinkedBuffer lb)\r\n    {\r\n        if (value == Long.MIN_VALUE)\r\n        {\r\n            final int valueLen = LONG_MIN_VALUE.length;\r\n            if (lb.offset + valueLen > lb.buffer.length)\r\n            {\r\n                // TODO space efficiency (slower path)\r\n                // not enough size\r\n                lb = new LinkedBuffer(session.nextBufferSize, lb);\r\n            }\r\n\r\n            System.arraycopy(LONG_MIN_VALUE, 0, lb.buffer, lb.offset, valueLen);\r\n\r\n            lb.offset += valueLen;\r\n            session.size += valueLen;\r\n\r\n            return lb;\r\n        }\r\n\r\n        final int size = (value < 0) ? stringSize(-value) + 1 : stringSize(value);\r\n\r\n        if (lb.offset + size > lb.buffer.length)\r\n        {\r\n            // TODO space efficiency (slower path)\r\n            // not enough size\r\n            lb = new LinkedBuffer(session.nextBufferSize, lb);\r\n        }\r\n\r\n        putBytesFromLong(value, lb.offset, size, lb.buffer);\r\n\r\n        lb.offset += size;\r\n        session.size += size;\r\n\r\n        return lb;\r\n    }\r\n\r\n    /**\r\n     * Writes the stringified float into the {@link LinkedBuffer}. TODO - skip string conversion and write directly to\r\n     * buffer\r\n     */\r\n    public static LinkedBuffer writeFloat(final float value, final WriteSession session,\r\n            final LinkedBuffer lb)\r\n    {\r\n        return writeAscii(Float.toString(value), session, lb);\r\n    }\r\n\r\n    /**\r\n     * Writes the stringified double into the {@link LinkedBuffer}. TODO - skip string conversion and write directly to\r\n     * buffer\r\n     */\r\n    public static LinkedBuffer writeDouble(final double value, final WriteSession session,\r\n            final LinkedBuffer lb)\r\n    {\r\n        return writeAscii(Double.toString(value), session, lb);\r\n    }\r\n\r\n    /**\r\n     * Computes the size of the utf8 string beginning at the specified {@code index} with the specified {@code length}.\r\n     */\r\n    public static int computeUTF8Size(final CharSequence str, final int index, final int len)\r\n    {\r\n        int size = len;\r\n        for (int i = index; i < len; i++)\r\n        {\r\n            final char c = str.charAt(i);\r\n            if (c < 0x0080)\r\n                continue;\r\n\r\n            if (c < 0x0800)\r\n                size++;\r\n            else\r\n                size += 2;\r\n        }\r\n        return size;\r\n    }\r\n\r\n    /**\r\n     * Slow path. It checks the limit before every write. Shared with StreamedStringSerializer.\r\n     */\r\n    static LinkedBuffer writeUTF8(final CharSequence str, int i, final int len,\r\n            byte[] buffer, int offset, int limit,\r\n            final WriteSession session, LinkedBuffer lb)\r\n    {\r\n        for (char c = 0;; c = 0)\r\n        {\r\n            while (i != len && offset != limit && (c = str.charAt(i++)) < 0x0080)\r\n                buffer[offset++] = (byte) c;\r\n\r\n            if (i == len && c < 0x0080)\r\n            {\r\n                session.size += (offset - lb.offset);\r\n                lb.offset = offset;\r\n                return lb;\r\n            }\r\n\r\n            if (offset == limit)\r\n            {\r\n                // we are done with this LinkedBuffer\r\n                session.size += (offset - lb.offset);\r\n                lb.offset = offset;\r\n\r\n                if (lb.next == null)\r\n                {\r\n                    // reset\r\n                    offset = 0;\r\n                    limit = session.nextBufferSize;\r\n                    buffer = new byte[limit];\r\n                    // grow\r\n                    lb = new LinkedBuffer(buffer, 0, lb);\r\n                }\r\n                else\r\n                {\r\n                    // use the existing buffer from previous utf8 write.\r\n                    // this condition happens only on streaming mode\r\n                    lb = lb.next;\r\n                    // reset\r\n                    lb.offset = offset = lb.start;\r\n                    buffer = lb.buffer;\r\n                    limit = buffer.length;\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            if (c < 0x0800)\r\n            {\r\n                if (offset == limit)\r\n                {\r\n                    // we are done with this LinkedBuffer\r\n                    session.size += (offset - lb.offset);\r\n                    lb.offset = offset;\r\n\r\n                    if (lb.next == null)\r\n                    {\r\n                        // reset\r\n                        offset = 0;\r\n                        limit = session.nextBufferSize;\r\n                        buffer = new byte[limit];\r\n                        // grow\r\n                        lb = new LinkedBuffer(buffer, 0, lb);\r\n                    }\r\n                    else\r\n                    {\r\n                        // use the existing buffer from previous utf8 write.\r\n                        // this condition happens only on streaming mode\r\n                        lb = lb.next;\r\n                        // reset\r\n                        lb.offset = offset = lb.start;\r\n                        buffer = lb.buffer;\r\n                        limit = buffer.length;\r\n                    }\r\n                }\r\n\r\n                buffer[offset++] = (byte) (0xC0 | ((c >> 6) & 0x1F));\r\n\r\n                if (offset == limit)\r\n                {\r\n                    // we are done with this LinkedBuffer\r\n                    session.size += (offset - lb.offset);\r\n                    lb.offset = offset;\r\n\r\n                    if (lb.next == null)\r\n                    {\r\n                        // reset\r\n                        offset = 0;\r\n                        limit = session.nextBufferSize;\r\n                        buffer = new byte[limit];\r\n                        // grow\r\n                        lb = new LinkedBuffer(buffer, 0, lb);\r\n                    }\r\n                    else\r\n                    {\r\n                        // use the existing buffer from previous utf8 write.\r\n                        // this condition happens only on streaming mode\r\n                        lb = lb.next;\r\n                        // reset\r\n                        lb.offset = offset = lb.start;\r\n                        buffer = lb.buffer;\r\n                        limit = buffer.length;\r\n                    }\r\n                }\r\n\r\n                buffer[offset++] = (byte) (0x80 | ((c >> 0) & 0x3F));\r\n            }\r\n            else if (Character.isHighSurrogate((char) c) && i < len && Character.isLowSurrogate((char) str.charAt(i)))\r\n            {\r\n                // We have a surrogate pair, so use the 4-byte encoding.\r\n                if (offset == limit)\r\n                {\r\n                    // we are done with this LinkedBuffer\r\n                    session.size += (offset - lb.offset);\r\n                    lb.offset = offset;\r\n\r\n                    if (lb.next == null)\r\n                    {\r\n                        // reset\r\n                        offset = 0;\r\n                        limit = session.nextBufferSize;\r\n                        buffer = new byte[limit];\r\n                        // grow\r\n                        lb = new LinkedBuffer(buffer, 0, lb);\r\n                    }\r\n                    else\r\n                    {\r\n                        // use the existing buffer from previous utf8 write.\r\n                        // this condition happens only on streaming mode\r\n                        lb = lb.next;\r\n                        // reset\r\n                        lb.offset = offset = lb.start;\r\n                        buffer = lb.buffer;\r\n                        limit = buffer.length;\r\n                    }\r\n                }\r\n\r\n                int codePoint = Character.toCodePoint((char) c, (char) str.charAt(i));\r\n\r\n                buffer[offset++] = (byte) (0xF0 | ((codePoint >> 18) & 0x07));\r\n\r\n                if (offset == limit)\r\n                {\r\n                    // we are done with this LinkedBuffer\r\n                    session.size += (offset - lb.offset);\r\n                    lb.offset = offset;\r\n\r\n                    if (lb.next == null)\r\n                    {\r\n                        // reset\r\n                        offset = 0;\r\n                        limit = session.nextBufferSize;\r\n                        buffer = new byte[limit];\r\n                        // grow\r\n                        lb = new LinkedBuffer(buffer, 0, lb);\r\n                    }\r\n                    else\r\n                    {\r\n                        // use the existing buffer from previous utf8 write.\r\n                        // this condition happens only on streaming mode\r\n                        lb = lb.next;\r\n                        // reset\r\n                        lb.offset = offset = lb.start;\r\n                        buffer = lb.buffer;\r\n                        limit = buffer.length;\r\n                    }\r\n                }\r\n\r\n                buffer[offset++] = (byte) (0x80 | ((codePoint >> 12) & 0x3F));\r\n\r\n                if (offset == limit)\r\n                {\r\n                    // we are done with this LinkedBuffer\r\n                    session.size += (offset - lb.offset);\r\n                    lb.offset = offset;\r\n\r\n                    if (lb.next == null)\r\n                    {\r\n                        // reset\r\n                        offset = 0;\r\n                        limit = session.nextBufferSize;\r\n                        buffer = new byte[limit];\r\n                        // grow\r\n                        lb = new LinkedBuffer(buffer, 0, lb);\r\n                    }\r\n                    else\r\n                    {\r\n                        // use the existing buffer from previous utf8 write.\r\n                        // this condition happens only on streaming mode\r\n                        lb = lb.next;\r\n                        // reset\r\n                        lb.offset = offset = lb.start;\r\n                        buffer = lb.buffer;\r\n                        limit = buffer.length;\r\n                    }\r\n                }\r\n\r\n                buffer[offset++] = (byte) (0x80 | ((codePoint >> 6) & 0x3F));\r\n\r\n                if (offset == limit)\r\n                {\r\n                    // we are done with this LinkedBuffer\r\n                    session.size += (offset - lb.offset);\r\n                    lb.offset = offset;\r\n\r\n                    if (lb.next == null)\r\n                    {\r\n                        // reset\r\n                        offset = 0;\r\n                        limit = session.nextBufferSize;\r\n                        buffer = new byte[limit];\r\n                        // grow\r\n                        lb = new LinkedBuffer(buffer, 0, lb);\r\n                    }\r\n                    else\r\n                    {\r\n                        // use the existing buffer from previous utf8 write.\r\n                        // this condition happens only on streaming mode\r\n                        lb = lb.next;\r\n                        // reset\r\n                        lb.offset = offset = lb.start;\r\n                        buffer = lb.buffer;\r\n                        limit = buffer.length;\r\n                    }\r\n                }\r\n\r\n                buffer[offset++] = (byte) (0x80 | ((codePoint >> 0) & 0x3F));\r\n\r\n                i++;\r\n            }\r\n            else\r\n            {\r\n                if (offset == limit)\r\n                {\r\n                    // we are done with this LinkedBuffer\r\n                    session.size += (offset - lb.offset);\r\n                    lb.offset = offset;\r\n\r\n                    if (lb.next == null)\r\n                    {\r\n                        // reset\r\n                        offset = 0;\r\n                        limit = session.nextBufferSize;\r\n                        buffer = new byte[limit];\r\n                        // grow\r\n                        lb = new LinkedBuffer(buffer, 0, lb);\r\n                    }\r\n                    else\r\n                    {\r\n                        // use the existing buffer from previous utf8 write.\r\n                        // this condition happens only on streaming mode\r\n                        lb = lb.next;\r\n                        // reset\r\n                        lb.offset = offset = lb.start;\r\n                        buffer = lb.buffer;\r\n                        limit = buffer.length;\r\n                    }\r\n                }\r\n\r\n                buffer[offset++] = (byte) (0xE0 | ((c >> 12) & 0x0F));\r\n\r\n                if (offset == limit)\r\n                {\r\n                    // we are done with this LinkedBuffer\r\n                    session.size += (offset - lb.offset);\r\n                    lb.offset = offset;\r\n\r\n                    if (lb.next == null)\r\n                    {\r\n                        // reset\r\n                        offset = 0;\r\n                        limit = session.nextBufferSize;\r\n                        buffer = new byte[limit];\r\n                        // grow\r\n                        lb = new LinkedBuffer(buffer, 0, lb);\r\n                    }\r\n                    else\r\n                    {\r\n                        // use the existing buffer from previous utf8 write.\r\n                        // this condition happens only on streaming mode\r\n                        lb = lb.next;\r\n                        // reset\r\n                        lb.offset = offset = lb.start;\r\n                        buffer = lb.buffer;\r\n                        limit = buffer.length;\r\n                    }\r\n                }\r\n\r\n                buffer[offset++] = (byte) (0x80 | ((c >> 6) & 0x3F));\r\n\r\n                if (offset == limit)\r\n                {\r\n                    // we are done with this LinkedBuffer\r\n                    session.size += (offset - lb.offset);\r\n                    lb.offset = offset;\r\n\r\n                    if (lb.next == null)\r\n                    {\r\n                        // reset\r\n                        offset = 0;\r\n                        limit = session.nextBufferSize;\r\n                        buffer = new byte[limit];\r\n                        // grow\r\n                        lb = new LinkedBuffer(buffer, 0, lb);\r\n                    }\r\n                    else\r\n                    {\r\n                        // use the existing buffer from previous utf8 write.\r\n                        // this condition happens only on streaming mode\r\n                        lb = lb.next;\r\n                        // reset\r\n                        lb.offset = offset = lb.start;\r\n                        buffer = lb.buffer;\r\n                        limit = buffer.length;\r\n                    }\r\n                }\r\n\r\n                buffer[offset++] = (byte) (0x80 | ((c >> 0) & 0x3F));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fast path. The {@link LinkedBuffer}'s capacity is >= string length.\r\n     */\r\n    static LinkedBuffer writeUTF8(final CharSequence str, int i, final int len,\r\n            final WriteSession session, final LinkedBuffer lb)\r\n    {\r\n        final byte[] buffer = lb.buffer;\r\n        for (int c = 0, offset = lb.offset, adjustableLimit = offset + len;; c = 0)\r\n        {\r\n            while (i != len && (c = str.charAt(i++)) < 0x0080)\r\n                buffer[offset++] = (byte) c;\r\n\r\n            if (i == len && c < 0x0080)\r\n            {\r\n                session.size += (offset - lb.offset);\r\n                lb.offset = offset;\r\n                return lb;\r\n            }\r\n\r\n            if (c < 0x0800)\r\n            {\r\n                if (++adjustableLimit > buffer.length)\r\n                {\r\n                    session.size += (offset - lb.offset);\r\n                    lb.offset = offset;\r\n                    return writeUTF8(str, i - 1, len, buffer, offset, buffer.length, session, lb);\r\n                }\r\n\r\n                buffer[offset++] = (byte) (0xC0 | ((c >> 6) & 0x1F));\r\n                buffer[offset++] = (byte) (0x80 | ((c >> 0) & 0x3F));\r\n            }\r\n            else if (Character.isHighSurrogate((char) c) && i < len && Character.isLowSurrogate((char) str.charAt(i)))\r\n            {\r\n                // We have a surrogate pair, so use the 4-byte encoding.\r\n                adjustableLimit += 3;\r\n                if (adjustableLimit > buffer.length)\r\n                {\r\n                    session.size += (offset - lb.offset);\r\n                    lb.offset = offset;\r\n                    return writeUTF8(str, i - 1, len, buffer, offset, buffer.length, session, lb);\r\n                }\r\n\r\n                int codePoint = Character.toCodePoint((char) c, (char) str.charAt(i));\r\n                buffer[offset++] = (byte) (0xF0 | ((codePoint >> 18) & 0x07));\r\n                buffer[offset++] = (byte) (0x80 | ((codePoint >> 12) & 0x3F));\r\n                buffer[offset++] = (byte) (0x80 | ((codePoint >> 6) & 0x3F));\r\n                buffer[offset++] = (byte) (0x80 | ((codePoint >> 0) & 0x3F));\r\n\r\n                i++;\r\n            }\r\n            else\r\n            {\r\n                adjustableLimit += 2;\r\n                if (adjustableLimit > buffer.length)\r\n                {\r\n                    session.size += (offset - lb.offset);\r\n                    lb.offset = offset;\r\n                    return writeUTF8(str, i - 1, len, buffer, offset, buffer.length, session, lb);\r\n                }\r\n\r\n                buffer[offset++] = (byte) (0xE0 | ((c >> 12) & 0x0F));\r\n                buffer[offset++] = (byte) (0x80 | ((c >> 6) & 0x3F));\r\n                buffer[offset++] = (byte) (0x80 | ((c >> 0) & 0x3F));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes the utf8-encoded bytes from the string into the {@link LinkedBuffer}.\r\n     */\r\n    public static LinkedBuffer writeUTF8(final CharSequence str, final WriteSession session,\r\n            final LinkedBuffer lb)\r\n    {\r\n        final int len = str.length();\r\n        if (len == 0)\r\n            return lb;\r\n\r\n        return lb.offset + len > lb.buffer.length ? writeUTF8(str, 0, len, lb.buffer, lb.offset,\r\n                lb.buffer.length, session, lb) : writeUTF8(str, 0, len, session, lb);\r\n    }\r\n\r\n    /**\r\n     * Writes the ascii bytes from the string into the {@link LinkedBuffer}. It is the responsibility of the caller to\r\n     * know in advance that the string is 100% ascii. E.g if you convert a double/float to a string, you are sure it\r\n     * only contains ascii chars.\r\n     */\r\n    public static LinkedBuffer writeAscii(final CharSequence str, final WriteSession session,\r\n            LinkedBuffer lb)\r\n    {\r\n        final int len = str.length();\r\n        if (len == 0)\r\n            return lb;\r\n\r\n        byte[] buffer = lb.buffer;\r\n        int offset = lb.offset, limit = lb.buffer.length;\r\n\r\n        // actual size\r\n        session.size += len;\r\n\r\n        if (offset + len > limit)\r\n        {\r\n            // slow path\r\n            for (int i = 0; i < len; i++)\r\n            {\r\n                if (offset == limit)\r\n                {\r\n                    // we are done with this LinkedBuffer\r\n                    lb.offset = offset;\r\n                    // reset\r\n                    offset = 0;\r\n                    limit = session.nextBufferSize;\r\n                    buffer = new byte[limit];\r\n                    // grow\r\n                    lb = new LinkedBuffer(buffer, 0, lb);\r\n                }\r\n                buffer[offset++] = (byte) str.charAt(i);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            // fast path\r\n            for (int i = 0; i < len; i++)\r\n                buffer[offset++] = (byte) str.charAt(i);\r\n        }\r\n\r\n        lb.offset = offset;\r\n\r\n        return lb;\r\n    }\r\n\r\n    static void writeFixed2ByteInt(final int value, final byte[] buffer, int offset,\r\n            final boolean littleEndian)\r\n    {\r\n        if (littleEndian)\r\n        {\r\n            buffer[offset++] = (byte) value;\r\n            buffer[offset] = (byte) ((value >>> 8) & 0xFF);\r\n        }\r\n        else\r\n        {\r\n            buffer[offset++] = (byte) ((value >>> 8) & 0xFF);\r\n            buffer[offset] = (byte) value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The length of the utf8 bytes is written first (big endian) before the string - which is fixed 2-bytes. Same\r\n     * behavior as {@link java.io.DataOutputStream#writeUTF(String)}.\r\n     */\r\n    public static LinkedBuffer writeUTF8FixedDelimited(final CharSequence str,\r\n            final WriteSession session, LinkedBuffer lb)\r\n    {\r\n        return writeUTF8FixedDelimited(str, false, session, lb);\r\n    }\r\n\r\n    /**\r\n     * The length of the utf8 bytes is written first before the string - which is fixed 2-bytes.\r\n     */\r\n    public static LinkedBuffer writeUTF8FixedDelimited(final CharSequence str,\r\n            final boolean littleEndian, final WriteSession session, LinkedBuffer lb)\r\n    {\r\n        final int lastSize = session.size, len = str.length(), withIntOffset = lb.offset + 2;\r\n\r\n        if (withIntOffset > lb.buffer.length)\r\n        {\r\n            // not enough space for int (2 bytes).\r\n            // create a new buffer.\r\n            lb = new LinkedBuffer(len + 2 > session.nextBufferSize ? len + 2 : session.nextBufferSize,\r\n                    lb);\r\n\r\n            lb.offset = 2;\r\n\r\n            if (len == 0)\r\n            {\r\n                writeFixed2ByteInt(0, lb.buffer, 0, littleEndian);\r\n                // update size\r\n                session.size += 2;\r\n                return lb;\r\n            }\r\n\r\n            // fast path\r\n            final LinkedBuffer rb = writeUTF8(str, 0, len, session, lb);\r\n\r\n            writeFixed2ByteInt((session.size - lastSize), lb.buffer, 0, littleEndian);\r\n\r\n            // update size\r\n            session.size += 2;\r\n\r\n            return rb;\r\n        }\r\n\r\n        if (len == 0)\r\n        {\r\n            writeFixed2ByteInt(0, lb.buffer, lb.offset, littleEndian);\r\n            lb.offset = withIntOffset;\r\n            // update size\r\n            session.size += 2;\r\n            return lb;\r\n        }\r\n\r\n        if (withIntOffset + len > lb.buffer.length)\r\n        {\r\n            // not enough space for the string.\r\n            lb.offset = withIntOffset;\r\n\r\n            // slow path\r\n            final LinkedBuffer rb = writeUTF8(str, 0, len,\r\n                    lb.buffer, withIntOffset, lb.buffer.length, session, lb);\r\n\r\n            writeFixed2ByteInt((session.size - lastSize), lb.buffer,\r\n                    withIntOffset - 2, littleEndian);\r\n\r\n            // update size\r\n            session.size += 2;\r\n\r\n            return rb;\r\n        }\r\n\r\n        // everything fits\r\n        lb.offset = withIntOffset;\r\n\r\n        final LinkedBuffer rb = writeUTF8(str, 0, len, session, lb);\r\n\r\n        writeFixed2ByteInt((session.size - lastSize), lb.buffer,\r\n                withIntOffset - 2, littleEndian);\r\n\r\n        // update size\r\n        session.size += 2;\r\n\r\n        return rb;\r\n    }\r\n\r\n    private static LinkedBuffer writeUTF8OneByteDelimited(final CharSequence str, final int index,\r\n            final int len, final WriteSession session, LinkedBuffer lb)\r\n    {\r\n        final int lastSize = session.size;\r\n\r\n        if (lb.offset == lb.buffer.length)\r\n        {\r\n            // create a new buffer.\r\n            lb = new LinkedBuffer(len + 1 > session.nextBufferSize ? len + 1 : session.nextBufferSize,\r\n                    lb);\r\n\r\n            lb.offset = 1;\r\n\r\n            // fast path\r\n            final LinkedBuffer rb = writeUTF8(str, index, len, session, lb);\r\n\r\n            lb.buffer[0] = (byte) (session.size - lastSize);\r\n\r\n            // update size\r\n            session.size++;\r\n\r\n            return rb;\r\n        }\r\n\r\n        final int withIntOffset = lb.offset + 1;\r\n        if (withIntOffset + len > lb.buffer.length)\r\n        {\r\n            // not enough space for the string.\r\n            lb.offset = withIntOffset;\r\n\r\n            final byte[] buffer = lb.buffer;\r\n\r\n            // slow path\r\n            final LinkedBuffer rb = writeUTF8(str, index, len, buffer, withIntOffset, buffer.length,\r\n                    session, lb);\r\n\r\n            buffer[withIntOffset - 1] = (byte) (session.size - lastSize);\r\n\r\n            // update size\r\n            session.size++;\r\n\r\n            return rb;\r\n        }\r\n\r\n        // everything fits\r\n        lb.offset = withIntOffset;\r\n\r\n        final LinkedBuffer rb = writeUTF8(str, index, len, session, lb);\r\n\r\n        lb.buffer[withIntOffset - 1] = (byte) (session.size - lastSize);\r\n\r\n        // update size\r\n        session.size++;\r\n\r\n        return rb;\r\n    }\r\n\r\n    private static LinkedBuffer writeUTF8VarDelimited(final CharSequence str, final int index,\r\n            final int len, final int lowerLimit, int expectedSize,\r\n            final WriteSession session, LinkedBuffer lb)\r\n    {\r\n        int lastSize = session.size, offset = lb.offset, withIntOffset = offset + expectedSize;\r\n\r\n        if (withIntOffset > lb.buffer.length)\r\n        {\r\n            // not enough space for the varint.\r\n            // create a new buffer.\r\n            lb = new LinkedBuffer(len + expectedSize > session.nextBufferSize ? len + expectedSize\r\n                    : session.nextBufferSize,\r\n                    lb);\r\n            offset = lb.start;\r\n            lb.offset = withIntOffset = offset + expectedSize;\r\n\r\n            // fast path\r\n            final LinkedBuffer rb = writeUTF8(str, index, len, session, lb);\r\n\r\n            int size = session.size - lastSize;\r\n\r\n            if (size < lowerLimit)\r\n            {\r\n                // move one space to the left since the varint is 1-byte smaller\r\n                System.arraycopy(lb.buffer, withIntOffset, lb.buffer, withIntOffset - 1,\r\n                        lb.offset - withIntOffset);\r\n\r\n                expectedSize--;\r\n                lb.offset--;\r\n            }\r\n\r\n            // update size\r\n            session.size += expectedSize;\r\n\r\n            for (; --expectedSize > 0; size >>>= 7)\r\n                lb.buffer[offset++] = (byte) ((size & 0x7F) | 0x80);\r\n\r\n            lb.buffer[offset] = (byte) (size);\r\n\r\n            return rb;\r\n        }\r\n\r\n        if (withIntOffset + len > lb.buffer.length)\r\n        {\r\n            // not enough space for the string.\r\n            lb.offset = withIntOffset;\r\n\r\n            // slow path\r\n            final LinkedBuffer rb = writeUTF8(str, index, len,\r\n                    lb.buffer, withIntOffset, lb.buffer.length, session, lb);\r\n\r\n            int size = session.size - lastSize;\r\n\r\n            if (size < lowerLimit)\r\n            {\r\n                // move one space to the left since the varint is 1-byte smaller\r\n                System.arraycopy(lb.buffer, withIntOffset, lb.buffer, withIntOffset - 1,\r\n                        lb.offset - withIntOffset);\r\n\r\n                expectedSize--;\r\n                lb.offset--;\r\n            }\r\n\r\n            // update size\r\n            session.size += expectedSize;\r\n\r\n            for (; --expectedSize > 0; size >>>= 7)\r\n                lb.buffer[offset++] = (byte) ((size & 0x7F) | 0x80);\r\n\r\n            lb.buffer[offset] = (byte) (size);\r\n\r\n            return rb;\r\n        }\r\n\r\n        // everything fits\r\n        lb.offset = withIntOffset;\r\n\r\n        final LinkedBuffer rb = writeUTF8(str, index, len, session, lb);\r\n\r\n        int size = session.size - lastSize;\r\n\r\n        if (size < lowerLimit)\r\n        {\r\n            // move one space to the left since the varint is 1-byte smaller\r\n            System.arraycopy(lb.buffer, withIntOffset, lb.buffer, withIntOffset - 1,\r\n                    lb.offset - withIntOffset);\r\n\r\n            expectedSize--;\r\n            lb.offset--;\r\n        }\r\n\r\n        // update size\r\n        session.size += expectedSize;\r\n\r\n        for (; --expectedSize > 0; size >>>= 7)\r\n            lb.buffer[offset++] = (byte) ((size & 0x7F) | 0x80);\r\n\r\n        lb.buffer[offset] = (byte) (size);\r\n\r\n        return rb;\r\n    }\r\n\r\n    /**\r\n     * The length of the utf8 bytes is written first before the string - which is a variable int (1 to 5 bytes).\r\n     */\r\n    public static LinkedBuffer writeUTF8VarDelimited(final CharSequence str, final WriteSession session,\r\n            LinkedBuffer lb)\r\n    {\r\n        final int len = str.length();\r\n        if (len == 0)\r\n        {\r\n            if (lb.offset == lb.buffer.length)\r\n            {\r\n                // buffer full\r\n                lb = new LinkedBuffer(session.nextBufferSize, lb);\r\n            }\r\n\r\n            // write zero\r\n            lb.buffer[lb.offset++] = 0x00;\r\n            // update size\r\n            session.size++;\r\n            return lb;\r\n        }\r\n\r\n        if (len < ONE_BYTE_EXCLUSIVE)\r\n        {\r\n            // the varint will be max 1-byte. (even if all chars are non-ascii)\r\n            return writeUTF8OneByteDelimited(str, 0, len, session, lb);\r\n        }\r\n\r\n        if (len < TWO_BYTE_EXCLUSIVE)\r\n        {\r\n            // the varint will be max 2-bytes and could be 1-byte. (even if all non-ascii)\r\n            return writeUTF8VarDelimited(str, 0, len, TWO_BYTE_LOWER_LIMIT, 2,\r\n                    session, lb);\r\n        }\r\n\r\n        if (len < THREE_BYTE_EXCLUSIVE)\r\n        {\r\n            // the varint will be max 3-bytes and could be 2-bytes. (even if all non-ascii)\r\n            return writeUTF8VarDelimited(str, 0, len, THREE_BYTE_LOWER_LIMIT, 3,\r\n                    session, lb);\r\n        }\r\n\r\n        if (len < FOUR_BYTE_EXCLUSIVE)\r\n        {\r\n            // the varint will be max 4-bytes and could be 3-bytes. (even if all non-ascii)\r\n            return writeUTF8VarDelimited(str, 0, len, FOUR_BYTE_LOWER_LIMIT, 4,\r\n                    session, lb);\r\n        }\r\n\r\n        // the varint will be max 5-bytes and could be 4-bytes. (even if all non-ascii)\r\n        return writeUTF8VarDelimited(str, 0, len, FIVE_BYTE_LOWER_LIMIT, 5, session, lb);\r\n    }\r\n\r\n    public static final class STRING\r\n    {\r\n        static final boolean CESU8_COMPAT = Boolean.getBoolean(\"io.protostuff.cesu8_compat\");\r\n\r\n        private STRING()\r\n        {\r\n        }\r\n\r\n        public static String deser(byte[] nonNullValue)\r\n        {\r\n            return deser(nonNullValue, 0, nonNullValue.length);\r\n        }\r\n\r\n        public static String deser(byte[] nonNullValue, int offset, int len)\r\n        {\r\n            final String result;\r\n            try\r\n            {\r\n                // Try to use the built in deserialization first, since we expect\r\n                // that the most likely case is a valid UTF-8 encoded byte array.\r\n                // Additionally, the built in serialization method has one less\r\n                // char[] copy than readUTF.\r\n                //\r\n                // If, however, there are invalid/malformed characters, i.e. 3-byte\r\n                // surrogates / 3-byte surrogate pairs, we should fall back to the\r\n                // readUTF method as it should be able to properly handle 3-byte surrogates\r\n                // (and therefore 6-byte surrogate pairs) in Java 8+.\r\n                //\r\n                // While Protostuff and many other applications, still use 3-byte surrogates\r\n                // / 6-byte surrogate pairs, the standard 'forbids' their use, and Java 8\r\n                // has started to enforce the standard, resulting in 'corrupted' data in\r\n                // strings when decoding using new String(nonNullValue, \"UTF-8\");\r\n                //\r\n                // While the readUTF should be able to handle both Standard Unicode\r\n                // (i.e. new String().getBytes(\"UTF-8\") and the Legacy Unicode\r\n                // (with 3-byte surrogates, used in CESU-8 and Modified UTF-8),\r\n                // we don't want to introduce an unexpected loss of data due to\r\n                // some unforseen bug. As a result, a fallback mechanism is in\r\n                // place such that the worst case scenario results in the previous\r\n                // implementation's behaviour.\r\n                //\r\n                // For the Java 8 change, see: https://bugs.openjdk.java.net/browse/JDK-7096080\r\n\r\n                result = new String(nonNullValue, offset, len, \"UTF-8\");\r\n\r\n                // Check if we should scan the string to make sure there were no\r\n                // corrupt characters caused by 3-byte / 6-byte surrogate pairs.\r\n                //\r\n                // In general, this *should* only be required for systems reading\r\n                // data stored using legacy protostuff. Moving forward, the data\r\n                // should be readable by new String(\"UTF-8\"), so the scan is unnecessary.\r\n                if (CESU8_COMPAT && result.indexOf(0xfffd) != -1)\r\n                {\r\n                    // If it contains the REPLACEMENT character, then there's a strong\r\n                    // possibility of it containing 3-byte surrogates / 6-byte surrogate\r\n                    // pairs, and we should try decoding using readUTF to handle it.\r\n                    try\r\n                    {\r\n                        return readUTF(nonNullValue, offset, len);\r\n                    }\r\n                    catch (UTFDataFormatException e)\r\n                    {\r\n                        // Unexpected, but most systems previously using\r\n                        // Protostuff don't expect error to occur from\r\n                        // String deserialization, so we use this just in case.\r\n                        return result;\r\n                    }\r\n                }\r\n            }\r\n            catch (UnsupportedEncodingException e)\r\n            {\r\n                throw new RuntimeException(e);\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Deserialize using readUTF only.\r\n         *\r\n         * @param nonNullValue\r\n         * @return\r\n         */\r\n        static String deserCustomOnly(byte[] nonNullValue)\r\n        {\r\n            try\r\n            {\r\n                // Same behaviour as deser(), but does NOT\r\n                // fall back to old implementation.\r\n                return readUTF(nonNullValue, 0, nonNullValue.length);\r\n            }\r\n            catch (UTFDataFormatException e)\r\n            {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n\r\n        public static byte[] ser(String nonNullValue)\r\n        {\r\n            try\r\n            {\r\n                return nonNullValue.getBytes(\"UTF-8\");\r\n            }\r\n            catch (UnsupportedEncodingException e)\r\n            {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reads the string from a byte[] using that was encoded a using Modified UTF-8 format. Additionally supports\r\n         * 4-byte surrogates, de-serializing them as surrogate pairs.\r\n         *\r\n         * See: http://en.wikipedia.org/wiki/UTF-8#Description for encoding details.\r\n         */\r\n        private static String readUTF(byte[] buffer, int offset, int len) throws UTFDataFormatException\r\n        {\r\n            char[] charArray = new char[len];\r\n\r\n            int i = 0;\r\n            int c = 0;\r\n\r\n            // Optimizaiton: Assume that the characters are all 7-bits encodable\r\n            // (which is most likely the standard case).\r\n            // If they're not, break out and take the 'slow' path.\r\n            for (; i < len; i++)\r\n            {\r\n                int ch = (int) buffer[offset + i] & 0xff;\r\n\r\n                // If it's not 7-bit character, break out\r\n                if (ch > 127)\r\n                    break;\r\n\r\n                charArray[c++] = (char) ch;\r\n            }\r\n\r\n            // 'Slow' path\r\n            while (i < len)\r\n            {\r\n                int ch = (int) buffer[offset + i] & 0xff;\r\n\r\n                // Determine how to decode based on 'bits of code point'\r\n                // See: http://en.wikipedia.org/wiki/UTF-8#Description\r\n                int upperBits = ch >> 4;\r\n\r\n                if (upperBits <= 7)\r\n                {\r\n                    // 1-byte: 0xxxxxxx\r\n                    charArray[c++] = (char) ch;\r\n                    i++;\r\n                }\r\n                else if (upperBits == 0x0C || upperBits == 0x0D)\r\n                {\r\n                    // 2-byte: 110xxxxx 10xxxxxx\r\n                    i += 2;\r\n\r\n                    if (i > len)\r\n                        throw new UTFDataFormatException(\"Malformed input: Partial character at end\");\r\n\r\n                    int ch2 = (int) buffer[offset + i - 1];\r\n\r\n                    // Make sure the second byte has the form 10xxxxxx\r\n                    if ((ch2 & 0xC0) != 0x80)\r\n                        throw new UTFDataFormatException(\"Malformed input around byte \" + i);\r\n\r\n                    charArray[c++] = (char) (((ch & 0x1F) << 6) | (ch2 & 0x3F));\r\n                }\r\n                else if (upperBits == 0xE)\r\n                {\r\n                    // 3-byte: 1110xxxx 10xxxxxx 10xxxxxx\r\n                    i += 3;\r\n\r\n                    if (i > len)\r\n                        throw new UTFDataFormatException(\"Malformed input: Partial character at end\");\r\n\r\n                    int ch2 = (int) buffer[offset + i - 2];\r\n                    int ch3 = (int) buffer[offset + i - 1];\r\n\r\n                    // Check the 10xxxxxx 10xxxxxx of second two bytes\r\n                    if (((ch2 & 0xC0) != 0x80) || ((ch3 & 0xC0) != 0x80))\r\n                        throw new UTFDataFormatException(\"Malformed input around byte \" + (i - 1));\r\n\r\n                    charArray[c++] = (char) (((ch & 0x0F) << 12) | ((ch2 & 0x3F) << 6) | (ch3 & 0x3F));\r\n                }\r\n                else\r\n                {\r\n                    // 4-byte: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\r\n                    upperBits = ch >> 3;\r\n                    if (upperBits == 0x1E)\r\n                    {\r\n                        // Because we're now in the UTF-32 bit range, we must\r\n                        // break it down into the UTF-16 surrogate pairs for\r\n                        // Java's String class (which is UTF-16).\r\n\r\n                        i += 4;\r\n                        if (i > len)\r\n                            throw new UTFDataFormatException(\"Malformed input: Partial character at end\");\r\n\r\n                        int ch2 = (int) buffer[offset + i - 3];\r\n                        int ch3 = (int) buffer[offset + i - 2];\r\n                        int ch4 = (int) buffer[offset + i - 1];\r\n\r\n                        int value =\r\n                                ((ch & 0x07) << 18) |\r\n                                        ((ch2 & 0x3F) << 12) |\r\n                                        ((ch3 & 0x3F) << 6) |\r\n                                        ((ch4 & 0x3F));\r\n\r\n                        charArray[c++] = highSurrogate(value);\r\n                        charArray[c++] = lowSurrogate(value);\r\n                    }\r\n                    else\r\n                    {\r\n                        // Anything above\r\n                        throw new UTFDataFormatException(\"Malformed input at byte \" + i);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return new String(charArray, 0, c);\r\n        }\r\n    }\r\n\r\n\r\n    public static char highSurrogate(int codePoint) {\r\n        return (char) ((codePoint >>> 10)\r\n                + (MIN_HIGH_SURROGATE - (MIN_SUPPLEMENTARY_CODE_POINT >>> 10)));\r\n    }\r\n\r\n    public static char lowSurrogate(int codePoint) {\r\n        return (char) ((codePoint & 0x3ff) + MIN_LOW_SURROGATE);\r\n    }\r\n\r\n}\r\n",
      "file_name": "StringSerializer.java",
      "human_label": "Compute the size of the utf8 string beginning at the specified  index  with the specified length.",
      "level": "self_contained",
      "lineno": "317",
      "name": "computeUTF8Size",
      "oracle_context": "{ \"apis\" : \"[charAt]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
      "package": "io.protostuff",
      "project": "protostuff-master"
    },
    {
      "_id": "636766f01a6d9265ec017639",
      "all_context": "{ \"class_level\" : \"import java.io.IOException;\\nimport java.io.InputStream;\\nimport java.lang.reflect.Constructor;\\nimport java.lang.reflect.InvocationTargetException;\\nimport java.lang.reflect.Method;\\nimport java.lang.reflect.Modifier;\\nimport java.net.URL;\\nimport java.util.Arrays;\\nimport java.util.Collections;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.logging.Logger;\\nLogger logger;\\nint CR;\\nint LF;\\nHashMap<String,Class<?>> name2Class;\\nHashMap<Class<?>,String> class2Name;\\nHashMap<Class<?>,Method> class2Value;\\nfromName(String name);\\ntoName(Class type);\\nvalueOf(Class type,String value);\\nvalueOf(String type,String value);\\nparseInt(String s,int offset,int length,int base);\\nparseInt(byte[] b,int offset,int length,int base);\\nparseBytes(String s,int base);\\ntoString(byte[] bytes,int base);\\nconvertHexDigit(byte b);\\ntoHex(byte b,Appendable buf);\\ntoHexString(byte b);\\ntoHexString(byte[] b);\\ntoHexString(byte[] b,int offset,int length);\\nfromHexString(String s);\\ndump(Class c);\\ndump(ClassLoader cl);\\nreadLine(InputStream in);\\njarFor(String className);\\ncall(Class oClass,String method,Object obj,Object[] arg);\\n\", \"repo_level\" : \"\" }",
      "class_name": "TypeUtil",
      "code": "public static <T>List<T> asList(T[] a){\n  if (a == null)   return Collections.emptyList();\n  return Arrays.asList(a);\n}\n",
      "docstring": "/** \n * Array to List. <p> Works like  {@link Arrays#asList(Object)}, but handles null arrays.\n * @return a list backed by the array.\n */\n",
      "end_lineno": "143",
      "file_content": "// ========================================================================\n// Copyright (c) 2004-2009 Mort Bay Consulting Pty. Ltd.\n// ------------------------------------------------------------------------\n// All rights reserved. This program and the accompanying materials\n// are made available under the terms of the Eclipse Public License v1.0\n// and Apache License v2.0 which accompanies this distribution.\n// The Eclipse Public License is available at\n// http://www.eclipse.org/legal/epl-v10.html\n// The Apache License v2.0 is available at\n// http://www.opensource.org/licenses/apache2.0.php\n// You may elect to redistribute this code under either of these licenses.\n// ========================================================================\npackage net.hasor.utils.json;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.logging.Logger;\n/* ------------------------------------------------------------ */\n\n/**\n * TYPE Utilities.\n * Provides various static utiltiy methods for manipulating types and their\n * string representations.\n *\n * @since Jetty 4.1\n */\nclass TypeUtil {\n    protected final static Logger                    logger     = Logger.getLogger(TypeUtil.class.getName());\n    public static          int                       CR         = '\\015';\n    public static          int                       LF         = '\\012';\n    /* ------------------------------------------------------------ */\n    private static final   HashMap<String, Class<?>> name2Class = new HashMap<String, Class<?>>();\n\n    static {\n        name2Class.put(\"boolean\", Boolean.TYPE);\n        name2Class.put(\"byte\", Byte.TYPE);\n        name2Class.put(\"char\", Character.TYPE);\n        name2Class.put(\"double\", Double.TYPE);\n        name2Class.put(\"float\", Float.TYPE);\n        name2Class.put(\"int\", Integer.TYPE);\n        name2Class.put(\"long\", Long.TYPE);\n        name2Class.put(\"short\", Short.TYPE);\n        name2Class.put(\"void\", Void.TYPE);\n        name2Class.put(\"java.lang.Boolean.TYPE\", Boolean.TYPE);\n        name2Class.put(\"java.lang.Byte.TYPE\", Byte.TYPE);\n        name2Class.put(\"java.lang.Character.TYPE\", Character.TYPE);\n        name2Class.put(\"java.lang.Double.TYPE\", Double.TYPE);\n        name2Class.put(\"java.lang.Float.TYPE\", Float.TYPE);\n        name2Class.put(\"java.lang.Integer.TYPE\", Integer.TYPE);\n        name2Class.put(\"java.lang.Long.TYPE\", Long.TYPE);\n        name2Class.put(\"java.lang.Short.TYPE\", Short.TYPE);\n        name2Class.put(\"java.lang.Void.TYPE\", Void.TYPE);\n        name2Class.put(\"java.lang.Boolean\", Boolean.class);\n        name2Class.put(\"java.lang.Byte\", Byte.class);\n        name2Class.put(\"java.lang.Character\", Character.class);\n        name2Class.put(\"java.lang.Double\", Double.class);\n        name2Class.put(\"java.lang.Float\", Float.class);\n        name2Class.put(\"java.lang.Integer\", Integer.class);\n        name2Class.put(\"java.lang.Long\", Long.class);\n        name2Class.put(\"java.lang.Short\", Short.class);\n        name2Class.put(\"Boolean\", Boolean.class);\n        name2Class.put(\"Byte\", Byte.class);\n        name2Class.put(\"Character\", Character.class);\n        name2Class.put(\"Double\", Double.class);\n        name2Class.put(\"Float\", Float.class);\n        name2Class.put(\"Integer\", Integer.class);\n        name2Class.put(\"Long\", Long.class);\n        name2Class.put(\"Short\", Short.class);\n        name2Class.put(null, Void.TYPE);\n        name2Class.put(\"string\", String.class);\n        name2Class.put(\"String\", String.class);\n        name2Class.put(\"java.lang.String\", String.class);\n    }\n\n    /* ------------------------------------------------------------ */\n    private static final HashMap<Class<?>, String> class2Name = new HashMap<Class<?>, String>();\n\n    static {\n        class2Name.put(Boolean.TYPE, \"boolean\");\n        class2Name.put(Byte.TYPE, \"byte\");\n        class2Name.put(Character.TYPE, \"char\");\n        class2Name.put(Double.TYPE, \"double\");\n        class2Name.put(Float.TYPE, \"float\");\n        class2Name.put(Integer.TYPE, \"int\");\n        class2Name.put(Long.TYPE, \"long\");\n        class2Name.put(Short.TYPE, \"short\");\n        class2Name.put(Void.TYPE, \"void\");\n        class2Name.put(Boolean.class, \"java.lang.Boolean\");\n        class2Name.put(Byte.class, \"java.lang.Byte\");\n        class2Name.put(Character.class, \"java.lang.Character\");\n        class2Name.put(Double.class, \"java.lang.Double\");\n        class2Name.put(Float.class, \"java.lang.Float\");\n        class2Name.put(Integer.class, \"java.lang.Integer\");\n        class2Name.put(Long.class, \"java.lang.Long\");\n        class2Name.put(Short.class, \"java.lang.Short\");\n        class2Name.put(null, \"void\");\n        class2Name.put(String.class, \"java.lang.String\");\n    }\n\n    /* ------------------------------------------------------------ */\n    private static final HashMap<Class<?>, Method> class2Value = new HashMap<Class<?>, Method>();\n\n    static {\n        try {\n            Class<?>[] s = { String.class };\n            class2Value.put(Boolean.TYPE, Boolean.class.getMethod(\"valueOf\", s));\n            class2Value.put(Byte.TYPE, Byte.class.getMethod(\"valueOf\", s));\n            class2Value.put(Double.TYPE, Double.class.getMethod(\"valueOf\", s));\n            class2Value.put(Float.TYPE, Float.class.getMethod(\"valueOf\", s));\n            class2Value.put(Integer.TYPE, Integer.class.getMethod(\"valueOf\", s));\n            class2Value.put(Long.TYPE, Long.class.getMethod(\"valueOf\", s));\n            class2Value.put(Short.TYPE, Short.class.getMethod(\"valueOf\", s));\n            class2Value.put(Boolean.class, Boolean.class.getMethod(\"valueOf\", s));\n            class2Value.put(Byte.class, Byte.class.getMethod(\"valueOf\", s));\n            class2Value.put(Double.class, Double.class.getMethod(\"valueOf\", s));\n            class2Value.put(Float.class, Float.class.getMethod(\"valueOf\", s));\n            class2Value.put(Integer.class, Integer.class.getMethod(\"valueOf\", s));\n            class2Value.put(Long.class, Long.class.getMethod(\"valueOf\", s));\n            class2Value.put(Short.class, Short.class.getMethod(\"valueOf\", s));\n        } catch (Exception e) {\n            throw new Error(e);\n        }\n    }\n    /* ------------------------------------------------------------ */\n\n    /** Array to List.\n     * <p>\n     * Works like {@link Arrays#asList(Object...)}, but handles null arrays.\n     * @return a list backed by the array.\n     */\n    public static <T> List<T> asList(T[] a) {\n        if (a == null)\n            return Collections.emptyList();\n        return Arrays.asList(a);\n    }\n    /* ------------------------------------------------------------ */\n\n    /** Class from a canonical name for a type.\n     * @param name A class or type name.\n     * @return A class , which may be a primitive TYPE field..\n     */\n    public static Class<?> fromName(String name) {\n        return name2Class.get(name);\n    }\n    /* ------------------------------------------------------------ */\n\n    /** Canonical name for a type.\n     * @param type A class , which may be a primitive TYPE field.\n     * @return Canonical name.\n     */\n    public static String toName(Class<?> type) {\n        return class2Name.get(type);\n    }\n    /* ------------------------------------------------------------ */\n\n    /** Convert String value to instance.\n     * @param type The class of the instance, which may be a primitive TYPE field.\n     * @param value The value as a string.\n     * @return The value as an Object.\n     */\n    public static Object valueOf(Class<?> type, String value) {\n        try {\n            if (type.equals(String.class))\n                return value;\n            Method m = class2Value.get(type);\n            if (m != null)\n                return m.invoke(null, value);\n            if (type.equals(Character.TYPE) || type.equals(Character.class))\n                return new Character(value.charAt(0));\n            Constructor<?> c = type.getConstructor(String.class);\n            return c.newInstance(value);\n        } catch (NoSuchMethodException e) {\n            // LogSupport.ignore(log,e);\n        } catch (IllegalAccessException e) {\n            // LogSupport.ignore(log,e);\n        } catch (InstantiationException e) {\n            // LogSupport.ignore(log,e);\n        } catch (InvocationTargetException e) {\n            if (e.getTargetException() instanceof Error)\n                throw (Error) (e.getTargetException());\n            // LogSupport.ignore(log,e);\n        }\n        return null;\n    }\n    /* ------------------------------------------------------------ */\n\n    /** Convert String value to instance.\n     * @param type classname or type (eg int)\n     * @param value The value as a string.\n     * @return The value as an Object.\n     */\n    public static Object valueOf(String type, String value) {\n        return valueOf(fromName(type), value);\n    }\n    /* ------------------------------------------------------------ */\n\n    /** Parse an int from a substring.\n     * Negative numbers are not handled.\n     * @param s String\n     * @param offset Offset within string\n     * @param length Length of integer or -1 for remainder of string\n     * @param base base of the integer\n     * @return the parsed integer\n     * @throws NumberFormatException if the string cannot be parsed\n     */\n    public static int parseInt(String s, int offset, int length, int base) throws NumberFormatException {\n        int value = 0;\n        if (length < 0)\n            length = s.length() - offset;\n        for (int i = 0; i < length; i++) {\n            char c = s.charAt(offset + i);\n            int digit = c - '0';\n            if (digit < 0 || digit >= base || digit >= 10) {\n                digit = 10 + c - 'A';\n                if (digit < 10 || digit >= base)\n                    digit = 10 + c - 'a';\n            }\n            if (digit < 0 || digit >= base)\n                throw new NumberFormatException(s.substring(offset, offset + length));\n            value = value * base + digit;\n        }\n        return value;\n    }\n    /* ------------------------------------------------------------ */\n\n    /** Parse an int from a byte array of ascii characters.\n     * Negative numbers are not handled.\n     * @param b byte array\n     * @param offset Offset within string\n     * @param length Length of integer or -1 for remainder of string\n     * @param base base of the integer\n     * @return the parsed integer\n     * @throws NumberFormatException if the array cannot be parsed into an integer\n     */\n    public static int parseInt(byte[] b, int offset, int length, int base) throws NumberFormatException {\n        int value = 0;\n        if (length < 0)\n            length = b.length - offset;\n        for (int i = 0; i < length; i++) {\n            char c = (char) (0xff & b[offset + i]);\n            int digit = c - '0';\n            if (digit < 0 || digit >= base || digit >= 10) {\n                digit = 10 + c - 'A';\n                if (digit < 10 || digit >= base)\n                    digit = 10 + c - 'a';\n            }\n            if (digit < 0 || digit >= base)\n                throw new NumberFormatException(new String(b, offset, length));\n            value = value * base + digit;\n        }\n        return value;\n    }\n\n    /* ------------------------------------------------------------ */\n    public static byte[] parseBytes(String s, int base) {\n        byte[] bytes = new byte[s.length() / 2];\n        for (int i = 0; i < s.length(); i += 2)\n            bytes[i / 2] = (byte) TypeUtil.parseInt(s, i, 2, base);\n        return bytes;\n    }\n\n    /* ------------------------------------------------------------ */\n    public static String toString(byte[] bytes, int base) {\n        StringBuilder buf = new StringBuilder();\n        for (byte b : bytes) {\n            int bi = 0xff & b;\n            int c = '0' + (bi / base) % base;\n            if (c > '9')\n                c = 'a' + (c - '0' - 10);\n            buf.append((char) c);\n            c = '0' + bi % base;\n            if (c > '9')\n                c = 'a' + (c - '0' - 10);\n            buf.append((char) c);\n        }\n        return buf.toString();\n    }\n    /* ------------------------------------------------------------ */\n\n    /**\n     * @param b An ASCII encoded character 0-9 a-f A-F\n     * @return The byte value of the character 0-16.\n     */\n    public static byte convertHexDigit(byte b) {\n        if ((b >= '0') && (b <= '9'))\n            return (byte) (b - '0');\n        if ((b >= 'a') && (b <= 'f'))\n            return (byte) (b - 'a' + 10);\n        if ((b >= 'A') && (b <= 'F'))\n            return (byte) (b - 'A' + 10);\n        throw new IllegalArgumentException(\"!hex:\" + Integer.toHexString(0xff & b));\n    }\n\n    /* ------------------------------------------------------------ */\n    public static void toHex(byte b, Appendable buf) {\n        try {\n            int bi = 0xff & b;\n            int c = '0' + (bi / 16) % 16;\n            if (c > '9')\n                c = 'A' + (c - '0' - 10);\n            buf.append((char) c);\n            c = '0' + bi % 16;\n            if (c > '9')\n                c = 'A' + (c - '0' - 10);\n            buf.append((char) c);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /* ------------------------------------------------------------ */\n    public static String toHexString(byte b) {\n        return toHexString(new byte[] { b }, 0, 1);\n    }\n\n    /* ------------------------------------------------------------ */\n    public static String toHexString(byte[] b) {\n        return toHexString(b, 0, b.length);\n    }\n\n    /* ------------------------------------------------------------ */\n    public static String toHexString(byte[] b, int offset, int length) {\n        StringBuilder buf = new StringBuilder();\n        for (int i = offset; i < offset + length; i++) {\n            int bi = 0xff & b[i];\n            int c = '0' + (bi / 16) % 16;\n            if (c > '9')\n                c = 'A' + (c - '0' - 10);\n            buf.append((char) c);\n            c = '0' + bi % 16;\n            if (c > '9')\n                c = 'a' + (c - '0' - 10);\n            buf.append((char) c);\n        }\n        return buf.toString();\n    }\n\n    /* ------------------------------------------------------------ */\n    public static byte[] fromHexString(String s) {\n        if (s.length() % 2 != 0)\n            throw new IllegalArgumentException(s);\n        byte[] array = new byte[s.length() / 2];\n        for (int i = 0; i < array.length; i++) {\n            int b = Integer.parseInt(s.substring(i * 2, i * 2 + 2), 16);\n            array[i] = (byte) (0xff & b);\n        }\n        return array;\n    }\n\n    public static void dump(Class<?> c) {\n        System.err.println(\"Dump: \" + c);\n        dump(c.getClassLoader());\n    }\n\n    public static void dump(ClassLoader cl) {\n        System.err.println(\"Dump Loaders:\");\n        while (cl != null) {\n            System.err.println(\"  loader \" + cl);\n            cl = cl.getParent();\n        }\n    }\n\n    /* ------------------------------------------------------------ */\n    public static byte[] readLine(InputStream in) throws IOException {\n        byte[] buf = new byte[256];\n        int i = 0;\n        int loops = 0;\n        int ch = 0;\n        while (true) {\n            ch = in.read();\n            if (ch < 0)\n                break;\n            loops++;\n            // skip a leading LF's\n            if (loops == 1 && ch == LF)\n                continue;\n            if (ch == CR || ch == LF)\n                break;\n            if (i >= buf.length) {\n                byte[] old_buf = buf;\n                buf = new byte[old_buf.length + 256];\n                System.arraycopy(old_buf, 0, buf, 0, old_buf.length);\n            }\n            buf[i++] = (byte) ch;\n        }\n        if (ch == -1 && i == 0)\n            return null;\n        // skip a trailing LF if it exists\n        if (ch == CR && in.available() >= 1 && in.markSupported()) {\n            in.mark(1);\n            ch = in.read();\n            if (ch != LF)\n                in.reset();\n        }\n        byte[] old_buf = buf;\n        buf = new byte[i];\n        System.arraycopy(old_buf, 0, buf, 0, i);\n        return buf;\n    }\n\n    public static URL jarFor(String className) {\n        try {\n            className = className.replace('.', '/') + \".class\";\n            // hack to discover jstl libraries\n            URL url = Loader.getResource(null, className, false);\n            String s = url.toString();\n            if (s.startsWith(\"jar:file:\"))\n                return new URL(s.substring(4, s.indexOf(\"!/\")));\n        } catch (Exception e) {\n            logger.fine(e.getMessage());\n        }\n        return null;\n    }\n\n    public static Object call(Class<?> oClass, String method, Object obj, Object[] arg) throws InvocationTargetException, NoSuchMethodException {\n        // Lets just try all methods for now\n        Method[] methods = oClass.getMethods();\n        for (int c = 0; methods != null && c < methods.length; c++) {\n            if (!methods[c].getName().equals(method))\n                continue;\n            if (methods[c].getParameterTypes().length != arg.length)\n                continue;\n            if (Modifier.isStatic(methods[c].getModifiers()) != (obj == null))\n                continue;\n            if ((obj == null) && methods[c].getDeclaringClass() != oClass)\n                continue;\n            try {\n                return methods[c].invoke(obj, arg);\n            } catch (IllegalAccessException e) {\n                logger.fine(e.getMessage());\n            } catch (IllegalArgumentException e) {\n                logger.fine(e.getMessage());\n            }\n        }\n        throw new NoSuchMethodException(method);\n    }\n}\n",
      "file_name": "TypeUtil.java",
      "human_label": "Convert an array to list, return empty list for null array.",
      "level": "slib_runnable",
      "lineno": "134",
      "name": "asList",
      "oracle_context": "{ \"apis\" : \"[emptyList]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
      "package": "net.hasor.utils.json",
      "project": "hasor-master"
    },
    {
      "_id": "6367672d1a6d9265ec017c74",
      "all_context": "{ \"class_level\" : \"HashMap<Integer,Integer> map;\\nArrayList<Integer> values;\\nRandomizedSet();\\nremove(int val);\\ngetRandom();\\ninsert(int val);\\n\", \"repo_level\" : \"\" }",
      "class_name": "RandomizedSet",
      "code": "public boolean remove(int val){\n  if (map.containsKey(val)) {\n    map.remove(val);\n    values.remove(values.indexOf(val));\n    return true;\n  }\n  return false;\n}\n",
      "docstring": "/** \n * Removes a value from the set. Returns true if the set contained the specified element. \n */\n",
      "end_lineno": "62",
      "file_content": "//Design a data structure that supports all following operations in average O(1) time.\n\n//insert(val): Inserts an item val to the set if not already present.\n//remove(val): Removes an item val from the set if present.\n//getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.\n\n//Example:\n// Init an empty set.\n//RandomizedSet randomSet = new RandomizedSet();\n\n// Inserts 1 to the set. Returns true as 1 was inserted successfully.\n//randomSet.insert(1);\n\n// Returns false as 2 does not exist in the set.\n//randomSet.remove(2);\n\n// Inserts 2 to the set, returns true. Set now contains [1,2].\n//randomSet.insert(2);\n\n// getRandom should return either 1 or 2 randomly.\n//randomSet.getRandom();\n\n// Removes 1 from the set, returns true. Set now contains [2].\n//randomSet.remove(1);\n\n// 2 was already in the set, so return false.\n//randomSet.insert(2);\n\n// Since 2 is the only number in the set, getRandom always return 2.\n//randomSet.getRandom();\n\nclass RandomizedSet {\n    HashMap<Integer, Integer> map;\n    ArrayList<Integer> values;\n\n    /** Initialize your data structure here. */\n    public RandomizedSet() {\n        map = new HashMap<Integer, Integer>();\n        values = new ArrayList<Integer>();\n    }\n    \n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\n    public boolean insert(int val) {\n        if(!map.containsKey(val)) {\n            map.put(val, val);\n            values.add(val);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    \n    /** Removes a value from the set. Returns true if the set contained the specified element. */\n    public boolean remove(int val) {\n        if(map.containsKey(val)) {\n            map.remove(val);\n            values.remove(values.indexOf(val));\n            return true;\n        }\n        return false;\n    }\n    \n    /** Get a random element from the set. */\n    public int getRandom() {\n        int random = (int)(Math.random() * values.size());\n        int valueToReturn = values.get(random);\n        return map.get(valueToReturn);\n    }\n}\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet obj = new RandomizedSet();\n * boolean param_1 = obj.insert(val);\n * boolean param_2 = obj.remove(val);\n * int param_3 = obj.getRandom();\n */\n\n",
      "file_name": "InsertDeleteGetRandomO1.java",
      "human_label": "Remove a value from the values if the map keys contains the val. Returns true if actually removed, and false otherwise.",
      "level": "self_contained",
      "lineno": "54",
      "name": "remove",
      "oracle_context": "{ \"apis\" : \"[containsKey, indexOf]\", \"classes\" : \"[]\", \"vars\" : \"[map, values]\" }",
      "package": "",
      "project": "interviews-master"
    },
    {
      "_id": "6367676b1a6d9265ec0181df",
      "all_context": "{ \"class_level\" : \"import java.nio.charset.Charset;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nimport java.util.Enumeration;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Locale;\\nimport java.util.Properties;\\nimport java.util.Set;\\nimport java.util.StringTokenizer;\\nimport java.util.TreeSet;\\nString FOLDER_SEPARATOR;\\nString WINDOWS_FOLDER_SEPARATOR;\\nString TOP_PATH;\\nString CURRENT_PATH;\\nchar EXTENSION_SEPARATOR;\\nCharset UTF_8;\\nStrings();\\nhasLength(String str);\\nhasText(CharSequence str);\\nhasText(String str);\\ncontainsWhitespace(CharSequence str);\\ncontainsWhitespace(String str);\\ntrimWhitespace(String str);\\ntrimWhitespace(CharSequence str);\\nclean(String str);\\nclean(CharSequence str);\\ntrimAllWhitespace(String str);\\ntrimLeadingWhitespace(String str);\\ntrimTrailingWhitespace(String str);\\ntrimLeadingCharacter(String str,char leadingCharacter);\\ntrimTrailingCharacter(String str,char trailingCharacter);\\nstartsWithIgnoreCase(String str,String prefix);\\nendsWithIgnoreCase(String str,String suffix);\\nsubstringMatch(CharSequence str,int index,CharSequence substring);\\ncountOccurrencesOf(String str,String sub);\\nreplace(String inString,String oldPattern,String newPattern);\\ndelete(String inString,String pattern);\\ndeleteAny(String inString,String charsToDelete);\\nquote(String str);\\nquoteIfString(Object obj);\\nunqualify(String qualifiedName);\\nunqualify(String qualifiedName,char separator);\\ncapitalize(String str);\\nuncapitalize(String str);\\nchangeFirstCharacterCase(String str,boolean capitalize);\\ngetFilename(String path);\\ngetFilenameExtension(String path);\\nstripFilenameExtension(String path);\\napplyRelativePath(String path,String relativePath);\\ncleanPath(String path);\\npathEquals(String path1,String path2);\\nparseLocaleString(String localeString);\\nvalidateLocalePart(String localePart);\\ntoLanguageTag(Locale locale);\\naddStringToArray(String[] array,String str);\\nconcatenateStringArrays(String[] array1,String[] array2);\\nmergeStringArrays(String[] array1,String[] array2);\\nsortStringArray(String[] array);\\ntoStringArray(Collection collection);\\ntoStringArray(Enumeration enumeration);\\ntrimArrayElements(String[] array);\\nremoveDuplicateStrings(String[] array);\\nsplit(String toSplit,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter,String charsToDelete);\\ntokenizeToStringArray(String str,String delimiters);\\ntokenizeToStringArray(String str,String delimiters,boolean trimTokens,boolean ignoreEmptyTokens);\\ndelimitedListToStringArray(String str,String delimiter);\\ndelimitedListToStringArray(String str,String delimiter,String charsToDelete);\\ncommaDelimitedListToStringArray(String str);\\ncommaDelimitedListToSet(String str);\\ncollectionToDelimitedString(Collection coll,String delim,String prefix,String suffix);\\ncollectionToDelimitedString(Collection coll,String delim);\\ncollectionToCommaDelimitedString(Collection coll);\\narrayToDelimitedString(Object[] arr,String delim);\\narrayToCommaDelimitedString(Object[] arr);\\nhasLength(CharSequence str);\\n\", \"repo_level\" : \"\" }",
      "class_name": "Strings",
      "code": "public static boolean startsWithIgnoreCase(String str,String prefix){\n  if (str == null || prefix == null) {\n    return false;\n  }\n  if (str.startsWith(prefix)) {\n    return true;\n  }\n  if (str.length() < prefix.length()) {\n    return false;\n  }\n  String lcStr=str.substring(0,prefix.length()).toLowerCase();\n  String lcPrefix=prefix.toLowerCase();\n  return lcStr.equals(lcPrefix);\n}\n",
      "docstring": "/** \n * Returns  {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n * @param str the String to check\n * @param prefix the prefix to look for\n * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n * @see java.lang.String#startsWith\n */\n",
      "end_lineno": "310",
      "file_content": "/*\n * Copyright (C) 2014 jsonwebtoken.io\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.jsonwebtoken.lang;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic final class Strings {\n\n    private static final String FOLDER_SEPARATOR = \"/\";\n\n    private static final String WINDOWS_FOLDER_SEPARATOR = \"\\\\\";\n\n    private static final String TOP_PATH = \"..\";\n\n    private static final String CURRENT_PATH = \".\";\n\n    private static final char EXTENSION_SEPARATOR = '.';\n\n    public static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    private Strings(){} //prevent instantiation\n\n    //---------------------------------------------------------------------\n    // General convenience methods for working with Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Check that the given CharSequence is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a CharSequence that purely consists of whitespace.\n     * <pre>\n     * Strings.hasLength(null) = false\n     * Strings.hasLength(\"\") = false\n     * Strings.hasLength(\" \") = true\n     * Strings.hasLength(\"Hello\") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(CharSequence str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasLength(CharSequence)\n     */\n    public static boolean hasLength(String str) {\n        return hasLength((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <pre>\n     * Strings.hasText(null) = false\n     * Strings.hasText(\"\") = false\n     * Strings.hasText(\" \") = false\n     * Strings.hasText(\"12345\") = true\n     * Strings.hasText(\" 12345 \") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not <code>null</code>,\n     * its length is greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     * greater than 0, and it does not contain whitespace only\n     * @see #hasText(CharSequence)\n     */\n    public static boolean hasText(String str) {\n        return hasText((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence contains any whitespace characters.\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not empty and\n     * contains at least 1 whitespace character\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean containsWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String contains any whitespace characters.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not empty and\n     * contains at least 1 whitespace character\n     * @see #containsWhitespace(CharSequence)\n     */\n    public static boolean containsWhitespace(String str) {\n        return containsWhitespace((CharSequence) str);\n    }\n\n    /**\n     * Trim leading and trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimWhitespace(String str) {\n        return (String) trimWhitespace((CharSequence)str);\n    }\n    \n    \n    private static CharSequence trimWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        final int length = str.length();\n\n        int start = 0;\n\t\twhile (start < length && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        \n\t\tint end = length;\n        while (start < length && Character.isWhitespace(str.charAt(end - 1))) {\n            end--;\n        }\n        \n        return ((start > 0) || (end < length)) ? str.subSequence(start, end) : str;\n    }\n\n    public static String clean(String str) {\n    \tCharSequence result = clean((CharSequence) str);\n        \n        return result!=null?result.toString():null;\n    }\n    \n    public static CharSequence clean(CharSequence str) {\n        str = trimWhitespace(str);\n        if (!hasLength(str)) {\n            return null;\n        }\n        return str;\n    }\n\n    /**\n     * Trim <i>all</i> whitespace from the given String:\n     * leading, trailing, and intermediate characters.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimAllWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        int index = 0;\n        while (sb.length() > index) {\n            if (Character.isWhitespace(sb.charAt(index))) {\n                sb.deleteCharAt(index);\n            }\n            else {\n                index++;\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim leading whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimLeadingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimTrailingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied leading character from the given String.\n     * @param str the String to check\n     * @param leadingCharacter the leading character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimLeadingCharacter(String str, char leadingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied trailing character from the given String.\n     * @param str the String to check\n     * @param trailingCharacter the trailing character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimTrailingCharacter(String str, char trailingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n\n    /**\n     * Returns {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @param str the String to check\n     * @param prefix the prefix to look for\n     * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @param str the String to check\n     * @param suffix the suffix to look for\n     * @return {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @see java.lang.String#endsWith\n     */\n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        if (str == null || suffix == null) {\n            return false;\n        }\n        if (str.endsWith(suffix)) {\n            return true;\n        }\n        if (str.length() < suffix.length()) {\n            return false;\n        }\n\n        String lcStr = str.substring(str.length() - suffix.length()).toLowerCase();\n        String lcSuffix = suffix.toLowerCase();\n        return lcStr.equals(lcSuffix);\n    }\n\n    /**\n     * Returns {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     * @param str the original string (or StringBuilder)\n     * @param index the index in the original string to start matching against\n     * @param substring the substring to match at the given index\n     * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     */\n    public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n        for (int j = 0; j < substring.length(); j++) {\n            int i = index + j;\n            if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the number of occurrences the substring {@code sub} appears in string {@code str}.\n     * @param str string to search in. Return 0 if this is null.\n     * @param sub string to search for. Return 0 if this is null.\n     * @return the number of occurrences the substring {@code sub} appears in string {@code str}.\n     */\n    public static int countOccurrencesOf(String str, String sub) {\n        if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n            return 0;\n        }\n        int count = 0;\n        int pos = 0;\n        int idx;\n        while ((idx = str.indexOf(sub, pos)) != -1) {\n            ++count;\n            pos = idx + sub.length();\n        }\n        return count;\n    }\n\n    /**\n     * Replace all occurrences of a substring within a string with\n     * another string.\n     * @param inString String to examine\n     * @param oldPattern String to replace\n     * @param newPattern String to insert\n     * @return a String with the replacements\n     */\n    public static String replace(String inString, String oldPattern, String newPattern) {\n        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        int pos = 0; // our position in the old string\n        int index = inString.indexOf(oldPattern);\n        // the index of an occurrence we've found, or -1\n        int patLen = oldPattern.length();\n        while (index >= 0) {\n            sb.append(inString.substring(pos, index));\n            sb.append(newPattern);\n            pos = index + patLen;\n            index = inString.indexOf(oldPattern, pos);\n        }\n        sb.append(inString.substring(pos));\n        // remember to append any characters to the right of a match\n        return sb.toString();\n    }\n\n    /**\n     * Delete all occurrences of the given substring.\n     * @param inString the original String\n     * @param pattern the pattern to delete all occurrences of\n     * @return the resulting String\n     */\n    public static String delete(String inString, String pattern) {\n        return replace(inString, pattern, \"\");\n    }\n\n    /**\n     * Delete any character in a given String.\n     * @param inString the original String\n     * @param charsToDelete a set of characters to delete.\n     * E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n     * @return the resulting String\n     */\n    public static String deleteAny(String inString, String charsToDelete) {\n        if (!hasLength(inString) || !hasLength(charsToDelete)) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < inString.length(); i++) {\n            char c = inString.charAt(i);\n            if (charsToDelete.indexOf(c) == -1) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with formatted Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Quote the given String with single quotes.\n     * @param str the input String (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or <code>null</code> if the input was <code>null</code>\n     */\n    public static String quote(String str) {\n        return (str != null ? \"'\" + str + \"'\" : null);\n    }\n\n    /**\n     * Turn the given Object into a String with single quotes\n     * if it is a String; keeping the Object as-is else.\n     * @param obj the input Object (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or the input object as-is if not a String\n     */\n    public static Object quoteIfString(Object obj) {\n        return (obj instanceof String ? quote((String) obj) : obj);\n    }\n\n    /**\n     * Unqualify a string qualified by a '.' dot character. For example,\n     * \"this.name.is.qualified\", returns \"qualified\".\n     * @param qualifiedName the qualified name\n     * @return an unqualified string by stripping all previous text before (and including) the last period character.\n     */\n    public static String unqualify(String qualifiedName) {\n        return unqualify(qualifiedName, '.');\n    }\n\n    /**\n     * Unqualify a string qualified by a separator character. For example,\n     * \"this:name:is:qualified\" returns \"qualified\" if using a ':' separator.\n     * @param qualifiedName the qualified name\n     * @param separator the separator\n     * @return an unqualified string by stripping all previous text before and including the last {@code separator} character.\n     */\n    public static String unqualify(String qualifiedName, char separator) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);\n    }\n\n    /**\n     * Capitalize a <code>String</code>, changing the first letter to\n     * upper case as per {@link Character#toUpperCase(char)}.\n     * No other letters are changed.\n     * @param str the String to capitalize, may be <code>null</code>\n     * @return the capitalized String, <code>null</code> if null\n     */\n    public static String capitalize(String str) {\n        return changeFirstCharacterCase(str, true);\n    }\n\n    /**\n     * Uncapitalize a <code>String</code>, changing the first letter to\n     * lower case as per {@link Character#toLowerCase(char)}.\n     * No other letters are changed.\n     * @param str the String to uncapitalize, may be <code>null</code>\n     * @return the uncapitalized String, <code>null</code> if null\n     */\n    public static String uncapitalize(String str) {\n        return changeFirstCharacterCase(str, false);\n    }\n\n    private static String changeFirstCharacterCase(String str, boolean capitalize) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str.length());\n        if (capitalize) {\n            sb.append(Character.toUpperCase(str.charAt(0)));\n        }\n        else {\n            sb.append(Character.toLowerCase(str.charAt(0)));\n        }\n        sb.append(str.substring(1));\n        return sb.toString();\n    }\n\n    /**\n     * Extract the filename from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"myfile.txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename, or <code>null</code> if none\n     */\n    public static String getFilename(String path) {\n        if (path == null) {\n            return null;\n        }\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);\n    }\n\n    /**\n     * Extract the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename extension, or <code>null</code> if none\n     */\n    public static String getFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return null;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return null;\n        }\n        return path.substring(extIndex + 1);\n    }\n\n    /**\n     * Strip the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"mypath/myfile\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the path with stripped filename extension,\n     * or <code>null</code> if none\n     */\n    public static String stripFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return path;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return path;\n        }\n        return path.substring(0, extIndex);\n    }\n\n    /**\n     * Apply the given relative path to the given path,\n     * assuming standard Java folder separation (i.e. \"/\" separators).\n     * @param path the path to start from (usually a full file path)\n     * @param relativePath the relative path to apply\n     * (relative to the full file path above)\n     * @return the full file path that results from applying the relative path\n     */\n    public static String applyRelativePath(String path, String relativePath) {\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (separatorIndex != -1) {\n            String newPath = path.substring(0, separatorIndex);\n            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n                newPath += FOLDER_SEPARATOR;\n            }\n            return newPath + relativePath;\n        }\n        else {\n            return relativePath;\n        }\n    }\n\n    /**\n     * Normalize the path by suppressing sequences like \"path/..\" and\n     * inner simple dots.\n     * <p>The result is convenient for path comparison. For other uses,\n     * notice that Windows separators (\"\\\") are replaced by simple slashes.\n     * @param path the original path\n     * @return the normalized path\n     */\n    public static String cleanPath(String path) {\n        if (path == null) {\n            return null;\n        }\n        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);\n\n        // Strip prefix from path to analyze, to not treat it as part of the\n        // first path element. This is necessary to correctly parse paths like\n        // \"file:core/../core/io/Resource.class\", where the \"..\" should just\n        // strip the first \"core\" directory while keeping the \"file:\" prefix.\n        int prefixIndex = pathToUse.indexOf(\":\");\n        String prefix = \"\";\n        if (prefixIndex != -1) {\n            prefix = pathToUse.substring(0, prefixIndex + 1);\n            pathToUse = pathToUse.substring(prefixIndex + 1);\n        }\n        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {\n            prefix = prefix + FOLDER_SEPARATOR;\n            pathToUse = pathToUse.substring(1);\n        }\n\n        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);\n        List<String> pathElements = new LinkedList<String>();\n        int tops = 0;\n\n        for (int i = pathArray.length - 1; i >= 0; i--) {\n            String element = pathArray[i];\n            if (CURRENT_PATH.equals(element)) {\n                // Points to current directory - drop it.\n            }\n            else if (TOP_PATH.equals(element)) {\n                // Registering top path found.\n                tops++;\n            }\n            else {\n                if (tops > 0) {\n                    // Merging path element with element corresponding to top path.\n                    tops--;\n                }\n                else {\n                    // Normal path element found.\n                    pathElements.add(0, element);\n                }\n            }\n        }\n\n        // Remaining top paths need to be retained.\n        for (int i = 0; i < tops; i++) {\n            pathElements.add(0, TOP_PATH);\n        }\n\n        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);\n    }\n\n    /**\n     * Compare two paths after normalization of them.\n     * @param path1 first path for comparison\n     * @param path2 second path for comparison\n     * @return whether the two paths are equivalent after normalization\n     */\n    public static boolean pathEquals(String path1, String path2) {\n        return cleanPath(path1).equals(cleanPath(path2));\n    }\n\n    /**\n     * Parse the given <code>localeString</code> value into a {@link java.util.Locale}.\n     * <p>This is the inverse operation of {@link java.util.Locale#toString Locale's toString}.\n     * @param localeString the locale string, following <code>Locale's</code>\n     * <code>toString()</code> format (\"en\", \"en_UK\", etc);\n     * also accepts spaces as separators, as an alternative to underscores\n     * @return a corresponding <code>Locale</code> instance\n     */\n    public static Locale parseLocaleString(String localeString) {\n        String[] parts = tokenizeToStringArray(localeString, \"_ \", false, false);\n        String language = (parts.length > 0 ? parts[0] : \"\");\n        String country = (parts.length > 1 ? parts[1] : \"\");\n        validateLocalePart(language);\n        validateLocalePart(country);\n        String variant = \"\";\n        if (parts.length >= 2) {\n            // There is definitely a variant, and it is everything after the country\n            // code sans the separator between the country code and the variant.\n            int endIndexOfCountryCode = localeString.indexOf(country) + country.length();\n            // Strip off any leading '_' and whitespace, what's left is the variant.\n            variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));\n            if (variant.startsWith(\"_\")) {\n                variant = trimLeadingCharacter(variant, '_');\n            }\n        }\n        return (language.length() > 0 ? new Locale(language, country, variant) : null);\n    }\n\n    private static void validateLocalePart(String localePart) {\n        for (int i = 0; i < localePart.length(); i++) {\n            char ch = localePart.charAt(i);\n            if (ch != '_' && ch != ' ' && !Character.isLetterOrDigit(ch)) {\n                throw new IllegalArgumentException(\n                    \"Locale part \\\"\" + localePart + \"\\\" contains invalid characters\");\n            }\n        }\n    }\n\n    /**\n     * Determine the RFC 3066 compliant language tag,\n     * as used for the HTTP \"Accept-Language\" header.\n     * @param locale the Locale to transform to a language tag\n     * @return the RFC 3066 compliant language tag as String\n     */\n    public static String toLanguageTag(Locale locale) {\n        return locale.getLanguage() + (hasText(locale.getCountry()) ? \"-\" + locale.getCountry() : \"\");\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with String arrays\n    //---------------------------------------------------------------------\n\n    /**\n     * Append the given String to the given String array, returning a new array\n     * consisting of the input array contents plus the given String.\n     * @param array the array to append to (can be <code>null</code>)\n     * @param str the String to append\n     * @return the new array (never <code>null</code>)\n     */\n    public static String[] addStringToArray(String[] array, String str) {\n        if (Objects.isEmpty(array)) {\n            return new String[] {str};\n        }\n        String[] newArr = new String[array.length + 1];\n        System.arraycopy(array, 0, newArr, 0, array.length);\n        newArr[array.length] = str;\n        return newArr;\n    }\n\n    /**\n     * Concatenate the given String arrays into one,\n     * with overlapping array elements included twice.\n     * <p>The order of elements in the original arrays is preserved.\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        String[] newArr = new String[array1.length + array2.length];\n        System.arraycopy(array1, 0, newArr, 0, array1.length);\n        System.arraycopy(array2, 0, newArr, array1.length, array2.length);\n        return newArr;\n    }\n\n    /**\n     * Merge the given String arrays into one, with overlapping\n     * array elements only included once.\n     * <p>The order of elements in the original arrays is preserved\n     * (with the exception of overlapping elements, which are only\n     * included on their first occurrence).\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] mergeStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        List<String> result = new ArrayList<String>();\n        result.addAll(Arrays.asList(array1));\n        for (String str : array2) {\n            if (!result.contains(str)) {\n                result.add(str);\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Turn given source String array into sorted array.\n     * @param array the source array\n     * @return the sorted array (never <code>null</code>)\n     */\n    public static String[] sortStringArray(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        Arrays.sort(array);\n        return array;\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Collection was <code>null</code>)\n     */\n    public static String[] toStringArray(Collection<String> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new String[collection.size()]);\n    }\n\n    /**\n     * Copy the given Enumeration into a String array.\n     * The Enumeration must contain String elements only.\n     * @param enumeration the Enumeration to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Enumeration was <code>null</code>)\n     */\n    public static String[] toStringArray(Enumeration<String> enumeration) {\n        if (enumeration == null) {\n            return null;\n        }\n        List<String> list = java.util.Collections.list(enumeration);\n        return list.toArray(new String[list.size()]);\n    }\n\n    /**\n     * Trim the elements of the given String array,\n     * calling <code>String.trim()</code> on each of them.\n     * @param array the original String array\n     * @return the resulting array (of the same size) with trimmed elements\n     */\n    public static String[] trimArrayElements(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        String[] result = new String[array.length];\n        for (int i = 0; i < array.length; i++) {\n            String element = array[i];\n            result[i] = (element != null ? element.trim() : null);\n        }\n        return result;\n    }\n\n    /**\n     * Remove duplicate Strings from the given array.\n     * Also sorts the array, as it uses a TreeSet.\n     * @param array the String array\n     * @return an array without duplicates, in natural sort order\n     */\n    public static String[] removeDuplicateStrings(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return array;\n        }\n        Set<String> set = new TreeSet<String>();\n        for (String element : array) {\n            set.add(element);\n        }\n        return toStringArray(set);\n    }\n\n    /**\n     * Split a String at the first occurrence of the delimiter.\n     * Does not include the delimiter in the result.\n     * @param toSplit the string to split\n     * @param delimiter to split the string up with\n     * @return a two element array with index 0 being before the delimiter, and\n     * index 1 being after the delimiter (neither element includes the delimiter);\n     * or <code>null</code> if the delimiter wasn't found in the given input String\n     */\n    public static String[] split(String toSplit, String delimiter) {\n        if (!hasLength(toSplit) || !hasLength(delimiter)) {\n            return null;\n        }\n        int offset = toSplit.indexOf(delimiter);\n        if (offset < 0) {\n            return null;\n        }\n        String beforeDelimiter = toSplit.substring(0, offset);\n        String afterDelimiter = toSplit.substring(offset + delimiter.length());\n        return new String[] {beforeDelimiter, afterDelimiter};\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was null or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {\n        return splitArrayElementsIntoProperties(array, delimiter, null);\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @param charsToDelete one or more characters to remove from each element\n     * prior to attempting the split operation (typically the quotation mark\n     * symbol), or <code>null</code> if no removal should occur\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was <code>null</code> or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(\n        String[] array, String delimiter, String charsToDelete) {\n\n        if (Objects.isEmpty(array)) {\n            return null;\n        }\n        Properties result = new Properties();\n        for (String element : array) {\n            if (charsToDelete != null) {\n                element = deleteAny(element, charsToDelete);\n            }\n            String[] splittedElement = split(element, delimiter);\n            if (splittedElement == null) {\n                continue;\n            }\n            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n        }\n        return result;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter)\n     * @param trimTokens trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     * (only applies to tokens that are empty after trimming; StringTokenizer\n     * will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     * was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(\n        String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List<String> tokens = new ArrayList<String>();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter) {\n        return delimitedListToStringArray(str, delimi