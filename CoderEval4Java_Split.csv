_id,name,code,docstring,human_label,one_line_summary,function_behavior,function_signature,examples,precond_postcond
6367676d1a6d9265ec018229,trimArrayElements,"public static String[] trimArrayElements(String[] array){
  if (Objects.isEmpty(array)) {
    return new String[0];
  }
  String[] result=new String[array.length];
  for (int i=0; i < array.length; i++) {
    String element=array[i];
    result[i]=(element != null ? element.trim() : null);
  }
  return result;
}
","/** 
 * Trim the elements of the given String array, calling <code>String.trim()</code> on each of them.
 * @param array the original String array
 * @return the resulting array (of the same size) with trimmed elements
 */
",Trim each element in the given string array and return the resulting array.,Trims whitespace from each element in a string array.,"The function takes an array of strings and returns a new array where each string element has leading and trailing whitespace removed. If an element is `null`, it remains `null`.",`public static String[] trimArrayElements(String[] array)` takes an array of strings as the input parameter and returns a new array of strings.,"- Typical usage: Input: `[""  hello "", "" world "", "" ! ""]` -> Output: `[""hello"", ""world"", ""!""]`
   - Boundary edge case: Input: `[]` -> Output: `[]`
   - Special or unusual case: Input: `[null, ""  test ""]` -> Output: `[null, ""test""]`","The input array may be empty or contain `null` values. The output will be a new array with the same length, and each non-null string element will have its whitespace trimmed.
---
```"
6367670b1a6d9265ec017a00,isSameLength,"public static boolean isSameLength(final byte[] array1,final byte[] array2){
  if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {
    return false;
  }
  return true;
}
","/** 
 * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array
 */
",Check whether the length of the given two byte arrays is the same.,Checks if two byte arrays have the same length.,"The function returns `true` if both byte arrays are `null` or if they are non-null and have the same length. It returns `false` if one is null and the other is not, or if they are both non-null but have different lengths.",Takes two byte arrays `array1` and `array2` as parameters and returns a boolean.,"- Typical usage: `isSameLength(new byte[]{1,2,3}, new byte[]{4,5,6})` returns `true`.
   - Boundary edge case: `isSameLength(new byte[]{}, new byte[]{})` returns `true`.
   - Special case: `isSameLength(null, null)` returns `true`.","Both parameters may be `null`. The function returns `true` only if both arrays are `null` or have the same non-zero length, otherwise it returns `false`.
---
```"
636766a91a6d9265ec0175c2,pop,"private int pop(){
  if (outputStackTop > 0) {
    return outputStack[--outputStackTop];
  }
 else {
    return STACK_KIND | -(--outputStackStart);
  }
}
","/** 
 * Pops an abstract type from the output frame stack and returns its value.
 * @return the abstract type that has been popped from the output frame stack.
 */
",Pop an abstract type from the output frame stack and return its value.,Returns an item from `outputStack` or a computation involving `outputStackStart`.,"The function checks if `outputStackTop` is greater than zero; if true, it decrements `outputStackTop` and returns the new top item from `outputStack`. If false, it decrements `outputStackStart`, negates it, combines it with `STACK_KIND` using bitwise OR, and returns the result.",No parameters; returns an `int`.,"- Typical usage: If `outputStackTop` is 3 and `outputStack = [10, 20, 30]`, `pop()` returns `30` after decrementing `outputStackTop`.
   - Boundary edge case: If `outputStackTop` is 1 with `outputStack = [10]`, `pop()` returns `10`; subsequent calls when `outputStackTop` is 0 return `STACK_KIND | -outputStackStart`.
   - Special or unusual case: If called when `outputStackTop` is 0, directly returns a value computed using `outputStackStart` and `STACK_KIND`.","- Preconditions: `outputStack`, `outputStackTop`, `outputStackStart`, and `STACK_KIND` should be properly initialized.
   - Postconditions: The method modifies `outputStackTop` or `outputStackStart` based on its condition checks and returns an integer.
---"
636767081a6d9265ec017989,toPrimitive,"public static boolean[] toPrimitive(final Boolean[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;
  }
  final boolean[] result=new boolean[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].booleanValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Booleans to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Boolean</code> array, may be <code>null</code>
 * @return a <code>boolean</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Convert the given Boolean array to primitives. Return ArrayUtils.EMPTY_BOOLEAN_ARRAY for an empty array, return null for null array.",Converts an array of Boolean objects to an array of primitive booleans.,"The function takes an array of Boolean objects and checks if it's null or empty. If null, it returns null. If empty, it returns a predefined constant empty boolean array. Otherwise, it creates a new boolean array of the same length and populates it by unboxing each Boolean to a boolean primitive.",The function receives an array of Boolean objects (`Boolean[]`) and returns a corresponding array of primitive booleans (`boolean[]`).,"- **Typical usage:** Input: `[Boolean.TRUE, Boolean.FALSE]` Output: `[true, false]`
   - **Boundary edge case:** Input: `null` Output: `null`
   - **Boundary edge case:** Input: `new Boolean[0]` Output: `ArrayUtils.EMPTY_BOOLEAN_ARRAY`","- Preconditions: The input can either be null, empty, or an array of Boolean objects.
   - Postconditions: The output is null if the input is null, a non-null array of primitive booleans with corresponding true/false values, or a predefined empty array if input is empty.
---
```"
6367672d1a6d9265ec017c73,shouldPrintMessage,"public boolean shouldPrintMessage(int timestamp,String message){
  if (messages.containsKey(message)) {
    if (timestamp - messages.get(message) >= 10) {
      messages.put(message,timestamp);
      return true;
    }
 else {
      return false;
    }
  }
 else {
    messages.put(message,timestamp);
    return true;
  }
}
","/** 
 * Returns true if the message should be printed in the given timestamp, otherwise returns false. If this method returns false, the message will not be printed. The timestamp is in seconds granularity. 
 */
"," If the message does not exist in the dict messages, or it exists but the timestamp (seconds) difference is bigger than 10, put the message and timestamp into messages and return true, otherwise return false.",Rate-limits messages to be printed at least 10 seconds apart.,"The function checks if a message can be printed based on a timestamp constraint. It only allows printing if the message was not printed in the last 10 seconds; otherwise, it updates the timestamp and permits printing.",The function takes an integer `timestamp` and a `String` message as parameters and returns a `boolean`.,"- Typical usage: `shouldPrintMessage(1, ""foo"")` returns `true` (first-time message).
   - Boundary edge case: `shouldPrintMessage(10, ""foo"")` returns `false` (exactly at 10 seconds interval).
   - Special case: `shouldPrintMessage(11, ""foo"")` returns `true` (message interval > 10 seconds).","- Preconditions: The `timestamp` is a non-negative integer, and `message` is a non-empty string.
   - Postconditions: The function ensures a 10-second interval between identical message prints.
---
```"
636766f81a6d9265ec01775c,toString,"public static String toString(Object obj){
  return obj == null ? """" : obj.toString();
}
","/** 
 * <p>Gets the <code>toString</code> of an <code>Object</code> returning an empty string ("""") if <code>null</code> input.</p> <pre> ObjectUtils.toString(null)         = """" ObjectUtils.toString("""")           = """" ObjectUtils.toString(""bat"")        = ""bat"" ObjectUtils.toString(Boolean.TRUE) = ""true"" </pre>
 * @see StringUtils#defaultString(String)
 * @see String#valueOf(Object)
 * @param obj  the Object to <code>toString</code>, may be null
 * @return the passed in Object's toString, or nullStr if <code>null</code> input
 * @since 2.0
 */
","Return the string representation of the given object, return an empty string if the object is null.",Converts an object to a string or returns an empty string if null.,"The function checks if the input object is null; if so, it returns an empty string. Otherwise, it returns the result of the object's `toString()` method.",The function takes an `Object` as a parameter and returns a `String`.,"- Typical usage: `toString(""Hello"")` returns `""Hello""`.
   - Boundary edge case: `toString(null)` returns `""""`.
   - Special or unusual case: `toString(new Object())` returns something like `""java.lang.Object@647e05""` (depending on the object's `toString()` implementation).","- Preconditions: The input can be any object reference or null.
   - Postconditions: The output is a non-null string that represents the input object or is empty if the input is null.
---"
6367667f1a6d9265ec017457,decodeOctets,"private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){
  if (bb.limit() == 1 && (bb.get(0) & 0xFF) < 0x80) {
    sb.append((char)bb.get(0));
    return i + 2;
  }
 else {
    CharBuffer cb=UTF_8_CHARSET.decode(bb);
    sb.append(cb);
    return i + bb.limit() * 3 - 1;
  }
}
","/** 
 * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.
 * @return the index to the next unchecked character in the string to decode
 */
","Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.",Decodes bytes from a ByteBuffer and appends the result to a StringBuilder.,"The function checks if the ByteBuffer contains a single byte less than 0x80, treating it as a single ASCII character; otherwise, it decodes the bytes as UTF-8 characters and appends them to a StringBuilder, updating and returning an index.","The function takes an integer `i`, a `ByteBuffer` `bb`, and a `StringBuilder` `sb`, returning an integer.","- Typical usage: 
     - Input: `decodeOctets(0, ByteBuffer.wrap(new byte[]{65}), new StringBuilder())`
     - Output: Returns 2, StringBuilder is ""A"".
   - Boundary edge case:
     - Input: `decodeOctets(0, ByteBuffer.wrap(new byte[]{}), new StringBuilder())`
     - Output: Returns behavior undefined due to empty buffer.
   - Special or unusual case:
     - Input: `decodeOctets(0, ByteBuffer.wrap(new byte[]{(byte)0xC3, (byte)0xA9}), new StringBuilder())`
     - Output: Returns 5, StringBuilder is ""é"".","- Preconditions: The ByteBuffer `bb` must be non-null; expect valid UTF-8 encoding if `bb.limit() > 1`.
   - Postconditions: The function modifies the StringBuilder `sb` by appending decoded characters and returns an updated integer index.
---
```"
636766aa1a6d9265ec0175ce,visitFrameStart,"int visitFrameStart(final int offset,final int numLocal,final int numStack){
  int frameLength=3 + numLocal + numStack;
  if (currentFrame == null || currentFrame.length < frameLength) {
    currentFrame=new int[frameLength];
  }
  currentFrame[0]=offset;
  currentFrame[1]=numLocal;
  currentFrame[2]=numStack;
  return 3;
}
","/** 
 * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}.
 * @param offset   the bytecode offset of the instruction to which the frame corresponds.
 * @param numLocal the number of local variables in the frame.
 * @param numStack the number of stack elements in the frame.
 * @return the index of the next element to be written in this frame.
 */
","Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.",Initializes or resizes a frame array based on input values.,"The function initializes `currentFrame` to a new array with a length determined by the sum of `numLocal` and `numStack` plus an offset of 3 if it doesn't exist or isn't large enough, sets specific offset values, and returns 3.","`int visitFrameStart(final int offset, final int numLocal, final int numStack)` where it takes three integer parameters `offset`, `numLocal`, `numStack` and returns an integer.","- Typical usage: `visitFrameStart(5, 2, 3)` returns `3` and sets `currentFrame` to `[5, 2, 3, ...]`.
   - Boundary edge case: `visitFrameStart(0, 0, 0)` returns `3` and sets `currentFrame` to `[0, 0, 0]`.
   - Special case: `visitFrameStart(7, 4, 1)` manipulates or resizes `currentFrame` to store `[7, 4, 1, ...]` and returns `3`.","- Preconditions: No explicit constraints on inputs but assumes `currentFrame` may need initialization or resizing.
   - Postconditions: A `currentFrame` array is initialized/updated with the first three elements set as `offset`, `numLocal`, and `numStack`.
---
```"
636767191a6d9265ec017c0f,enlarge,"private void enlarge(final int size){
  int doubleCapacity=2 * data.length;
  int minimalCapacity=length + size;
  byte[] newData=new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];
  System.arraycopy(data,0,newData,0,length);
  data=newData;
}
","/** 
 * Enlarges this byte vector so that it can receive 'size' more bytes.
 * @param size number of additional bytes that this byte vector should be able to receive.
 */
","Enlarge the byte vector data, by increasing it by the given size.",Resizes an internal byte array to accommodate additional data.,"The function doubles the current array's capacity or expands it to the minimum required size, copying existing elements to the new array.",The function takes an integer `size` as a parameter and returns void. It operates on a private field `byte[] data`.,"- Typical usage: 
     - Input: `size = 10`, `data.length = 15`, `length = 5`
     - Result: `newData.length = 30`
   - Boundary edge case:
     - Input: `size = 1`, `data.length = 5`, `length = 5`
     - Result: `newData.length = 10`
   - Special case: 
     - Input: `size = 0`, `data.length = 20`, `length = 20`
     - Result: `newData.length = 40`","- Preconditions: `data` is a non-null byte array, `length` is the number of used elements in `data`, and `size` is non-negative.
   - Postconditions: The `data` array is updated to a new larger size that can accommodate at least `size` more elements.
---
```"
636767821a6d9265ec0183a0,deleteFile,"protected static void deleteFile(String fileName){
  File file=new File(fileName);
  if (file.exists()) {
    file.delete();
  }
}
","/** 
 * Delete's the specified file if it exists 
 */
",Delete the given file if it exists,Deletes a file if it exists in the specified path.,The function checks if a file with the specified name exists and deletes it if it does.,"Takes a single parameter `fileName` which is a `String` representing the file path, and has a `void` return type.","- Typical usage: Input: ""document.txt"" (file exists), deletes the file.
   - Boundary edge case: Input: ""nonexistent.txt"" (file does not exist), does nothing.
   - Special or unusual case: Input: """" (empty string for path), does nothing as no valid file can be identified.","- Preconditions: `fileName` should be a valid string representing a file path.
   - Postconditions: If the file exists, it is deleted, no return value.
---
```"
636767691a6d9265ec0181aa,nullSafeHashCode,"public static int nullSafeHashCode(long[] array){
  if (array == null) {
    return 0;
  }
  int hash=INITIAL_HASH;
  int arraySize=array.length;
  for (int i=0; i < arraySize; i++) {
    hash=MULTIPLIER * hash + hashCode(array[i]);
  }
  return hash;
}
","/** 
 * Return a hash code based on the contents of the specified array. If <code>array</code> is <code>null</code>, this method returns 0.
 * @param array the long array to obtain a hashcode
 * @return the long array's hashcode, which could be 0 if the array is null.
 */
","Compute the hash code of the whole array, by accumulating the multiplication of each element hash code and the  MULTIPLIER.",Computes a hash code for a long array safely handling null values.,"The function calculates a hash code for a given array of longs, returning 0 if the array is null. It starts with an initial hash value and iteratively updates the hash using each element in the array, multiplied by a constant multiplier and combined with each element's hash code using a helper method `hashCode(array[i])`.",The function takes a `long[]` array as input and returns an `int` as the hash code.,"- Typical usage: `nullSafeHashCode(new long[]{1, 2, 3})` returns a computed hash code based on `[1, 2, 3]`.
   - Boundary edge case: `nullSafeHashCode(null)` returns `0`.
   - Special or unusual case: `nullSafeHashCode(new long[]{})` returns the initial hash value since the array is empty.","Expects a `long[]` or `null` as input; outputs an `int` that represents the array's hash code or `0` if null is provided.
---"
636767441a6d9265ec017cc1,rotateRight,"private TreeNode<T> rotateRight(TreeNode<T> node){
  TreeNode<T> left=node.left;
  left.parent=null;
  node.setLeftChild(left.right);
  left.setRightChild(node);
  node.updateHeightAndSubtreeSize();
  left.updateHeightAndSubtreeSize();
  return left;
}
","/** 
 * Performs a right node rotation.
 * @param node a node to rotate
 * @return a new parent of the {@code node}
 */
",Perform a right node rotation on the AVL tree.,Performs a right rotation on a binary tree node.,The function rotates the subtree rooted at the given node to the right by following these steps: 1) It makes the left child of the node the new root of the subtree. 2) The right child of the left child becomes the left child of the old root node. 3) It updates the parental relation and reconnects the subtree to the old root. 4) It updates the height and subtree size attributes for both the old root and new root nodes.,The function takes a single parameter `node` of type `TreeNode<T>` and returns a `TreeNode<T>`.,"- *Typical usage:* Rotating a node with a left child and adjusting tree structure.
      - Input: `node = (3, left=(1, right=2))`
      - Output: `new root = (1, right=(3, left=2))`
   - *Boundary edge case:* Rotating a node with no left child.
      - Input: `node = (3, left=null)`
      - Output: No change, returns the same node.
   - *Special case:* Subtree with various heights.
      - Input: `node = (10, left=(5, left=3, right=8))`
      - Output: `new root = (5, right=(10, left=8))`","The function assumes that the input node is non-null and part of a well-formed binary tree. After the function is executed, the subtree rooted at the node will be rotated to the right, maintaining binary tree properties.
---
```"
6367677e1a6d9265ec01830f,format,"public String format(LoggingEvent event){
  if (sbuf.capacity() > MAX_CAPACITY) {
    sbuf=new StringBuffer(BUF_SIZE);
  }
 else {
    sbuf.setLength(0);
  }
  PatternConverter c=head;
  while (c != null) {
    c.format(sbuf,event);
    c=c.next;
  }
  return sbuf.toString();
}
","/** 
 * Produces a formatted string as specified by the conversion pattern.
 */
","Format the buffered string with the pattern converter, and return the result.",Formats a logging event using a specified pattern conversion.,"The function first checks if the StringBuffer `sbuf` exceeds `MAX_CAPACITY`, reallocating it if necessary and resetting its length otherwise. It then iterates through a linked list of `PatternConverter` objects starting with `head`, applying each converter to format the `sbuf` based on the `LoggingEvent` details. Finally, it returns the formatted string from the buffer.","The function takes one parameter: a `LoggingEvent` object, and returns a `String`.","- **Typical usage:**  
     - Input: `event = new LoggingEvent(""message"")`  
     - Output: ""INFO - message"" (Assuming a pattern that formats messages with level)  
   - **Boundary edge case:**  
     - Input: `event = new LoggingEvent("""")`  
     - Output: ""INFO - "" (Empty event message)  
   - **Special or unusual case:**  
     - Input: `event = null` (not typical usage)  
     - Output: """" or an exception, depending on handling of nulls in `format` method inside `PatternConverter`.","The input `event` is expected to be an instance of `LoggingEvent`. The function assumes `sbuf` and `head` are properly initialized. The output is a formatted string representation based on the pattern converters.
---
```"
636767031a6d9265ec0178dd,contentLength,"public long contentLength(){
  long size;
  try {
    size=Long.parseLong(request.getHeader(FileUpload.CONTENT_LENGTH));
  }
 catch (  NumberFormatException e) {
    size=request.getContentLength();
  }
  return size;
}
","/** 
 * Retrieve the content length of the request.
 * @return The content length of the request.
 * @since 1.3
 */
","Compute and return the length of the request content header, return the content length if NumberFormatException happens.",Returns the content length of a file upload request.,"Attempts to extract the content length from the request header using `FileUpload.CONTENT_LENGTH`; if parsing fails, uses `request.getContentLength()`.",No parameters; returns a long representing the content length.,"- Typical usage: Content-Length header is ""1024"", returns `1024L`.
   - Boundary edge case: Content-Length header is missing, returns value from `request.getContentLength()`.
   - Special or unusual case: Content-Length header is ""notANumber"", returns value from `request.getContentLength()`.","Requires a valid HTTP request object; ensures a non-negative long output representing content length.
---"
636766f11a6d9265ec017658,indexOfLastSeparator,"public static int indexOfLastSeparator(String filename){
  if (filename == null) {
    return -1;
  }
  int lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);
  int lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);
  return Math.max(lastUnixPos,lastWindowsPos);
}
","/** 
 * Returns the index of the last directory separator character. <p> This method will handle a file in either Unix or Windows format. The position of the last forward or backslash is returned. <p> The output will be the same irrespective of the machine that the code is running on.
 * @param filename  the filename to find the last path separator in, null returns -1
 * @return the index of the last separator character, or -1 if thereis no such character
 */
","Return the index of the last directory separator character, under Unix or Windows.",Finds the last occurrence of file path separators in a filename string.,"The function checks for the last occurrence of both Unix-like '/' and Windows '\' separators in the provided filename and returns the index of the last occurrence among them. If the filename is null, it returns -1.",Takes a String `filename` as input and returns an `int` representing the index.,"- Typical usage: `indexOfLastSeparator(""path/to/file.txt"")` returns `8`.
   - Boundary edge case: `indexOfLastSeparator(""file"")` returns `-1`.
   - Special or unusual case: `indexOfLastSeparator(""C:\\path\\to\\file.txt"")` returns `10`.","- Preconditions: The input `filename` is a `String` or null.
   - Postconditions: The function returns a non-negative integer index of the last separator or -1 if none exists.
---
```"
636767121a6d9265ec017b0a,parseEndOfLine,"private int parseEndOfLine(String headerPart,int end){
  int index=end;
  for (; ; ) {
    int offset=headerPart.indexOf('\r',index);
    if (offset == -1 || offset + 1 >= headerPart.length()) {
      throw new IllegalStateException(""Expected headers to be terminated by an empty line."");
    }
    if (headerPart.charAt(offset + 1) == '\n') {
      return offset;
    }
    index=offset + 1;
  }
}
","/** 
 * Skips bytes until the end of the current line.
 * @param headerPart The headers, which are being parsed.
 * @param end Index of the last byte, which has yet been processed.
 * @return Index of the \r\n sequence, which indicates end of line.
 */
",Parse the header part starting from the given end position and return the index of the enter sequence. ,Find the position of '\r\n' sequence ending a line in a string segment.,"The function iteratively searches for the sequence '\r\n' in a given string, starting from a specified index. It returns the position of the '\r' if found; otherwise, it throws an exception if the sequence is not found before the string ends.","The function takes a `String` `headerPart` and an `int` `end`, and returns an `int`.","- Typical usage: 
     Input: `parseEndOfLine(""Header line\r\nAnother line\r\n"", 0)`
     Output: `11`
   - Boundary edge case:
     Input: `parseEndOfLine(""\r\n"", 0)`
     Output: `0`
   - Special or unusual case:
     Input: `parseEndOfLine(""No newline"", 0)`
     Output: throws `IllegalStateException`","- Preconditions: `headerPart` is a non-null string; `end` is a valid index within `headerPart`.
   - Postconditions: Returns the index of '\r' if followed by '\n', throws exception otherwise.
---
```"
636766f61a6d9265ec017701,lastIndexOf,"public static int lastIndexOf(String str,String searchStr){
  if (StringUtils.isEmpty(str)) {
    return StringUtils.INDEX_NOT_FOUND;
  }
  return str.lastIndexOf(searchStr);
}
","/** 
 * Finds the last index within a String, handling <code>null</code>. This method uses  {@link String#lastIndexOf(String)}. 
 */
","Find the last index of the searchStr in str, and return INDEXNOTFOUND if str is empty.","Returns the last index where a substring occurs in a string, or a constant if the string is empty.","The function checks if the string `str` is empty using `StringUtils.isEmpty`; if it is, it returns `StringUtils.INDEX_NOT_FOUND`. Otherwise, it uses the `lastIndexOf` method of the `String` class to find the last occurrence of `searchStr` within `str` and returns that index.","Takes two `String` parameters (`str`, `searchStr`) and returns an `int`.","- Typical usage: `lastIndexOf(""hello, world"", ""o"")` returns `8`.
   - Boundary edge case: `lastIndexOf("""", ""o"")` returns `StringUtils.INDEX_NOT_FOUND`.
   - Special case: `lastIndexOf(""hello"", ""z"")` returns `-1`.","- Preconditions: `str` and `searchStr` are both non-null strings.
   - Postconditions: Returns the last index of `searchStr` in `str`, or `StringUtils.INDEX_NOT_FOUND` if `str` is empty or `searchStr` does not occur in `str`.
---
```"
6367670b1a6d9265ec0179fe,write,"@Override public void write(byte b[]) throws IOException {
  checkThreshold(b.length);
  getStream().write(b);
  written+=b.length;
}
","/** 
 * Writes <code>b.length</code> bytes from the specified byte array to this output stream.
 * @param b The array of bytes to be written.
 * @exception IOException if an error occurs.
 */
",Write the given byte array b into the output stream that this class represents.,Writes byte array data to an output stream while tracking the number of bytes written and checking the write threshold.,"The function checks if the length of the byte array `b[]` exceeds a certain threshold through `checkThreshold()`, then writes the byte array to the associated output stream using `getStream().write(b)`, and increments the `written` count by the length of the byte array.",Takes a single parameter `b[]` of type `byte[]` and returns nothing (`void`); may throw `IOException`.,"- Typical usage: Input: `write(new byte[]{0, 1, 2})` → Writes the bytes 0,1,2, increases `written` by 3.
   - Boundary edge case: Input: `write(new byte[]{})` → Writes nothing, `written` remains unchanged.
   - Special or unusual case: Input: `write(new byte[]{Byte.MAX_VALUE, Byte.MIN_VALUE})` → Writes max and min byte values, `written` increases by 2.","- Preconditions: 
     - `b` should be a non-null array of bytes.
     - The output stream derived from `getStream()` should be open and writable.
     - `checkThreshold(b.length)` must handle the byte array length correctly.
   - Postconditions: 
     - Byte array `b` is written to the output stream.
     - The `written` counter is incremented by the length of `b`.
     - If an error occurs during writing, an `IOException` is thrown.
---
```"
636767df1a6d9265ec01873c,id,"public String id(String entityId){
  if (entityId == null) {
    return String.valueOf(point);
  }
 else {
    return point + Const.ID_CONNECTOR + entityId;
  }
}
","/** 
 * @return the row id
 */
",Return the id by concatenating the point and the entity id with id connector.,Concatenates a constant prefix with an entity ID if provided.,"Returns a string that combines a constant value `point` and a connecting string if `entityId` is non-null; otherwise, it returns the string representation of `point`.",The function takes a single parameter `entityId` of type `String` and returns a `String`.,"- Typical usage: `id(""123"")` may return `""point_value-123""`.
   - Boundary edge case: `id(null)` returns `""point_value""`.
   - Unusual case: If `entityId` is `""""`, it may return `""point_value-""`.","The `entityId` can be `null` or any string, and `point` should be initialized and `Const.ID_CONNECTOR` should be defined. The function must return a valid string even for `null` input.
---
```"
636766f91a6d9265ec01777f,toBoolean,"public static boolean toBoolean(Boolean bool){
  if (bool == null) {
    return false;
  }
  return bool.booleanValue() ? true : false;
}
","/** 
 * <p>Converts a Boolean to a boolean handling <code>null</code> by returning <code>false</code>.</p> <pre> BooleanUtils.toBoolean(Boolean.TRUE)  = true BooleanUtils.toBoolean(Boolean.FALSE) = false BooleanUtils.toBoolean(null)          = false </pre>
 * @param bool  the boolean to convert
 * @return <code>true</code> or <code>false</code>, <code>null</code> returns <code>false</code>
 */
",Convert a Boolean to a boolean handling null by returning false.,Converts a Boolean object to a primitive boolean value.,"The function checks if the provided Boolean object is null; if it is, it returns false. Otherwise, it returns the primitive boolean value that the Boolean object represents.",The function takes a single parameter of type Boolean and returns a primitive boolean.,"- Typical usage: `toBoolean(Boolean.TRUE)` returns `true`.
   - Boundary edge case: `toBoolean(null)` returns `false`.
   - Special case: `toBoolean(Boolean.FALSE)` returns `false`.","- Preconditions: The input can be a Boolean object or null.
   - Postconditions: The output is a primitive boolean value, with null objects resulting in `false`.
---"
6367675f1a6d9265ec0180d3,identity,"public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){
  Map<V,V> fMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());
  Map<V,V> bMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());
  for (  V v : graph.vertexSet()) {
    fMap.put(v,v);
    bMap.put(v,v);
  }
  return new IsomorphicGraphMapping<>(fMap,bMap,graph,graph);
}
","/** 
 * Computes an identity automorphism (i.e. a self-mapping of a graph in which each vertex also maps to itself).
 * @param graph the input graph
 * @param < V > the graph vertex type
 * @param < E > the graph edge type
 * @return a mapping from graph to graph
 */
",Compute and return an identity automorphism for the given graph.,"Returns a mapping of a graph to itself, establishing an identity isomorphism.","The function creates a mapping from each vertex in the graph to itself, forming a bijective mapping for each vertex in both forward (`fMap`) and backward (`bMap`) directions, subsequently returning an `IsomorphicGraphMapping` object that maps the graph to itself using these maps.","The function takes one parameter, a `Graph<V,E>` object representing the graph, and returns an `IsomorphicGraphMapping<V,E>` object.","- Typical usage: For a graph `G` with vertices {A, B, C}, `identity(G)` returns a mapping where A->A, B->B, C->C.
   - Boundary edge case: For an empty graph `G`, `identity(G)` returns an `IsomorphicGraphMapping` with empty maps.
   - Special or unusual case: For a graph `G` with a single vertex {A}, `identity(G)` returns a mapping where A->A.","- Preconditions: The input must be a valid graph object with a defined set of vertices.
   - Postconditions: The output is an `IsomorphicGraphMapping` that represents an identity mapping from the graph to itself.
---
```"
636766ff1a6d9265ec017851,findByte,"protected int findByte(byte value,int pos){
  for (int i=pos; i < tail; i++) {
    if (buffer[i] == value) {
      return i;
    }
  }
  return -1;
}
","/** 
 * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.
 * @param value The value to find.
 * @param pos   The starting position for searching.
 * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.
 */
","Searche for a byte of the specified value in the buffer, starting at the specified position.",Find the index of a specified byte value in a buffer array starting from a given position.,"The function iterates through a buffer array from a specified starting position to the end, returning the index of the first occurrence of a specified byte value; if not found, it returns -1.",Takes a byte `value` to search for and an integer `pos` indicating the starting position; returns an integer.,"- **Typical usage:** Given `buffer = {1, 2, 3, 4}` and `pos = 1`, `findByte(3, 1)` returns `2`.
   - **Boundary edge case:** Given `buffer = {1, 2, 3, 4}` and `pos = 4`, `findByte(3, 4)` returns `-1`.
   - **Special or unusual case:** Given `buffer = {1, 2, 2, 2}` and `pos = 0`, `findByte(2, 2)` returns `2`.","Assumes `buffer` is initialized and `pos` is within bounds [0, buffer.length); returns index or -1 if value is not found within the range starting from `pos`.
---
```"
636767a41a6d9265ec018582,writeDelimitedTo,"public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {
  if (buffer.start != buffer.offset)   throw new IllegalArgumentException(""Buffer previously used and had not been reset."");
  final ProtobufOutput output=new ProtobufOutput(buffer);
  schema.writeTo(output,message);
  final int size=output.getSize();
  ProtobufOutput.writeRawVarInt32Bytes(out,size);
  final int msgSize=LinkedBuffer.writeTo(out,buffer);
  assert size == msgSize;
  return size;
}
","/** 
 * Serializes the  {@code message}, prefixed with its length, into an  {@link OutputStream}.
 * @return the size of the message
 */
","Use ProtobufOutput and the LinkedBuffer to write the message into the given OutputStream out, and return the message size.",Serializes a message to an output stream with a prefixed length.,"This function writes a serialized form of a message into an output stream by first checking if the provided buffer is reset. It utilizes the supplied schema to serialize the message into the buffer, calculates the serialized size, writes the size as a varint to the output stream, writes the buffer contents to the stream, and ensures the written size matches the serialized size before returning it.","This method is generic and takes an `OutputStream` where data will be written, a message `T` to be serialized, a `Schema<T>` for serialization logic, and a `LinkedBuffer` that holds the intermediary serialized data. It returns an `int` that represents the number of bytes written to the stream.","- Typical usage: Given an initialized buffer, a valid message object, schema, and output stream, the function will serialize the message, write the length as varint, and then write the serialized data.
   - Boundary edge case: If `buffer.start` is not equal to `buffer.offset`, an `IllegalArgumentException` is thrown immediately, and no data is written.
   - Special or unusual case: If the message size is zero, the function will still write a varint indicating the size (which is zero) to the output stream.","- Preconditions: The `LinkedBuffer` must be reset (i.e., unused) before calling this function.
   - Postconditions: The message is serialized, the size is prepended as a varint, and the output stream contains the complete message prefixed with its byte length. The returned size should match the serialized message's byte count.
---
```"
636766821a6d9265ec0174b6,resolveArguments,"public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){
  Class<?>[] result=null;
  if (genericType instanceof ParameterizedType) {
    ParameterizedType paramType=(ParameterizedType)genericType;
    Type[] arguments=paramType.getActualTypeArguments();
    result=new Class[arguments.length];
    for (int i=0; i < arguments.length; i++)     result[i]=resolveClass(arguments[i],targetType);
  }
 else   if (genericType instanceof TypeVariable) {
    result=new Class[1];
    result[0]=resolveClass(genericType,targetType);
  }
  return result;
}
","/** 
 * Resolves the arguments for the  {@code genericType} using the type variable information for the{@code targetType}. Returns  {@code null} if {@code genericType} is not parameterized or ifarguments cannot be resolved.
 */
",Resolve and return the arguments for the genericType using the type variable information for the targetType. Returns null if  genericType is not parameterized or if arguments cannot be resolved.,Resolves generic type arguments into classes.,"The function extracts and resolves the actual type arguments of a given generic type (either a `ParameterizedType` or a `TypeVariable`) against a specified target class, returning them as an array of `Class<?>`.",The function takes a `Type` object representing the generic type and a `Class<?>` object representing a target class; it returns an array of `Class<?>` representing resolved type arguments.,"- Typical usage: `resolveArguments(List<String>.class, List.class)` returns `[String.class]`.
   - Boundary edge case: `resolveArguments(List.class, List.class)` returns `null`.
   - Special or unusual case: `resolveArguments(Map.Entry<K, V>.class, Map.class)` returns `[Object.class, Object.class]`.","- Preconditions: The input type should be a valid Java `Type`, and the target should be a valid `Class`.
- Postconditions: Returns an array of resolved `Class<?>` if the type is parameterized or a type variable; otherwise, returns `null`.
---"
636767e11a6d9265ec018781,accept,"@Override public void accept(final METRICS data){
  final String id=data.id();
  final METRICS existed=buffer.get(id);
  if (existed == null) {
    buffer.put(id,data);
  }
 else {
    final boolean isAbandoned=!existed.combine(data);
    if (isAbandoned) {
      buffer.remove(id);
    }
  }
}
","/** 
 * Accept the data into the cache and merge with the existing value. This method is not thread safe, should avoid concurrency calling.
 * @param data to be added potentially.
 */
","Accept the data into the buffer if its id does not exist in the buffer. Otherwise try to combine it with the existing value, and remove it if the combined is abandoned.",Manage METRICS data with unique IDs for buffering.,"The function checks if the incoming METRICS data with a unique ID exists in the buffer. If it does not, the data is added to the buffer. If it does exist, it attempts to combine the new data with the existing data using the `combine` method. If combining fails, the existing data is removed from the buffer.",The function `accept` takes a single parameter `data` of type `METRICS` and has no return value.,"- Typical usage: 
     - Input: `accept(new METRICS(""id1"", ...))` when ""id1"" is not in buffer
     - Output: METRICS stored in buffer with ID ""id1"".
   - Boundary edge case: 
     - Input: `accept(new METRICS(""id2"", ...))` when ""id2"" is in buffer and doesn't combine
     - Output: METRICS with ID ""id2"" removed from buffer.
   - Special case:
     - Input: `accept(new METRICS(""id3"", ...))` where combining succeeds
     - Output: METRICS with ID ""id3"" is updated in buffer.","- Preconditions: `data` must have a method `id()` returning a unique identifier and a method `combine()` returning a boolean.
   - Postconditions: Buffer will only contain METRICS data that is not flagged as abandoned.
---
```"
636766f11a6d9265ec017641,available,"@Override public int available() throws IOException {
  return this.index < this.length ? this.length - this.index : this.length >= 0 && this.reader.ready() ? 1 : 0;
}
","/** 
 * @see InputStream#available() 
 */
",Check the available space of this InputStream according to the index.,Determines the number of bytes available for reading from a stream.,"The function checks if the current index is less than the total length. If true, it returns the difference between the length and the index. If the index is not less than the length, it checks if the reader is ready to be read and returns 1 if true; otherwise, it returns 0.",() -> int,"- Typical usage: If `length = 10` and `index = 5`, `available()` returns `5`.
   - Boundary edge case: If `length = 0` and `index = 0`, but `reader.ready()` returns `true`, `available()` returns `1`.
   - Special case: If `index = 15` and `length = 10` with `reader.ready()` returning `false`, `available()` returns `0`.","- Preconditions: The function assumes valid `index`, `length`, and a `reader` with a `ready()` method.
   - Postconditions: The function will return a non-negative integer, representing available bytes or a readiness state.
---"
636767dd1a6d9265ec0186e5,addNewTarget,"public void addNewTarget(Channels channels,IConsumer consumer){
  Group group=new Group(channels,consumer);
  ArrayList<Group> newList=new ArrayList<Group>();
  for (  Group target : consumeTargets) {
    newList.add(target);
  }
  newList.add(group);
  consumeTargets=newList;
  size+=channels.size();
}
","/** 
 * Add a new target channels.
 */
",Add the given target channels to the consumeTargets.,Adds a new target group to consumeTargets and updates the size.,"The function creates a new Group object with given channels and consumer, adds it to a new list along with copying existing groups from consumeTargets, updates consumeTargets to this new list, and increments the size variable by the number of channels.",Takes a Channels object and an IConsumer object as parameters and returns void.,"- Typical usage:
     - Input: `channels = Channels(5), consumer = IConsumer()`
     - Before: `consumeTargets = [Group1, Group2], size = 10`
     - After: `consumeTargets = [Group1, Group2, NewGroup], size = 15`
   - Boundary edge case:
     - Input: `channels = Channels(0), consumer = IConsumer()`
     - Before: `consumeTargets = [Group1], size = 5`
     - After: `consumeTargets = [Group1, NewGroup], size = 5`
   - Special case:
     - Input: `channels = Channels(-1), consumer = IConsumer()`
     - Before: `consumeTargets = [Group1], size = 5`
     - After: `consumeTargets = [Group1, NewGroup], size = 4`","- Preconditions: The consumeTargets is initialized; size correctly reflects the total of all channels in consumeTargets.
   - Postconditions: A new Group is added to consumeTargets, and size is incremented by the number of channels in the new Group.
---
```"
636767871a6d9265ec01846d,createConfigurationDirectory,"public static void createConfigurationDirectory(){
  String home=System.getProperty(""user.home"");
  String sep=System.getProperty(""file.separator"");
  File f=new File(home + sep + ""lf5"");
  if (!f.exists()) {
    try {
      f.mkdir();
    }
 catch (    SecurityException e) {
      e.printStackTrace();
    }
  }
}
","/** 
 * Creates the directory where the MRU file list will be written. The ""lf5"" directory is created in the Documents and Settings directory on Windows 2000 machines and where ever the user.home variable points on all other platforms.
 */
","Create the ""lf5"" directory in the Documents and Settings directory on Windows machines, or the user.home variable points on all other platforms.","Creates an ""lf5"" directory in the user's home if it doesn't exist.","The function retrieves the user's home directory path and file separator, constructs a path for a directory named ""lf5"", and creates it if it does not already exist, handling any security exceptions that may occur.",The function takes no parameters and returns no value.,"- Typical usage: If the user's home directory is ""/home/user"" and ""lf5"" does not exist, the function creates ""/home/user/lf5"".
   - Boundary edge case: If the ""lf5"" directory already exists in the user's home, the function does nothing.
   - Special or unusual case: If the user lacks permission to create the directory, a SecurityException is caught and its stack trace is printed.","Preconditions: The function assumes the existence of the user home directory and valid system properties. Postconditions: If permissions allow, the directory ""lf5"" will exist within the user's home directory after execution.
---
```"
636766f81a6d9265ec01775b,readLong,"public long readLong(final int offset){
  long l1=readInt(offset);
  long l0=readInt(offset + 4) & 0xFFFFFFFFL;
  return (l1 << 32) | l0;
}
","/** 
 * Reads a signed long value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
 * @param offset the start offset of the value to be read in this {@link ClassReader}.
 * @return the read value.
 */
",Read a signed long value.,Combines two 32-bit integers read from a given offset into a 64-bit long.,"The function reads two 32-bit integers from a specific offset in memory: the first integer at the given offset and the second one at the offset plus 4 bytes. It then combines them into a single 64-bit long by shifting the first integer by 32 bits to the left and using bitwise OR to include the second integer, which is treated as an unsigned 32-bit value.",The function takes an integer `offset` as a parameter and returns a long.,"- **Typical usage:** `readLong(0)` might return `4294967298` if `readInt(0)` returns `1` and `readInt(4)` returns `2`.
   - **Boundary edge case:** `readLong(Integer.MAX_VALUE)` assumes a valid offset is provided; boundary specifics depend on implementation of `readInt`.
   - **Special or unusual case:** `readLong(offset)` could return a large negative number if the first integer is negative and bits are treated as signed.","- Preconditions: `offset` must be a valid starting point for reading two consecutive 32-bit integers.
   - Postconditions: Returns a 64-bit long that combines two 32-bit integers from memory.
---
```"
636767a51a6d9265ec01859d,equals,"public boolean equals(final byte[] data,int offset,final int len){
  final byte[] bytes=this.bytes;
  if (len != bytes.length)   return false;
  for (int i=0; i < len; ) {
    if (bytes[i++] != data[offset++]) {
      return false;
    }
  }
  return true;
}
","/** 
 * Returns true if the contents of the internal array and the provided array match.
 */
",Return true if the contents of the internal array bytes and the provided array data match.,Compares a segment of a byte array to another byte array.,"This method checks if a slice of the given 'data' array, starting from 'offset' and having length 'len', matches the 'bytes' array exactly. It returns false if lengths differ or any byte does not match.","The function takes a byte array 'data', an integer 'offset', and an integer 'len'; it returns a boolean.","- Typical usage: `equals([0,1,2,3], 0, 4)` returns `true` if `this.bytes` is `[0,1,2,3]`.
   - Boundary edge case: `equals([1,2,3], 1, 2)` returns `false` if `this.bytes` is `[1,2]` since segment lengths aren't matching.
   - Special case: `equals([3,2,1,0], 2, 2)` returns `false` if `this.bytes` is `[1,2]` since elements don't match exactly.","- Preconditions: 'data' must have at least 'offset' + 'len' elements, and 'offset', 'len' must be non-negative.
   - Postconditions: Returns true if the specified segment of 'data' matches 'bytes'; false otherwise.
---"
6367670b1a6d9265ec0179ff,nullToEmpty,"public static Byte[] nullToEmpty(final Byte[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
",Return an EMPTY_BYTE_OBJECT_ARRAY array for a null or empty input array.,Converts null or empty Byte arrays to a predefined empty Byte array.,"The function checks if the input Byte array is null or has zero length. If so, it returns a constant empty Byte array from `ArrayUtils`. Otherwise, it returns the input array as-is.",The function takes a `Byte[]` array as input and returns a `Byte[]` array.,"- Typical usage: `nullToEmpty(new Byte[]{1, 2, 3})` returns `[1, 2, 3]`.
   - Boundary edge case: `nullToEmpty(null)` returns `ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY`.
   - Special or unusual case: `nullToEmpty(new Byte[]{})` returns `ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY`.","- Preconditions: The input can be a null `Byte[]` or any `Byte[]`.
   - Postconditions: The output is never null; it is either the input array or a constant empty array.
---
```"
6367677f1a6d9265ec018347,send,"public synchronized void send(final String message){
  Iterator ce=connections.iterator();
  for (Iterator e=writers.iterator(); e.hasNext(); ) {
    ce.next();
    PrintWriter writer=(PrintWriter)e.next();
    writer.print(message);
    if (writer.checkError()) {
      ce.remove();
      e.remove();
    }
  }
}
","/** 
 * sends a message to each of the clients in telnet-friendly output. 
 */
",Send a message to each of the connections in telnet-friendly output. ,Sends a message to all writer streams and removes faulty connections.,"The function iterates through `writers` and `connections`. For each `writer`, it sends a `message`, checks for errors, and removes disconnected streams and connections when errors are found.",The function takes a `String` parameter called `message` and has no return type (void).,"- **Typical usage:** With `writers` containing active connections with no errors, sending `""Hello""` broadcasts to all, leaving `writers` unchanged.
   - **Boundary edge case:** With `writers` containing a single faulty connection, sending any message results in that connection being removed.
   - **Special or unusual case:** If `writers` is empty, calling the function has no effect or output.","- Preconditions: `writers` and `connections` are non-null iterables of objects and must be synchronized internally to avoid concurrent modification.
   - Postconditions: All non-faulty connections in `writers` have received the message; faulty ones are removed.
---
```"
6367670a1a6d9265ec0179e8,nullToEmpty,"public static Boolean[] nullToEmpty(final Boolean[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
",Return an EMPTY_BOOLEAN_OBJECT_ARRAY array for a null or empty input array.,"Converts a null or empty Boolean array to an empty array, returns original otherwise.","The function checks if the input Boolean array is null or has a length of zero and returns a predefined empty Boolean object array in these cases; otherwise, it returns the original array.","The function takes a single parameter, a Boolean array, and returns a Boolean array.","- **Typical usage:** Input: `[true, false, true]` Output: `[true, false, true]`
   - **Boundary edge case:** Input: `null` Output: `ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY`
   - **Special or unusual case:** Input: `[]` Output: `ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY`","Input can be null or an array; returns a predefined empty array if input is null or empty, otherwise returns input array.
---
```"
6367677f1a6d9265ec01834b,put,"public void put(LoggingEvent o){
  if (numElements != maxSize) {
    buf[next]=o;
    if (++next == maxSize) {
      next=0;
    }
    numElements++;
  }
}
","/** 
 * Place a  {@link LoggingEvent} in the buffer. If the buffer is fullthen the event is <b>silently dropped</b>. It is the caller's responsability to make sure that the buffer has free space.  
 */
",Place a  LoggingEvent in the buffer buf.,Appends an element to a circular buffer if it's not full.,"The function adds a `LoggingEvent` object to a circular buffer if the buffer isn't already full. It places the object at the position designated by `next`, increments the `next` index (wrapping to zero if necessary), and increments the `numElements` counter.","The function takes a single parameter, `LoggingEvent o`, and has a void return type.","- Typical usage: If `maxSize` is 5 and `numElements` is 3, adding a new `LoggingEvent` will increase `numElements` to 4 and place the event at `buf[next]`.
   - Boundary edge case: When `numElements` equals `maxSize`, no event is added, and `next` and `numElements` remain unchanged.
   - Special case: If `next` is at the last index for a full buffer, adding an event will place it at the start of the buffer if there is space.","- Preconditions: `buf` is non-null, and `maxSize` is a positive integer representing the buffer's size.
   - Postconditions: `LoggingEvent` is added to `buf` only if `numElements` is less than `maxSize`. `next` wraps around if it exceeds `maxSize - 1`.
---
```"
636767df1a6d9265ec018744,buildTimeRanges,"protected List<TimeRange> buildTimeRanges(long start,long end){
  if (start >= end) {
    return null;
  }
  end+=1;
  final List<TimeRange> timeRanges=new ArrayList<>();
  do {
    long batchEnd=Math.min(start + FETCH_DATA_DURATION,end);
    timeRanges.add(new TimeRange(start,batchEnd));
    start=batchEnd;
  }
 while (start < end);
  return timeRanges;
}
","/** 
 * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}
 */
",Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.,Returns a list of TimeRange objects splitting a time interval into maximum-sized batches.,"The function creates a list of `TimeRange` objects, dividing a given interval between `start` and `end` into segments of size up to `FETCH_DATA_DURATION`, incrementing the current batch's start each time to create new segments until the end is reached.","The function takes two parameters: `start` (long) and `end` (long), and returns a `List<TimeRange>`.","- **Typical usage:** 
     - Input: `buildTimeRanges(0, 1000)` with `FETCH_DATA_DURATION = 500`
     - Output: `[TimeRange(0,500), TimeRange(500,1000)]`
   - **Boundary edge case:** 
     - Input: `buildTimeRanges(1000, 1000)`
     - Output: `null`
   - **Special case:** 
     - Input: `buildTimeRanges(1000, 1008)` with `FETCH_DATA_DURATION = 5`
     - Output: `[TimeRange(1000, 1005), TimeRange(1005, 1009)]`","- Preconditions: `start` and `end` must be non-negative integers.
   - Postconditions: Returns `null` if `start` is greater than or equal to `end`; otherwise, returns a list of `TimeRange` objects, ensuring each time range splits the interval into segments no longer than `FETCH_DATA_DURATION`.
---
```"
636767031a6d9265ec0178e6,toPrimitive,"public static byte[] toPrimitive(final Byte[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_BYTE_ARRAY;
  }
  final byte[] result=new byte[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].byteValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Bytes to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Byte</code> array, may be <code>null</code>
 * @return a <code>byte</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Convert an array of object Bytes to primitives, return null for a null input array.",Converts an array of Byte objects to a byte array.,"The function checks if the input Byte array is null, returning null if true. If the array is empty, it returns a predefined empty byte array. It then iterates over the input array, converting each Byte object to its corresponding byte primitive and storing it in a new byte array, which is returned.",The function accepts a parameter `array` of type `Byte[]` and returns `byte[]`.,"- Typical usage: `toPrimitive(new Byte[]{1, 2, 3})` returns `[1, 2, 3]`.
   - Boundary edge case: `toPrimitive(new Byte[]{})` returns `ArrayUtils.EMPTY_BYTE_ARRAY`.
   - Special or unusual case: `toPrimitive(null)` returns `null`.","- Preconditions: The input should be an array of Byte objects or null.  
    - Postconditions: The function outputs a byte array equivalent to the input or null/empty array if the input was null/empty.
---
```"
636767dc1a6d9265ec0186be,compressTimeBucket,"static long compressTimeBucket(long timeBucket,int dayStep){
  if (dayStep > 1) {
    DateTime time=TIME_BUCKET_FORMATTER.parseDateTime("""" + timeBucket);
    int days=Days.daysBetween(DAY_ONE,time).getDays();
    int groupBucketOffset=days % dayStep;
    return Long.parseLong(time.minusDays(groupBucketOffset).toString(TIME_BUCKET_FORMATTER));
  }
 else {
    return timeBucket;
  }
}
","/** 
 * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123
 */
","Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.",The function adjusts a time bucket to align with specified day intervals.,"The function parses the given `timeBucket` into a date, calculates the number of days from a reference date (`DAY_ONE`), finds the offset from the nearest multiple of `dayStep`, and adjusts the date backwards by this offset to return a new time bucket; returns the original if `dayStep` is 1 or less.","`compressTimeBucket(long timeBucket, int dayStep): long`","- Typical usage: `compressTimeBucket(20230501, 3)` returns an adjusted time bucket aligning to the first day in a 3-day cycle.
   - Boundary edge case: `compressTimeBucket(20230101, 1)` returns 20230101 as no changes are needed.
   - Special case: `compressTimeBucket(20230715, 5)` aligns 20230715 to the start of the nearest 5-day interval, returning 20230711.","- Preconditions: `timeBucket` is a valid date in the format of `YYYYMMDD`; `dayStep` is a positive integer.
   - Postconditions: The function returns a valid time bucket adjusted to the specified `dayStep` intervals or the original `timeBucket` if no adjustment is needed.
---
```"
636767a41a6d9265ec01856c,computeUTF8Size,"public static int computeUTF8Size(final CharSequence str,final int index,final int len){
  int size=len;
  for (int i=index; i < len; i++) {
    final char c=str.charAt(i);
    if (c < 0x0080)     continue;
    if (c < 0x0800)     size++;
 else     size+=2;
  }
  return size;
}
","/** 
 * Computes the size of the utf8 string beginning at the specified  {@code index} with the specified {@code length}.
 */
",Compute the size of the utf8 string beginning at the specified  index  with the specified length.,Calculates the UTF-8 encoded byte size of a substring in a CharSequence.,"The function calculates the number of bytes required to encode a substring of a given CharSequence as UTF-8, starting at a specified index and for a specified length. It iterates through each character of the substring, increasing the byte size based on the character's value: 1 byte for ASCII (0-127), 2 bytes for characters from 128 to 2047, and 3 bytes otherwise.","Takes a CharSequence `str`, an integer `index` indicating the start, and an integer `len` for length; returns an integer representing the UTF-8 byte size.","- Typical usage: `computeUTF8Size(""hello"", 0, 5)` returns `5`.  
   - Boundary edge case: `computeUTF8Size("""", 0, 0)` returns `0`.  
   - Special case: `computeUTF8Size(""héllo"", 0, 5)` returns `6`. (The 'é' adds an extra byte.)","The function assumes `index` and `len` are within the bounds of the CharSequence, `len` is non-negative, and the CharSequence contains valid characters; returns a non-negative integer that equals or exceeds `len`.
---
```"
636766f01a6d9265ec017639,asList,"public static <T>List<T> asList(T[] a){
  if (a == null)   return Collections.emptyList();
  return Arrays.asList(a);
}
","/** 
 * Array to List. <p> Works like  {@link Arrays#asList(Object)}, but handles null arrays.
 * @return a list backed by the array.
 */
","Convert an array to list, return empty list for null array.",Converts an array to a list with null handling.,"The function checks if the input array is null; if true, it returns an empty list, otherwise, it uses Arrays.asList to convert the array to a list.",The function takes a generic array T[] as a parameter and returns a List<T>.,"- Typical usage: Input: new Integer[]{1, 2, 3}; Output: [1, 2, 3]
   - Boundary edge case: Input: null; Output: []
   - Special case: Input: new String[]{""apple"", ""banana""}; Output: [apple, banana]","- Preconditions: The input can be a generic array or null.
   - Postconditions: The output is a list converted from the array or an empty list if the input is null.
---
```"
6367672d1a6d9265ec017c74,remove,"public boolean remove(int val){
  if (map.containsKey(val)) {
    map.remove(val);
    values.remove(values.indexOf(val));
    return true;
  }
  return false;
}
","/** 
 * Removes a value from the set. Returns true if the set contained the specified element. 
 */
","Remove a value from the values if the map keys contains the val. Returns true if actually removed, and false otherwise.",Remove value from map and list if it exists.,"The function checks if the value `val` exists in the `map`. If it does, it removes the entry with key `val` from the `map` and also removes the first occurrence of `val` from the `values` list, then returns `true`. If `val` does not exist in the `map`, it returns `false`.",The function takes a single integer parameter `val` and returns a boolean.,"- **Typical usage:** If `map = {1: ""a"", 2: ""b""}` and `values = [1, 2, 3]`, calling `remove(1)` results in `map = {2: ""b""}` and `values = [2, 3]`, returns `true`.
   - **Boundary edge case:** If `map = {}` and `values = []`, calling `remove(1)` returns `false` without modifying anything.
   - **Special or unusual case:** If `map = {3: ""c""}` and `values = [3, 3, 3]`, calling `remove(3)` results in `map = {}` and `values = [3, 3]`, returns `true`.","Assume `map` and `values` are initialized and can potentially be empty or contain duplicates in `values`. The function modifies these collections only if the value exists in the `map`. The map's keys are integers corresponding to the values in the list.
---
```"
6367676b1a6d9265ec0181df,startsWithIgnoreCase,"public static boolean startsWithIgnoreCase(String str,String prefix){
  if (str == null || prefix == null) {
    return false;
  }
  if (str.startsWith(prefix)) {
    return true;
  }
  if (str.length() < prefix.length()) {
    return false;
  }
  String lcStr=str.substring(0,prefix.length()).toLowerCase();
  String lcPrefix=prefix.toLowerCase();
  return lcStr.equals(lcPrefix);
}
","/** 
 * Returns  {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.
 * @param str the String to check
 * @param prefix the prefix to look for
 * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.
 * @see java.lang.String#startsWith
 */
","Return true if the given string starts with the specified case-insensitive prefix, false otherwise.","Checks if a string starts with a specified prefix, ignoring case.","The function verifies if the input string `str` begins with the string `prefix`, ignoring case. It returns `false` if either `str` or `prefix` is `null`. First, it checks for a direct match, then compares the start of `str` with `prefix` after converting both to lowercase.","The function takes two parameters: `str` and `prefix`, both of type `String`, and returns a `boolean`.","- Typical usage: `startsWithIgnoreCase(""HelloWorld"", ""hello"")` returns `true`.
   - Boundary edge case: `startsWithIgnoreCase(""Hi"", ""Hello"")` returns `false`.
   - Special/unusual case: `startsWithIgnoreCase(null, ""test"")` returns `false`.","- Preconditions: Both inputs can be any string, including `null`.
   - Postconditions: Returns `true` if `str` starts with `prefix` ignoring case and `false` otherwise.
---
```"
636767001a6d9265ec017873,reverse,"public static String reverse(final String str){
  if (str == null) {
    return null;
  }
  return new StringBuilder(str).reverse().toString();
}
","/** 
 * <p>Reverses a String as per  {@link StringBuilder#reverse()}.</p> <p>A <code>null</code> String returns <code>null</code>.</p> <pre> StringUtils.reverse(null)  = null StringUtils.reverse("""")    = """" StringUtils.reverse(""bat"") = ""tab"" </pre>
 * @param str  the String to reverse, may be null
 * @return the reversed String, <code>null</code> if null String input
 */
",Reverse the given String as per.,Reverses the order of characters in a given string.,"Takes a string input, checks if it is null, and returns the reversed version using StringBuilder; returns null if input is null.",Takes a single String parameter and returns a String.,"- Typical usage: reverse(""hello"") -> ""olleh""
   - Boundary edge case: reverse("""") -> """"
   - Special or unusual case: reverse(null) -> null","Input can be any string or null; output is the reversed string or null, maintaining input type.
---
```"
636766ff1a6d9265ec01783b,sub,"public static String sub(String str,int start,int end){
  return StringUtils.substring(str,start,end);
}
","/** 
 * Gets a substring from the specified String avoiding exceptions. 
 */
",Get a substring from the specified String avoiding exceptions. ,Extracts a substring from the specified start to end index.,"The function returns a substring from the given string, starting at the specified start index and extending up to the specified end index. It uses the `StringUtils.substring` method which handles edge cases like null input, negative indices, and indices exceeding string length.","Takes a string `str`, an integer `start`, and an integer `end` as parameters; returns a string.","- Typical usage: `sub(""Hello World"", 0, 5)` returns `""Hello""`.
   - Boundary edge case: `sub(""Hello"", 2, 2)` returns `""""`.
   - Special or unusual case: `sub(null, 0, 5)` returns `null`.","- Preconditions: `str` can be null; `start` and `end` should be non-negative but can exceed `str` length.
   - Postconditions: Function returns a valid substring or null if input is null, gracefully handling index bounds.
---"
6367671a1a6d9265ec017c15,putByteArray,"public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){
  if (length + byteLength > data.length) {
    enlarge(byteLength);
  }
  if (byteArrayValue != null) {
    System.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);
  }
  length+=byteLength;
  return this;
}
","/** 
 * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.
 * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.
 * @param byteOffset index of the first byte of byteArrayValue that must be copied.
 * @param byteLength number of bytes of byteArrayValue that must be copied.
 * @return this byte vector.
 */
","Put an array of bytes into this byte vector, enlarge the byte vector automatically if necessary.","Appends a byte array to the ByteVector, starting from specified offset and for a given length.","The function appends a portion of a byte array to the internal byte array of a ByteVector object, enlarging the internal array if necessary, and updates the length of the ByteVector. It uses `System.arraycopy` to perform the copy operation starting from `byteOffset` within the `byteArrayValue` and copies `byteLength` bytes to the current `length` position of the `data` array, then increases the `length` by `byteLength`.","`ByteVector putByteArray(final byte[] byteArrayValue, final int byteOffset, final int byteLength)` returns a `ByteVector`.","- Typical usage: 
     - Input: `byteArrayValue = new byte[]{1, 2, 3, 4, 5}`, `byteOffset = 1`, `byteLength = 3`
     - Output: ByteVector data contains bytes `{2, 3, 4}`
   - Boundary edge case:
     - Input: `byteArrayValue = new byte[]{1, 2}`, `byteOffset = 0`, `byteLength = 0`
     - Output: ByteVector data remains unchanged.
   - Special or unusual case:
     - Input: `byteArrayValue = null`, `byteOffset = 0`, `byteLength = 5`
     - Output: ByteVector data remains unchanged if there is no enlargement needed.","- Preconditions: 
     - `byteArrayValue` can be `null`.
     - `byteOffset` and `byteLength` must refer to valid positions within `byteArrayValue`.
   - Postconditions:
     - The data array is updated with the specified byte portion, and no exception is thrown for `null` `byteArrayValue`.
---
```"
6367675c1a6d9265ec01805b,removeFromTreeEdgeList,"public void removeFromTreeEdgeList(){
  for (int dir=0; dir < 2; dir++) {
    if (prev[dir] != null) {
      prev[dir].next[dir]=next[dir];
    }
 else {
      head[1 - dir].first[dir]=next[dir];
    }
    if (next[dir] != null) {
      next[dir].prev[dir]=prev[dir];
    }
  }
  head[0]=head[1]=null;
}
","/** 
 * Removes this edge from both doubly linked lists of tree edges.
 */
",Remove this edge from both doubly linked lists of the tree edges.,Removes a node from a bidirectional linked list.,"The function iterates through two directions of a doubly linked list and adjusts pointers to remove the current element, updating neighboring nodes for both directions. It sets list head references to null at the end.","This function does not take any parameters and has no return type; it operates on class fields such as `prev`, `next`, and `head`.","- Typical usage: When a node with prev and next defined in both directions is part of a list, calling this function updates its surrounding pointers, effectively removing itself.
   - Boundary edge case: Calling this function on a node that is at the boundary of the list (i.e., has null on one side) will adjust the list without affecting undefined pointers.
   - Special case: If the function operates on nodes that form part of a circular doubly linked list, the integrity of the circular references is maintained.","- Preconditions: The node is part of a doubly linked list represented by `prev`, `next`, and `head` arrays.
   - Postconditions: The node is removed from the list with all relevant pointers updated accordingly, and its head references set to null.
---
```"
636767791a6d9265ec01826d,findAndSubst,"public static String findAndSubst(String key,Properties props){
  String value=props.getProperty(key);
  if (value == null)   return null;
  try {
    return substVars(value,props);
  }
 catch (  IllegalArgumentException e) {
    LogLog.error(""Bad option value ["" + value + ""]."",e);
    return value;
  }
}
","/** 
 * Find the value corresponding to <code>key</code> in <code>props</code>. Then perform variable substitution on the found value.
 */
","Find the value corresponding to key in props, then perform variable substitution on the found value. Return the substitution result, or the value in case of exception. ",Finds and substitutes variables in a string associated with a given key.,"The function retrieves a property value using the key from a Properties object, substitutes any variables within the value using those properties, and returns the substituted result. If the value is not found, it returns null. It handles substitution errors by logging them and returning the originally retrieved value.",The function takes a `String` key and a `Properties` object as parameters and returns a `String`.,"- Typical usage:  
     Input: key = ""path"", props = {""path"": ""${home}/bin"", ""home"": ""/usr/local""}  
     Output: ""/usr/local/bin""
   - Boundary edge case:  
     Input: key = ""home"", props = {""home"": """"}  
     Output: """"
   - Special or unusual case:  
     Input: key = ""unknown"", props = {""path"": ""/bin""}  
     Output: null","Preconditions: The key is a non-null string, and props is a non-null Properties object. Postconditions: Returns a string that has all substitutable variables replaced with their corresponding values, or null if the key is not found.
---
```"
636766fe1a6d9265ec017834,sessionId,"public static String sessionId(){
  HttpSession httpSession=servletSession();
  if (httpSession == null) {
    return null;
  }
  return httpSession.getId();
}
","/** 
 * Session ID. 
 */
",Return the servlet session id,Retrieves the session ID from the HTTP session.,"The function attempts to return the session ID by first obtaining the HttpSession object through another method, `servletSession()`. If the session is not present, it returns `null`; otherwise, it returns the session ID as a String.",No parameters; returns a `String`.,"- Typical usage: If a session is active, `sessionId()` returns something like `""ABC123SESSIONID""`.
       - Boundary edge case: If no session exists, `sessionId()` returns `null`.
       - Special or unusual case: Not applicable as the logic is straightforward.","The `servletSession()` method should correctly handle session creation/retrieval; function returns `null` if no session is present.
    ---"
636766ff1a6d9265ec01784b,isDigits,"public static boolean isDigits(String str){
  if ((str == null) || (str.length() == 0)) {
    return false;
  }
  for (int i=0; i < str.length(); i++) {
    if (!Character.isDigit(str.charAt(i))) {
      return false;
    }
  }
  return true;
}
","/** 
 * <p>Checks whether the <code>String</code> contains only digit characters.</p> <p><code>Null</code> and empty String will return <code>false</code>.</p>
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if str contains only unicode numeric
 */
","Check whether a character string is a dight. If yes, true is returned. Otherwise, false is returned.",Checks if a string consists entirely of digit characters.,"The function returns true if the input string is non-null, non-empty, and all its characters are digits; otherwise, it returns false.","It takes a single parameter, `str` of type `String`, and returns a `boolean`.","- Typical usage: `isDigits(""12345"")` returns `true`.
   - Boundary edge case: `isDigits("""")` returns `false`.
   - Special or unusual case: `isDigits(""12a34"")` returns `false`.","- Preconditions: Input can be any string, including `null` or empty strings.
   - Postconditions: Returns `true` only if the string is non-null, non-empty, and each character is a digit.
---
```"
636766fc1a6d9265ec0177da,isParameterSeparator,"private static boolean isParameterSeparator(final char c){
  if (Character.isWhitespace(c)) {
    return true;
  }
  for (  char separator : PARAMETER_SEPARATORS) {
    if (c == separator) {
      return true;
    }
  }
  return false;
}
","/** 
 * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. 
 */
","Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.",Checks if a character is a whitespace or matches any specified separator.,"The function determines if the given character is a parameter separator by first checking if it is a whitespace using `Character.isWhitespace()`. If it is not whitespace, it checks against a predefined list of separator characters (`PARAMETER_SEPARATORS`) and returns true if the character matches any of these separators.",The function takes a single character (`char c`) as input and returns a boolean indicating if it is a parameter separator.,"- Typical usage: `isParameterSeparator(',')` → `true` (assuming ',' is in `PARAMETER_SEPARATORS`).
   - Boundary edge case: `isParameterSeparator(' ')` → `true` (space is a whitespace).
   - Unusual case: `isParameterSeparator('x')` → `false` (assuming 'x' is not a separator or whitespace).","- Preconditions: `PARAMETER_SEPARATORS` must be defined as an array or collection of characters representing separators.
   - Postconditions: Returns `true` if the character is a whitespace or found in `PARAMETER_SEPARATORS`, otherwise `false`.
---
```"
6367670c1a6d9265ec017a35,endsWith,"private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){
  if (str == null || suffix == null) {
    return str == null && suffix == null;
  }
  if (suffix.length() > str.length()) {
    return false;
  }
  int strOffset=str.length() - suffix.length();
  return str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());
}
","/** 
 * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>
 * @see String#endsWith(String)
 * @param str  the String to check, may be null
 * @param suffix the suffix to find, may be null
 * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.
 * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>
 */
",Determines whether a character string ends with a specified suffix.,Checks if a string ends with a specified suffix.,"The function determines if the input string `str` ends with the `suffix`. It optionally ignores case when comparing, based on the `ignoreCase` boolean. If either string is null, it returns true only if both are null. If the suffix is longer than the input string, it returns false. Otherwise, it uses `regionMatches` to compare the suffix to the corresponding end segment of the input string.","`endsWith(String str, String suffix, boolean ignoreCase)` returns a `boolean`.","- Typical usage: `endsWith(""HelloWorld"", ""World"", false)` returns `true`.
   - Boundary edge case: `endsWith("""", """", false)` returns `true`.
   - Special or unusual case: `endsWith(""Test"", ""TestTest"", false)` returns `false`.","- Preconditions: `str` and `suffix` can be any string or null; `ignoreCase` is a boolean.
   - Postconditions: Returns `true` if the `str` ends with `suffix`, considering the `ignoreCase` for comparisons, or both are null; otherwise, returns `false`.
---"
6367667f1a6d9265ec01745d,decodePath,"public static List<PathSegmentImpl> decodePath(URI u,boolean decode){
  String rawPath=u.getRawPath();
  if (rawPath != null && rawPath.length() > 0 && rawPath.charAt(0) == '/') {
    rawPath=rawPath.substring(1);
  }
  return decodePath(rawPath,decode);
}
","/** 
 * Decode the path component of a URI as path segments.
 * @param u the URI. If the path component is an absolute path componentthen the leading '/' is ignored and is not considered a delimiator of a path segment.
 * @param decode true if the path segments of the path componentshould be in decoded form.
 * @return the list of path segments.
 */
",Decode the raw path.,Trims leading slash from URI's raw path and decodes it if needed.,"The function extracts the raw path from the given URI, removes the initial slash if present, and then calls another method to decode the path into a list of PathSegmentImpl objects, depending on the boolean flag.",The function takes a URI `u` and a boolean `decode` as parameters and returns a `List<PathSegmentImpl>`.,"- **Typical usage:** 
     Input: `decodePath(new URI(""http://example.com:/path/to/resource""), true)`
     Output: Decoded path segments of ""path/to/resource"".
   - **Boundary edge case:** 
     Input: `decodePath(new URI(""http://example.com:/""), false)`
     Output: Empty list, as there's no path segment after the slash.
   - **Special or unusual case:** 
     Input: `decodePath(new URI(""http://example.com:""), true)`
     Output: Empty list, as there's no raw path to decode.","- Preconditions: The input URI must be well-formed and non-null.
   - Postconditions: Returns a list of path segments, with the initial slash removed and optionally decoded elements.
---
```"
636766f11a6d9265ec017651,nullToEmpty,"public static Character[] nullToEmpty(final Character[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
","If array is null or its length is 0, convert array to EMPTY_CHARACTER_OBJECT_ARRAY. Otherwise, return array itself.",Converts null or empty Character arrays to an empty array constant.,"The function checks if the input Character array is null or has zero length; if either condition is true, it returns a predefined empty Character array constant; otherwise, it returns the original array.",The function takes a final Character array as an input parameter and returns a Character array.,"- **Typical usage**
     - Input: ['a', 'b', 'c']
     - Output: ['a', 'b', 'c']
   - **Boundary edge case**
     - Input: null
     - Output: EMPTY_CHARACTER_OBJECT_ARRAY
   - **Special or unusual case**
     - Input: []
     - Output: EMPTY_CHARACTER_OBJECT_ARRAY","- Preconditions: The input is expected to be a Character array or null.
   - Postconditions: Returns a non-null Character array, either the input array itself or an empty array constant if the input is null or empty.
---
```"
636767821a6d9265ec0183ab,hasThrown,"public boolean hasThrown(){
  Throwable thrown=getThrown();
  if (thrown == null) {
    return false;
  }
  String thrownString=thrown.toString();
  return thrownString != null && thrownString.trim().length() != 0;
}
","/** 
 * @return true if getThrown().toString() is a non-empty string.
 */
",Check whether there is a thrown,Checks if a Throwable object has been captured.,"The function retrieves a Throwable object using getThrown() and returns false if it is null. If the Throwable is non-null, it converts it to a string and checks if the resulting string is not empty after trimming; if so, it returns true.",The function takes no parameters and returns a boolean value.,"- Typical usage: If getThrown() returns a non-null Throwable object with a non-empty string representation, the function returns true.
   - Boundary edge case: If getThrown() returns null, the function returns false.
   - Special or unusual case: If getThrown() returns a Throwable with an empty description but non-null, the function returns false.","- Preconditions: It assumes the existence of a getThrown() method that returns a Throwable object or null.
   - Postconditions: Returns true only if a non-null Throwable with a non-empty description is returned by getThrown().
---
```"
636767831a6d9265ec0183c9,peek,"public static String peek(){
  Stack stack=getCurrentStack();
  if (stack != null && !stack.isEmpty())   return ((DiagnosticContext)stack.peek()).message;
 else   return """";
}
","/** 
 * Looks at the last diagnostic context at the top of this NDC without removing it. <p>The returned value is the value that was pushed last. If no context is available, then the empty string """" is returned.
 * @return String The innermost diagnostic context.
 */
",Return the value at the top of the stack,Retrieves the message from the top DiagnosticContext on the stack if available.,"The function obtains the current stack, checks if it is non-empty, and returns the message from the DiagnosticContext object at the top without modifying the stack. If the stack is null or empty, it returns an empty string.",This function takes no parameters and returns a String.,"- Typical usage: If the stack contains a DiagnosticContext with the message ""Hello"", `peek()` returns ""Hello"".
   - Boundary edge case: If the stack is empty, `peek()` returns """".
   - Special or unusual case: If the stack is null, `peek()` returns """".","- Preconditions: `getCurrentStack()` must return a valid Stack object or null. The stack may contain instances of `DiagnosticContext`.
   - Postconditions: The function returns a string message from the top of the stack if available, otherwise it returns an empty string.
---
```"
636767de1a6d9265ec01871c,valueAccumulation,"public void valueAccumulation(String key,Long value){
  Long element=data.get(key);
  if (element == null) {
    element=value;
  }
 else {
    element+=value;
  }
  data.put(key,element);
}
","/** 
 * Accumulate the value with existing value in the same given key.
 */
",Add the value to the original value of the key.,Accumulates and updates a Long value in a map by key.,"The function retrieves a value associated with a given key from a map called `data`. If no value is found, it initializes the value for that key; otherwise, it adds the provided value to the existing value in the map. The updated or initialized value is then stored back in the map with the same key.",The function takes a `String` key and a `Long` value as parameters and has a void return type; it updates a map named `data`.,"- Typical usage: 
     - Input: (""apple"", 10L) - Initial: {""apple"": 5L} 
     - Output: {""apple"": 15L}
   - Boundary edge case:
     - Input: (""banana"", 0L) - Initial: {""banana"": null}
     - Output: {""banana"": 0L}
   - Special or unusual case:
     - Input: (""cherry"", -5L) - Initial: {""cherry"": 3L}
     - Output: {""cherry"": -2L}","- Preconditions: `data` is a map that holds keys as `String` and values as `Long`. 
   - Postconditions: The map is updated to include the new or accumulated value for the provided key.
---
```"
6367677e1a6d9265ec01832e,exists,"public Logger exists(String name){
  Object o=ht.get(new CategoryKey(name));
  if (o instanceof Logger) {
    return (Logger)o;
  }
 else {
    return null;
  }
}
","/** 
 * Check if the named logger exists in the hierarchy. If so return its reference, otherwise returns <code>null</code>.
 * @param name The name of the logger to search for.
 */
","Check if the named logger exists. If so return its reference, otherwise returns null.",Retrieves a Logger object from a hashtable if it exists.,"The function checks the hashtable for an entry associated with a `CategoryKey` created from the given string `name`. If the object retrieved is an instance of `Logger`, it returns that object; otherwise, it returns `null`.",`public Logger exists(String name)` takes a single `String` parameter and returns a `Logger` object or `null`.,"- A **typical usage**: If called with `exists(""mainLogger"")` and a `Logger` object is stored in `ht` with the key `new CategoryKey(""mainLogger"")`, it returns that `Logger`.
   - A **boundary edge case**: If called with `exists("""")` and `ht` contains a `Logger` with the key `new CategoryKey("""")`, it returns that `Logger`.
   - A **special or unusual case**: If called with `exists(""nonExistentLogger"")` and there is no associated `Logger` object in `ht`, it returns `null`.","- Preconditions: The hashtable `ht` and class `CategoryKey` must be properly defined and initialized.
   - Postconditions: Returns either a `Logger` object if the key is found and the object is a `Logger`, or `null` if the key doesn't exist or the object is not a `Logger`.
---
```"
6367670a1a6d9265ec0179e7,lookup,"public Converter lookup(final Class<?> clazz){
  Converter conv=(Converter)this.converters.get(clazz);
  if (conv != null) {
    return conv;
  }
  for (  Object regType : this.converters.keySet()) {
    if (((Class<?>)regType).isAssignableFrom(clazz)) {
      return (Converter)this.converters.get(regType);
    }
  }
  return null;
}
","/** 
 * Look up and return any registered  {@link Converter} for the specifieddestination class; if there is no registered Converter, return <code>null</code>.
 * @param clazz Class for which to return a registered Converter
 * @return The registered {@link Converter} or <code>null</code> if not found
 */
","Check whether the specified converter exists in converters. If yes, converter is returned. If no, null is returned.",Function retrieves the best matching converter for the given class.,"The function looks up and returns a converter object for a given class type; first, it directly checks if there's an exact converter for the class, and if not, it searches for one that can handle subclasses or implementers.",Function accepts a Class<?> as a parameter and returns a Converter object or null.,"- Typical usage: Given Class<String>, returns a StringConverter if registered.
   - Boundary edge case: Given a class with no converters or assignable converters registered, it returns null.
   - Special case: Given Class<Number> where IntegerConverter is registered, it returns IntegerConverter if Integer is assignable.","The converters map is populated with class-to-converter mappings; expected output is a corresponding Converter object or null if no suitable match is found. 
---
```"
636767a41a6d9265ec018572,readRawVarint64,"public long readRawVarint64() throws IOException {
  int shift=0;
  long result=0;
  while (shift < 64) {
    final byte b=readRawByte();
    result|=(long)(b & 0x7F) << shift;
    if ((b & 0x80) == 0) {
      return result;
    }
    shift+=7;
  }
  throw ProtobufException.malformedVarint();
}
","/** 
 * Read a raw Varint from the stream.
 */
",Read raw varint,Decodes a raw Varint64 encoded input from a byte stream.,"The function reads bytes from a stream, performing bitwise operations to decode a 64-bit integer value from Varint64 format, which is used to efficiently encode integer values by using one or more bytes. It processes each byte, checking if the highest bit is set (indicating more bytes), and forms the integer by assembling bits from bytes with shifts and bitwise ORs. The function exits when a byte without the highest bit set is encountered. If the shift exceeds 64 bits, it throws an exception.","The function takes no parameters, except implicitly through its operation on a stream, and returns a `long`.","- Typical Usage: Given a byte stream [0x96, 0x01], the function returns 150.
   - Boundary Edge Case: For the smallest value encoded [0x00], it returns 0.
   - Special Case: If input is malformed such that more than 64 bits would be necessary, it throws `ProtobufException`.","- Preconditions: Input bytes should be in Varint64 format within a byte stream.
   - Postconditions: Returns the decoded 64-bit integer or throws an exception if malformed.
---
```"
636767021a6d9265ec0178bb,nullToEmpty,"public static Double[] nullToEmpty(final Double[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
","If the double type array is null or its length is 0, convert array to EMPTY_CHARACTER_OBJECT_ARRAY. Otherwise, return array itself.",Converts null or empty Double arrays to an empty array constant.,"The function checks if the input array is null or has zero length; if so, it returns a predefined empty Double array constant. Otherwise, it returns the original array unchanged.",The function takes an array of Double objects as input and returns an array of Double objects.,"- **Typical usage:** `nullToEmpty(new Double[]{1.0, 2.0})` returns `[1.0, 2.0]`.
       - **Boundary edge case:** `nullToEmpty(null)` returns `ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY`.
       - **Special case:** `nullToEmpty(new Double[]{})` returns `ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY`.","- Preconditions: The input can be a null reference or a valid Double array.
       - Postconditions: The function returns a predefined constant empty array if the input is null or empty; otherwise, it returns the same array.
    ---"
636767021a6d9265ec0178b2,pop,"private void pop(final String descriptor){
  char firstDescriptorChar=descriptor.charAt(0);
  if (firstDescriptorChar == '(') {
    pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);
  }
 else   if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {
    pop(2);
  }
 else {
    pop(1);
  }
}
","/** 
 * Pops as many abstract types from the output frame stack as described by the given descriptor.
 * @param descriptor a type or method descriptor (in which case its argument types are popped).
 */
",Pop the various value according to the first character of the descriptor.,The function pops a specific number of elements from a stack based on a descriptor's type.,"The function analyzes the first character of a descriptor string to determine how many elements to pop from a stack: it pops a calculated number for method signatures, two for long/double, and one for other types.",The function takes a single `String` argument called `descriptor` and returns void.,"- Typical usage: Input: `pop(""(I)V"")`, Output: Pop 1 element after analyzing method signature.
   - Boundary edge case: Input: `pop(""I"")`, Output: Pop 1 element for basic integer type.
   - Special or unusual case: Input: `pop(""D"")`, Output: Pop 2 elements for double type.","The `descriptor` is expected to be a valid type descriptor string from a Java method or type signature. The function modifies the state of a stack by removing/popping elements but does not return any value.
---"
636766f91a6d9265ec01776e,write,"@Override public void write(final byte b[],final int off,final int len) throws IOException {
  if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {
    throw new IndexOutOfBoundsException();
  }
 else   if (len == 0) {
    return;
  }
  if (this.count + len > this.buf.length) {
    this.encodePendingBytes(false);
  }
  System.arraycopy(b,off,this.buf,this.count,len);
  this.count+=len;
}
","/** 
 * Writes <code>len</code> bytes from the specified byte array starting at offset <code>off</code> to this byte array output stream.
 * @param b   the data.
 * @param off the start offset in the data.
 * @param len the number of bytes to write.
 */
",Write bytes of length len from a byte array,"Writes a specified byte array segment to a buffer, possibly encoding pending data.","The function checks for valid input indices, writes a specified segment of the byte array `b` (from offset `off`, length `len`) into the internal buffer `buf`, encodes pending bytes if the buffer overflows, and updates a counter `count`. It throws an exception on invalid indices or returns instantly if length is zero.","`write(byte[] b, int off, int len) throws IOException` - Accepts a byte array, an offset, and a length; has no return type.","- Typical usage: `write(new byte[]{1,2,3,4}, 1, 2)` writes `2,3` to `buf`.
   - Boundary edge case: `write(new byte[]{5,6}, 0, 2)` writes `5,6` without issues.
   - Special or unusual case: `write(new byte[]{}, 0, 0)` immediately returns without modifying `buf`.","Preconditions: The offset and length must be within the byte array bounds. Postconditions: The buffer reflects the new data up to the specified length, and `count` is increased. IndexOutOfBoundsException is thrown for invalid inputs.  

---"
636767551a6d9265ec017f3f,swap,"public static final <V>void swap(V[] arr,int i,int j){
  V tmp=arr[j];
  arr[j]=arr[i];
  arr[i]=tmp;
}
","/** 
 * Swaps the two elements at the specified indices in the given array.
 * @param < V > the type of elements in the array
 * @param arr the array
 * @param i the index of the first element
 * @param j the index of the second element
 */
",Swap values at indexes i and j in arr,Swaps two elements in an array.,The function swaps the elements at indices `i` and `j` within the given array `arr` using a temporary variable to hold one of the values during the swap process.,"The function `swap` is a static generic method that takes an array of type `V`, and two integer indices `i` and `j`, and returns no value (void).","- Typical usage:
     - Input: arr = [1, 2, 3, 4, 5], i = 1, j = 3
     - Output: arr = [1, 4, 3, 2, 5]
   - Boundary edge case:
     - Input: arr = [10, 9], i = 0, j = 1
     - Output: arr = [9, 10]
   - Special or unusual case:
     - Input: arr = [7], i = 0, j = 0
     - Output: arr = [7]","- Preconditions: 
     - `arr` is a non-null array of objects (type `V[]`).
     - `i` and `j` are valid indices within the bounds of the array.
   - Postconditions: 
     - The elements at `i` and `j` are swapped; the array is otherwise unchanged.
---
```"
636766ae1a6d9265ec0175dc,isPartialContentResponse,"public Boolean isPartialContentResponse(){
  Integer limit=drc.getLimit() == null ? 0 : drc.getLimit();
  Long count=drc.getCount() == null ? 0 : drc.getCount();
  return !((limit + 1) >= count);
}
","/** 
 * Check if the actual response is a Partial Content (HTTP 206 code)
 * @return is partial content or not
 */
",Determine whether the actual response is a Partial Content,Check if the content response is not complete based on the limit and count values.,"The function retrieves 'limit' and 'count' values from a data source; it initializes these to zero if null, and returns true if the sum of 'limit' plus one is less than 'count', indicating the content is partial.",(No parameters); returns Boolean.,"- Typical usage: If drc.getLimit() returns 4 and drc.getCount() returns 10, output is true.
   - Boundary edge case: If drc.getLimit() returns 9 and drc.getCount() returns 10, output is false.
   - Special case: If drc.getLimit() returns null and drc.getCount() returns null, output is false.","Preconditions: drc must be initialized and have the methods getLimit() and getCount().
   Postconditions: Returns true if limit + 1 < count; false otherwise.
---
```"
636766f01a6d9265ec01762e,isEmpty,"public static boolean isEmpty(final double[] array){
  return array == null || array.length == 0;
}
","/** 
 * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */
",Check whether the array of the double type is empty.,Check if a double array is null or empty.,"The function returns true if the given double array is either null or has no elements; otherwise, it returns false.","The function takes a single parameter, a double array `array`, and returns a boolean value.","- Typical usage: `isEmpty(new double[]{1.0, 2.0, 3.0})` returns `false`.
   - Boundary edge case: `isEmpty(new double[]{})` returns `true`.
   - Special or unusual case: `isEmpty(null)` returns `true`.","- Preconditions: The parameter can be a null reference or a double array.
   - Postconditions: The function outputs a boolean indicating whether the array is null or has zero length.
---
```"
6367667e1a6d9265ec01743a,lastWriteTimeStampInMilliseconds,"public long lastWriteTimeStampInMilliseconds(){
  return lastWrite == -1 ? System.currentTimeMillis() : lastWrite;
}
","/** 
 * The last time, in milliseconds, a write operation occurred.
 * @return this
 */
","Check whether lastwrite is - 1. If yes, return - 1. Otherwise, return System.currentTimeMillis().",Returns the last write timestamp or the current time if uninitialized.,"The function checks if the instance variable `lastWrite` is -1, indicating no previous writes, and returns the current system time in milliseconds; otherwise, it returns the `lastWrite` value.",No parameters; returns a long integer.,"- Typical usage: If `lastWrite = 1625217600000`, `lastWriteTimeStampInMilliseconds()` returns `1625217600000`.
   - Boundary edge case: If `lastWrite = -1`, `lastWriteTimeStampInMilliseconds()` might return `1657872897000` (current time).
   - Special/Unusual case: If `lastWrite` is very old (e.g., `0`), `lastWriteTimeStampInMilliseconds()` returns `0`.","- Preconditions: `lastWrite` should be defined as a `long`.
   - Postconditions: Returns a long representing time in milliseconds.
---
```"
636766821a6d9265ec0174c9,classPath,"private static File[] classPath(){
  final String[] fileNames=System.getProperty(""java.class.path"").split(File.pathSeparator);
  final File[] files=new File[fileNames.length];
  for (int i=0; i < files.length; ++i) {
    files[i]=new File(fileNames[i]);
  }
  return files;
}
","/** 
 * Returns the class path of the current JVM instance as an array of  {@link File} objects.
 */
",Creates an array of the file type based on all file names in java.class.path and returns the array.,Converts Java classpath to an array of File objects.,"The function retrieves the Java classpath, splits it into individual paths using the system's path separator, and creates a File object for each path, returning an array of these File objects.",The function takes no parameters and returns an array of File objects.,"- **Typical usage:** If the classpath is ""lib/a.jar:lib/b.jar"", the function returns [File(""lib/a.jar""), File(""lib/b.jar"")].
   - **Boundary edge case:** If the classpath is empty, the function returns an empty array.
   - **Special or unusual case:** If the classpath contains a non-existent path ""lib/z.jar"", a File object for the non-existent path ""lib/z.jar"" is still created and returned in the array.","- Preconditions: The function assumes that it is running in an environment where the Java property ""java.class.path"" is set.
   - Postconditions: The function returns an array of File objects representing each path in the classpath, with no validation of whether the paths exist or are accessible.
---
```"
636767041a6d9265ec0178f8,copyStrings,"private static String[] copyStrings(final String[] src){
  String[] dst=new String[src.length];
  for (int i=0; i < src.length; ++i) {
    dst[i]=src[i].toLowerCase();
  }
  return dst;
}
","/** 
 * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.
 */
",Copy the source string and transfer each character to lowecase.,Converts all strings in the input array to lowercase.,"The function iterates over each string in the input array `src`, converts each string to lowercase, and stores it in a new array `dst` of the same length, which is then returned.",Takes a single array of strings (`String[] src`) as input and returns a new array of lowercase strings (`String[]`).,"- Typical usage: 
     Input: `[""Hello"", ""WORLD""]` 
     Output: `[""hello"", ""world""]`
   - Boundary edge case: 
     Input: `[]` 
     Output: `[]`
   - Special or unusual case: 
     Input: `[""CoDe"", ""123"", ""!@#""]` 
     Output: `[""code"", ""123"", ""!@#""]`","Preconditions: Assumes `src` is a valid array of strings, and can be empty.
   Postconditions: `dst` is an array of same length as `src` with all elements in lowercase.
---"
636767521a6d9265ec017ecc,splitAlongXAxis,"public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){
  double newWidth=box.getWidth() / 2d;
  double height=box.getHeight();
  return Pair.of(Box2D.of(box.getMinX(),box.getMinY(),newWidth,height),Box2D.of(box.getMinX() + newWidth,box.getMinY(),newWidth,height));
}
","/** 
 * Split a box along the x axis into two equal boxes.
 * @param box the box to split
 * @return a pair with the two resulting boxes
 */
",Divide a box into two equal boxes on the x axis.,Splits a Box2D object into two equal-width halves along the X-axis.,"The function `splitAlongXAxis` takes a `Box2D` object, computes the width to be half of the original, and splits it into two new `Box2D` objects that have the same height and half the width, positioned side by side along the X-axis. The first box starts at the original minimum X-coordinate, while the second starts immediately after the first box.","Takes a `Box2D` object as a parameter and returns a `Pair<Box2D, Box2D>`.","- Typical Usage: Given a box with `minX=0, minY=0, width=10, height=5`, returns two boxes: `(Box2D(0, 0, 5, 5), Box2D(5, 0, 5, 5))`.
   - Boundary Edge Case: Given a box with `minX=0, minY=0, width=0, height=5`, returns two identical boxes: `(Box2D(0, 0, 0, 5), Box2D(0, 0, 0, 5))`.
   - Special Case: Given a box with `minX=1, minY=3, width=8, height=2`, returns two boxes: `(Box2D(1, 3, 4, 2), Box2D(5, 3, 4, 2))`.","- Preconditions: The input box is non-null, and its width is a non-negative real number.
   - Postconditions: The result is a pair of boxes with each having half the original width, the same height, and positioned horizontally adjacent.
---
```"
636766a91a6d9265ec0175c1,enlarge,"private void enlarge(final int size){
  int doubleCapacity=2 * data.length;
  int minimalCapacity=length + size;
  byte[] newData=new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];
  System.arraycopy(data,0,newData,0,length);
  data=newData;
}
","/** 
 * Enlarges this byte vector so that it can receive 'size' more bytes.
 * @param size number of additional bytes that this byte vector should be able to receive.
 */
",Convert the original data array to a longer array.,Resizes the byte array `data` to accommodate additional elements.,"The function `enlarge` calculates a new array size based on the current array's length doubled and the required capacity for a given additional size. It creates a new byte array of the larger calculated size, copies the original array's contents to the new array, and replaces the original array with this larger array.",The function takes an integer `size` as a parameter and returns nothing (void); it modifies the instance variable `data`.,"- **Typical usage:** Given `data` with length 10 and `length` of 7, calling `enlarge(5)` will create a new array with size 20 since 2x10 (20) > 7+5 (12).
   - **Boundary edge case:** If `size` is 0, the function will enlarge the array based on current length conditions, resulting in a new array size depending on the original size logic.
   - **Special or unusual case if relevant:** If `data` is already sufficiently large (e.g., `length + size` is less than `data.length`), the function will still ensure a new array is created with at least double the current array size.","- Preconditions: `data` should be a valid byte array; `length` should represent the current occupied length of `data`.
- Postconditions: The `data` array is replaced with a larger byte array capable of containing `length + size` bytes, maintaining existing elements.
---
```"
6367674a1a6d9265ec017dab,compare,"@Override public int compare(Double o1,Double o2){
  if (Math.abs(o1 - o2) < epsilon) {
    return 0;
  }
 else {
    return Double.compare(o1,o2);
  }
}
","/** 
 * Compares two floating point values. Returns 0 if they are equal, -1 if  {@literal o1 < o2}, 1 otherwise
 * @param o1 the first value
 * @param o2 the second value
 * @return 0 if they are equal, -1 if {@literal o1 < o2}, 1 otherwise
 */
","Compares two values. If the difference between the two values is less than epsilon, 0 is returned. Otherwise, Double.compare is invoked.",Compares two Double values considering a small difference as equal.,"The function compares two Double objects by first checking if their absolute difference is within a small predefined range, epsilon. If they are within this range, they are considered equal, and the function returns 0. Otherwise, it uses the standard Double comparison to determine which is larger, returning -1 or 1 accordingly.","The function takes two Double objects, o1 and o2, and returns an int.","- Typical usage:
     - Input: o1 = 5.0, o2 = 5.0000001, epsilon = 0.000001
     - Output: 0
   - Boundary edge case:
     - Input: o1 = 5.0, o2 = 4.999999, epsilon = 0.000001
     - Output: 1
   - Special or unusual case:
     - Input: o1 = Double.POSITIVE_INFINITY, o2 = Double.POSITIVE_INFINITY, epsilon = 0.000001
     - Output: 0","- Preconditions: Both o1 and o2 are non-null Double objects, and epsilon is a small positive double value defined elsewhere in the class.
   - Postconditions: The function returns 0, -1, or 1 corresponding to whether the values are considered equal, o1 is less than o2, or o1 is greater than o2, respectively.
---
```"
6367672d1a6d9265ec017c78,insert,"public boolean insert(int val){
  if (!map.containsKey(val)) {
    map.put(val,val);
    values.add(val);
    return true;
  }
 else {
    return false;
  }
}
","/** 
 * Inserts a value to the set. Returns true if the set did not already contain the specified element. 
 */
","If the key whose value is val does not exist in the map, add (val, val) to the map and return true. Otherwise, return false.","Inserts a value into a collection, ensuring it's not already present.","The function checks if the given integer value is not already present in a map. If it is not present, it inserts the value into both the map and a list, and returns true. If the value is already present in the map, it does not insert the value and returns false.",The function takes an integer `val` as a parameter and returns a boolean indicating the success of the insertion.,"- Typical usage: 
     - Input: `insert(3)` when `map` is empty
     - Output: `true` 
     - State: `map = {3=3}`, `values = [3]`
   - Boundary edge case: 
     - Input: `insert(3)` when `map = {3=3}`
     - Output: `false`
     - State: `map = {3=3}`, `values = [3]`
   - Special case:
     - Input: `insert(10)` when `map = {}`
     - Output: `true`
     - State: `map = {10=10}`, `values = [10]`","- Preconditions: The `map` and `values` are initialized and available within the function's scope. The `map` must support `containsKey` and `put` methods, while `values` must support `add` method.
   - Postconditions: If `val` is successfully inserted, both `map` and `values` contain the new value; otherwise, they remain unchanged.
---
```"
636766821a6d9265ec0174bf,capitalize,"public static String capitalize(String name){
  if (name == null || name.length() == 0) {
    return name;
  }
  char chars[]=name.toCharArray();
  chars[0]=Character.toUpperCase(chars[0]);
  return new String(chars);
}
","/** 
 * Reverse of Introspector.decapitalize
 */
",Converts a name of the string type to a character array and converts the first letter to an uppercase letter.,Capitalizes the first letter of a given string.,"The function takes a string, checks if it is null or empty, and if not, it converts the first character to uppercase while leaving the rest of the string unchanged.",The function takes a single string parameter `name` and returns a string.,"- Typical usage: Input: ""john"" Output: ""John""
   - Boundary edge case: Input: """" Output: """"
   - Special or unusual case: Input: null Output: null","- Precondition: Input string can be null or any valid string (possibly empty).
   - Postcondition: Output is the same string with the first character capitalized, or unchanged if the input is null or empty.
---
```"
636766f21a6d9265ec017677,isNotTrue,"public static boolean isNotTrue(Boolean bool){
  return !isTrue(bool);
}
","/** 
 * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>true</code>, handling <code>null</code> by returning <code>true</code>.</p> <pre> BooleanUtils.isNotTrue(Boolean.TRUE)  = false BooleanUtils.isNotTrue(Boolean.FALSE) = true BooleanUtils.isNotTrue(null)          = true </pre>
 * @param bool  the boolean to check, null returns <code>true</code>
 * @return <code>true</code> if the input is null or false
 * @since 2.3
 */
",Check whether the parameter bool is not true.,Determines if a given Boolean value is not true by negating isTrue's result.,"The function isNotTrue calls another function isTrue and returns the negation of its Boolean output, indicating if the input value is not true.",Takes a Boolean object (Boolean bool) and returns a boolean primitive.,"- Typical usage: `isNotTrue(Boolean.TRUE)` returns `false`.
   - Boundary edge case: `isNotTrue(null)` (assuming isTrue handles null appropriately, the behavior follows isTrue implementation).
   - Special or unusual case: `isNotTrue(Boolean.FALSE)` returns `true`.","The function expects a Boolean input, considering null as a valid input; the output strictly follows the negation of isTrue with minimal assumptions of isTrue's behavior.
---
```"
6367674f1a6d9265ec017e74,toString,"public String toString(){
  StringBuilder s=new StringBuilder();
  for (int j=i; j < n; j++)   s.append(vs[j]).append("" "");
  return s.toString();
}
","/** 
 * Returns a textual representation of the queue.
 * @return a textual representation of the queue.
 */
",Convert a value in a vs array to a string,Converts a segment of an array into a space-separated string.,"The function constructs a String by appending elements from the `vs` array starting at index `i` to index `n-1`, with each element followed by a space.",The function is called without parameters and returns a String.,"- Typical usage: If `vs = {""a"", ""b"", ""c"", ""d""}`, `i = 1`, `n = 3`, the output is `""b c ""`.
   - Boundary edge case: If `vs = {""x"", ""y""}`, `i = 0`, `n = 2`, the output is `""x y ""`.
   - Special case: If `vs = {}`, `i = 0`, `n = 0`, the output is `""""`.","- Preconditions: `0 <= i <= n <= vs.length`; `vs` is an array of strings.
   - Postconditions: Returns a single string containing elements from `vs[i]` to `vs[n-1]` separated by spaces, ending with a space if there is at least one element.
---
```"
6367675c1a6d9265ec018058,createStringSupplier,"@SuppressWarnings(""unchecked"") public static Supplier<String> createStringSupplier(int start){
  int[] container=new int[]{start};
  return (Supplier<String> & Serializable)() -> String.valueOf(container[0]++);
}
","/** 
 * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.
 * @param start where to start the sequence
 * @return a string supplier
 */
",Create a string supplier which returns unique integer strings starting from the given start.,Creates a serializable Supplier that generates incrementing string representations of integers.,"The function returns a Supplier of type String that captures an array containing a single integer initialized to `start`. The Supplier, when invoked, returns the string representation of the current integer value and increments the integer value in the array for subsequent calls.",`createStringSupplier(int start)` returns `Supplier<String>`,"- Typical usage: `createStringSupplier(5).get()` returns `""5""` on the first call.
   - Sequential usage: First call `createStringSupplier(5).get()` returns `""5""`, second call returns `""6""`.
   - Boundary edge case: `createStringSupplier(Integer.MAX_VALUE).get()` returns `""2147483647""`; subsequent calls produce overflow behavior.","- Preconditions: An integer `start` is provided as an argument.
   - Postconditions: The returned Supplier generates non-decreasing string representations of integers, starting from `start`.
---
```"
6367677b1a6d9265ec0182bd,format,"public String format(final LoggingEvent event){
  StringBuffer buf=new StringBuffer();
  for (PatternConverter c=head; c != null; c=c.next) {
    c.format(buf,event);
  }
  return buf.toString();
}
","/** 
 * Formats a logging event to a writer.
 * @param event logging event to be formatted.
 */
",Formats LoggingEvent as a fixed-format string,Formats a logging event into a string using pattern converters.,"The function creates a StringBuffer, then iterates through a linked list of PatternConverter instances starting from 'head'. Each PatternConverter processes the LoggingEvent and appends formatted data to the StringBuffer. Finally, it returns the assembled string representation.",Takes a LoggingEvent object as a parameter and returns a formatted string.,"- Typical usage: Given a LoggingEvent with message ""Error"" and pattern converters for time and message, it might produce ""12:00:00 - Error"".
   - Boundary edge case: With no PatternConverter linked list (head is null), it returns an empty string """".
   - Special case: With only one PatternConverter that adds static text, it returns that static text.","- Preconditions: 'head' must be a linked list of PatternConverter instances, and 'event' must be a valid LoggingEvent.
   - Postconditions: Returns a formatted string based on the pattern converters applied on the logging event.
---
```"
636766ff1a6d9265ec017842,toPrimitive,"public static double[] toPrimitive(final Double[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_DOUBLE_ARRAY;
  }
  final double[] result=new double[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].doubleValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Doubles to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Double</code> array, may be <code>null</code>
 * @return a <code>double</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","If the length of the array is 0, return EMPTY_DOUBLE_ARAY. Otherwise, convert the array to an array of the double type.",Converts a Double array to a primitive double array.,"The function takes an array of Double objects and converts each element to its primitive double counterpart, storing them in a new double array which it then returns. If the input array is null, it returns null; if the array is empty, it returns an empty double array.",Takes a Double[] as input and returns a double[].,"- Typical usage: 
     - Input: [new Double(1.5), new Double(2.5), new Double(3.5)]
     - Output: [1.5, 2.5, 3.5]
   - Boundary edge case:
     - Input: []
     - Output: []
   - Special or unusual case:
     - Input: null
     - Output: null","- Preconditions: The input array may be null or empty.
   - Postconditions: The function will not throw exceptions; it either returns null, an empty array, or a primitive double array with converted values.
---
```"
636766fa1a6d9265ec0177a9,addInitializedType,"private void addInitializedType(final int abstractType){
  if (initializations == null) {
    initializations=new int[2];
  }
  int initializationsLength=initializations.length;
  if (initializationCount >= initializationsLength) {
    int[] newInitializations=new int[Math.max(initializationCount + 1,2 * initializationsLength)];
    System.arraycopy(initializations,0,newInitializations,0,initializationsLength);
    initializations=newInitializations;
  }
  initializations[initializationCount++]=abstractType;
}
","/** 
 * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.
 * @param abstractType an abstract type on a which a constructor is invoked.
 */
",Add abstractType to the initializations variable.,"Adds an integer to an internal array, expanding it if necessary.","The function checks if the `initializations` array is null and initializes it with a length of 2 if it is. It then ensures the array can accommodate another element by expanding it if the `initializationCount` has reached the current array length, doubling the size or adding one, whichever is greater. Finally, it adds the `abstractType` value to the `initializations` array and increments the `initializationCount`.",The function takes a single integer parameter `abstractType` and has no return type (void).,"- Typical usage: 
     - Input: initializations = [1, 2], initializationCount = 2, abstractType = 3
     - Output: initializations = [1, 2, 3], initializationCount = 3
   - Boundary edge case:
     - Input: initializations = null, initializationCount = 0, abstractType = 1
     - Output: initializations = [1, 0], initializationCount = 1
   - Special case:
     - Input: initializations = [5, 10], initializationCount = 2, abstractType = 15
     - Output: initializations = [5, 10, 15, 0], initializationCount = 3","- Preconditions: The `initializations` array may be null and must store integers; `initializationCount` must be a valid index in the array or equal to its length.
   - Postconditions: The `initializations` array contains the added `abstractType`, potentially resized, and `initializationCount` is incremented.
---
```"
6367670a1a6d9265ec0179dc,putAbstractTypes,"private void putAbstractTypes(final int start,final int end){
  for (int i=start; i < end; ++i) {
    Frame.putAbstractType(symbolTable,currentFrame[i],stackMapTableEntries);
  }
}
","/** 
 * Puts some abstract types of  {@link #currentFrame} in {@link #stackMapTableEntries} , using theJVMS verification_type_info format used in StackMapTable attributes.
 * @param start index of the first type in {@link #currentFrame} to write.
 * @param end index of last type in {@link #currentFrame} to write (exclusive).
 */
",Add the elements indexed from start to end in currentFrame to Frame.,Iterate over a range and apply a specific function to each element in a frame.,"The function iterates from `start` to `end`, and for each index, it calls `Frame.putAbstractType` with `symbolTable`, the current frame element at that index, and `stackMapTableEntries` as arguments.",The function takes two integer parameters `start` and `end` and has a void return type.,"- **Typical usage:** `putAbstractTypes(0, 5);` iterates over `currentFrame` from index 0 to 4, applying `Frame.putAbstractType` for each.
   - **Boundary edge case:** `putAbstractTypes(3, 3);` does not perform any operations as the start and end are the same.
   - **Special or unusual case:** `putAbstractTypes(10, 5);` is likely a no-op since the start is greater than the end.","- Preconditions: `start` and `end` are within valid index ranges of `currentFrame`. 
   - Postconditions: The function will not modify external states except effects from `putAbstractType`.
---
```"
6367670a1a6d9265ec0179d8,write,"@Override public void write(final byte[] b) throws IOException {
  if (this.encoding == null) {
    this.writer.write(new String(b));
  }
 else {
    this.writer.write(new String(b,this.encoding));
  }
}
","/** 
 * @see OutputStream#write(byte[]) 
 */
",Write the byte array b to the buffer based on the encoding.,"Converts and writes a byte array to a writer, using optional encoding.","The function checks if an encoding is specified; if not, it writes the byte array `b` to the writer directly as a string. If encoding is specified, it converts the byte array to a string using the specified encoding and writes it to the writer.",The function takes a single parameter `b` of type `byte[]` and does not return any value. It may throw an `IOException`.,"- **Typical usage:** Given `b = new byte[]{65, 66, 67}` and `encoding = ""UTF-8""`, it writes ""ABC"" using UTF-8 encoding.
   - **Boundary edge case:** Given `b = new byte[]{}` and no encoding, it writes an empty string.
   - **Special or unusual case:** Given `b = new byte[]{-50, -60}` with encoding ""UTF-16"", it attempts to write the corresponding UTF-16 string representation.","- Preconditions: `b` must not be null. `encoding` should be valid if specified.
   - Postconditions: The byte array is written to the writer as a string. An `IOException` is thrown on write failure.
---"
636767021a6d9265ec0178bf,convertToType,"@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {
  String string=value.toString();
  if (string.length() == 0) {
    return BeanUtils.getDefaultValue(type);
  }
 else {
    return string.charAt(0);
  }
}
","/** 
 * <p>Convert the input object into a java.lang.Character.</p>
 * @param type Data type to which this value should be converted.
 * @param value The input value to be converted.
 * @return The converted value.
 * @throws Exception if conversion cannot be performed successfully
 * @since 1.8.0
 */
","If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.","Converts an object to a specified type, defaulting to the type's default value if input is an empty string.","The function takes a type and a value as input, converts the value to a string, and checks its length; if the string is empty, it returns the default value of the specified type using `BeanUtils.getDefaultValue`, otherwise returns the first character of the string.","The function `convertToType(Class<?> type, Object value)` accepts a type to convert to and an object value, returning an Object which is either the type’s default value or the first character of the string representation of the value.","- **Typical usage**: convertToType(Character.class, ""Hello"") -> 'H'
   - **Boundary edge case**: convertToType(Integer.class, """") -> default value for Integer (e.g., 0)
   - **Special or unusual case**: convertToType(String.class, null) -> default value for String (e.g., null)","- Preconditions: `type` is a valid class type; `value` is properly castable to a string.
   - Postconditions: Outputs either the default value for the specified type or the first character of the string representation of `value`.
---
```"
6367670b1a6d9265ec017a0f,containsAnyIgnoreCase,"public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){
  if (StringUtils.isEmpty(str) || searchStrArray == null || searchStrArray.isEmpty()) {
    return false;
  }
  for (  String item : searchStrArray) {
    if (containsIgnoreCase(str,item)) {
      return true;
    }
  }
  return false;
}
","/** 
 * Case in-sensitive Checks if the String contains any character in the given set of string. 
 */
","Check whether str contains elements in searchStrArray. If yes, true is returned. If no, false is returned.",Checks if any string in a list is a case-insensitive substring of the given string.,"The function iterates over a list of strings, checking if any of the strings is present in the input `str` without considering case sensitivity. If any string matches, it returns `true`; otherwise, `false`.",The function takes a `String` and a `List<String>` as parameters and returns a `boolean`.,"- **Typical usage:** `containsAnyIgnoreCase(""HelloWorld"", Arrays.asList(""world"", ""test""))` returns `true`.
   - **Boundary edge case:** `containsAnyIgnoreCase("""", Arrays.asList(""test""))` returns `false`.
   - **Special case:** `containsAnyIgnoreCase(""Test"", Arrays.asList(""""))` returns `false`.","- Preconditions: `str` should be a valid string, and `searchStrArray` should be a list of strings.
   - Postconditions: Returns `false` if `str` is empty, `searchStrArray` is null, or `searchStrArray` is empty.
---"
636766a81a6d9265ec01758e,nextPrime,"public static int nextPrime(int desiredCapacity){
  if (desiredCapacity >= largestPrime) {
    return largestPrime;
  }
  int i=Arrays.binarySearch(primeCapacities,desiredCapacity);
  if (i < 0) {
    i=-i - 1;
  }
  return primeCapacities[i];
}
","/** 
 * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code> (within 11% if <code>desiredCapacity &gt;= 1000</code>).
 * @param desiredCapacity the capacity desired by the user.
 * @return the capacity which should be used for a hashtable.
 */
",Returns the element at the location specified by desiredCapacity in primeCapacities.,Finds the smallest prime number greater than or equal to a given integer.,"The function checks if the input `desiredCapacity` is greater than or equal to `largestPrime` and returns `largestPrime` if true. Otherwise, it performs a binary search on the sorted array `primeCapacities` to find the smallest prime number greater than or equal to `desiredCapacity`. If `desiredCapacity` is not in the array, it returns the first prime number greater than it.",The function takes an integer `desiredCapacity` and returns an integer.,"- Typical usage: `nextPrime(25)` returns `29`.
   - Boundary edge case: `nextPrime(largestPrime-1)` returns `largestPrime`.
   - Special case: `nextPrime(largestPrime)` returns `largestPrime`.","- Preconditions: `primeCapacities` is a sorted array of prime numbers and `largestPrime` is defined as the largest element in `primeCapacities`.
   - Postconditions: Function returns a valid prime number from `primeCapacities` that is the smallest prime greater than or equal to `desiredCapacity`.
---
```"
6367670a1a6d9265ec0179cf,toChar,"public static char toChar(final Character ch,final char defaultValue){
  if (ch == null) {
    return defaultValue;
  }
  return ch.charValue();
}
","/** 
 * <p>Converts the Character to a char handling <code>null</code>.</p> <pre> CharUtils.toChar(null, 'X') = 'X' CharUtils.toChar(' ', 'X')  = ' ' CharUtils.toChar('A', 'X')  = 'A' </pre>
 * @param ch  the character to convert
 * @param defaultValue  the value to use if the  Character is null
 * @return the char value of the Character or the default if null
 */
","Obtains the character value of ch. If ch is null, defaultValue is returned.","Converts a Character object to a primitive char, with a default if null.","This function takes a Character object and a default char. If the Character object is not null, it returns its primitive char value using `charValue()`. If the Character is null, it returns the specified defaultValue.",Parameters are a `Character` object (`ch`) and a `char` (`defaultValue`). Returns a `char`.,"- Typical usage: toChar(Character.valueOf('A'), 'Z') -> returns 'A'
   - Boundary edge case: toChar(null, 'Z') -> returns 'Z'
   - Special or unusual case: toChar(Character.valueOf('\0'), 'Z') -> returns '\0'","The function expects a `Character` object, which may be null, and a default `char`. Output will be a primitive `char` either from the Character instance or the default value if the Character is null.
---
```"
6367676b1a6d9265ec0181e2,findFirstMatch,"public static Object findFirstMatch(Collection source,Collection candidates){
  if (isEmpty(source) || isEmpty(candidates)) {
    return null;
  }
  for (  Object candidate : candidates) {
    if (source.contains(candidate)) {
      return candidate;
    }
  }
  return null;
}
","/** 
 * Return the first element in '<code>candidates</code>' that is contained in '<code>source</code>'. If no element in '<code>candidates</code>' is present in '<code>source</code>' returns <code>null</code>. Iteration order is {@link Collection} implementation specific.
 * @param source the source Collection
 * @param candidates the candidates to search for
 * @return the first present object, or <code>null</code> if not found
 */
",Returns the first element in candidates that matches the source.,Finds and returns the first common element between two collections.,Iterates over the candidates collection and returns the first element that is contained in the source collection; returns null if there is no match or if either collection is empty.,Takes two Collection objects as parameters and returns an Object that is the first common element or null.,"- Typical usage: 
     - Input: source = [1, 2, 3], candidates = [4, 2, 5]
     - Output: 2
   - Boundary edge case:
     - Input: source = [], candidates = [1, 2, 3]
     - Output: null
   - Special or unusual case:
     - Input: source = [""a"", ""b""], candidates = [""x"", ""y"", ""b""]
     - Output: ""b""","- Preconditions: Both source and candidates are valid Collection objects.
   - Postconditions: The returned object is either the first match found in both collections, or null if no match is found or collections are empty.
---
```"
6367676b1a6d9265ec0181ee,trimTrailingWhitespace,"public static String trimTrailingWhitespace(String str){
  if (!hasLength(str)) {
    return str;
  }
  StringBuilder sb=new StringBuilder(str);
  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {
    sb.deleteCharAt(sb.length() - 1);
  }
  return sb.toString();
}
","/** 
 * Trim trailing whitespace from the given String.
 * @param str the String to check
 * @return the trimmed String
 * @see java.lang.Character#isWhitespace
 */
",Trim the end space of the str.,Removes trailing whitespace from a string.,"The function checks if the input string has content. If it does, it uses a StringBuilder to iteratively remove whitespace characters from the end of the string until it encounters a non-whitespace character. The resulting string with trailing whitespace removed is returned.",The function takes a single parameter `str` of type `String` and returns a `String`.,"- Typical usage: Input: `""  Hello World  ""` Output: `""  Hello World""`
   - Boundary edge case: Input: `""""` Output: `""""`
   - Special or unusual case: Input: `""NoTrailingWhitespace""` Output: `""NoTrailingWhitespace""`","- Preconditions: The input is a non-null string.
   - Postconditions: The returned string will have no trailing whitespace.
---
```"
636767dc1a6d9265ec0186cb,init,"public void init(){
  File dist=new File(analyzeResultDist);
  if (!dist.exists()) {
    dist.mkdirs();
    return;
  }
  if (dist.isFile()) {
    throw new IllegalArgumentException(analyzeResultDist + "" must be a directory"");
  }
}
","/** 
 * initialize config, such as check dist path
 */
",Initializes a directory.,Creates a directory if it doesn't exist and validates existing paths.,"This function checks if a specified file path exists. If it doesn't exist, it creates a directory at that path. If it does exist, it ensures the path is a directory, throwing an exception if it is a file.",The function takes no parameters; it has a void return type.,"- Typical usage: If `analyzeResultDist` is ""output/results"" and it doesn't exist, create the directory ""output/results"".
   - Boundary edge case: If `analyzeResultDist` is ""output/results"" and ""output/results"" already exists as a directory, do nothing.
   - Special/unusual case: If `analyzeResultDist` is ""output/results"" and ""output/results"" is a file, throw an `IllegalArgumentException`.","- Preconditions: The `analyzeResultDist` variable is initialized with a path as a string.
   - Postconditions: A directory at the specified path is ensured to exist if the path is valid.
---
```"
636767a31a6d9265ec018552,readString,"@Override public String readString() throws IOException {
  final int size=readRawVarint32();
  if (size <= (bufferSize - bufferPos) && size > 0) {
    final String result=STRING.deser(buffer,bufferPos,size);
    bufferPos+=size;
    return result;
  }
 else {
    return STRING.deser(readRawBytes(size));
  }
}
","/** 
 * Read a  {@code string} field value from the stream.
 */
",Read string from a buffer.,Reads and deserializes a string from a buffer or raw bytes.,"The function first reads a size using `readRawVarint32()`. If this size is positive and fits within the remaining buffer space, it deserializes the string from the buffer starting at the current position and increments the position by the size. If not, it reads raw bytes of the specified size and deserializes those into a string.",The function takes no parameters and returns a `String`.,"- Typical usage: Suppose `bufferPos = 2`, `bufferSize = 10`, and the buffer contains the varint size `4` at position 2. If the buffer has enough space, it reads 4 bytes as a string from the buffer.
   - Boundary edge case: If `size = 0`, the function would typically return an empty string, assuming `STRING.deser()` can handle this.
   - Special case: If `size` exceeds buffer limits, it falls back to deserializing from `readRawBytes(size)` which handles larger or non-buffer-contained strings.","- Preconditions: `bufferPos` must be valid, `readRawVarint32()` must not fail, and `readRawBytes(size)` must handle cases where `size` is larger than buffer limits.
   - Postconditions: Function returns a deserialized string, potentially reading directly from raw bytes if not possible in buffer.
---
```"
636767a61a6d9265ec0185b7,digitValue,"private static int digitValue(final char c){
  if ('0' <= c && c <= '9') {
    return c - '0';
  }
 else   if ('a' <= c && c <= 'z') {
    return c - 'a' + 10;
  }
 else {
    return c - 'A' + 10;
  }
}
","/** 
 * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()} but we don't accept non-ASCII digits.
 */
",Obtains the number corresponding to the character c.,Converts a character to its numeric value based on digit or letter.,"The function determines the numeric value of the input character `c`. If `c` is a digit ('0'-'9'), it returns its integer equivalent. If `c` is a lowercase letter ('a'-'z'), it returns the position of the letter in the alphabet starting from 10. If `c` is an uppercase letter ('A'-'Z'), it similarly returns the position starting from 10.",The function takes a single character `c` as input and returns an integer.,"- Typical usage: digitValue('5') returns 5
   - Typical usage: digitValue('b') returns 11
   - Boundary edge case: digitValue('0') returns 0
   - Boundary edge case: digitValue('z') returns 35
   - Special case: digitValue('A') returns 10","- Preconditions: Input character `c` must be alphanumeric ('0'-'9', 'a'-'z', 'A'-'Z').
   - Postconditions: Returns a non-negative integer representing the value of `c`.
---
```"
636767e01a6d9265ec018755,buildContent,"private Map<String,Object> buildContent(JsonObject jsonObject){
  Map<String,Object> content=new HashMap<>();
  content.put(""msg_type"",jsonObject.get(""msg_type"").getAsString());
  if (jsonObject.get(""ats"") != null) {
    String ats=jsonObject.get(""ats"").getAsString();
    String text=jsonObject.get(""content"").getAsJsonObject().get(""text"").getAsString();
    List<String> collect=Arrays.stream(ats.split("","")).map(String::trim).collect(Collectors.toList());
    for (    String userId : collect) {
      text+=""<at user_id=\"""" + userId + ""\""></at>"";
    }
    jsonObject.get(""content"").getAsJsonObject().addProperty(""text"",text);
  }
  content.put(""content"",jsonObject.get(""content"").getAsJsonObject());
  return content;
}
","/** 
 * build content,if it has ats someone set the ats
 */
","Put the ""content"" from the  jsonObject to the content.","Builds a content map from a given JsonObject, optionally modifying text with user tags.","The function retrieves a message type and content from the provided JsonObject. If ""ats"" are present, it appends user tags to the text in the content. It then constructs a Map where the message type and modified content are stored and returns this Map.","Takes a JsonObject as input, returns a Map<String, Object>.","- Typical usage:
     - Input: `{""msg_type"":""text"",""content"":{""text"":""Hello!""},""ats"":""user1,user2""}`
     - Output: `{""msg_type"":""text"", ""content"":{""text"":""Hello!<at user_id=\""user1\""></at><at user_id=\""user2\""></at>""}}`
   - Boundary edge case:
     - Input: `{""msg_type"":""text"",""content"":{""text"":""Hi""}}`
     - Output: `{""msg_type"":""text"", ""content"":{""text"":""Hi""}}`
   - Special case:
     - Input: `{""msg_type"":""text"",""content"":{""text"":""Hi""},""ats"":""""}`
     - Output: `{""msg_type"":""text"", ""content"":{""text"":""Hi""}}`","- Preconditions: The input JsonObject must have valid keys like ""msg_type"" and ""content"".
   - Postconditions: Returns a Map where content text may include user tags if 'ats' are provided and non-empty.
---"
636767a21a6d9265ec018517,toByteArray,"public final byte[] toByteArray(){
  LinkedBuffer node=head;
  int offset=0, len;
  final byte[] buf=new byte[size];
  do {
    if ((len=node.offset - node.start) > 0) {
      System.arraycopy(node.buffer,node.start,buf,offset,len);
      offset+=len;
    }
  }
 while ((node=node.next) != null);
  return buf;
}
","/** 
 * Returns a single byte array containg all the contents written to the buffer(s).
 */
",Copy bytes from LinkedBuffer and return.,Converts linked buffer nodes into a single byte array.,"The function iterates through a linked list of buffer nodes, copying each node's conten from its start to its offset into a new byte array, which is then returned as the combined representation of all the nodes.",`public final byte[] toByteArray()` takes no parameters and returns a byte array (`byte[]`).,"- Typical usage: With two nodes with buffers `[01, 02]` and `[03, 04]`, it returns `[01, 02, 03, 04]`.
   - Boundary edge case: With `head` pointing to a single node with a buffer of size 0, it returns `[]`.
   - Special case: With nodes having gaps, i.e., buffer `[10, 0(ignored)]` and `[20]` with set starts and offsets, it returns `[10, 20]`.","- Preconditions: `head` is not null, and `size` accurately represents the total bytes within all nodes.
   - Postconditions: Returns a byte array constituting a sequential combination of node buffers up to their respective offsets.
---"
6367667d1a6d9265ec017401,unescapeJava,"public static String unescapeJava(String str) throws Exception {
  if (str == null) {
    return null;
  }
  StringWriter writer=new StringWriter(str.length());
  unescapeJava(writer,str);
  return writer.toString();
}
","/** 
 * <p>Unescapes any Java literals found in the <code>String</code>. For example, it will turn a sequence of <code>'\'</code> and <code>'n'</code> into a newline character, unless the <code>'\'</code> is preceded by another <code>'\'</code>.</p>
 * @param str the <code>String</code> to unescape, may be null
 * @return a new unescaped <code>String</code>, <code>null</code> if null string input
 */
",Unescapes Java that found in the String.,Decodes a string with Java escape sequences into unescaped characters.,"The function `unescapeJava` converts Unicode escape sequences and other Java escape sequences (like `\\n`, `\\t`, etc.) found in the input string into their respective unescaped characters; it writes the unescaped result to a `StringWriter` and returns the resulting string.",`public static String unescapeJava(String str) throws Exception` - Takes a single parameter `str` of type `String` and returns an unescaped `String`; may throw an `Exception` during processing.,"- Typical usage: Input: `""Hello\\nWorld""`; Output: `""Hello\nWorld""`
   - Boundary edge case: Input: `null`; Output: `null`
   - Special or unusual case: Input: `""\\u0041""`; Output: `""A""`","- Preconditions: The input `str` can be any string, including `null`.
   - Postconditions: Returns the decoded string with all recognized escape sequences replaced by their corresponding characters. The function may throw exceptions if it encounters issues during decoding.
---
```"
636766f01a6d9265ec01763e,javaCharset,"private static String javaCharset(String charset){
  if (charset == null) {
    return null;
  }
  String mappedCharset=MIME2JAVA.get(charset.toLowerCase(Locale.ENGLISH));
  if (mappedCharset == null) {
    return charset;
  }
  return mappedCharset;
}
","/** 
 * Translate a MIME standard character set name into the Java equivalent.
 * @param charset The MIME standard name.
 * @return The Java equivalent for this name.
 */
",Translate a MIME standard charset name into the Java equivalent.,Maps a character set name to its Java equivalent or returns it unchanged.,"The function takes a character set name as input, converts it to lowercase, and checks a mapping hash table (MIME2JAVA) to find its Java equivalent. If a mapping exists, it returns the mapped Java charset name; otherwise, it returns the original charset name. If the input charset is null, it simply returns null.",The function takes a single String parameter 'charset' and returns a String.,"- Typical usage: `javaCharset(""UTF-8"")` might return ""UTF8"".
   - Boundary edge case: `javaCharset(null)` returns `null`.
   - Special or unusual case: `javaCharset(""unknown-charset"")` returns ""unknown-charset"".","- Preconditions: `charset` can be any string, including null.
   - Postconditions: Returns either a mapped Java charset, the input charset itself if not mapped, or null if the input was null.
---
```"
6367676a1a6d9265ec0181bf,quoteIfString,"public static Object quoteIfString(Object obj){
  return (obj instanceof String ? quote((String)obj) : obj);
}
","/** 
 * Turn the given Object into a String with single quotes if it is a String; keeping the Object as-is else.
 * @param obj the input Object (e.g. ""myString"")
 * @return the quoted String (e.g. ""'myString'""),or the input object as-is if not a String
 */
",Check whether an obj variable is of the String type.,"Return a quoted string if input is a string, otherwise return the input as is.","The function checks if the input object is an instance of a String; if it is, it converts it into a quoted string using the `quote` function and returns it. If not, it returns the object unchanged.",`quoteIfString(Object obj)` takes a single parameter `obj` of type Object and returns an Object.,"- Typical usage: 
     - Input: ""hello"" 
     - Output: ""\""hello\""""
   - Boundary edge case: 
     - Input: 42 
     - Output: 42
   - Special or unusual case: 
     - Input: null 
     - Output: null","- Preconditions: `obj` can be any object, including strings, numbers, or even null.
   - Postconditions: The output maintains the type of the input, except when the input is a string, which it returns as a quoted string.
---
```"
636767501a6d9265ec017e86,previousNode,"@Override public ListNode<E> previousNode(){
  checkForComodification();
  if (!hasPrevious()) {
    throw new NoSuchElementException();
  }
  last=next=next.prev;
  nextIndex--;
  return last;
}
","/** 
 * {@inheritDoc}
 */
",Returns the previous ListNode.,Returns the previous list node in a bidirectional iteration.,"The function checks for concurrent modifications, ensures there is a previous node, updates `next` and `last` to reference the previous node, decrements the `nextIndex`, and returns the last accessed node.",The function takes no parameters and returns a `ListNode<E>`.,"- A **typical usage**: If the list is [A, B, C] and `next` is at C, calling `previousNode()` returns B.
   - A **boundary edge case**: If `next` is at the start of the list, calling `previousNode()` throws a `NoSuchElementException`.
   - A **special or unusual case**: If the list is empty, calling `previousNode()` throws a `NoSuchElementException`.","- Preconditions: The list must have at least one previous element to move to.
   - Postconditions: The index is moved back by one, reflecting the previous node's position.
---"
636766f21a6d9265ec017667,readShort,"public short readShort(final int offset){
  byte[] classBuffer=classFileBuffer;
  return (short)(((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF));
}
","/** 
 * Reads a signed short value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
 * @param offset the start offset of the value to be read in this {@link ClassReader}.
 * @return the read value.
 */
",Read a short value from classFileBuffer,Extracts a short integer from a byte array at a specified offset.,"The function reads two consecutive bytes starting at the given offset from the `classFileBuffer` byte array, combines them into a short integer using big-endian byte order (most significant byte first), and returns the resultant short.",The function accepts an integer parameter `offset` specifying the starting position in the byte array and returns a short integer.,"- Typical usage: With `classFileBuffer` being `[0x00, 0x10, 0x00, 0x20]`, `readShort(0)` returns `16` (0x0010).
   - Boundary edge case: With `classFileBuffer` being `[0xFF, 0xFF]`, `readShort(0)` returns `-1` (0xFFFF).
   - Special case: With `classFileBuffer` being `[0x7F, 0xFF]`, `readShort(0)` returns `32767` (0x7FFF).","- Preconditions: `offset` must be within bounds such that `offset + 1` is a valid index in `classFileBuffer`; `classFileBuffer` must be initialized.
   - Postconditions: Returns a short integer representation of two bytes starting at the given offset using big-endian order.
---
```"
636767031a6d9265ec0178ef,copyArrayGrow1,"private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){
  if (array != null) {
    int arrayLength=Array.getLength(array);
    Object newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength + 1);
    System.arraycopy(array,0,newArray,0,arrayLength);
    return newArray;
  }
  return Array.newInstance(newArrayComponentType,1);
}
","/** 
 * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.
 * @param array The array to copy, must not be <code>null</code>.
 * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.
 * @return A new copy of the array of size 1 greater than the input.
 */
",Copy the given array and add a default value at the end.,Creates a new array by copying and expanding an existing array by one element.,"The function checks if the input array is non-null, calculates its length, creates a new array of the same component type with one additional element, and copies all elements from the old array to the new one, leaving the last new element uninitialized or null. If the input array is null, it creates a new single-element array of the specified component type.","Parameters: `Object array` (input array to be copied and expanded), `Class<?> newArrayComponentType` (the component type for the new array if input is null); Return type: `Object` (a new array with one additional slot).","- Typical usage:  
     Input: `copyArrayGrow1(new int[]{1, 2, 3}, int.class)`  
     Output: `[1, 2, 3, 0]`
   - Boundary edge case:  
     Input: `copyArrayGrow1(new int[0], int.class)`  
     Output: `[0]`
   - Special or unusual case:  
     Input: `copyArrayGrow1(null, String.class)`  
     Output: `[null]`","- Preconditions: If the array is not null, it must be a valid array object; `newArrayComponentType` is used if the input array is null.
   - Postconditions: The returned array has the same contents as the input, with an uninitialized extra element; if input is null, output is a single-element array of the specified type.  
---
```"
636767611a6d9265ec018116,intersection,"private Set<V> intersection(Set<V> set1,Set<V> set2){
  Set<V> a;
  Set<V> b;
  if (set1.size() <= set2.size()) {
    a=set1;
    b=set2;
  }
 else {
    a=set2;
    b=set1;
  }
  return a.stream().filter(b::contains).collect(Collectors.toSet());
}
","/** 
 * Efficient way to compute the intersection between two sets
 * @param set1 set $1$
 * @param set2 set $2$
 * @return intersection of set $1$ and $2$
 */
",Return the intersection between two sets.,Finds the intersection of two sets and returns it.,"The function takes two sets, determines the smaller one to minimize iteration cost, and returns a new set containing elements present in both sets by filtering one set's elements that exist in the other set.","The function accepts two sets, `set1` and `set2`, both of generic type `V`, and returns a set of type `V`.","- Typical usage: Input: `set1 = {1, 2, 3}, set2 = {2, 3, 4}`; Output: `{2, 3}`
   - Boundary edge case: Input: `set1 = {}, set2 = {1, 2, 3}`; Output: `{}`
   - Special case: Input: `set1 = {1, 2, 3}, set2 = {}`; Output: `{}`","- Preconditions: Both input sets can contain any type of object, and either or both sets can be empty.
   - Postconditions: The returned set contains only those elements that exist in both input sets; if there are no common elements, the result is an empty set.
---"
636766f71a6d9265ec017730,toNoNullStringArray,"static String[] toNoNullStringArray(Collection<?> collection){
  if (collection == null) {
    return ArrayUtils.EMPTY_STRING_ARRAY;
  }
  return toNoNullStringArray(collection.toArray());
}
","/** 
 * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element is <code>null</code>.
 * @param collection The collection to convert
 * @return A new array of Strings.
 */
","If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array. ???",Converts a collection to a string array with no null values.,"The function converts a given collection to a string array, replacing any null collection with an empty string array; it utilizes an overloaded method for conversion.",The function takes a Collection<?> as input and returns a String[].,"- Typical usage: `toNoNullStringArray(Arrays.asList(""a"", ""b"", null))` returns `[""a"", ""b"", """"]`.
   - Boundary edge case: `toNoNullStringArray(null)` returns `[]`.
   - Special case: `toNoNullStringArray(Collections.singletonList(""test""))` returns `[""test""]`.","The input can be any collection type or null; the output is a non-null string array without null elements.
---
```"
636767081a6d9265ec0179a2,isAllZeros,"private static boolean isAllZeros(String s){
  if (s == null) {
    return true;
  }
  for (int i=s.length() - 1; i >= 0; i--) {
    if (s.charAt(i) != '0') {
      return false;
    }
  }
  return s.length() > 0;
}
","/** 
 * <p>Utility method for  {@link #createNumber(String)}.</p> <p>Returns <code>true</code> if s is <code>null</code>.</p>
 * @param s the String to check
 * @return if it is all zeros or <code>null</code>
 */
",Check whether a character string is all consist of zero. ,Checks if a string is null or consists entirely of zero characters.,"The function returns `true` if the input string is `null` or contains only the character '0'. It iterates through the string, verifying each character is '0', and returns `false` if it encounters any non-'0' character.",The function takes a String `s` as a parameter and returns a boolean value.,"- Typical usage: `isAllZeros(""000"")` returns `true`.
   - Boundary edge case: `isAllZeros("""")` returns `false`.
   - Special case: `isAllZeros(null)` returns `true`.","- Preconditions: Input can be a `null` string or any valid string.
   - Postconditions: Returns `true` if the string is `null` or composed solely of zero characters; `false` otherwise.
---
```"
636767e01a6d9265ec018764,convertProperties,"private JsonObject convertProperties(List<KeyStringValuePair> properties){
  final JsonObject result=new JsonObject();
  for (  KeyStringValuePair kv : properties) {
    result.addProperty(kv.getKey(),kv.getValue());
  }
  return result;
}
","/** 
 * Convert process properties to source data
 */
",Convert process properties to the JsonObject.,Converts a list of key-value pairs to a JSON object.,"The function iterates over a list of KeyStringValuePair objects, extracting the key and value from each and adding them as a property to a JsonObject, which is then returned.",The function takes a List of KeyStringValuePair objects and returns a JsonObject.,"- Typical usage: Input: [KeyStringValuePair(""name"", ""John""), KeyStringValuePair(""age"", ""30"")] Output: {""name"":""John"",""age"":""30""}
   - Boundary edge case: Input: [] Output: {}
   - Special case: Input: [KeyStringValuePair("""", ""emptyKey"")] Output: {"""":""emptyKey""}","- Preconditions: Input is a list of KeyStringValuePair objects where getKey() and getValue() return non-null string values.
   - Postconditions: Returns a JsonObject with string keys and values derived from input list.
---
```"
636766ff1a6d9265ec017853,readLabel,"protected Label readLabel(final int bytecodeOffset,final Label[] labels){
  if (labels[bytecodeOffset] == null) {
    labels[bytecodeOffset]=new Label();
  }
  return labels[bytecodeOffset];
}
","/** 
 * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.
 * @param bytecodeOffset a bytecode offset in a method.
 * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.
 * @return a non null Label, which must be equal to labels[bytecodeOffset].
 */
","Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.",Retrieves or initializes a Label object at a specified index in an array of Labels.,"The function checks if there is a Label object at the given bytecodeOffset in the labels array; if not, it creates a new Label object and assigns it to that position, then returns the Label.","(int bytecodeOffset, Label[] labels) -> Label","- Typical usage: 
     - Input: bytecodeOffset = 2, labels = [label1, null, label3]
     - Output: label3
   - Boundary edge case: 
     - Input: bytecodeOffset = 0, labels = [null, label2, label3]
     - Output: new Label()
   - Special or unusual case:
     - Input: bytecodeOffset = 1, labels = [label1, null]
     - Output: new Label()","- Preconditions: `bytecodeOffset` must be within the bounds of the `labels` array.
   - Postconditions: The function ensures that `labels[bytecodeOffset]` is not null and returns a reference to the Label at that position.
---
```"
6367677d1a6d9265ec0182fd,toBoolean,"public static boolean toBoolean(String value,boolean dEfault){
  if (value == null)   return dEfault;
  String trimmedVal=value.trim();
  if (""true"".equalsIgnoreCase(trimmedVal))   return true;
  if (""false"".equalsIgnoreCase(trimmedVal))   return false;
  return dEfault;
}
","/** 
 * If <code>value</code> is ""true"", then <code>true</code> is returned. If <code>value</code> is ""false"", then <code>true</code> is returned. Otherwise, <code>default</code> is returned. <p>Case of value is unimportant.  
 */
","Check whether a string is true or false after ignore cases and trim the whitespaces at both ends. If so, its boolean value is returned. Otherwise, dEfault is returned.",Converts a string to a boolean or returns a default value.,"The function checks if the input string `value` is `""true""` or `""false""` (case-insensitive), returning the corresponding boolean; if `value` is null or not a valid boolean string, it returns the provided `dEfault` boolean value.",The function takes a `String` named `value` and a `boolean` named `dEfault` as parameters and returns a `boolean`.,"- Typical usage: `toBoolean(""true"", false)` results in `true`.
   - Boundary edge case: `toBoolean(null, true)` results in `true`.
   - Special case: `toBoolean(""yes"", false)` results in `false`.","- Preconditions: `value` can be any string or null; `dEfault` is a boolean.
   - Postconditions: Returns `true` if `value` is `""true""`, `false` if `value` is `""false""`, otherwise returns `dEfault`.
---
```"
6367676a1a6d9265ec0181cd,trimLeadingWhitespace,"public static String trimLeadingWhitespace(String str){
  if (!hasLength(str)) {
    return str;
  }
  StringBuilder sb=new StringBuilder(str);
  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {
    sb.deleteCharAt(0);
  }
  return sb.toString();
}
","/** 
 * Trim leading whitespace from the given String.
 * @param str the String to check
 * @return the trimmed String
 * @see java.lang.Character#isWhitespace
 */
",Trim the leading whitespaces in a string.,Removes leading whitespace from a string.,"The function iterates over the input string and removes spaces and tabs from the start until finding a non-whitespace character, then returns the trimmed string.",The function accepts a single String argument `str` and returns a String.,"- Typical usage: `""  hello world""` -> `""hello world""`
   - Boundary edge case: `""""` -> `""""`
   - Special or unusual case: `""\n\t leading and trailing \n""` -> `""leading and trailing \n""`","- Preconditions: The input should be a valid String (can be empty).
   - Postconditions: Returns a string with all leading whitespace removed.
---
```"
636766fe1a6d9265ec01782a,readUtf,"final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){
  String value=constantUtf8Values[constantPoolEntryIndex];
  if (value != null) {
    return value;
  }
  int cpInfoOffset=cpInfoOffsets[constantPoolEntryIndex];
  return constantUtf8Values[constantPoolEntryIndex]=readUtf(cpInfoOffset + 2,readUnsignedShort(cpInfoOffset),charBuffer);
}
","/** 
 * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}.
 * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pooltable.
 * @param charBuffer the buffer to be used to read the string. This buffer must be sufficientlylarge. It is not automatically resized.
 * @return the String corresponding to the specified CONSTANT_Utf8 entry.
 */
",Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.,Retrieves a UTF-8 string value from a constant pool at a specified index.,"The function retrieves a UTF-8 encoded string from a constant pool if it is already cached; otherwise, it calculates the string value from the constant pool data using the given character buffer and stores it back in the cache for future access.",The function takes an integer constant pool entry index and a character array as parameters and returns a UTF-8 string.,"- **Typical usage:** If `constantPoolEntryIndex` 5 holds ""Hello"", `readUtf(5, charBuffer)` returns ""Hello"".
   - **Boundary edge case:** If `constantPoolEntryIndex` 0 points to an empty string, `readUtf(0, charBuffer)` returns """".
   - **Special case:** If `constantPoolEntryIndex` points to a null in `constantUtf8Values`, the function reads and caches the UTF-8 string anew.","Assumes `constantUtf8Values` and `cpInfoOffsets` arrays are correctly initialized and `constantPoolEntryIndex` is within bounds; updates `constantUtf8Values` when reading new UTF-8 strings.
---
```"
636766851a6d9265ec01751b,decodeHexNibble,"private static char decodeHexNibble(final char c){
  if ('0' <= c && c <= '9') {
    return (char)(c - '0');
  }
 else   if ('a' <= c && c <= 'f') {
    return (char)(c - 'a' + 10);
  }
 else   if ('A' <= c && c <= 'F') {
    return (char)(c - 'A' + 10);
  }
 else {
    return Character.MAX_VALUE;
  }
}
","/** 
 * Helper to decode half of a hexadecimal number from a string.
 * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}.
 * @return The hexadecimal value represented in the ASCII charactergiven, or  {@link Character#MAX_VALUE} if the character is invalid.
 */
",Convert a hexadecimal number to binary and return its character type.,Converts a hexadecimal character to its numeric value.,"The function accepts a single character, checks if it is a valid hexadecimal digit ('0'-'9', 'a'-'f', 'A'-'F'), and returns the corresponding numeric value as a character. If the character is not a valid hexadecimal digit, it returns the maximum possible character value.",The function takes a single character (`char c`) as input and returns a character (`char`) representing the numeric value.,"- Typical usage: Input 'A', Output '\n' (char value 10)
   - Boundary edge case: Input '0', Output '\0' (char value 0)
   - Special or unusual case: Input 'g', Output '￿' (char value 65535)","Input character is expected to be a single character. Valid hexadecimal characters return their numeric equivalent; otherwise, the function returns `Character.MAX_VALUE`.
---
```"
636766f21a6d9265ec01767d,toString,"public static String toString(Object object){
  return (object == null) ? null : object.toString();
}
","/** 
 * Object to String ,when null object then null else return toString(); 
 */
","Convert object to string  if the object is not null. Otherwise, null is returned.",Converts an object to its string representation or returns null if the object is null.,"The function checks if the provided object is null; if so, it returns null. Otherwise, it calls the object's `toString()` method and returns the resulting string representation.","The function takes one parameter: an `Object` named `object`, and it returns a `String`.","- Typical usage: `toString(new Integer(5))` returns `""5""`.
   - Boundary edge case: `toString(null)` returns `null`.
   - Special or unusual case: `toString(new Object())` returns a string like `""java.lang.Object@1b6d3586""`.","- Preconditions: The `object` parameter can be any object or null.
   - Postconditions: Returns a string if an object is provided, null if the input is null.
---"
636767581a6d9265ec017fc4,factorial,"public static long factorial(int n){
  long multi=1;
  for (int i=1; i <= n; i++) {
    multi=multi * i;
  }
  return multi;
}
","/** 
 * Calculate the factorial of $n$.
 * @param n the input number
 * @return the factorial
 */
",Calculate the factorial of the given number.,Computes the factorial of a non-negative integer n.,"The function iteratively multiplies integers from 1 to n, storing the product in a variable called `multi`, which is then returned as the factorial of n.",Takes a single integer parameter `n` and returns a `long` type representing n!.,"- Typical usage: `factorial(5)` returns `120`.
   - Boundary edge case: `factorial(0)` returns `1`.
   - Special or unusual case: `factorial(1)` returns `1`.","- Preconditions: Input `n` should be a non-negative integer.
   - Postconditions: Returns a `long` representing the factorial of n, handling large results due to factorial growth within the `long` data type limits.
---
```"
636767511a6d9265ec017eb6,selectOnOuterFace,"private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){
  OuterFaceCirculator circulator=start.iterator(dir);
  Node current=circulator.next();
  while (current != stop && !predicate.test(current)) {
    current=circulator.next();
  }
  return circulator;
}
","/** 
 * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate} or returns a circulator to the {@code stop} node.
 * @param predicate the condition the desired node should satisfy
 * @param start the node to start the search from
 * @param stop the node to end the search with
 * @param dir the direction to start the traversal in
 * @return a circulator to the node satisfying the {@code predicate} or to the {@code stop} node
 */
",Find a circulator to the node that satisfies the Interface predicate.,Iterates over nodes on the outer face to find one matching a predicate.,"The function initializes a circulator with a starting node and direction, then iterates through nodes using the circulator. It advances until the stop node is reached or a node satisfying the predicate is found. It returns the circulator at the point where the iteration halts.","The function takes a predicate, two nodes (start and stop), a direction (int), and returns an `OuterFaceCirculator`.","- Typical usage: Given a predicate that checks for a specific attribute, starting from node A and stopping at node C, with direction 1, it returns a circulator stopping at the node that meets the predicate.
   - Boundary edge case: If the start and stop nodes are the same, the function immediately returns the circulator without iteration.
   - Special or unusual case: If no nodes satisfy the predicate before reaching the stop node, it returns the circulator at the stop node.","The nodes are connected in a circular manner on the outer face; the circulator must be valid and able to iterate in the given direction. The output is a circulator positioned at either the first node that satisfies the predicate or the stop node.
---
```"
636767841a6d9265ec0183e8,add,"public void add(LoggingEvent event){
  ea[last]=event;
  if (++last == maxSize)   last=0;
  if (numElems < maxSize)   numElems++;
 else   if (++first == maxSize)   first=0;
}
","/** 
 * Add an <code>event</code> as the last event in the buffer.
 */
",Add an event as the last event in the buffer.,Circular buffer implementation for storing LoggingEvent objects.,"The function adds a `LoggingEvent` to a circular buffer; it replaces the oldest event when the buffer is full by updating the `last` pointer, optionally updating the `first` pointer when the buffer wraps around.",The function takes a `LoggingEvent` object as a parameter and returns nothing.,"- **Typical usage:** Adding a `LoggingEvent` to a buffer with available space: The event is stored, `last` is incremented.
   - **Boundary edge case:** Adding to a full buffer: The oldest event is overwritten, `first` and `last` are both updated.
   - **Special case:** Adding when `last` is at the end of the buffer: `last` wraps to the start after increment.","Preconditions: `ea` is initialized, `maxSize` is set, `last`, `first`, and `numElems` are valid indices. Postconditions: Buffer contains the added event, size/count variables (first, last, numElems) are correctly updated.
---"
636767a41a6d9265ec01857e,compareSigned,"private static int compareSigned(long a,long b){
  return (a < b) ? -1 : ((a > b) ? 1 : 0);
}
","/** 
 * Compares the two specified  {@code long} values. The sign of the value returned is the same as that of{@code ((Long) a).compareTo(b)}. <p> <b>Note for Java 7 and later:</b> this method should be treated as deprecated; use the equivalent {@link Long#compare} method instead.
 * @param a the first  {@code long} to compare
 * @param b the second  {@code long} to compare
 * @return a negative value if {@code a} is less than {@code b}; a positive value if  {@code a} is greater than{@code b}; or zero if they are equal
 */
",Compare two numbers.,"Compares two long integers and returns -1, 0, or 1 based on their difference.","The function compares two `long` integers, `a` and `b`, returning -1 if `a` is less than `b`, 1 if `a` is greater than `b`, and 0 if they are equal.",The function takes two `long` type parameters and returns an `int`.,"- Typical usage: `compareSigned(3L, 5L)` returns `-1`.
   - Boundary edge case: `compareSigned(Long.MAX_VALUE, Long.MIN_VALUE)` returns `1`.
   - Special or unusual case: `compareSigned(-100L, -100L)` returns `0`.","- Preconditions: Inputs are two valid `long` integers.
   - Postconditions: The return value is an integer (-1, 0, or 1) indicating the comparison result.
---
```"
636766a91a6d9265ec0175ae,putByteArray,"public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){
  if (length + byteLength > data.length) {
    enlarge(byteLength);
  }
  if (byteArrayValue != null) {
    System.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);
  }
  length+=byteLength;
  return this;
}
","/** 
 * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.
 * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.
 * @param byteOffset     index of the first byte of byteArrayValue that must be copied.
 * @param byteLength     number of bytes of byteArrayValue that must be copied.
 * @return this byte vector.
 */
",Add a byte array into the byte vector.,A function to append a segment of a byte array to a ByteVector's internal array.,"The function appends a specified segment of the input byte array to the internal storage array of a ByteVector object, enlarging the storage if necessary, and updates its length.","The function takes a byte array (`byteArrayValue`), an integer byte offset (`byteOffset`), and an integer byte length (`byteLength`), and returns a `ByteVector` object.","- Typical usage: 
     - Input: (`[1, 2, 3, 4]`, 1, 2), Output: ByteVector's data contains `[2, 3]` added starting at current length.
   - Boundary edge case: 
     - Input: (`[1, 2, 3]`, 0, 0), Output: ByteVector's data remains unchanged as no bytes are added.
   - Special case: 
     - Input: (`[1, 2, 3, 4]`, 1, 5), Output: Enlarge method is triggered to accommodate the overflow.","- Preconditions: `byteArrayValue` should not be `null` for copying; `byteOffset` and `byteLength` must be within valid range of the input byte array.
   - Postconditions: ByteVector's array will be enlarged if necessary, and it will contain the copied byte(s) starting from the current length.
---
```"
636766f11a6d9265ec01764f,values,"public Collection<Object> values(){
  ArrayList<Object> answer=new ArrayList<>(readMethods.size());
  for (Iterator<Object> iter=valueIterator(); iter.hasNext(); ) {
    answer.add(iter.next());
  }
  return Collections.unmodifiableList(answer);
}
","/** 
 * Returns the values for the BeanMap.
 * @return values for the BeanMap. The returned collection is not modifiable.
 */
",Return an unmodifiable list that contains all methods in the BeanMap.,Returns an unmodifiable list of all values obtained from a value iterator.,"The function initializes an ArrayList to store objects, iterates through elements obtained from a value iterator, adds each element to the list, and finally returns an unmodifiable view of this list.",The function takes no parameters and returns a `Collection<Object>`.,"- *Typical usage:* If `valueIterator()` provides elements `[1, 2, 3]`, then `values()` returns an unmodifiable list `[1, 2, 3]`.
   - *Boundary edge case:* If `valueIterator()` yields no elements, `values()` returns an empty unmodifiable list `[]`.
   - *Special or unusual case:* If elements from `valueIterator()` are of mixed types like `[1, ""string"", 3.0]`, `values()` returns `[1, ""string"", 3.0]`.","- Preconditions: `valueIterator()` must exist and return an iterator for objects.
   - Postconditions: The returned collection is an unmodifiable list containing all elements the iterator produces.
---
```"
636766f81a6d9265ec017758,hashCode,"@Override public int hashCode(){
  int hashCode=13 * (sort == INTERNAL ? OBJECT : sort);
  if (sort >= ARRAY) {
    for (int i=valueBegin, end=valueEnd; i < end; i++) {
      hashCode=17 * (hashCode + valueBuffer.charAt(i));
    }
  }
  return hashCode;
}
","/** 
 * Returns a hash code value for this type.
 * @return a hash code value for this type.
 */
",Compute a hash code according to the type.,Computes a hash code for an object based on its type and internal character values.,"The function calculates a hash code for an object by first multiplying a base value by an object-specific constant and then, if the object is an array or larger, iterates through a character buffer to add its characters to the hash using a prime multiplier.",This is a Java method that takes no parameters and returns an integer.,"- Typical usage: For an object with `sort=ARRAY` and `valueBuffer` containing ""abc"" from `valueBegin=0` to `valueEnd=3`, it returns an integer hash.
   - Boundary edge case: For an object with `sort=INTERNAL`, the function operates only with its preliminarily computed hash and doesn't iterate through a buffer.
   - Special or unusual case: If `sort` is less than `ARRAY`, the resulting hash is a simple calculation without buffer processing.","- Preconditions: The `sort` variable must be defined and either `INTERNAL`, `ARRAY`, or other integer values; `valueBuffer`, `valueBegin`, and `valueEnd` should be correctly assigned for buffer traversal.
   - Postconditions: An integer hash code is returned, representing a pseudo-unique value for an object based on its initial parameters and buffer content.
---
```"
6367676c1a6d9265ec01820b,deleteAny,"public static String deleteAny(String inString,String charsToDelete){
  if (!hasLength(inString) || !hasLength(charsToDelete)) {
    return inString;
  }
  StringBuilder sb=new StringBuilder();
  for (int i=0; i < inString.length(); i++) {
    char c=inString.charAt(i);
    if (charsToDelete.indexOf(c) == -1) {
      sb.append(c);
    }
  }
  return sb.toString();
}
","/** 
 * Delete any character in a given String.
 * @param inString the original String
 * @param charsToDelete a set of characters to delete.E.g. ""az\n"" will delete 'a's, 'z's and new lines.
 * @return the resulting String
 */
",Delete characters that exists in the intersection between two character strings of the first character string and return the first character string that is modified.,Removes specified characters from a string.,The function iterates through each character of the input string and appends it to a `StringBuilder` only if the character is not present in the `charsToDelete` string.,"Takes two `String` parameters `inString` and `charsToDelete`, returns a `String`.","- Typical usage: `deleteAny(""hello world"", ""eo"")` returns `""hll wrld""`.
   - Boundary edge case: `deleteAny("""", ""aeiou"")` returns `""""`.
   - Special or unusual case: `deleteAny(""aaaa"", ""aa"")` returns `""""`.","- Preconditions: Both parameters are non-null strings; `charsToDelete` can be empty.
   - Postconditions: Returns a string that contains all characters from `inString` except those found in `charsToDelete`.
---"
636766861a6d9265ec01755a,match,"public final MatchResult match(CharSequence uri){
  if (uri == null || uri.length() == 0)   return (regexPattern == null) ? EMPTY_STRING_MATCH_RESULT : null;
 else   if (regexPattern == null)   return null;
  Matcher m=regexPattern.matcher(uri);
  if (!m.matches())   return null;
  return (groupIndexes.length > 0) ? new GroupIndexMatchResult(m) : m;
}
","/** 
 * Match a URI against the pattern.
 * @param uri the uri to match against the template.
 * @return the match result, otherwise null if no match occurs.
 */
","If the match between the url and the pattern occurs, return the match result. Otherwise, return null.",Match a URI against a regex pattern and return the match result.,"The `match` function takes a URI represented as a `CharSequence` and determines if it matches a pre-defined regex pattern (`regexPattern`). If the URI is null or empty, it returns an empty string match result or null depending on whether a pattern is defined. If `regexPattern` is available, it attempts to match the URI. If the match is unsuccessful, it returns null. If successful, it returns a `GroupIndexMatchResult` if there are group indexes, otherwise the raw Matcher result.","The function takes a single parameter, `uri` of type `CharSequence`, and returns a `MatchResult` object.","- Typical usage: `match(""http://example.com"")` returns a match result if the URI matches the regex pattern.
   - Boundary edge case: `match("""")` returns `EMPTY_STRING_MATCH_RESULT` or null if no regex pattern is set.
   - Special case: `match(null)` returns `EMPTY_STRING_MATCH_RESULT` or null if no regex pattern is set.","- Preconditions: `regexPattern` might be null; `groupIndexes` is assumed to be defined elsewhere.
   - Postconditions: Returns null if the URI doesn't match or the pattern is null; a `MatchResult` object otherwise.
---"
636766f91a6d9265ec01777d,convertHexDigit,"public static byte convertHexDigit(byte b){
  if ((b >= '0') && (b <= '9'))   return (byte)(b - '0');
  if ((b >= 'a') && (b <= 'f'))   return (byte)(b - 'a' + 10);
  if ((b >= 'A') && (b <= 'F'))   return (byte)(b - 'A' + 10);
  throw new IllegalArgumentException(""!hex:"" + Integer.toHexString(0xff & b));
}
","/** 
 * @param b An ASCII encoded character 0-9 a-f A-F
 * @return The byte value of the character 0-16.
 */
",Convert an ASCII encoded character to hex.,Converts a hexadecimal digit character to its numeric value.,"The function checks if the byte represents a valid hexadecimal digit ('0'-'9', 'a'-'f', 'A'-'F'), and converts it to its corresponding numeric value; throws an exception if it's not valid.",It takes a single byte as input and returns a byte.,"- Typical usage: `convertHexDigit((byte)'9')` returns `9`.
   - Boundary edge case: `convertHexDigit((byte)'f')` returns `15`.
   - Special or unusual case: `convertHexDigit((byte)'G')` throws an IllegalArgumentException.","The input must be a byte that represents a character. Valid outputs are in the range 0-15, otherwise, an exception is thrown.
---
```"
636767861a6d9265ec01844c,removeAppender,"public void removeAppender(String name){
  if (name == null || appenderList == null)   return;
  int size=appenderList.size();
  for (int i=0; i < size; i++) {
    if (name.equals(((Appender)appenderList.elementAt(i)).getName())) {
      appenderList.removeElementAt(i);
      break;
    }
  }
}
","/** 
 * Remove the appender with the name passed as parameter form the list of appenders.  
 */
",Remove the appender by the given name from the list of appenders.,Removes an appender with a matching name from the appender list.,"The function iterates through a list of appenders and removes the appender that has a name matching the provided name parameter. If the name is null or the appender list is null, the function returns immediately without doing anything.",The function takes a String parameter `name` and returns void.,"- **Typical usage:** Given appenderList = [Appender(""A""), Appender(""B"")], calling removeAppender(""B"") modifies the list to [Appender(""A"")].
   - **Boundary edge case:** Given an empty appenderList = [], calling removeAppender(""A"") results in no change.
   - **Special or unusual case:** Given appenderList = [Appender(""A""), Appender(""B"")], calling removeAppender(null) results in no change.","- Preconditions: The `appenderList` exists and is a list of Appender objects having a valid `getName()` method.
   - Postconditions: `appenderList` may have one less element if an appender with a matching name was removed.
---
```"
6367670c1a6d9265ec017a2a,toPrimitive,"public static int[] toPrimitive(final Integer[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_INT_ARRAY;
  }
  final int[] result=new int[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].intValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Integers to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Integer</code> array, may be <code>null</code>
 * @return an <code>int</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Convert the given Integer array to primitives. Return ArrayUtils.EMPTY_INT_ARRAY for an empty array, return null for null array.",Converts an Integer array to a primitive int array.,"The function takes an array of Integer objects and returns a new array of primitive int with the same values. If the input is null, it returns null. If the input array is empty, it returns an empty int array using ArrayUtils.EMPTY_INT_ARRAY. The function iterates over the input array, converting each Integer to int and storing it in a new array.",The function accepts an array of Integer objects (`Integer[] array`) and returns an array of primitive integers (`int[]`).,"- Typical usage: 
     - Input: `[new Integer(1), new Integer(2), new Integer(3)]`
     - Output: `[1, 2, 3]`
   
   - Boundary edge case:
     - Input: `null`
     - Output: `null`

   - Special case:
     - Input: `[]`
     - Output: `[]` (empty array using ArrayUtils.EMPTY_INT_ARRAY)","- Preconditions: Input can be a null reference or a valid Integer array.
   - Postconditions: Returns a primitive int array or null matching the input; empty array if input empty.
---"
636767041a6d9265ec017911,register,"static void register(Object value){
  if (value != null) {
    Map m=getRegistry();
    if (m == null) {
      m=new WeakHashMap();
      REGISTRY.set(m);
    }
    m.put(value,null);
  }
}
","/** 
 * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>
 * @param value The object to register.
 */
",Register the value in REGISTRY if the value is not null.,Registers a non-null object into a thread-local weak hash map.,"The function checks if the input value is not null and retrieves a thread-local registry map. If the map is null, it initializes a new `WeakHashMap` and sets it in the thread-local storage. Then, it adds the value to the map with a null key.",`void register(Object value)`,"- Typical usage: `register(new Object())` adds the object to the map if it is not null.
   - Boundary edge case: `register(null)` does nothing as the input is null.
   - Special or unusual case: Upon calling `register()` repeatedly with the same object, the object is stored in the map without duplicates.","- Preconditions: The function should be given an object, possibly null.
   - Postconditions: The object is stored in a `WeakHashMap` associated with the current thread if it's non-null; otherwise, no action is taken.
---"
636767511a6d9265ec017eb0,nonZeros,"public int nonZeros(int row){
  assert row >= 0 && row < rowOffsets.length;
  return rowOffsets[row + 1] - rowOffsets[row];
}
","/** 
 * Get the number of non-zero entries of a row.
 * @param row the row
 * @return the number of non-zero entries of a row
 */
",Return the number of non-zero entries of a row.,Computes non-zero elements in a specific matrix row using row offsets.,The function calculates the number of non-zero elements in a given row of a matrix represented in Compressed Sparse Row (CSR) format by subtracting consecutive entries in the `rowOffsets` array corresponding to the specified row.,The function accepts a single integer parameter `row` indicating the row index and returns an integer representing the count of non-zero elements in that row.,"- Typical usage: `nonZeros(2)` returns `rowOffsets[3] - rowOffsets[2]`.  
   - Boundary edge case: `nonZeros(0)` returns `rowOffsets[1] - rowOffsets[0]`.  
   - Special case: If rowOffsets are all equal, `nonZeros(row)` returns `0`.","- Preconditions: `row` must be within the valid index range for `rowOffsets` (0 to `rowOffsets.length - 2`).
   - Postconditions: Returns the integer difference between two consecutive `rowOffsets` elements as the count of non-zero elements in the specified row.
---"
6367676c1a6d9265ec018223,containsInstance,"public static boolean containsInstance(Collection collection,Object element){
  if (collection != null) {
    for (    Object candidate : collection) {
      if (candidate == element) {
        return true;
      }
    }
  }
  return false;
}
","/** 
 * Check whether the given Collection contains the given element instance. <p>Enforces the given instance to be present, rather than returning <code>true</code> for an equal element as well.
 * @param collection the Collection to check
 * @param element the element to look for
 * @return <code>true</code> if found, <code>false</code> else
 */
",Check whether the element exists in the collection. ,Checks if a collection contains a specific instance.,"The function iterates through the given collection and returns `true` if any object reference in the collection matches the provided element reference using `==`, otherwise it returns `false`.",The function takes a `Collection` and an `Object` as parameters and returns a `boolean`.,"- **Typical usage:** For `containsInstance(Arrays.asList(""cat"", ""dog""), ""cat"")`, returns `false` if ""cat"" is a different instance.
   - **Boundary edge case:** For `containsInstance(null, ""cat"")`, returns `false`.
   - **Special or unusual case:** For a collection `list` with duplicates, `containsInstance(list, list.get(0))` returns `true` if the exact instance exists.","- Preconditions: Collection may be null, but the element must not necessarily be.
   - Postconditions: The function returns `true` if an element with the exact reference exists in the collection, otherwise `false`.
---"
636766fa1a6d9265ec01779d,isAsciiControl,"public static boolean isAsciiControl(final char ch){
  return ch < 32 || ch == 127;
}
","/** 
 * <p>Checks whether the character is ASCII 7 bit control.</p> <pre> CharUtils.isAsciiControl('a')  = false CharUtils.isAsciiControl('A')  = false CharUtils.isAsciiControl('3')  = false CharUtils.isAsciiControl('-')  = false CharUtils.isAsciiControl('\n') = true CharUtils.isAsciiControl('&copy;') = false </pre>
 * @param ch  the character to check
 * @return true if less than 32 or equals 127
 */
",Check whether the character is ASCII 7 bit control.,Checks if a character is an ASCII control character.,"The function returns true if the input character has an ASCII value less than 32 or is exactly 127, indicating it is a control character; otherwise, it returns false.",It takes a single character `ch` as a parameter and returns a boolean.,"- Typical usage: `isAsciiControl('\n')` returns `true`.
   - Boundary edge case: `isAsciiControl(' ')` returns `false`.
   - Special or unusual case: `isAsciiControl('\u007F')` returns `true`.","- Preconditions: Input is a valid `char` type.
   - Postconditions: Output is a boolean indicating control character status.
---
```"
6367670b1a6d9265ec0179f2,containsKey,"@Override public boolean containsKey(final Object key){
  if (this.fast) {
    return this.map.containsKey(key);
  }
 else {
synchronized (this.map) {
      return this.map.containsKey(key);
    }
  }
}
","/** 
 * Return <code>true</code> if this map contains a mapping for the specified key.
 * @param key  the key to be searched for
 * @return true if the map contains the key
 */
",Check whether a map contains a mapping for the specified key.,The function checks for the presence of a specified key in a map.,"The `containsKey` method checks if the specified key exists in the map. If the `fast` flag is set to true, it accesses the `containsKey` method of the map directly without synchronization for faster performance. Otherwise, it synchronizes on the map object to ensure thread safety before checking the key.","The `containsKey` function takes one parameter, an `Object key`, and returns a `boolean`.","- **Typical usage:** For a map `{1: 'a', 2: 'b'}` and `key = 1`, `containsKey(1)` returns `true`.
   - **Boundary edge case:** For a map `{}`, any key like `containsKey('x')` returns `false`.
   - **Special or unusual case if relevant:** For a map `{null: 'value'}` and `key = null`, `containsKey(null)` returns `true`.","The input `key` must be a valid object or null; the function will return `true` if the key exists in the map and `false` otherwise.
---
```"
636766fa1a6d9265ec017796,toObject,"public static Boolean[] toObject(final boolean[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;
  }
  final Boolean[] result=new Boolean[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i] ? Boolean.TRUE : Boolean.FALSE;
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive booleans to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>boolean</code> array
 * @return a <code>Boolean</code> array, <code>null</code> if null array input
 */
",Convert an array of primitive booleans to objects.,Converts a boolean array to a Boolean object array.,"The function takes a primitive boolean array and converts it into an array of Boolean objects, returning null if the input is null and an empty array if the input is empty.","The function takes a single parameter, an array of primitive booleans `boolean[] array`, and returns a `Boolean[]`.","- Typical usage: `toObject(new boolean[]{true, false, true})` returns `[Boolean.TRUE, Boolean.FALSE, Boolean.TRUE]`.
   - Boundary edge case: `toObject(new boolean[]{})` returns an empty `Boolean[]` array.
   - Special or unusual case: `toObject(null)` returns `null`.","- Preconditions: The input can be a boolean array or null.
   - Postconditions: Returns a `Boolean[]` of the same length as the input if not null, otherwise returns appropriate special cases.
---
```"
636767aa1a6d9265ec01864a,toByteArray,"public byte[] toByteArray(){
  final int size=bytes.length;
  final byte[] copy=new byte[size];
  System.arraycopy(bytes,0,copy,0,size);
  return copy;
}
","/** 
 * Copies bytes to a  {@code byte[]}.
 */
",Copy bytes to a byte array.,Returns a copy of the byte array.,"The function creates a new byte array of the same length as the original array `bytes`, then uses `System.arraycopy` to copy all elements from `bytes` to this new array, and finally returns the new array.",The function does not take any parameters and returns a byte array (`byte[]`).,"- Typical usage: If `bytes` is `[1, 2, 3]`, `toByteArray()` returns `[1, 2, 3]`.
   - Boundary edge case: If `bytes` is `[]`, `toByteArray()` returns `[]`.
   - No unusual cases as the function handles all byte arrays in a standard way.","- Preconditions: `bytes` must be properly initialized.
   - Postconditions: The returned byte array is a new instance and identical in content to `bytes`.
---
```"
636767561a6d9265ec017f7c,edgeSetToTour,"protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){
  List<V> vertices=new ArrayList<>(tour.size() + 1);
  MaskSubgraph<V,E> tourGraph=new MaskSubgraph<>(graph,v -> false,e -> !tour.contains(e));
  new DepthFirstIterator<>(tourGraph).forEachRemaining(vertices::add);
  return vertexListToTour(vertices,graph);
}
","/** 
 * Transform from a Set representation to a graph path.
 * @param tour a set containing the edges of the tour
 * @param graph the graph
 * @return a graph path
 */
",Convert a set representation to a graph path.,Converts a set of edges on a graph into a GraphPath object representing a tour.,"The function creates a subgraph from the input graph, excluding edges not in the provided set of edges (tour). It then uses a DepthFirstIterator to traverse the graph and collects the vertices. Finally, it constructs and returns a GraphPath using these vertices and the original graph.","The function accepts a Set<E> representing edges of a tour, and a Graph<V,E>, returning a GraphPath<V,E>.","- Typical usage: 
     - Input: tour = {e1, e2, e3}, graph = Graph with vertices [v1, v2, v3, v4] and edges [e1 = (v1, v2), e2 = (v2, v3), e3 = (v3, v1)]
     - Output: GraphPath using vertices [v1, v2, v3, v1]
   - Boundary edge case: 
     - Input: tour = {}, graph = Graph with vertices [v1]
     - Output: GraphPath with vertices [v1] if vertexListToTour handles empty lists
   - Special case:
     - Input: tour = {e1}, graph = Graph with vertices [v1, v2] and edges [e1 = (v1, v2)]
     - Output: GraphPath using vertices [v1, v2]","- Preconditions: The provided tour set contains edges that form a connected subgraph; the graph is non-null and contains all vertices and edges referenced by the tour.
   - Postconditions: A GraphPath containing vertices traversed in depth-first order is returned, representing the tour within the original graph.
---
```"
6367670a1a6d9265ec0179f1,toObject,"public static Short[] toObject(final short[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;
  }
  final Short[] result=new Short[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=new Short(array[i]);
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive shorts to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>short</code> array
 * @return a <code>Short</code> array, <code>null</code> if null array input
 */
",Convert an array of primitive shorts to objects.,Converts a primitive short array to a Short object array.,"The function checks if the input array is null or empty, and returns null or an empty Short array accordingly; otherwise, it converts each short in the array to a Short object and returns a new array of Short objects.",The function takes a primitive short array as a parameter and returns an array of Short objects.,"- Typical usage: 
     - Input: `new short[]{1, 2, 3}`
     - Output: `new Short[]{1, 2, 3}`
   - Boundary edge case:
     - Input: `new short[]{}`
     - Output: `ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY`
   - Special or unusual case:
     - Input: `null`
     - Output: `null`","The input array can be null or any length, and the function will return a null, empty, or populated Short object array reflecting the input.
---"
6367676c1a6d9265ec018204,concatenateStringArrays,"public static String[] concatenateStringArrays(String[] array1,String[] array2){
  if (Objects.isEmpty(array1)) {
    return array2;
  }
  if (Objects.isEmpty(array2)) {
    return array1;
  }
  String[] newArr=new String[array1.length + array2.length];
  System.arraycopy(array1,0,newArr,0,array1.length);
  System.arraycopy(array2,0,newArr,array1.length,array2.length);
  return newArr;
}
","/** 
 * Concatenate the given String arrays into one, with overlapping array elements included twice. <p>The order of elements in the original arrays is preserved.
 * @param array1 the first array (can be <code>null</code>)
 * @param array2 the second array (can be <code>null</code>)
 * @return the new array (<code>null</code> if both given arrays were <code>null</code>)
 */
",Concatenate two string arrays into one.,Concatenates two string arrays into one.,"The function checks if each input array is empty, returning the non-empty array or a combined array by copying both into a new array, using `System.arraycopy`.",It accepts two `String[]` parameters and returns a `String[]`.,"- Typical usage: 
     - Input: `[""a"", ""b""]`, `[""c"", ""d""]`
     - Output: `[""a"", ""b"", ""c"", ""d""]`
   - Boundary edge case:
     - Input: `[]`, `[""x"", ""y""]`
     - Output: `[""x"", ""y""]`
   - Special case:
     - Input: `[]`, `[]`
     - Output: `[]`","Assumes input arrays are not `null`; returns a new array containing all elements from both input arrays, maintaining order.
---
```"
6367676a1a6d9265ec0181d4,addStringToArray,"public static String[] addStringToArray(String[] array,String str){
  if (Objects.isEmpty(array)) {
    return new String[]{str};
  }
  String[] newArr=new String[array.length + 1];
  System.arraycopy(array,0,newArr,0,array.length);
  newArr[array.length]=str;
  return newArr;
}
","/** 
 * Append the given String to the given String array, returning a new array consisting of the input array contents plus the given String.
 * @param array the array to append to (can be <code>null</code>)
 * @param str the String to append
 * @return the new array (never <code>null</code>)
 */
",Append a string to a string array.,Adds a string to the end of an existing string array.,"The function checks if the input array is null or empty and returns a new array containing only the specified string if true. Otherwise, it creates a new array with a size one greater than the original array, copies the original array elements into the new array, appends the specified string to the end, and returns the new array.","The function takes a non-null array of strings and a non-null string, and returns a new array of strings.","- Typical usage: 
     Input: `addStringToArray(new String[]{""apple"", ""banana""}, ""cherry"")` 
     Output: `[""apple"", ""banana"", ""cherry""]`
   - Boundary edge case: 
     Input: `addStringToArray(new String[]{}, ""cherry"")` 
     Output: `[""cherry""]`
   - Special or unusual case if relevant: 
     Input: `addStringToArray(null, ""cherry"")` 
     Output: `[""cherry""]`  *(assuming Objects.isEmpty checks for null; adjust if the assumption changes)*","- Preconditions: The input array can be null or empty; the string to be added is non-null.
   - Postconditions: Returns a non-null array with the added string as the last element.
---"
6367676b1a6d9265ec0181dd,countOccurrencesOf,"public static int countOccurrencesOf(String str,String sub){
  if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {
    return 0;
  }
  int count=0;
  int pos=0;
  int idx;
  while ((idx=str.indexOf(sub,pos)) != -1) {
    ++count;
    pos=idx + sub.length();
  }
  return count;
}
","/** 
 * Returns the number of occurrences the substring  {@code sub} appears in string {@code str}.
 * @param str string to search in. Return 0 if this is null.
 * @param sub string to search for. Return 0 if this is null.
 * @return the number of occurrences the substring {@code sub} appears in string {@code str}.
 */
",Return the frequencies that the substring appears in the string.,Counts occurrences of a substring within a string.,"The function iterates over the main string to find non-overlapping occurrences of a given substring, counting each occurrence by updating the starting search position.","The function takes two `String` parameters, `str` and `sub`, and returns an `int` representing the count of `sub` occurrences in `str`.","- Typical usage: `countOccurrencesOf(""hellohello"", ""hello"")` returns `2`.
   - Boundary edge case: `countOccurrencesOf("""", ""anything"")` returns `0`.
   - Special or unusual case: `countOccurrencesOf(""ababab"", ""aba"")` returns `1`.","The function assumes both input strings can be null or empty, and in such cases will return `0` occurrences.
---
```"
636766fe1a6d9265ec017821,appendDetail,"protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){
  buffer.append(arrayStart);
  for (int i=0; i < array.length; i++) {
    if (i > 0) {
      buffer.append(arraySeparator);
    }
    appendDetail(buffer,fieldName,array[i]);
  }
  buffer.append(arrayEnd);
}
","/** 
 * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>
 * @param buffer  the <code>StringBuffer</code> to populate
 * @param fieldName  the field name, typically not used as already appended
 * @param array  the array to add to the <code>toString</code>,not <code>null</code>
 */
",Append a byte array to a buffer.,Concatenates a representation of a byte array into a StringBuffer.,"The function appends a representation of a byte array into a given `StringBuffer` by iterating over the array and calling `appendDetail` recursively, separated by `arraySeparator` and enclosed with `arrayStart` and `arrayEnd`.","Takes a `StringBuffer`, a `String` for the field name, and a `byte[]` array; returns void (modifies the `StringBuffer`).","- Typical usage: 
     - Input: buffer = ""Numbers: "", fieldName = ""byteArray"", array = {1, 2, 3}
     - Output: buffer = ""Numbers: [1, 2, 3]""
   - Boundary edge case:
     - Input: buffer = """", fieldName = ""byteArray"", array = {}
     - Output: buffer = ""[]""
   - Special or unusual case:
     - Input: buffer = ""Data: "", fieldName = ""nullArray"", array = null
     - Output: buffer remains unchanged","- Preconditions: `buffer` is non-null; `arrayStart`, `arraySeparator`, and `arrayEnd` are appropriately initialized and accessible in the context.
   - Postconditions: `buffer` is updated to include a string representation of the input byte array, adhering to the structure defined by the delimiters.
---"
636767561a6d9265ec017f63,hasNext,"@Override public boolean hasNext(){
  if (current != null) {
    return true;
  }
  current=advance();
  if (current != null && nListeners != 0) {
    fireVertexTraversed(createVertexTraversalEvent(current));
  }
  return current != null;
}
","/** 
 * Checks whether there exist unvisited vertices.
 * @return true if there exist unvisited vertices.
 */
","Check whether there are unvisited vertices. If so, return true. Otherwise, return false.",Check if there is a next element in a traversal.,"The function returns true if the current element is non-null, otherwise it advances to the next element, triggers event listeners if applicable, and returns true if the advanced element is non-null.",No parameters; returns a boolean indicating if a next element exists.,"- Typical usage: If `current` is non-null, `hasNext()` returns true.
   - Boundary edge case: If `current` is initially null and no next element exists upon advancing, `hasNext()` returns false.
   - Special case: If `advance()` sets `current` to non-null and `nListeners` > 0, an event is fired.","- Preconditions: `current` represents the current element in the traversal; `advance()` should properly move to the next element.
   - Postconditions: `current` will be non-null if a next element exists and true is returned; event listeners might be triggered if they exist.
---
```"
636766a81a6d9265ec017586,pop,"private void pop(final int elements){
  if (outputStackTop >= elements) {
    outputStackTop-=elements;
  }
 else {
    outputStackStart-=elements - outputStackTop;
    outputStackTop=0;
  }
}
","/** 
 * Pops the given number of abstract types from the output frame stack.
 * @param elements the number of abstract types that must be popped.
 */
",Pop the given number of elements from the stack.,Reduces the number of elements in a stack without returning any value.,"The function decreases the `outputStackTop` by `elements` if `outputStackTop` is greater than or equal to `elements`; otherwise, it decreases `outputStackStart` by the excess elements needed after setting `outputStackTop` to zero.","Takes an integer `elements` as input, does not return a value.","- **Typical usage:** If `outputStackTop` is 5 and `elements` is 3, both `outputStackTop` and `outputStackStart` remain unaffected.
   - **Boundary edge case:** If `outputStackTop` is 3 and `elements` is 3, `outputStackTop` becomes 0.
   - **Special or unusual case:** If `outputStackTop` is 2 and `elements` is 5, `outputStackTop` becomes 0 and `outputStackStart` is decreased by 3.","Preconditions: `outputStackTop` and `outputStackStart` must be non-negative integers representing the current stack state.  
Postconditions: Modifies `outputStackTop` and possibly `outputStackStart` without exceeding or dropping below zero.
---
```"
636767e11a6d9265ec018795,isCompatible,"public boolean isCompatible(DataTable dataset){
  final List<String> sortedKeys=dataset.sortedKeys(new HeatMap.KeyComparator(true));
  long[] existedBuckets=new long[sortedKeys.size()];
  for (int i=0; i < sortedKeys.size(); i++) {
    String key=sortedKeys.get(i);
    if (key.equals(Bucket.INFINITE_NEGATIVE)) {
      existedBuckets[i]=Long.MIN_VALUE;
    }
 else {
      if (key.contains("":"")) {
        key=StringUtils.substringAfterLast(key,"":"");
      }
      existedBuckets[i]=Long.parseLong(key);
    }
  }
  return Arrays.equals(buckets,existedBuckets);
}
","/** 
 * @return true if the bucket is same.
 */
",Check whether the existed buckets are the same as the buckets.,Checks if dataset's sorted bucket keys match a predefined set of bucket values.,"The function first retrieves sorted keys from the dataset and processes each key into a long value, storing it in an array. It compares this array to a predefined `buckets` array to determine compatibility, returning true for an exact match, false otherwise.","The function `isCompatible` accepts a single parameter, `dataset` of type `DataTable`, and returns a boolean value.","- Typical usage: `isCompatible(dataset)` returns `true` if `buckets` array matches the sorted bucket keys extracted from `dataset`.
   - Boundary edge case: `isCompatible(emptyDataset)` returns `true` if `buckets` is also empty.
   - Special case: If `sortedKeys` contain only `INFINITE_NEGATIVE`, the function returns `true` if `buckets` contains only `Long.MIN_VALUE`.","- Preconditions: `dataset` must have a method `sortedKeys(Comparator)` that returns a list of strings, and `buckets` is predefined elsewhere as an array of long values.
   - Postconditions: Returns `true` if the processed keys from the dataset exactly match the `buckets` array; otherwise returns `false`.
---
```"
636767611a6d9265ec018112,provideNextVertex,"@Override protected V provideNextVertex(){
  V v=super.provideNextVertex();
  for (int i=path.size() - 1; i >= 0; --i) {
    if (graph.containsEdge(path.get(i),v)) {
      break;
    }
    path.remove(i);
  }
  path.add(v);
  return v;
}
","/** 
 * {@inheritDoc}
 */
",Get next vertext from a graph.,"Updates path with the next vertex if connected, else trims path.","The function extends a path by adding a new vertex returned by a superclass method. It iterates backward through the current path to check connectivity with the new vertex, removing elements that are not directly connected and adding the new vertex to the path thereafter.",No parameters. Returns a vertex `v` of generic type `V`.,"- Typical usage: If the path is `[A, B]`, `v` is `C`, and `graph` has an edge from `B` to `C`, the path updates to `[A, B, C]`.
   - Boundary edge case: If the path is `[]`, any vertex `v` added becomes the only element in the path.
   - Special or unusual case: If the path is `[A, B, C]`, `v` is `D`, and no vertex in the path connects to `D`, the path resets to `[D]`.","- Preconditions: The path must be a list holding vertices, and `v` must be a vertex returned by `super.provideNextVertex()`.
- Postconditions: The path is adjusted to connect with new vertex `v`, either appended to the existing path or started anew if no connections exist.
---
```"
636767131a6d9265ec017b23,addLineNumber,"final void addLineNumber(final int lineNumber){
  if (this.lineNumber == 0) {
    this.lineNumber=(short)lineNumber;
  }
 else {
    if (otherLineNumbers == null) {
      otherLineNumbers=new int[LINE_NUMBERS_CAPACITY_INCREMENT];
    }
    int otherLineNumberIndex=++otherLineNumbers[0];
    if (otherLineNumberIndex >= otherLineNumbers.length) {
      int[] newLineNumbers=new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT];
      System.arraycopy(otherLineNumbers,0,newLineNumbers,0,otherLineNumbers.length);
      otherLineNumbers=newLineNumbers;
    }
    otherLineNumbers[otherLineNumberIndex]=lineNumber;
  }
}
","/** 
 * Adds a source line number corresponding to this label.
 * @param lineNumber a source line number (which should be strictly positive).
 */
",Add the number of lines. ,Add a line number to the object's storage.,"The function sets the initial `lineNumber` if it is zero, otherwise adds the new line number to an array `otherLineNumbers`, expanding the array if necessary, to store additional line numbers.",This method takes a single `int` parameter `lineNumber` and returns nothing.,"- **Typical usage:** Given `lineNumber=5` and `this.lineNumber=0`, it sets `this.lineNumber` to 5.
   - **Boundary edge case:** Given `lineNumber=5` and `this.lineNumber=5`, it initializes `otherLineNumbers` and adds 5 to it.
   - **Special or unusual case:** Given `lineNumber=5` with `otherLineNumbers` full, it expands the array and adds 5.","- Preconditions: The object has an integer member `lineNumber` and an array `otherLineNumbers`.
   - Postconditions: If `lineNumber` is not set, it assigns it; otherwise, it adds the new number to the `otherLineNumbers` array, resizing if necessary.
---
```"
636767dd1a6d9265ec0186f3,overrideName,"public void overrideName(String oldName,String newName){
  for (int i=0; i < columns.length; i++) {
    if (columns[i].equals(oldName)) {
      columns[i]=newName;
    }
  }
}
","/** 
 * Keep the same name replacement as  {@link ColumnName#overrideName(String,String)}
 * @param oldName to be replaced.
 * @param newName to use in the storage level.
 */
",Change the elements whose values are oldName to newName in column,Replaces occurrences of a specific string in an array with a new string.,"The function iterates through an array named `columns`, and whenever an entry matches `oldName`, it is replaced by `newName`.","`overrideName(String oldName, String newName)` modifies an array of strings with void return type.","- Typical usage: `columns = {""name"", ""age"", ""location""}` with `oldName = ""location""`, `newName = ""address""` results in `columns = {""name"", ""age"", ""address""}`.
   - Boundary edge case: `columns = {""name"", ""name"", ""name""}` with `oldName = ""name""`, `newName = ""firstName""` results in `columns = {""firstName"", ""firstName"", ""firstName""}`.
   - Special case: `columns = {}` with `oldName = ""anything""`, `newName = ""something""` results in `columns = {}`.","- Preconditions: `columns` is a predefined, non-null array of strings. `oldName` and `newName` are non-null strings.
   - Postconditions: All occurrences of `oldName` in `columns` are replaced by `newName`. If `oldName` is not in `columns`, it remains unchanged.
---
```"
636767631a6d9265ec018171,unlink,"private boolean unlink(ListNodeImpl<E> node){
  ListNodeImpl<E> prev=node.prev;
  ListNodeImpl<E> next=node.next;
  if (removeListNode(node)) {
    if (size == 0) {
      head=null;
    }
 else {
      link(prev,next);
      if (head == node) {
        head=next;
      }
    }
    return true;
  }
  return false;
}
","/** 
 * Remove the non null  {@code node} from the list. 
 */
","Remove the doubly circular linked list node.If success return true,otherwise return false.",Removes a node from a linked list and updates the list's head if necessary.,"The function attempts to remove the given node from a linked list, updating the 'prev' and 'next' links of adjacent nodes, adjusts the head if the removed node was the head, and handles the case when the list becomes empty.",The function takes a `ListNodeImpl<E>` node as a parameter and returns a `boolean`.,"- Typical usage: For a node in the middle of the list, input `node`, output `true` if `removeListNode(node)` returns `true`.
   - Boundary edge case: When the list has only one node, input `node`, output `true` results in an empty list.
   - Special or unusual case: For a non-existent node in the list, input `node`, output `false`.","- Preconditions: The input node must be part of the list.
   - Postconditions: The specified node is removed from the list or the list remains unchanged if removal fails.
---
```"
6367676c1a6d9265ec018220,stripFilenameExtension,"public static String stripFilenameExtension(String path){
  if (path == null) {
    return null;
  }
  int extIndex=path.lastIndexOf(EXTENSION_SEPARATOR);
  if (extIndex == -1) {
    return path;
  }
  int folderIndex=path.lastIndexOf(FOLDER_SEPARATOR);
  if (folderIndex > extIndex) {
    return path;
  }
  return path.substring(0,extIndex);
}
","/** 
 * Strip the filename extension from the given path, e.g. ""mypath/myfile.txt"" -&gt; ""mypath/myfile"".
 * @param path the file path (may be <code>null</code>)
 * @return the path with stripped filename extension,or <code>null</code> if none
 */
",Return the path without the extension.,Removes the file extension from a file path.,"The function removes the file extension from a given file path string if it exists; otherwise, it returns the path unchanged. It checks if the path is non-null, searches for the last period as a separator, and ensures it's not in a folder name before removing the extension.",Takes a single parameter `String path` and returns a `String`.,"- Typical usage: Input: ""file.txt"" -> Output: ""file""
   - Boundary edge case: Input: ""file"" -> Output: ""file""
   - Special or unusual case: Input: ""/folder/file.txt"" -> Output: ""/folder/file""","- Preconditions: Input `path` can be any string, including valid file paths or folder paths.
   - Postconditions: Returns the input string with the extension removed if present; folders remain unchanged.
---
```"
636766fe1a6d9265ec017838,toPrimitive,"public static char[] toPrimitive(final Character[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_CHAR_ARRAY;
  }
  final char[] result=new char[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].charValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Characters to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Character</code> array, may be <code>null</code>
 * @return a <code>char</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Return a string which is consist of the values of elements in the given array.If array is equal to null,return null,or return ArrayUtils.EMPTY_CHAR_ARRAY if the size of array is equal to zero.",Converts an array of Character objects to a primitive char array.,"The function checks if the input array is null or empty, returning null or an empty char array accordingly. It iterates through the elements of the input Character array, converting and storing each in a new primitive char array, which it then returns.",Accepts a Character array (Character[]) and returns a char array (char[]).,"- Typical usage: 
     - Input: [`Character[] { 'a', 'b', 'c' }`]
     - Output: [`char[] { 'a', 'b', 'c' }`]
   - Boundary edge case:
     - Input: [`Character[] {}`]
     - Output: [`char[] {}`]
   - Special or unusual case:
     - Input: [`Character[] { null, 'x' }`]
     - Output: Invocation causes a `NullPointerException`.","- Preconditions: The input can be null or an empty array; elements can be null.
   - Postconditions: Returns null for a null array and an empty array for an input with length zero; elements must be non-null to avoid exceptions. 
---"
636766fa1a6d9265ec01779c,parseToken,"private String parseToken(final char[] terminators){
  char ch;
  i1=pos;
  i2=pos;
  while (hasChar()) {
    ch=chars[pos];
    if (isOneOf(ch,terminators)) {
      break;
    }
    i2++;
    pos++;
  }
  return getToken(false);
}
","/** 
 * Parses out a token until any of the given terminators is encountered.
 * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token
 * @return the token
 */
",Parses out a token until any of the given terminators is encountered and then return the token.,Extracts a substring from a sequence until a terminator is found.,"The function parses through a character array starting from the current position (`pos`), checking each character against an array of terminator characters. It continues advancing until a terminator is found or the end of the character array is reached, then it returns the substring from the starting position to the last position checked using the `getToken` function.",`parseToken` accepts an array of characters as terminators and returns a string.,"- Typical usage: 
     - Input: `parseToken(new char[]{',', ';', ' '})` with `chars` containing ""hello,world"", starting at `pos=0`.
     - Output: `""hello""`
   - Boundary edge case:
     - Input: `parseToken(new char[]{'#'})` with `chars` containing """" (empty array).
     - Output: `""""`
   - Special or unusual case:
     - Input: `parseToken(new char[]{','})` with `chars` containing ""test"", which contains no terminator.
     - Output: `""test""`","- Preconditions: `chars` must be initialized and `terminators` should be a non-null array of characters.
   - Postconditions: The function returns a string representing the characters from the starting position to just before the first encountered terminator or the end of the array.
---
```"
636767691a6d9265ec0181a7,trimLeadingCharacter,"public static String trimLeadingCharacter(String str,char leadingCharacter){
  if (!hasLength(str)) {
    return str;
  }
  StringBuilder sb=new StringBuilder(str);
  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {
    sb.deleteCharAt(0);
  }
  return sb.toString();
}
","/** 
 * Trim all occurrences of the supplied leading character from the given String.
 * @param str the String to check
 * @param leadingCharacter the leading character to be trimmed
 * @return the trimmed String
 */
","Trim all the characters which are equal to the given character and appear at the beginning of the given string,and return the trimmed string.",Removes leading occurrences of a specified character from a string.,"The function iterates over the string using a StringBuilder to remove all instances of the specified leading character until a different character is encountered or the string is empty, then returns the modified string.","The function takes a `String` `str` and a `char` `leadingCharacter`, and returns a `String`.","- Typical usage: 
     - Input: `(""aaaHello"",'a')`
     - Output: `""Hello""`
   - Boundary edge case: 
     - Input: `("""",'a')`
     - Output: `""""`
   - Special or unusual case:
     - Input: `(""bbbb"",'b')`
     - Output: `""""`","- Preconditions: `str` may be null or any string value; `leadingCharacter` is a valid character.
   - Postconditions: Returns a new string with leading `leadingCharacter` instances removed.
---
```"
636767041a6d9265ec01790f,toObject,"public static Integer[] toObject(final int[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;
  }
  final Integer[] result=new Integer[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=new Integer(array[i]);
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive ints to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  an <code>int</code> array
 * @return an <code>Integer</code> array, <code>null</code> if null array input
 */
",Return an array of Integer objects which are converted from an array of primitive ints.,Converts a primitive int array to an Integer array.,"The function checks if the input array is null, returning null if so. If the array is empty, it returns a predefined empty Integer array. For non-empty arrays, it iterates over each element, converting each int to an Integer using the Integer constructor, and returns the resulting Integer array.",Takes an array of primitive ints (`int[]`) as input and returns an array of Integer objects (`Integer[]`).,"- Typical usage: `toObject(new int[]{1, 2, 3})` returns `[1, 2, 3]`
   - Boundary edge case: `toObject(new int[]{})` returns `ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY`
   - Special or unusual case: `toObject(null)` returns `null`","- Preconditions: Input can be null or an array of integers.
   - Postconditions: Returns null for a null input, a predefined empty Integer array for an empty input, or a new Integer array with the same length as the input for non-empty arrays.
---
```"
636766fa1a6d9265ec0177a4,toObject,"public static Double[] toObject(final double[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;
  }
  final Double[] result=new Double[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=new Double(array[i]);
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive doubles to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>double</code> array
 * @return a <code>Double</code> array, <code>null</code> if null array input
 */
",Return an array of Double objects which are converted from an array of primitive doubles.,Converts a primitive double array to an array of Double objects.,"The function checks if the input array is null and returns null; if it is empty, it returns a predefined empty Double array. Otherwise, it creates a new Double array with the same length and populates it by iterating over the input array, converting each primitive double to a Double object, and then returns this newly created array.","The function takes a single parameter, a primitive double array (double[] array), and returns an array of Double objects (Double[]).","- Typical usage: 
     - Input: `double[] array = {1.2, 3.4, 5.6}`
     - Output: `[1.2, 3.4, 5.6]`
   - Boundary edge case: 
     - Input: `double[] array = {}`
     - Output: `ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY`
   - Special or unusual case:
     - Input: `double[] array = null`
     - Output: `null`","- Preconditions: The input is a primitive double array, which can be null or empty.
   - Postconditions: The output is null if the input is null, a predefined empty Double array if the input is empty, or a new Double array containing the elements of the input converted to Double.
---
```"
636767461a6d9265ec017d0e,computeSuffixSum,"private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){
  List<Integer> suffixSum=new ArrayList<>(Collections.nCopies(bounds.size(),0));
  long sum=0;
  for (int i=bounds.size() - 1; i >= 0; i--) {
    suffixSum.set(i,(int)Math.min(Integer.MAX_VALUE,sum));
    sum+=bounds.get(i);
  }
  return Pair.of(suffixSum,sum);
}
","/** 
 * Computes a suffix sum of the  {@code bounds}. Returns computed suffix sum and the sum of all elements in the  {@code bounds list}.
 * @param bounds list of integers.
 * @return computed pair of suffix sum list and a sum of all elements.
 */
",Return a pair of the list of suffix sum and the sum of all elements of bounds.,"Computes suffix sums for a list, capped by Integer.MAX_VALUE, and returns the sums with the total sum.","The function iterates through the input list of integers in reverse, calculating and storing the cumulative sum from the end to the start in a new list called `suffixSum`. Each entry in `suffixSum` is the minimum of the current cumulative sum or `Integer.MAX_VALUE`. It also computes the total sum of all elements in the input list. The function returns a pair containing the `suffixSum` list and the total sum as a long.","The function takes a `List<Integer>` as a parameter and returns a `Pair<List<Integer>, Long>`.","- Typical usage: `computeSuffixSum(Arrays.asList(1,2,3))` returns `Pair.of(Arrays.asList(Integer.MAX_VALUE, 5, 3), 6L)`
   - Boundary edge case: `computeSuffixSum(Arrays.asList())` returns `Pair.of(Collections.emptyList(), 0L)`
   - Special case: `computeSuffixSum(Arrays.asList(Integer.MAX_VALUE, 1))` returns `Pair.of(Arrays.asList(Integer.MAX_VALUE, Integer.MAX_VALUE), 2147483648L)`","- Preconditions: The input is a list of integers which may be empty.
   - Postconditions: Returns a pair with the suffix sum list (cap by Integer.MAX_VALUE) and the total sum of input elements as a long.
---
```"
636767491a6d9265ec017d90,reverse,"public static final <V>void reverse(V[] arr,int from,int to){
  for (int i=from, j=to; i < j; ++i, --j) {
    swap(arr,i,j);
  }
}
","/** 
 * Reverses the order of the elements in the specified range within the given array.
 * @param < V > the type of elements in the array
 * @param arr the array
 * @param from the index of the first element (inclusive) inside the range to reverse
 * @param to the index of the last element (inclusive) inside the range to reverse
 */
",Reverse the order of the given elements in the specified range.,Reverses elements in an array between specified indices.,"The function takes an array and two indices, reversing the order of elements between those indices (inclusive). It does this by iteratively swapping elements at the start and end of the specified range until it meets in the middle.","`reverse(V[] arr, int from, int to)`: The function accepts an array `arr` of any type `V`, and two integers `from` and `to`, indicating the range of indices to reverse. The function does not return any value.","- Typical usage: For `arr = {1, 2, 3, 4, 5}` and `reverse(arr, 1, 3)`, the array becomes `{1, 4, 3, 2, 5}`.
   - Boundary edge case: For `arr = {1, 2, 3, 4, 5}` and `reverse(arr, 0, 4)`, the array becomes `{5, 4, 3, 2, 1}`.
   - Special case: For `arr = {1, 2, 3, 4, 5}` and `reverse(arr, 2, 2)`, the array remains unchanged as `{1, 2, 3, 4, 5}`.","- Preconditions: The indices `from` and `to` must be within the bounds of the array, and `from` should be less than or equal to `to`.
   - Postconditions: The elements between `from` and `to` are reversed in place in the array; the rest of the array remains unchanged.
---"
6367674a1a6d9265ec017da9,moveAllListNodes,"private void moveAllListNodes(DoublyLinkedList<E> list){
  for (ListNodeIteratorImpl it=list.new ListNodeIteratorImpl(0); it.hasNext(); ) {
    ListNodeImpl<E> node=it.nextNode();
    assert node.list == list;
    node.list=this;
  }
  size+=list.size;
  list.size=0;
  modCount++;
  list.modCount++;
}
","/** 
 * Atomically moves all  {@link ListNode ListNodes} from {@code list} to this list as if eachnode was removed with  {@link #removeListNode(ListNodeImpl)} from {@code list} andsubsequently added to this list by  {@link #addListNode(ListNodeImpl)}.
 */
",Move the nodes of the given doubly linked list to a new list sequentially.,Transfers all nodes from one doubly linked list to another.,"It iterates through each node in the provided list, updates the node's list reference to the current list, adjusts the sizes of both lists, and increments the modification counts.",The function is a private void method that takes a parameter `list` of type `DoublyLinkedList<E>`.,"- Typical usage:
     - Input: `this = [1, 2]`, `list = [3, 4]`
     - Output: `this = [1, 2, 3, 4]`, `list = []`
   - Boundary edge case:
     - Input: `this = []`, `list = []`
     - Output: `this = []`, `list = []`
   - Special case:
     - Input: `this = [1, 2]`, `list = []`
     - Output: `this = [1, 2]`, `list = []`","- Preconditions: Both `this` and `list` are initialized `DoublyLinkedList<E>` objects. 
   - Postconditions: All nodes from `list` are transferred to `this`, `list` becomes an empty list, and the sizes and modification counts are updated accordingly.
---
```"
636767151a6d9265ec017b6b,startsWith,"private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){
  if (str == null || prefix == null) {
    return str == null && prefix == null;
  }
  if (prefix.length() > str.length()) {
    return false;
  }
  return str.regionMatches(ignoreCase,0,prefix,0,prefix.length());
}
","/** 
 * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>
 * @see String#startsWith(String)
 * @param str  the String to check, may be null
 * @param prefix the prefix to find, may be null
 * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.
 * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>
 */
","Return true if the given string has the specified prefix with optional cases which can be ignored,or both string and prefix are null.Otherwise return false. ","Checks if a string starts with a specified prefix, optionally ignoring case.","The function determines if the string `str` begins with the substring `prefix`, using an optional case-insensitive comparison. It handles null inputs and checks that `prefix` is not longer than `str` before comparing the two.","`startsWith(String str, String prefix, boolean ignoreCase)`: Takes two strings and a boolean, returns a boolean.","- **Typical usage:** `startsWith(""HelloWorld"", ""Hello"", false)` returns `true`.
   - **Boundary edge case:** `startsWith("""", """", true)` returns `true`.
   - **Special or unusual case:** `startsWith(null, ""prefix"", true)` returns `false`.","Both `str` and `prefix` can be null; if both are null, returns true. If `prefix` is longer than `str`, returns false. The return value will be true or false based on the conditions met.
---
```"
636766fe1a6d9265ec01781c,toCharacterObject,"public static Character toCharacterObject(final char ch){
  if (ch < CharUtils.CHAR_ARRAY.length) {
    return CharUtils.CHAR_ARRAY[ch];
  }
  return new Character(ch);
}
","/** 
 * <p>Converts the character to a Character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same Character object each time.</p> <pre> CharUtils.toCharacterObject(' ')  = ' ' CharUtils.toCharacterObject('A')  = 'A' </pre>
 * @param ch  the character to convert
 * @return a Character of the specified character
 */
",Return the Character object converted from the given character.,Converts a primitive char to a Character object using a cache if possible.,"The function checks if the input character is within the bounds of a pre-defined character cache array and returns the cached Character object if so; otherwise, it creates and returns a new Character object.",The function takes a single char parameter `ch` and returns a Character object.,"- Typical usage: `toCharacterObject('A')` returns `Character('A')` (from cache if 'A' is in `CHAR_ARRAY`).
   - Boundary edge case: `toCharacterObject('\u0000')` returns `Character('\u0000')` (from cache if present).
   - Special case: `toCharacterObject('\uFFFF')` returns `Character('\uFFFF')` (a new instance, assuming it's outside `CHAR_ARRAY`).","- Preconditions: `CHAR_ARRAY` is a valid array of Character objects.
   - Postconditions: Returns a Character object equivalent to the primitive input `ch`.
---
```"
636766fb1a6d9265ec0177c1,isAsciiAlphaUpper,"public static boolean isAsciiAlphaUpper(final char ch){
  return ch >= 'A' && ch <= 'Z';
}
","/** 
 * <p>Checks whether the character is ASCII 7 bit alphabetic upper case.</p> <pre> CharUtils.isAsciiAlphaUpper('a')  = false CharUtils.isAsciiAlphaUpper('A')  = true CharUtils.isAsciiAlphaUpper('3')  = false CharUtils.isAsciiAlphaUpper('-')  = false CharUtils.isAsciiAlphaUpper('\n') = false CharUtils.isAsciiAlphaUpper('&copy;') = false </pre>
 * @param ch  the character to check
 * @return true if between 65 and 90 inclusive
 */
",Return true if the character is ASCII alphabetic upper case.Otherwise return false.,Checks if a character is an uppercase ASCII alphabet letter.,"The function returns `true` if the input character is an uppercase letter (from 'A' to 'Z'), otherwise it returns `false`.",The function takes a single parameter of type `char` and returns a boolean value (`boolean`).,"- Typical usage: `isAsciiAlphaUpper('B')` returns `true`.
   - Boundary edge case: `isAsciiAlphaUpper('A')` returns `true`.
   - Special case: `isAsciiAlphaUpper('@')` returns `false`.","- Preconditions: The input is a valid `char` type.
   - Postconditions: The function will return a boolean indicating whether the input character is an uppercase ASCII letter.
---
```"
636767781a6d9265ec018250,decide,"public int decide(LoggingEvent event){
  String msg=event.getRenderedMessage();
  if (msg == null || stringToMatch == null)   return Filter.NEUTRAL;
  if (msg.indexOf(stringToMatch) == -1) {
    return Filter.NEUTRAL;
  }
 else {
    if (acceptOnMatch) {
      return Filter.ACCEPT;
    }
 else {
      return Filter.DENY;
    }
  }
}
","/** 
 * Returns  {@link Filter#NEUTRAL} is there is no string match.
 */
",Return a decision based on the message generated by the event and whether the given string is matched.,Evaluates a logging event message against a pre-defined string pattern to determine a filter outcome.,"The function evaluates a logging event's message to determine if it contains a specific substring (`stringToMatch`). If the substring is present and `acceptOnMatch` is true, it returns `Filter.ACCEPT`; otherwise, it returns `Filter.DENY`. If the substring is absent or either input is null, it returns `Filter.NEUTRAL`.",The function `decide` takes a `LoggingEvent` object as a parameter and returns an integer indicating the filtering decision.,"- Typical usage: If `msg=""error occurred""` and `stringToMatch=""error""`, the result is `Filter.ACCEPT` if `acceptOnMatch` is true, otherwise `Filter.DENY`.
   - Boundary edge case: If `msg=""""` (empty string) or `stringToMatch=null`, the result is `Filter.NEUTRAL`.
   - Special case: If `msg=""success""` and `stringToMatch=""fail""`, the result is `Filter.NEUTRAL` because the substring isn't found.","- Preconditions: `LoggingEvent` and `stringToMatch` must be defined in the context where the function is used. `msg` should be a valid string.
   - Postconditions: The return value is one of the Filter constants: `Filter.ACCEPT`, `Filter.DENY`, or `Filter.NEUTRAL`.
---
```"
636766861a6d9265ec017553,isTemplateVariablePresent,"public final boolean isTemplateVariablePresent(String name){
  for (  String s : templateVariables) {
    if (s.equals(name))     return true;
  }
  return false;
}
","/** 
 * Ascertain if a template variable is a member of this template.
 * @param name name The template variable.
 * @return true if the template variable is a member of the template, otherwisefalse.
 */
","Return true if the given name is a member variable of this template,otherwise return false.",Checks if a string exists in a list of template variables.,"The function iterates through a list of strings called `templateVariables` and returns `true` if it finds a string that matches the input `name`. If no match is found after checking all elements, it returns `false`.",The function takes a single `String` parameter `name` and returns a `boolean`.,"- Typical usage: 
     - Input: `templateVariables = [""var1"", ""var2"", ""var3""]`, `name = ""var2""` 
     - Output: `true`
   - Boundary edge case: 
     - Input: `templateVariables = []`, `name = ""anyname""` 
     - Output: `false`
   - Special or unusual case: 
     - Input: `templateVariables = [""temp1"", ""Temp1""]`, `name = ""temp1""` 
     - Output: `true`","- Preconditions: `templateVariables` is expected to be a list of strings populated before the function is called. `name` is a non-null string.
   - Postconditions: Returns `true` if `name` is found within `templateVariables`; otherwise, returns `false`.
---
```"
6367670a1a6d9265ec0179d9,length,"public static int length(final String str){
  return str == null ? 0 : str.length();
}
","/** 
 * Gets a String's length or <code>0</code> if the String is <code>null</code>.
 * @param str a String or <code>null</code>
 * @return String length or <code>0</code> if the String is <code>null</code>.
 * @since 2.4
 */
","Return the given string's length.If the string is null,and zero will be returned.","Returns the length of a string, or 0 if the string is null.","This function checks if the given string `str` is null; if it is, the function returns 0. Otherwise, it returns the length of the string using the `length()` method.","The function takes a single parameter, `str`, which is a `String`, and returns an `int` representing the length of the string or 0 if the string is null.","- Typical usage: `length(""hello"")` returns `5`
   - Boundary edge case: `length("""")` returns `0`
   - Special or unusual case: `length(null)` returns `0`","The precondition is that the input can be any `String` object, including possibly being null. The postcondition is that the output will be an integer: either the length of the string or 0 if the input is null.
---
```"
636767ab1a6d9265ec018676,isHex,"private static boolean isHex(final char c){
  return ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F');
}
","/** 
 * Is this a hex digit?
 */
","Return true if the given character is a hex digit,otherwise return false.",Checks if a char is a valid hexadecimal digit.,"The function evaluates if a given character is a hexadecimal digit by checking if it falls within the ranges of '0'-'9', 'a'-'f', or 'A'-'F'.",The function takes a single char `c` as input and returns a boolean indicating whether it is a hex digit.,"- Typical usage: Input: 'A' Output: true
   - Boundary edge case: Input: '9' Output: true
   - Special or unusual case: Input: 'G' Output: false","- Preconditions: Input must be a single char.
   - Postconditions: Returns true for '0'-'9', 'a'-'f', 'A'-'F'; false otherwise.
---
```"
636766f11a6d9265ec017663,isSameLength,"public static boolean isSameLength(final double[] array1,final double[] array2){
  if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {
    return false;
  }
  return true;
}
","/** 
 * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array
 */
","Return true if the length of array1 is the same as the length of array2 or both them are null,otherwise return false.",Checks if two arrays have the same length.,"The function returns `true` if both arrays are non-null and have the same length, or if both are null. It returns `false` if either one is null (while the other is non-null with length > 0), or if both arrays have different lengths.",The function takes two arrays of type `double[]` as input and returns a `boolean`.,"- **Typical usage:** `isSameLength(new double[]{1.0, 2.0}, new double[]{3.0, 4.0})` returns `true`.
   - **Boundary edge case:** `isSameLength(null, null)` returns `true`.
   - **Special or unusual case:** `isSameLength(new double[]{}, new double[]{1.0})` returns `false`.","The function assumes input arrays can be `null`. It returns `true` if the lengths are equal or both arrays are `null`; otherwise, it returns `false`.
---"
636767691a6d9265ec0181a6,split,"public static String[] split(String toSplit,String delimiter){
  if (!hasLength(toSplit) || !hasLength(delimiter)) {
    return null;
  }
  int offset=toSplit.indexOf(delimiter);
  if (offset < 0) {
    return null;
  }
  String beforeDelimiter=toSplit.substring(0,offset);
  String afterDelimiter=toSplit.substring(offset + delimiter.length());
  return new String[]{beforeDelimiter,afterDelimiter};
}
","/** 
 * Split a String at the first occurrence of the delimiter. Does not include the delimiter in the result.
 * @param toSplit the string to split
 * @param delimiter to split the string up with
 * @return a two element array with index 0 being before the delimiter, andindex 1 being after the delimiter (neither element includes the delimiter); or <code>null</code> if the delimiter wasn't found in the given input String
 */
","Split the given string toSplit at the first occurrence of the given delimiter,and return two substrings that don't include the delimiter.",Splits a string into two parts using the first occurrence of a given delimiter.,"The function checks if both the input string and delimiter are non-empty. It then finds the first occurrence of the delimiter in the input string, splitting the string into two parts: the portion before and the portion after the delimiter. If the delimiter is found, the function returns these two parts as an array; otherwise, it returns null.","`public static String[] split(String toSplit, String delimiter)`; takes two strings and returns a string array or null.","- Typical usage: `split(""apple-orange"", ""-"")` returns `[""apple"", ""orange""]`.
   - Boundary edge case: `split("""", ""-"")` returns `null`.
   - Special case: `split(""appleorange"", ""-"")` returns `null`.","Both `toSplit` and `delimiter` must be non-null strings; returns null if the delimiter is not found in the input string or if any input string is empty.
---
```"
636767601a6d9265ec0180e2,computeGlobalSeparatorList,"private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){
  List<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<>();
  for (  E edge : graph.edgeSet()) {
    V source=graph.getEdgeSource(edge);
    V target=graph.getEdgeTarget(edge);
    if (source != target) {
      List<Set<V>> edgeSeparators=findSeparators(graph,edge);
      globalSeparatorList.addAll(reformatSeparatorList(edgeSeparators,edge));
    }
  }
  return globalSeparatorList;
}
","/** 
 * Computes the global separator list of the  {@code graph}. More precisely, for every edge $e$ in the $G = (V, E)$ computes list of minimal separators $S_e$ in the neighborhood of $e$ and then concatenates these lists. Note: the result may contain duplicates
 * @return the list of minimal separators of every edge $e$ in the inspected graph
 */
","Select an edge which isn't a circle in the graph,compute the list of the minimal separators in the neighborhood of the edge and put the pair of list and edge into the return list.Repeat for each edge in the graph and then return the final list.",Compute global separator list for non-trivial edges in a graph.,"The function iterates over all edges in a graph, checking if the source and target vertices of each edge are different. For each such edge, it finds separators, reformats them, and adds them to a global separator list that is returned.","The function takes no parameters and returns a `List<Pair<List<Pair<Integer,Integer>>,E>>`.","- **Typical usage:**
     - Input: A graph with edges having distinct source and target vertices.
     - Output: A list of separators formatted from non-trivial edges.
   - **Boundary edge case:**
     - Input: A graph with no edges.
     - Output: An empty list.
   - **Special or unusual case:**
     - Input: A graph where all edges connect a vertex to itself.
     - Output: An empty list.","The graph should be initialized with vertices and edges before calling the function. The function ensures no duplicates in pairs and returns a list of separator sets paired with their associated edge.
---
```"
636766f31a6d9265ec01768f,clone,"public static char[] clone(final char[] array){
  if (array == null) {
    return null;
  }
  return array.clone();
}
","/** 
 * <p>Clones an array returning a typecast result and handling <code>null</code>.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */
",Return a clone of the given array.,Clones an input character array.,"The function returns a shallow copy of the input character array if it is not null; otherwise, it returns null.","The function takes a single parameter, a character array `char[] array`, and returns a character array.","- Typical usage: Input: `{'a', 'b', 'c'}`; Output: `{'a', 'b', 'c'}`
   - Boundary edge case: Input: `{}`; Output: `{}`
   - Special case: Input: `null`; Output: `null`","- Preconditions: The input array can be null or of any length.
   - Postconditions: The returned array is a new object, independent of the input array.
---
```"
636766831a6d9265ec0174eb,addReverse,"private void addReverse(final File[] files){
  if (files == null)   return;
  for (int i=files.length - 1; i >= 0; --i) {
    stack.add(files[i]);
  }
}
","/** 
 * Add the specified files in reverse order.
 */
",Put the given array of files into a stack in reverse order. ,Adds an array of files to a stack in reverse order.,"The function iterates over a non-null array of File objects from end to start and adds each File object to a stack, ensuring they are added in reverse order.","The function accepts a single parameter `files`, an array of File objects, and does not return a value.","- Typical usage: 
     Input: files = [File1, File2, File3]
     Action: stack contains [File3, File2, File1] after execution.
   - Boundary edge case: 
     Input: files = []
     Action: stack remains unchanged.
   - Special or unusual case: 
     Input: files = null
     Action: stack remains unchanged.","- Preconditions: `files` is either null or an array of File objects.
   - Postconditions: If `files` is not null, the stack will have the elements of `files` added in reverse order.
---
```"
636766fd1a6d9265ec017814,arrayequals,"public static boolean arrayequals(byte[] a,byte[] b,int count){
  for (int i=0; i < count; i++) {
    if (a[i] != b[i]) {
      return false;
    }
  }
  return true;
}
","/** 
 * Compares <code>count</code> first bytes in the arrays <code>a</code> and <code>b</code>.
 * @param a     The first array to compare.
 * @param b     The second array to compare.
 * @param count How many bytes should be compared.
 * @return <code>true</code> if <code>count</code> first bytes in arrays<code>a</code> and <code>b</code> are equal.
 */
","Given two arrays with the given length count,return true if the array a is equal to array b,otherwise return false.",Compares the first `count` elements of two byte arrays for equality.,"The function iterates over the first `count` elements of two byte arrays `a` and `b`, returning `false` if any pair of corresponding elements differ. If all pairs are equal, it returns `true`.","`arrayequals(byte[] a, byte[] b, int count)` takes two byte arrays `a` and `b`, and an integer `count`, returning a boolean indicating if the arrays are equal for the first `count` elements.","- Typical usage: `arrayequals(new byte[]{1, 2, 3}, new byte[]{1, 2, 3}, 3)` returns `true`.
   - Boundary edge case: `arrayequals(new byte[]{}, new byte[]{}, 0)` returns `true`.
   - Special or unusual case: `arrayequals(new byte[]{1, 2, 3}, new byte[]{1, 2, 4}, 2)` returns `true`.","- Preconditions: Both arrays `a` and `b` must have at least `count` elements.
   - Postconditions: Returns `true` if the first `count` elements of both arrays are equal, otherwise returns `false`.
---
```"
636767861a6d9265ec018440,abbreviate,"public void abbreviate(final int nameStart,final StringBuffer buf){
  int i=count;
  for (int pos=buf.indexOf(""."",nameStart); pos != -1; pos=buf.indexOf(""."",pos + 1)) {
    if (--i == 0) {
      buf.delete(nameStart,pos + 1);
      break;
    }
  }
}
","/** 
 * Abbreviate name.
 * @param buf buffer to append abbreviation.
 * @param nameStart start of name to abbreviate.
 */
","The given name can be split into several substrings by ""."",and abbreviate the name in the buf by deleting the first count substrings. ",Deletes part of a string buffer after a certain number of periods.,"The function searches for periods starting from a specified index in the string buffer and, after a specified number of periods is encountered, deletes characters from the start index up to and including the character just after the target period.",Takes an integer `nameStart` and a `StringBuffer` `buf` as parameters; returns void.,"- Typical usage: Given `nameStart=0`, `buf=""com.example.test.Class""`, with `count=2`, the buffer becomes `""Class""`.
   - Boundary edge case: Given `nameStart=0`, `buf=""com.class""`, with `count=2`, the buffer remains `""com.class""` because there aren't enough periods.
   - Special or unusual case: Given `nameStart=4`, `buf=""com.example.foo.bar""`, with `count=1`, the buffer becomes `""com.example.bar""`.","The input buffer must be non-null; the count variable must be initialized to reflect how many periods should pass before truncation occurs. The function modifies the buffer in place.
---
```"
6367667d1a6d9265ec01741d,resolveBound,"public static Type resolveBound(TypeVariable<?> typeVariable){
  Type[] bounds=typeVariable.getBounds();
  if (bounds.length == 0)   return Unknown.class;
  Type bound=bounds[0];
  if (bound instanceof TypeVariable)   bound=resolveBound((TypeVariable<?>)bound);
  return bound == Object.class ? Unknown.class : bound;
}
","/** 
 * Resolves the first bound for the  {@code typeVariable}, returning  {@code Unknown.class} if nonecan be resolved.
 */
","Resolve the class of the first bound for the typeVariable recursively,return Unknown.class if it can't be resolved.Otherwise return the bound.",Resolves the first bound of a type variable or returns Unknown if none or Object.,"The function retrieves the bounds of a given type variable and checks the first bound. If the bound is another type variable, the function recursively resolves it. If the resolved bound is `Object` or no bounds are present, it returns `Unknown.class`. Otherwise, it returns the resolved bound.",The function takes a `TypeVariable<?>` as input and returns a `Type`.,"- Typical usage: 
     - Input: TypeVariable with bounds `[Number.class]`
     - Output: `Number.class`
   - Boundary edge case:
     - Input: TypeVariable with no bounds
     - Output: `Unknown.class`
   - Special or unusual case:
     - Input: TypeVariable with bounds `[Object.class, Number.class]`
     - Output: `Unknown.class`","- Preconditions: The input must be a `TypeVariable<?>`.
   - Postconditions: Returns either the first bound of the type variable, the resolved bound, or `Unknown.class` if no usable bounds are found.
---
```"
6367675f1a6d9265ec0180cf,isClique,"private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){
  for (  V v1 : vertices) {
    for (    V v2 : vertices) {
      if (!v1.equals(v2) && (graph.getEdge(v1,v2) == null)) {
        return false;
      }
    }
  }
  return true;
}
","/** 
 * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.
 * @param graph the graph.
 * @param vertices the vertices to induce the subgraph from.
 * @return true if the induced subgraph is a clique.
 */
","Return true if the subgraph of the given graph induced by the given vertices is a clique,otherwise return false.",Checks if a set of vertices forms a clique in a graph.,"The function iterates over pairs of vertices in a given set, checking if each pair of distinct vertices is connected by an edge in the graph; if all pairs are connected, it returns true, otherwise false.","Takes a graph instance `Graph<V,E>` and a set of vertices `Set<V>` as parameters; returns a boolean indicating if the vertices form a clique.","- Typical usage: isClique(graph, {v1, v2, v3}) returns true if all vertex pairs are connected, otherwise false.
   - Boundary edge case: isClique(graph, {}) returns true as an empty set trivially forms a clique.
   - Special case: isClique(graph, {v1}) returns true as a single vertex forms a clique by definition.","Assumes the graph is undirected and the `getEdge` function correctly returns the edge between two vertices or null if no edge exists; returns true if all provided vertices form a complete subgraph, otherwise false.
---
```"
636767431a6d9265ec017c88,computeLowerBounds,"private List<Integer> computeLowerBounds(List<K> keys){
  List<Integer> keyLowerBounds=new ArrayList<>(keys.size());
  for (  K key : keys) {
    int lowerBound=0;
    for (    Function<K,Integer> lowerBoundFunction : lowerBounds) {
      lowerBound=Math.max(lowerBound,lowerBoundFunction.apply(key));
    }
    keyLowerBounds.add(lowerBound);
  }
  return keyLowerBounds;
}
","/** 
 * Finds a maximum lower bound for every key.
 * @param keys list of keys.
 * @return the computed key lower bounds.
 */
","The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.",Computes largest lower bounds for keys using provided functions.,The function iterates over each key in the input list and applies a series of lower bound functions to each key to compute the largest lower bound. The results are stored in a list.,The function takes a `List<K>` of keys and returns a `List<Integer>` containing the largest lower bounds for those keys.,"- Typical usage: Given functions [f1, f2], and keys [key1, key2], if f1(key1)=2, f2(key1)=3, f1(key2)=5, f2(key2)=4, outputs [3, 5].
   - Boundary edge case: No keys, with any functions, outputs [].
   - Special case: Single key, single function, outputs [result of function on key].","- Preconditions: `lowerBounds` is defined as a list of functions returning integers for a key of type `K`; it's assumed to be accessible within the method.
   - Postconditions: Returns list of maximum lower bounds for each input key calculated using available functions.
---
```"
636766a91a6d9265ec0175c4,pop,"private void pop(final String descriptor){
  char firstDescriptorChar=descriptor.charAt(0);
  if (firstDescriptorChar == '(') {
    pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);
  }
 else   if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {
    pop(2);
  }
 else {
    pop(1);
  }
}
","/** 
 * Pops as many abstract types from the output frame stack as described by the given descriptor.
 * @param descriptor a type or method descriptor (in which case its argument types are popped).
 */
",Pop different value of type based on the first character of the given descriptor.,Decides the number of elements to pop from a stack based on a descriptor's first character.,"The `pop` function evaluates the input `descriptor`, a string, by examining its first character to determine the number of times the `pop` method should be called. If the first character is '(', it extracts the arguments and return sizes from the descriptor and calculates the number of elements to pop based on a bitwise shift. If the first character is 'J' or 'D', it calls `pop(2)`. For all other starting characters, it calls `pop(1)`.","The function takes one parameter, `descriptor` (a `String`), and returns `void`.","- Typical usage: Given `descriptor = ""(ID)Ljava/lang/String;""`, if `Type.getArgumentsAndReturnSizes(descriptor)` returns a size of 8, the function calls `pop(1)` after evaluating `(8 >> 2) - 1`.
   - Boundary edge case: Given `descriptor = ""I""`, the function calls `pop(1)`.
   - Special case: Given `descriptor = ""J""`, the function calls `pop(2)`.","- Preconditions: `descriptor` is a non-null string, possibly representing a method descriptor or a type signature.
   - Postconditions: The function effectively calls `pop(n)` where `n` is decided by the logic based on the provided descriptor.
---
```"
636766fb1a6d9265ec0177c3,isAscii,"public static boolean isAscii(final char ch){
  return ch < 128;
}
","/** 
 * <p>Checks whether the character is ASCII 7 bit.</p> <pre> CharUtils.isAscii('a')  = true CharUtils.isAscii('A')  = true CharUtils.isAscii('3')  = true CharUtils.isAscii('-')  = true CharUtils.isAscii('\n') = true CharUtils.isAscii('&copy;') = false </pre>
 * @param ch  the character to check
 * @return true if less than 128
 */
","Return true if the given character is a ASCII seven bit character,otherwise return false.",Checks if a character is within the ASCII range.,"The function compares the numerical value of a character to 128 and returns true if it is less than 128, indicating the character is an ASCII character.",Takes a character parameter `ch` and returns a boolean value.,"- Typical usage: isAscii('A') → true
   - Boundary edge case: isAscii('\u007F') → true
   - Special case: isAscii('é') → false","- Preconditions: Input is a valid character.
   - Postconditions: Returns true for ASCII characters, false otherwise.
---
```"
636767581a6d9265ec017fb4,computeUpperBounds,"private List<Integer> computeUpperBounds(List<K> keys){
  List<Integer> keyUpperBounds=new ArrayList<>(keys.size());
  for (  K key : keys) {
    int upperBound=Integer.MAX_VALUE;
    for (    Function<K,Integer> upperBoundFunction : upperBounds) {
      upperBound=Math.min(upperBound,upperBoundFunction.apply(key));
    }
    keyUpperBounds.add(upperBound);
  }
  return keyUpperBounds;
}
","/** 
 * Finds a minimum lower bound for every key.
 * @param keys a list of keys.
 * @return the computed key upper bound.
 */
","The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.",Computes a list of minimal upper bounds for each key using predefined functions.,The function iterates through a list of keys and calculates an upper bound for each key by applying a list of functions that map a key to an integer. It collects the minimum value among these results for each key and returns a list of these minimum upper bounds.,"The function takes a `List<K>` where `K` is a generic type, and returns `List<Integer>`.","- Typical usage: 
     - Input: keys = [3, 5, 7] with upperBounds functions that return [10, 9, 8] for all keys.
     - Output: [8, 8, 8]
   - Boundary edge case: 
     - Input: keys = [] with any upperBounds functions.
     - Output: []
   - Special or unusual case: 
     - Input: keys = [4] with functions returning MAX_VALUE for any input.
     - Output: [Integer.MAX_VALUE]","- Preconditions: The list of keys must not be null, and the list of upper bound functions must exist.
   - Postconditions: The result is a list where each entry represents the minimum upper bound determined by upperBoundFunctions for a corresponding key. The length of the result list matches the length of the input key list.
---
```"
636766801a6d9265ec017487,encodeTemplateNames,"public static String encodeTemplateNames(String s){
  int i=s.indexOf('{');
  if (i != -1)   s=s.replace(""{"",""%7B"");
  i=s.indexOf('}');
  if (i != -1)   s=s.replace(""}"",""%7D"");
  return s;
}
","/** 
 * Encodes a string with template parameters names present, specifically the characters '{' and '}' will be percent-encoded.
 * @param s the string with zero or more template parameters names
 * @return the string with encoded template parameters names.
 */
","Encoding the given string by changing '{' and '}' to the specified character for each,return the string after encoding.",The function replaces braces in a string with their URL encoded versions.,"The function checks for the presence of '{' and '}' characters within a string, and if found, replaces them with ""%7B"" and ""%7D"" respectively. It performs the replacement using the `String.replace` method, which substitutes all occurrences of the specified character.",The function takes a single `String` parameter and returns a `String`.,"- Typical usage: `encodeTemplateNames(""Hello {world}"")` returns ""Hello %7Bworld%7D"".
   - Boundary edge case: `encodeTemplateNames("""")` returns """".
   - Special case: `encodeTemplateNames(""No braces here"")` returns ""No braces here"".","- Preconditions: The input is a valid non-null string.
   - Postconditions: The output string will have all '{' replaced with ""%7B"" and all '}' replaced with ""%7D"".
---
```"
636767691a6d9265ec0181ac,applyRelativePath,"public static String applyRelativePath(String path,String relativePath){
  int separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);
  if (separatorIndex != -1) {
    String newPath=path.substring(0,separatorIndex);
    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {
      newPath+=FOLDER_SEPARATOR;
    }
    return newPath + relativePath;
  }
 else {
    return relativePath;
  }
}
","/** 
 * Apply the given relative path to the given path, assuming standard Java folder separation (i.e. ""/"" separators).
 * @param path the path to start from (usually a full file path)
 * @param relativePath the relative path to apply(relative to the full file path above)
 * @return the full file path that results from applying the relative path
 */
","Combine the substring before FOLDER_SEPARATOR of the given path with the given relative path to construct a new full file path,and return the full file path.",Concatenates a relative path to a base path by replacing the last directory or prepending it if necessary.,"The function finds the last directory in the base path and appends the relative path after this directory, ensuring proper folder separators. If the base path lacks any directory structure, it defaults to returning the relative path itself.","(String path, String relativePath) -> String","- Typical usage: 
     - Input: (""folder1/folder2/folder3"", ""subfolder"") 
     - Output: ""folder1/folder2/subfolder""
   - Boundary edge case: 
     - Input: (""folder1"", ""subfolder"") 
     - Output: ""subfolder""
   - Special or unusual case: 
     - Input: (""folder1/folder2/"", ""/subfolder"") 
     - Output: ""folder1/folder2/subfolder""","- Preconditions: `path` and `relativePath` must be non-null strings; `path` uses a consistent folder separator.
   - Postconditions: The function ensures the final path starts with all existing directories up to the last segment of `path`, followed by `relativePath`, properly handling separators.
---
```"
636767021a6d9265ec0178bc,indexOf,"public static int indexOf(String str,String searchStr){
  if (str == null || searchStr == null) {
    return StringUtils.INDEX_NOT_FOUND;
  }
  return str.indexOf(searchStr);
}
","/** 
 * Finds the first index within a String, handling <code>null</code>. This method uses  {@link String#indexOf(String)}. 
 */
",Return the first index of the searchStr in the given string.,Finds the index of a substring within a string.,"If either input string is null, returns a constant for not found; otherwise, returns the index of the first occurrence of the second string within the first string.","The function takes two strings (`str`, `searchStr`) as parameters and returns an integer.","- Typical usage: indexOf(""hello world"", ""world"") returns 6.
   - Boundary edge case: indexOf("""", ""world"") returns -1.
   - Special or unusual case: indexOf(null, ""a"") returns -1.","Inputs can be null and will result in an output of a constant for string not found. If `searchStr` is not found in `str`, return -1.
---
```"
636766fc1a6d9265ec0177ef,toNoNullStringArray,"static String[] toNoNullStringArray(Object[] array){
  ArrayList<String> list=new ArrayList<String>(array.length);
  for (int i=0; i < array.length; i++) {
    Object e=array[i];
    if (e != null) {
      list.add(e.toString());
    }
  }
  return (String[])list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);
}
","/** 
 * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}if an array element is <code>null</code>.
 * @param array The array to check
 * @return The given array or a new array without null.
 */
","Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.","Converts an Object array to a String array, excluding nulls.","The function iterates over a given Object array and collects non-null elements by invoking their `toString()` method, storing the results in an ArrayList. The list is then converted to a String array and returned.",Accepts an Object array as a parameter and returns a String array.,"- Typical usage: `toNoNullStringArray(new Object[]{1, ""text"", null})` returns `[""1"", ""text""]`
   - Boundary edge case: `toNoNullStringArray(new Object[]{null, null})` returns `[]`
   - Special or unusual case: `toNoNullStringArray(new Object[]{null, 123.456, true})` returns `[""123.456"", ""true""]`","- Preconditions: The input must be an array of Objects.
   - Postconditions: The function returns a String array with no null elements; the input order is preserved for non-null elements.
---
```"
636767061a6d9265ec01794a,indexOfExtension,"public static int indexOfExtension(String filename){
  if (filename == null) {
    return -1;
  }
  int extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);
  int lastSeparator=indexOfLastSeparator(filename);
  return lastSeparator > extensionPos ? -1 : extensionPos;
}
","/** 
 * Returns the index of the last extension separator character, which is a dot. <p> This method also checks that there is no directory separator after the last dot. To do this it uses  {@link #indexOfLastSeparator(String)} which willhandle a file in either Unix or Windows format. <p> The output will be the same irrespective of the machine that the code is running on.
 * @param filename  the filename to find the last path separator in, null returns -1
 * @return the index of the last separator character, or -1 if thereis no such character
 */
","Return the last index of the extension separator in the given filename,it will return -1 if the filename doesn't have the separator or there is a directory separator after it.",Finds the position of the last file extension separator in a filename.,"This function checks if the input string is null and returns -1 if true. It retrieves the index of the last occurrence of the file extension separator (a constant, EXTENSION_SEPARATOR) in the filename, and the index of the last path separator using indexOfLastSeparator. It returns the extension index unless the path separator is after the extension, indicating the extension is not valid for a filename in a given path context.",Takes a single String parameter representing the filename and returns an integer indicating the index of the last extension separator or -1 if absent or invalid.,"- Typical usage: `indexOfExtension(""document.txt"")` returns `8`.
   - Boundary edge case: `indexOfExtension(""document"")` returns `-1`.
   - Special or unusual case: `indexOfExtension(null)` returns `-1`.","- Preconditions: The EXTENSION_SEPARATOR and indexOfLastSeparator() are correctly defined; input is a non-null string.
   - Postconditions: Returns the correct index of the extension separator unless the filename is null, has no extension, or the extension is invalid.
---
```"
636767dd1a6d9265ec0186de,isExpired,"public boolean isExpired(long timestamp,long expiredThreshold){
  return timestamp - lastUpdateTimestamp > expiredThreshold;
}
","/** 
 * @param timestamp        of current time
 * @param expiredThreshold represents the duration between last update time and the time point removing from cache.
 * @return true means this metrics should be removed from cache.
 */
","Return true if the timestamp minus the lastUpdateTimestamp is greater than expiredThreshold,otherwise return false.",Determines if a given timestamp has expired based on a threshold.,"The function compares the difference between the provided `timestamp` and a global variable `lastUpdateTimestamp` against the `expiredThreshold`. If the difference is greater than the threshold, the function returns `true`, indicating that the timestamp is expired. Otherwise, it returns `false`.","The function takes two long parameters: `timestamp` and `expiredThreshold`, and returns a boolean value.","- Typical usage: 
     Input: `timestamp = 2000, lastUpdateTimestamp = 1000, expiredThreshold = 500` 
     Output: `true`
   - Boundary edge case: 
     Input: `timestamp = 1500, lastUpdateTimestamp = 1000, expiredThreshold = 500` 
     Output: `false`
   - Special or unusual case:
     Input: `timestamp = 1000, lastUpdateTimestamp = 1000, expiredThreshold = 0` 
     Output: `false`","- Preconditions: `lastUpdateTimestamp` is initialized and accessible; `timestamp` and `expiredThreshold` are non-negative. 
   - Postconditions: Returns `true` if the timestamp is considered expired relative to `lastUpdateTimestamp` and the `expiredThreshold`, otherwise `false`.
---
```"
6367675d1a6d9265ec018082,edgeToNext,"Edge edgeToNext(){
  Edge edge=prev.embedded.getFirst();
  Node target=toExistingNode(current);
  Node source=toExistingNode(prev);
  if (edge.getOpposite(source) == target) {
    return edge;
  }
 else {
    return prev.embedded.getLast();
  }
}
","/** 
 * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.
 * @return an edge from the current node to the next node
 */
",Return the edge connecting the previously returned node with the current node.,Returns an edge from `prev` node to `current` node using embedded edges.,"The function retrieves the first edge from a collection associated with `prev`, determines the `source` and `target` nodes using `current` and `prev`, and checks if the opposite end of the edge is the `target`. If true, it returns the first edge; otherwise, it returns the last edge from `prev`'s collection.",The function takes no parameters and returns an `Edge` object.,"- Typical usage: If `prev.embedded` has edges towards `current`, the edge connecting `prev` to `current` is returned.
   - Boundary edge case: If `prev.embedded` has only a single edge and it does not connect to `current`, this single edge is returned.
   - Special case: If `prev.embedded` is empty, the behavior depends on the implementation details not shown in the function (might return `null` or throw an error).","- Preconditions: `prev` and `current` must be defined, `prev` must have an `embedded` property that supports `getFirst()` and `getLast()` methods, and nodes must be retrievable using `toExistingNode()`.
   - Postconditions: An edge in the collection that potentially connects `prev` to `current` is returned.
---
```"
6367676b1a6d9265ec0181e9,substringMatch,"public static boolean substringMatch(CharSequence str,int index,CharSequence substring){
  for (int j=0; j < substring.length(); j++) {
    int i=index + j;
    if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {
      return false;
    }
  }
  return true;
}
","/** 
 * Returns  {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.
 * @param str the original string (or StringBuilder)
 * @param index the index in the original string to start matching against
 * @param substring the substring to match at the given index
 * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.
 */
","Return true if starting at the given index,the given string matches the given substring.Otherwise return false.",The function checks if a substring matches a section of a string starting at a given index.,"The function iterates through each character of the substring, comparing it to the corresponding character in the main string starting from the given index. If any character does not match or if the index goes out of bounds, it returns false; otherwise, it returns true.","`substringMatch(CharSequence str, int index, CharSequence substring)` returns a boolean.","- Typical usage: `substringMatch(""HelloWorld"", 5, ""World"")` returns `true`.
   - Boundary edge case: `substringMatch(""Hello"", 0, """")` returns `true`.
   - Special or unusual case: `substringMatch(""Test"", 4, ""Test"")` returns `false`.","Preconditions include `str` and `substring` being non-null character sequences, and `index` being a valid starting index within `str`. The postcondition is a boolean indicating if the substring exactly matches a section of `str` starting at `index`.
---
```"
6367670b1a6d9265ec017a05,toString,"public static String toString(final char ch){
  if (ch < 128) {
    return CharUtils.CHAR_STRING_ARRAY[ch];
  }
  return new String(new char[]{ch});
}
","/** 
 * <p>Converts the character to a String that contains the one character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same String object each time.</p> <pre> CharUtils.toString(' ')  = "" "" CharUtils.toString('A')  = ""A"" </pre>
 * @param ch  the character to convert
 * @return a String containing the one specified character
 */
",Return the String object that contains the given character.,Converts a character to a string representation.,"The function checks if the input character `ch` has an ASCII value less than 128. If it does, it returns a pre-allocated string representation from `CharUtils.CHAR_STRING_ARRAY`. If the ASCII value is 128 or greater, it creates and returns a new string containing that character.",The function takes a single `char` parameter and returns a `String`.,"- Typical usage: `toString('A')` returns ""A"".
   - Boundary edge case: `toString('\u007F')` returns ""\u007F"".
   - Special or unusual case: `toString('€')` (ASCII value 128 or above) returns ""€"".","- Preconditions: Input must be a valid `char`.
   - Postconditions: Returns a non-null `String` representation of the character, using cached values for ASCII < 128, and creating new strings otherwise.
---
```"
636767a31a6d9265ec01854f,checkIfPackedField,"private void checkIfPackedField() throws IOException {
  if (packedLimit == 0 && WireFormat.getTagWireType(lastTag) == WIRETYPE_LENGTH_DELIMITED) {
    final int length=readRawVarint32();
    if (length < 0)     throw ProtobufException.negativeSize();
    this.packedLimit=getTotalBytesRead() + length;
  }
}
","/** 
 * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that packed fields are being read.
 * @throws IOException
 */
","Check if the field should be packed,if so,read the field and update the internal state. It will throw an exception when the process of reading is wrong.",Adjusts packedLimit based on lastTag's wire type.,"The function checks if packedLimit is zero and the wire type of the lastTag is WIRETYPE_LENGTH_DELIMITED. If so, it reads a varint32 value as length, throws an exception if length is negative, and sets packedLimit to the sum of the current total bytes read and the length.",The function has no parameters and returns no value; it throws an IOException.,"- Typical usage: When `packedLimit` is 0 and `lastTag` has a WIRETYPE_LENGTH_DELIMITED, it sets `packedLimit` to a new calculated value.
   - Boundary edge case: If `length` read is negative, an exception is thrown.
   - Special case: If `lastTag` is not WIRETYPE_LENGTH_DELIMITED or `packedLimit` is not 0, the function does nothing.","- Preconditions: `packedLimit` is 0, and `lastTag` wire type is WIRETYPE_LENGTH_DELIMITED.
   - Postconditions: `packedLimit` is updated to current total bytes read plus length if conditions are met; otherwise, it remains unchanged. Exception thrown if length is negative.
---
```"
636767a81a6d9265ec0185fc,readTag,"public int readTag() throws IOException {
  if (!buffer.hasRemaining()) {
    lastTag=0;
    return 0;
  }
  final int tag=readRawVarint32();
  if (tag >>> TAG_TYPE_BITS == 0) {
    throw ProtobufException.invalidTag();
  }
  lastTag=tag;
  return tag;
}
","/** 
 * Attempt to read a field tag, returning zero if we have reached EOF. Protocol message parsers use this to read tags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.
 */
","Return a field tag, and if reach the EOF the tag will be zero.It will throw an exception when the tag is equal to zero after logical shift right  TAG_TYPE_BITS.",Reads a protobuf tag from a buffer and validates it.,"The function checks if there is remaining data in a buffer; if not, it sets `lastTag` to 0 and returns 0. If data is available, it reads a varint from the buffer, and verifies the tag by shifting right by a certain number of bits. If the tag is invalid, it throws an exception; otherwise, it updates `lastTag` with the read tag and returns it.",`public int readTag() throws IOException`,"- A **typical usage**: If `buffer` contains a valid varint tag, it reads and returns the tag (e.g., buffer: 10 -> returns 10).
   - A **boundary edge case**: If `buffer` is empty, returns 0 (e.g., buffer: [] -> returns 0).
   - A **special or unusual case**: If read varint shifts to zero, throws `ProtobufException` (e.g., buffer: [7] where tag shifts to 0 -> throws exception).","- Preconditions: The buffer should be initialized and potentially have remaining data.
   - Postconditions: Returns a positive integer tag, sets `lastTag`, or throws an exception if the tag is invalid.
---
```"
636766a81a6d9265ec017595,put11,"final ByteVector put11(final int byteValue1,final int byteValue2){
  int currentLength=length;
  if (currentLength + 2 > data.length) {
    enlarge(2);
  }
  byte[] currentData=data;
  currentData[currentLength++]=(byte)byteValue1;
  currentData[currentLength++]=(byte)byteValue2;
  length=currentLength;
  return this;
}
","/** 
 * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.
 * @param byteValue1 a byte.
 * @param byteValue2 another byte.
 * @return this byte vector.
 */
",Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.,Appends two byte values to a ByteVector's data array with automatic resizing.,"The function `put11` adds two byte values at the current end of the `data` array within a `ByteVector` object. If the current `length` of the data plus two exceeds the data array's capacity, it enlarges the capacity first. The method then casts the input integers to bytes, appends them to the array, updates the length, and returns the ByteVector object itself.","Takes two integers `byteValue1`, `byteValue2` as arguments and returns a `ByteVector` object.","- Typical usage: Given a ByteVector with data length 5, `put11(65, 66)` appends bytes 65 ('A') and 66 ('B') to the data.
   - Boundary edge case: With an array length of 10 and current length 9, `put11(70, 71)` causes an enlargement to fit two more bytes.
   - Special case: If `byteValue1` or `byteValue2` exceeds byte range, it's cast, e.g., `put11(130, 131)` appends -126 and -125 (due to casting).","- Preconditions: The `ByteVector` must be initialized; the `data` array and `length` are defined.
   - Postconditions: The `data` array contains `byteValue1` and `byteValue2` appended, and `length` is incremented by 2. If resized, `data` is larger.
---
```"
636766ae1a6d9265ec0175d8,buildContentRange,"private String buildContentRange(){
  Integer limit=drc.getLimit() == null ? getDefaultNumberPagination() - 1 : drc.getLimit();
  Integer offset=drc.getOffset() == null ? 0 : drc.getOffset();
  Long count=drc.getCount() == null ? 0 : drc.getCount();
  return offset + ""-"" + (limit.equals(0) ? count - 1 : limit)+ ""/""+ count;
}
","/** 
 * Build the 'Content-Range' HTTP Header value.
 * @return 'Content-Range' value
 */
","Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.",Constructs a Content-Range string based on pagination and total count.,"The function calculates the range of items being displayed based on an offset, limit, and total count, defaulting values if necessary, and returns a string in the format ""start-end/total"".",No parameters; returns a `String`.,"- Typical usage: `drc.getLimit() = 10, drc.getOffset() = 5, drc.getCount() = 100` returns ""5-10/100"".
   - Boundary edge case: `drc.getLimit() = 0, drc.getOffset() = 0, drc.getCount() = 0` returns ""0-(-1)/0"".
   - Special case: `drc.getLimit() = null, drc.getOffset() = null, drc.getCount() = 0` returns ""0-<default-1>/0"" where `<default>` is from `getDefaultNumberPagination()`.","- Preconditions: `drc` object provides methods `getLimit()`, `getOffset()`, and `getCount()`, which may return `null`.
   - Postconditions: Returns a Content-Range string formatted as ""offset-limit/total"" based on calculated values.
---"
