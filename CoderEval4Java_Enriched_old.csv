_id,name,code,docstring,human_label,enriched_description
6367676d1a6d9265ec018229,trimArrayElements,"public static String[] trimArrayElements(String[] array){
  if (Objects.isEmpty(array)) {
    return new String[0];
  }
  String[] result=new String[array.length];
  for (int i=0; i < array.length; i++) {
    String element=array[i];
    result[i]=(element != null ? element.trim() : null);
  }
  return result;
}
","/** 
 * Trim the elements of the given String array, calling <code>String.trim()</code> on each of them.
 * @param array the original String array
 * @return the resulting array (of the same size) with trimmed elements
 */
",Trim each element in the given string array and return the resulting array.,"```
---
**1. One-line summary:** Trims whitespace from elements of a string array.
**2. Function behavior:** The function takes an array of strings, checks if it is empty or null, and returns an empty array if so. Otherwise, it trims leading and trailing whitespace from each non-null element, producing a new array with the trimmed strings or null for the originally null elements.
**3. Function signature:** Accepts an array of strings and returns an array of strings.
**4. Examples:** 
   Input: [""  hello"", ""world  "", null]
   Output: [""hello"", ""world"", null]
   Input: [""  foo"", "" bar ""]
   Output: [""foo"", ""bar""]
   Input: null
   Output: []
**5. Preconditions & Postconditions:** 
   Preconditions: Input is a string array, which can contain nulls.
   Postconditions: Returns a new array of the same length, with each string trimmed of whitespace or null, outputting an empty array if the input is null.
---
```"
6367670b1a6d9265ec017a00,isSameLength,"public static boolean isSameLength(final byte[] array1,final byte[] array2){
  if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {
    return false;
  }
  return true;
}
","/** 
 * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array
 */
",Check whether the length of the given two byte arrays is the same.,"```
---
**1. One-line summary:** Checks if two byte arrays have the same length.
**2. Function behavior:** The function returns false if either array is null and the other is non-null with elements or if both are non-null and have different lengths; otherwise, it returns true.
**3. Function signature:** The function takes two byte arrays (array1, array2) as parameters and returns a boolean.
**4. Examples:** 
   - Input: array1 = [1, 2, 3], array2 = [4, 5, 6]; Output: true
   - Input: array1 = [1, 2], array2 = [4, 5, 6]; Output: false
   - Input: array1 = null, array2 = []; Output: true
   - Input: array1 = [1, 2], array2 = null; Output: false
**5. Preconditions & Postconditions:** Arrays can be null or non-null with zero or more elements; function returns true if both arrays are the same length or both are null/empty, and false if not.
---
```"
636766a91a6d9265ec0175c2,pop,"private int pop(){
  if (outputStackTop > 0) {
    return outputStack[--outputStackTop];
  }
 else {
    return STACK_KIND | -(--outputStackStart);
  }
}
","/** 
 * Pops an abstract type from the output frame stack and returns its value.
 * @return the abstract type that has been popped from the output frame stack.
 */
",Pop an abstract type from the output frame stack and return its value.,"```
---
**1. One-line summary:** Pops the top element from a simulated stack or returns a modified index value with error flag.
**2. Function behavior:** The function checks if the outputStack has elements by comparing outputStackTop with 0. If there are elements, it decreases the outputStackTop and returns the value from outputStack. Otherwise, it decreases outputStackStart and returns it modified with STACK_KIND.
**3. Function signature:** private int pop() returns an integer; it has no parameters.
**4. Examples:** 
   - Input: outputStackTop = 3, outputStack = {10,20,30}, outputStackStart = 0
     Output: 30
   - Input: outputStackTop = 0, outputStackStart = 5, STACK_KIND = 100
     Output: 95
**5. Preconditions & Postconditions:** 
   - Preconditions: outputStackTop and outputStackStart are non-negative integers, outputStack is initialized.
   - Postconditions: If outputStackTop > 0, return the top element; if 0, return STACK_KIND | -(outputStackStart - 1).
---
```"
636767081a6d9265ec017989,toPrimitive,"public static boolean[] toPrimitive(final Boolean[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;
  }
  final boolean[] result=new boolean[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].booleanValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Booleans to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Boolean</code> array, may be <code>null</code>
 * @return a <code>boolean</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Convert the given Boolean array to primitives. Return ArrayUtils.EMPTY_BOOLEAN_ARRAY for an empty array, return null for null array.","```
---
**1. One-line summary:** Converts an array of Boolean objects to an array of primitive boolean values.
**2. Function behavior:** The function takes an array of Boolean objects and converts it to an array of primitive boolean values, returning null if the input is null or an empty array if the input is empty using `ArrayUtils.EMPTY_BOOLEAN_ARRAY`.
**3. Function signature:** Takes a Boolean array as a parameter and returns a boolean array.
**4. Examples:** 
   Input: [Boolean.TRUE, Boolean.FALSE] -> Output: [true, false]
   Input: [Boolean.FALSE, Boolean.TRUE, Boolean.FALSE] -> Output: [false, true, false]
   Input: [] -> Output: []
**5. Preconditions & Postconditions:** The input can be null or an empty array. The function returns null for a null input, and an empty boolean array for an empty input using `ArrayUtils.EMPTY_BOOLEAN_ARRAY`. Each Boolean object in the input array is expected to be non-null for correct processing.
---
```"
6367672d1a6d9265ec017c73,shouldPrintMessage,"public boolean shouldPrintMessage(int timestamp,String message){
  if (messages.containsKey(message)) {
    if (timestamp - messages.get(message) >= 10) {
      messages.put(message,timestamp);
      return true;
    }
 else {
      return false;
    }
  }
 else {
    messages.put(message,timestamp);
    return true;
  }
}
","/** 
 * Returns true if the message should be printed in the given timestamp, otherwise returns false. If this method returns false, the message will not be printed. The timestamp is in seconds granularity. 
 */
"," If the message does not exist in the dict messages, or it exists but the timestamp (seconds) difference is bigger than 10, put the message and timestamp into messages and return true, otherwise return false.","```
---
**1. One-line summary:** Checks whether a message can be printed based on a 10-second interval condition.
**2. Function behavior:** The function maintains a record of messages and their timestamps; it returns true if the message hasn't been printed in the last 10 seconds, otherwise, returns false.
**3. Function signature:** Takes an integer 'timestamp' and a string 'message' as parameters; returns a boolean.
**4. Examples:** 
  - shouldPrintMessage(1, ""test"") -> true
  - shouldPrintMessage(2, ""test"") -> false
  - shouldPrintMessage(11, ""test"") -> true
**5. Preconditions & Postconditions:** 
   - Preconditions: 'timestamp' is a non-negative integer; 'message' is a non-null string.
   - Postconditions: Returns true if 'timestamp' for 'message' is at least 10 seconds later than the previous, or it's a new message; otherwise, returns false.
---
```"
636766f81a6d9265ec01775c,toString,"public static String toString(Object obj){
  return obj == null ? """" : obj.toString();
}
","/** 
 * <p>Gets the <code>toString</code> of an <code>Object</code> returning an empty string ("""") if <code>null</code> input.</p> <pre> ObjectUtils.toString(null)         = """" ObjectUtils.toString("""")           = """" ObjectUtils.toString(""bat"")        = ""bat"" ObjectUtils.toString(Boolean.TRUE) = ""true"" </pre>
 * @see StringUtils#defaultString(String)
 * @see String#valueOf(Object)
 * @param obj  the Object to <code>toString</code>, may be null
 * @return the passed in Object's toString, or nullStr if <code>null</code> input
 * @since 2.0
 */
","Return the string representation of the given object, return an empty string if the object is null.","```
---
**1. One-line summary:** Converts an object to its string representation.
**2. Function behavior:** The function checks if the provided object is null, returning an empty string if true; otherwise, it returns the result of the object's toString() method.
**3. Function signature:** Takes an Object as a parameter and returns a String.
**4. Examples:** 
   - Input: toString(null), Output: """"
   - Input: toString(123), Output: ""123""
   - Input: toString(new Object()), Output: ""java.lang.Object@<hashcode>""
   - Input: toString(""Hello""), Output: ""Hello""
**5. Preconditions & Postconditions:** The object parameter may be any valid Java object or null; the function is guaranteed to return a non-null String.
---
```"
6367667f1a6d9265ec017457,decodeOctets,"private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){
  if (bb.limit() == 1 && (bb.get(0) & 0xFF) < 0x80) {
    sb.append((char)bb.get(0));
    return i + 2;
  }
 else {
    CharBuffer cb=UTF_8_CHARSET.decode(bb);
    sb.append(cb);
    return i + bb.limit() * 3 - 1;
  }
}
","/** 
 * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.
 * @return the index to the next unchecked character in the string to decode
 */
","Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.","```
---
**1. One-line summary:** Decodes bytes from a ByteBuffer and appends the result to a StringBuilder.

**2. Function behavior:** The function checks if the ByteBuffer contains a single byte representing a US-ASCII character. If true, it appends this character to the StringBuilder and returns an incremented index. Otherwise, it decodes the ByteBuffer using UTF-8 and appends the resulting characters to the StringBuilder, returning an index based on the ByteBuffer's limit.

**3. Function signature:** The function takes an integer `i`, a `ByteBuffer` bb, and a `StringBuilder` sb, returning an integer.

**4. Examples:** 
- Input: i = 0, bb = ByteBuffer.wrap(new byte[]{0x41}), sb = new StringBuilder(); Output: i = 2, sb = ""A""
- Input: i = 0, bb = ByteBuffer.wrap(new byte[]{(byte)0xC3, (byte)0xA9}), sb = new StringBuilder(); Output: i = 5, sb = ""Ã©""

**5. Preconditions & Postconditions:** 
- Preconditions: `bb` is assumed to have a valid position and limit set, containing bytes encoded either in US-ASCII or UTF-8.
- Postconditions: Returns an incremented index, and `sb` will contain decoded string characters.
---
```"
636766aa1a6d9265ec0175ce,visitFrameStart,"int visitFrameStart(final int offset,final int numLocal,final int numStack){
  int frameLength=3 + numLocal + numStack;
  if (currentFrame == null || currentFrame.length < frameLength) {
    currentFrame=new int[frameLength];
  }
  currentFrame[0]=offset;
  currentFrame[1]=numLocal;
  currentFrame[2]=numStack;
  return 3;
}
","/** 
 * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}.
 * @param offset   the bytecode offset of the instruction to which the frame corresponds.
 * @param numLocal the number of local variables in the frame.
 * @param numStack the number of stack elements in the frame.
 * @return the index of the next element to be written in this frame.
 */
","Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.","```
---
**1. One-line summary:** Initializes or resizes the current frame array and sets its initial values.

**2. Function behavior:** The function calculates the required length for the `currentFrame` array based on the sum of a fixed base value (3), the `numLocal`, and `numStack`. If `currentFrame` is null or lacks sufficient length, it is initialized or resized to accommodate this newly calculated length. The array is then populated with the `offset`, `numLocal`, and `numStack` at its start positions, and the function returns the fixed base value, 3.

**3. Function signature:** The function takes three integer parameters: `offset`, `numLocal`, and `numStack`, and returns an integer.

**4. Examples:** 
- Input: `(5, 10, 15)` -> Output: `3`
- Input: `(0, 0, 0)` -> Output: `3`
- Input: `(1, 2, 3)` -> Output: `3`

**5. Preconditions & Postconditions:** 
Preconditions: `currentFrame` is an integer array that may be null or of insufficient length. All parameters are non-negative integers. 
Postconditions: The function returns the value `3`, and the `currentFrame` array is guaranteed to contain values `[offset, numLocal, numStack]` at its start. There are no failure cases specified beyond memory constraints.
---
```"
636767191a6d9265ec017c0f,enlarge,"private void enlarge(final int size){
  int doubleCapacity=2 * data.length;
  int minimalCapacity=length + size;
  byte[] newData=new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];
  System.arraycopy(data,0,newData,0,length);
  data=newData;
}
","/** 
 * Enlarges this byte vector so that it can receive 'size' more bytes.
 * @param size number of additional bytes that this byte vector should be able to receive.
 */
","Enlarge the byte vector data, by increasing it by the given size.","```
---
**1. One-line summary:** Enlarges the array to fit additional elements.
**2. Function behavior:** The function creates a new byte array of a specified size or double the current array's length, whichever is larger, copies the existing elements into this new array, and updates the reference.
**3. Function signature:** Accepts an integer 'size' as a parameter and has a void return type.
**4. Examples:** 
   Input: size = 10, current data length = 5
   Output: new data length = 20 (if data has a length of 5)
**5. Preconditions & Postconditions:** Preconditions: the 'data' array is properly initialized and 'length' is valid. Postconditions: 'data' is assigned a new array that can contain at least 'length + size' elements.
---
```"
636767821a6d9265ec0183a0,deleteFile,"protected static void deleteFile(String fileName){
  File file=new File(fileName);
  if (file.exists()) {
    file.delete();
  }
}
","/** 
 * Delete's the specified file if it exists 
 */
",Delete the given file if it exists,"```
---
**1. One-line summary:** Deletes a specified file if it exists.

**2. Function behavior:** The function takes a string representing a file name, creates a File object with it, checks if this file exists, and attempts to delete it if it does.

**3. Function signature:** (String fileName) -> void

**4. Examples:** 
- Input: ""example.txt""
- Action: Deletes ""example.txt"" if it exists.

**5. Preconditions & Postconditions:** 
- Preconditions: The function expects a valid file name as a string.
- Postconditions: The specified file is deleted if it exists; no action is taken if it does not.
---
```"
636767691a6d9265ec0181aa,nullSafeHashCode,"public static int nullSafeHashCode(long[] array){
  if (array == null) {
    return 0;
  }
  int hash=INITIAL_HASH;
  int arraySize=array.length;
  for (int i=0; i < arraySize; i++) {
    hash=MULTIPLIER * hash + hashCode(array[i]);
  }
  return hash;
}
","/** 
 * Return a hash code based on the contents of the specified array. If <code>array</code> is <code>null</code>, this method returns 0.
 * @param array the long array to obtain a hashcode
 * @return the long array's hashcode, which could be 0 if the array is null.
 */
","Compute the hash code of the whole array, by accumulating the multiplication of each element hash code and the  MULTIPLIER.","
---
**1. One-line summary:** Computes a hash code for a long array, handling null gracefully.

**2. Function behavior:** The function returns 0 if the array is null; otherwise, it iterates over each element of the array, updating a hash value using a specified multiplier and a helper method `hashCode` for individual long elements, finally returning the computed hash.

**3. Function signature:** Accepts a single parameter `array` of type `long[]` and returns an `int`.

**4. Examples:** 
- Input: null; Output: 0
- Input: [] (empty array); Output: INITIAL_HASH
- Input: [1, 2, 3]; Output: Computed hash value based on elements 1, 2, and 3

**5. Preconditions & Postconditions:** Preconditions include that the array can be null or a valid long array; the postcondition is that it returns a non-negative integer hash code or 0 if the input is null.
---"
636767441a6d9265ec017cc1,rotateRight,"private TreeNode<T> rotateRight(TreeNode<T> node){
  TreeNode<T> left=node.left;
  left.parent=null;
  node.setLeftChild(left.right);
  left.setRightChild(node);
  node.updateHeightAndSubtreeSize();
  left.updateHeightAndSubtreeSize();
  return left;
}
","/** 
 * Performs a right node rotation.
 * @param node a node to rotate
 * @return a new parent of the {@code node}
 */
",Perform a right node rotation on the AVL tree.,"```
---
**1. One-line summary:** Performs a right rotation on a binary tree node.
**2. Function behavior:** The function performs a right rotation by making the left child of the specified node the new root of the subtree and adjusting the necessary child and parent pointers, along with updating subtree sizes and heights.
**3. Function signature:** The function takes a single argument, a TreeNode<T> representing the current root of the subtree and returns a TreeNode<T> which is the new root after rotation.
**4. Examples:** 
   Input: a subtree rooted at node C with a left child node B
   Output: subtree now rooted at node B with node C as the right child of node B
**5. Preconditions & Postconditions:** The node must have a non-null left child for rotation; after execution, the left child becomes the new root of the subtree, and both nodes have updated height and subtree size.
---
```"
6367677e1a6d9265ec01830f,format,"public String format(LoggingEvent event){
  if (sbuf.capacity() > MAX_CAPACITY) {
    sbuf=new StringBuffer(BUF_SIZE);
  }
 else {
    sbuf.setLength(0);
  }
  PatternConverter c=head;
  while (c != null) {
    c.format(sbuf,event);
    c=c.next;
  }
  return sbuf.toString();
}
","/** 
 * Produces a formatted string as specified by the conversion pattern.
 */
","Format the buffered string with the pattern converter, and return the result.","```
---
**1. One-line summary:** Formats a logging event into a string using a buffer.
**2. Function behavior:** The function checks if a buffer exceeds a maximum capacity, reset its length or create a new buffer. It then iterates through a linked list of `PatternConverter` objects, using them to format the contents of a logging event into the buffer.
**3. Function signature:** The function takes a `LoggingEvent` object as a parameter and returns a `String`.
**4. Examples:** Input: A `LoggingEvent` object representing a log entry. Output: A formatted string representation of the log entry.
**5. Preconditions & Postconditions:** Precondition: The `sbuf`, `MAX_CAPACITY`, `BUF_SIZE`, `head`, and `PatternConverter` must be initialized and correctly set up before calling the function. Postcondition: If the buffer was oversized, it is reset, and the log event is converted to a string using the pattern converters.
---
```"
636767031a6d9265ec0178dd,contentLength,"public long contentLength(){
  long size;
  try {
    size=Long.parseLong(request.getHeader(FileUpload.CONTENT_LENGTH));
  }
 catch (  NumberFormatException e) {
    size=request.getContentLength();
  }
  return size;
}
","/** 
 * Retrieve the content length of the request.
 * @return The content length of the request.
 * @since 1.3
 */
","Compute and return the length of the request content header, return the content length if NumberFormatException happens.","```
---
**1. One-line summary:** Determines the content length from the HTTP request headers.
**2. Function behavior:** The function attempts to read the content length from the HTTP header using `FileUpload.CONTENT_LENGTH`; if parsing fails due to a `NumberFormatException`, it falls back to using `request.getContentLength()` for the content length.
**3. Function signature:** No parameters; returns a `long` representing the content length.
**4. Examples:** 
   Input: Request header with ""Content-Length"" = ""1024""  
   Output: 1024
   
   Input: Request header with ""Content-Length"" = ""invalid"" and `getContentLength()` returns 512  
   Output: 512
**5. Preconditions & Postconditions:** The method assumes that `request.getHeader` and `request.getContentLength` are correctly implemented. If `getHeader` returns a non-number, it defaults to `getContentLength()`; if both fail, the output is implementation-specific.
---
```"
636766f11a6d9265ec017658,indexOfLastSeparator,"public static int indexOfLastSeparator(String filename){
  if (filename == null) {
    return -1;
  }
  int lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);
  int lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);
  return Math.max(lastUnixPos,lastWindowsPos);
}
","/** 
 * Returns the index of the last directory separator character. <p> This method will handle a file in either Unix or Windows format. The position of the last forward or backslash is returned. <p> The output will be the same irrespective of the machine that the code is running on.
 * @param filename  the filename to find the last path separator in, null returns -1
 * @return the index of the last separator character, or -1 if thereis no such character
 */
","Return the index of the last directory separator character, under Unix or Windows.","```
---
**1. One-line summary:** Finds the last file path separator in a filename string.
**2. Function behavior:** Given a filename, it finds the position of the last occurrence of either UNIX or Windows path separators and returns the maximum index or -1 if the input is null.
**3. Function signature:** (String filename) -> int
**4. Examples:** 
    - Input: ""folder/subfolder/file.txt"" -> Output: 17
    - Input: ""folder\\subfolder\\file.txt"" -> Output: 17
    - Input: ""file.txt"" -> Output: -1
    - Input: null -> Output: -1
**5. Preconditions & Postconditions:** Strings with no separators return -1; null input returns -1; extraneous or multiple separators are correctly ignored.
---
```"
636767121a6d9265ec017b0a,parseEndOfLine,"private int parseEndOfLine(String headerPart,int end){
  int index=end;
  for (; ; ) {
    int offset=headerPart.indexOf('\r',index);
    if (offset == -1 || offset + 1 >= headerPart.length()) {
      throw new IllegalStateException(""Expected headers to be terminated by an empty line."");
    }
    if (headerPart.charAt(offset + 1) == '\n') {
      return offset;
    }
    index=offset + 1;
  }
}
","/** 
 * Skips bytes until the end of the current line.
 * @param headerPart The headers, which are being parsed.
 * @param end Index of the last byte, which has yet been processed.
 * @return Index of the \r\n sequence, which indicates end of line.
 */
",Parse the header part starting from the given end position and return the index of the enter sequence. ,"```
---
**1. One-line summary:** Parses a string to find the end of a line terminated by ""\r\n"".
**2. Function behavior:** Iterates through `headerPart` from the given `end` index to locate the first ""\r\n"" sequence, throwing an exception if such a sequence is not found before reaching the string's end.
**3. Function signature:** Takes a `String` headerPart and an `int` end, returns an `int`.
**4. Examples:** 
   Input: parseEndOfLine(""Header\r\nAnother header"", 0) 
   Output: 6
   Input: parseEndOfLine(""No end line here"", 0) 
   Output: IllegalStateException
**5. Preconditions & Postconditions:** 
   Preconditions: `headerPart` is a non-null string, `end` is a valid index within the string.
   Postconditions: Returns the index of '\r' in the first occurrence of ""\r\n"", or throws IllegalStateException if no ""\r\n"" sequence exists after the initial `end` index.
---
```"
636766f61a6d9265ec017701,lastIndexOf,"public static int lastIndexOf(String str,String searchStr){
  if (StringUtils.isEmpty(str)) {
    return StringUtils.INDEX_NOT_FOUND;
  }
  return str.lastIndexOf(searchStr);
}
","/** 
 * Finds the last index within a String, handling <code>null</code>. This method uses  {@link String#lastIndexOf(String)}. 
 */
","Find the last index of the searchStr in str, and return INDEXNOTFOUND if str is empty.","```
---
**1. One-line summary:** Finds the last index of a substring in a given string.

**2. Function behavior:** The function checks if the main string is empty using a utility method; if it is, it returns a constant indicating the substring is not found. Otherwise, it returns the last index at which the specified substring is found within the main string.

**3. Function signature:** The function takes two parameters: a main string (`str`) and a search substring (`searchStr`), both are of type `String`, and it returns an integer indicating the position of the last occurrence.

**4. Examples:** 
    Input: lastIndexOf(""hello world"", ""world""), Output: 6
    Input: lastIndexOf(""hello world"", ""o""), Output: 7
    Input: lastIndexOf(""hello world"", ""x""), Output: -1
    Input: lastIndexOf("""", ""hello""), Output: -1

**5. Preconditions & Postconditions:** The main string and search substring must be valid strings (null cases may throw exceptions unless handled elsewhere). The function assumes case-sensitive search. If the `searchStr` is not found, it returns `-1`. If the `str` is empty, it returns `-1` indicating not found.
---
```"
6367670b1a6d9265ec0179fe,write,"@Override public void write(byte b[]) throws IOException {
  checkThreshold(b.length);
  getStream().write(b);
  written+=b.length;
}
","/** 
 * Writes <code>b.length</code> bytes from the specified byte array to this output stream.
 * @param b The array of bytes to be written.
 * @exception IOException if an error occurs.
 */
",Write the given byte array b into the output stream that this class represents.,"```
---
**1. One-line summary:** The method writes a byte array to an output stream with threshold checking.

**2. Function behavior:** The function first checks if the length of the byte array `b` exceeds a certain threshold using `checkThreshold(b.length)`. Then, it writes the byte array `b` to an output stream retrieved via `getStream()`. Finally, it increments a variable `written` by the length of `b` to track the total number of bytes written.

**3. Function signature:** The function takes a single parameter `b`, which is a byte array, and does not return any value (`void`).

**4. Examples:** 
   Input: `b = [104, 101, 108, 108, 111]`  (representing the string ""hello"")  
   Output: The byte array is written to the output stream, and `written` is incremented by 5.

**5. Preconditions & Postconditions:** 
   - Preconditions: `b` is not null and represents a valid byte array.
   - Postconditions: The byte array is successfully written to the output stream; `checkThreshold` does not prevent execution.
   - Failure cases may occur if an IOException is thrown by the output stream.
---
```"
636767df1a6d9265ec01873c,id,"public String id(String entityId){
  if (entityId == null) {
    return String.valueOf(point);
  }
 else {
    return point + Const.ID_CONNECTOR + entityId;
  }
}
","/** 
 * @return the row id
 */
",Return the id by concatenating the point and the entity id with id connector.,"```
---
**1. One-line summary:** Concatenates a global 'point' value with an entityId using a connector if entityId isn't null.
**2. Function behavior:** The function checks if the input string entityId is null; if so, it returns the 'point' converted to string. Otherwise, it concatenates 'point', a separator (Const.ID_CONNECTOR), and entityId into a single string.
**3. Function signature:** The function takes a single string parameter 'entityId' and returns a string.
**4. Examples:** 
Input: entityId = null; Output: ""point""
Input: entityId = ""123""; Output: ""point-123"" (assuming Const.ID_CONNECTOR is ""-"")
**5. Preconditions & Postconditions:** Preconditions: 'point' is a valid integer or string, Const.ID_CONNECTOR is a defined string. Postconditions: Returns a combined string with 'point' and entityId if entityId is not null, or just the string of 'point' if entityId is null.
---
```"
636766f91a6d9265ec01777f,toBoolean,"public static boolean toBoolean(Boolean bool){
  if (bool == null) {
    return false;
  }
  return bool.booleanValue() ? true : false;
}
","/** 
 * <p>Converts a Boolean to a boolean handling <code>null</code> by returning <code>false</code>.</p> <pre> BooleanUtils.toBoolean(Boolean.TRUE)  = true BooleanUtils.toBoolean(Boolean.FALSE) = false BooleanUtils.toBoolean(null)          = false </pre>
 * @param bool  the boolean to convert
 * @return <code>true</code> or <code>false</code>, <code>null</code> returns <code>false</code>
 */
",Convert a Boolean to a boolean handling null by returning false.,"
---
**1. One-line summary:** Converts a Boolean object to a primitive boolean with null as false.  
**2. Function behavior:** The function checks if the input Boolean is null, returning false if it is; otherwise, it returns the primitive boolean value of the input.  
**3. Function signature:** Takes a Boolean object (which can be null) and returns a primitive boolean.  
**4. Examples:** toBoolean(null) -> false; toBoolean(Boolean.TRUE) -> true; toBoolean(Boolean.FALSE) -> false  
**5. Preconditions & Postconditions:** Input can be a Boolean object or null; output is a primitive boolean with null returning false.  
---"
6367675f1a6d9265ec0180d3,identity,"public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){
  Map<V,V> fMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());
  Map<V,V> bMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());
  for (  V v : graph.vertexSet()) {
    fMap.put(v,v);
    bMap.put(v,v);
  }
  return new IsomorphicGraphMapping<>(fMap,bMap,graph,graph);
}
","/** 
 * Computes an identity automorphism (i.e. a self-mapping of a graph in which each vertex also maps to itself).
 * @param graph the input graph
 * @param < V > the graph vertex type
 * @param < E > the graph edge type
 * @return a mapping from graph to graph
 */
",Compute and return an identity automorphism for the given graph.,"```
---
**1. One-line summary:** Returns an identity isomorphism for a given graph.

**2. Function behavior:** The function constructs and returns an isomorphism mapping a graph to itself by creating forward and backward mappings that map each vertex in the graph to itself.

**3. Function signature:** The function takes a graph with vertices and edges as input and returns an IsomorphicGraphMapping object that represents an identity isomorphism for that graph.

**4. Examples:**
   - Input: A graph with vertices {A, B, C}.
   - Output: An IsomorphicGraphMapping where the forward and backward maps are {A->A, B->B, C->C}.

**5. Preconditions & Postconditions:** The input graph is assumed to have well-defined vertex sets, and the function returns a valid identity mapping as an IsomorphicGraphMapping object. It should not fail with a null or empty graph, as identity mappings are valid for any graph.
---
```"
636766ff1a6d9265ec017851,findByte,"protected int findByte(byte value,int pos){
  for (int i=pos; i < tail; i++) {
    if (buffer[i] == value) {
      return i;
    }
  }
  return -1;
}
","/** 
 * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.
 * @param value The value to find.
 * @param pos   The starting position for searching.
 * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.
 */
","Searche for a byte of the specified value in the buffer, starting at the specified position.","```
---
**1. One-line summary:** Finds the index of the first occurrence of a byte value in a buffer from a starting position.
**2. Function behavior:** The function iterates through the buffer array starting from the given position, checking each byte to see if it matches the specified value; it returns the index of the first match or -1 if the value is not found.
**3. Function signature:** The function takes a byte `value` and an integer `pos`, returning an integer index.
**4. Examples:** 
   - Input: value = 3, pos = 0, buffer = [1, 3, 5], tail = 3; Output: 1
   - Input: value = 4, pos = 1, buffer = [1, 3, 5], tail = 3; Output: -1
**5. Preconditions & Postconditions:** Preconditions: `pos` should be within the valid range of the buffer; the buffer and tail must be properly initialized. Postconditions: Returns the index of the first matching byte if found, otherwise returns -1; may fail if `pos` is beyond `tail`.
---
```"
636767a41a6d9265ec018582,writeDelimitedTo,"public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {
  if (buffer.start != buffer.offset)   throw new IllegalArgumentException(""Buffer previously used and had not been reset."");
  final ProtobufOutput output=new ProtobufOutput(buffer);
  schema.writeTo(output,message);
  final int size=output.getSize();
  ProtobufOutput.writeRawVarInt32Bytes(out,size);
  final int msgSize=LinkedBuffer.writeTo(out,buffer);
  assert size == msgSize;
  return size;
}
","/** 
 * Serializes the  {@code message}, prefixed with its length, into an  {@link OutputStream}.
 * @return the size of the message
 */
","Use ProtobufOutput and the LinkedBuffer to write the message into the given OutputStream out, and return the message size.","```
---
**1. One-line summary:** Writes a message to an output stream in length-delimited Protobuf format.
**2. Function behavior:** This function serializes a message using a provided schema into a buffer, calculates its size, writes the size as a VarInt to the output stream, and then writes the serialized data; it ensures the buffer is unused prior to serialization.
**3. Function signature:** The function accepts an OutputStream `out`, a message object `message` of generic type `T`, a `Schema<T>` to describe the structure, and a `LinkedBuffer` for serialization; it returns an integer indicating the size of the serialized message.
**4. Examples:** 
   - Input: `writeDelimitedTo(out, someMessage, someSchema, someBuffer)`
   - Output: Returns `42`, writes the size and serialized message to `out`.
**5. Preconditions & Postconditions:** 
   - Preconditions: The buffer must be reset before use; compatible message and schema are required.
   - Postconditions: The serialized message size must match the actual bytes written; throws `IOException` or `IllegalArgumentException` if preconditions are violated.
---
```"
636766821a6d9265ec0174b6,resolveArguments,"public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){
  Class<?>[] result=null;
  if (genericType instanceof ParameterizedType) {
    ParameterizedType paramType=(ParameterizedType)genericType;
    Type[] arguments=paramType.getActualTypeArguments();
    result=new Class[arguments.length];
    for (int i=0; i < arguments.length; i++)     result[i]=resolveClass(arguments[i],targetType);
  }
 else   if (genericType instanceof TypeVariable) {
    result=new Class[1];
    result[0]=resolveClass(genericType,targetType);
  }
  return result;
}
","/** 
 * Resolves the arguments for the  {@code genericType} using the type variable information for the{@code targetType}. Returns  {@code null} if {@code genericType} is not parameterized or ifarguments cannot be resolved.
 */
",Resolve and return the arguments for the genericType using the type variable information for the targetType. Returns null if  genericType is not parameterized or if arguments cannot be resolved.,"    
---
**1. One-line summary:** Resolves and returns classes for the type arguments of a generic type.

**2. Function behavior:** The function determines the class types of the arguments of a given generic type. If the generic type is a `ParameterizedType`, it extracts and resolves each argument's type to a class. If the generic type is a `TypeVariable`, it resolves it directly to a class. The function returns an array of the corresponding classes.

**3. Function signature:** The function takes a `Type` called `genericType` and a `Class` object called `targetType`, and returns an array of `Class<?>`.

**4. Examples:** 
- Input: resolveArguments(MyType<String, Integer>, SomeClass.class) 
  Output: [String.class, Integer.class]
- Input: resolveArguments(T, SomeClass.class)
  Output: [ResolvedClass.class]

**5. Preconditions & Postconditions:** The input `genericType` can be a `ParameterizedType` or a `TypeVariable`. The function will return an array of classes representing the resolved types or null if the input type is not understood. It assumes `resolveClass` correctly maps types to their respective classes. Failure to resolve types results in a null output.
---"
636767e11a6d9265ec018781,accept,"@Override public void accept(final METRICS data){
  final String id=data.id();
  final METRICS existed=buffer.get(id);
  if (existed == null) {
    buffer.put(id,data);
  }
 else {
    final boolean isAbandoned=!existed.combine(data);
    if (isAbandoned) {
      buffer.remove(id);
    }
  }
}
","/** 
 * Accept the data into the cache and merge with the existing value. This method is not thread safe, should avoid concurrency calling.
 * @param data to be added potentially.
 */
","Accept the data into the buffer if its id does not exist in the buffer. Otherwise try to combine it with the existing value, and remove it if the combined is abandoned.","```
---
**1. One-line summary:** Update or remove metrics from a buffer based on ID and combination results.
**2. Function behavior:** The function checks the buffer for existing metrics using a unique ID; if not found, it adds the new data to the buffer. If found, it attempts to combine the data; if this fails, it removes the existing data from the buffer.
**3. Function signature:** accept(METRICS data) -> void
**4. Examples:** 
   Input: data with id ""123"" (not in buffer)  
   Output: Data added to buffer  
   Input: data with id ""456"" (in buffer, combine succeeds)  
   Output: Data updated in buffer  
   Input: data with id ""789"" (in buffer, combine fails)  
   Output: Data removed from buffer  
**5. Preconditions & Postconditions:** 
   - Preconditions: `data` contains a unique `id`; buffer is a Map-like structure.
   - Postconditions: Missing data is added; existing data is combined or removed based on the result.
---
```"
636766f11a6d9265ec017641,available,"@Override public int available() throws IOException {
  return this.index < this.length ? this.length - this.index : this.length >= 0 && this.reader.ready() ? 1 : 0;
}
","/** 
 * @see InputStream#available() 
 */
",Check the available space of this InputStream according to the index.,"---
**1. One-line summary:** Calculates and returns the number of available elements to read.

**2. Function behavior:** The function checks if the current index is less than the total length and returns the difference; if not, it checks if the reader is ready and returns 1, otherwise returns 0.

**3. Function signature:** The function has no parameters and returns an integer (`int`).

**4. Examples:** 
- If `index` is 5 and `length` is 10, it returns 5.
- If `index` is 10, `length` is 10, and reader is ready, it returns 1.
- If `index` is 10, `length` is 10, and reader is not ready, it returns 0.

**5. Preconditions & Postconditions:** 
- Preconditions: `index` and `length` are non-negative integers, and `reader` is a valid object.
- Postconditions: The function returns a non-negative integer indicating the number of readable units or readiness status.
---"
636767dd1a6d9265ec0186e5,addNewTarget,"public void addNewTarget(Channels channels,IConsumer consumer){
  Group group=new Group(channels,consumer);
  ArrayList<Group> newList=new ArrayList<Group>();
  for (  Group target : consumeTargets) {
    newList.add(target);
  }
  newList.add(group);
  consumeTargets=newList;
  size+=channels.size();
}
","/** 
 * Add a new target channels.
 */
",Add the given target channels to the consumeTargets.,"```
---
**1. One-line summary:** Adds a new Group to the consumeTargets list and updates size.

**2. Function behavior:** The function creates a new Group object using the provided Channels and IConsumer, then creates a copy of the existing consumeTargets list, adds the new Group to this list, updates the consumeTargets to this new list, and increments the size by the number of channels.

**3. Function signature:** `public void addNewTarget(Channels channels, IConsumer consumer)`

**4. Examples:** 
Input: channels = {3 channels}, consumer = Consumer A; 
Effect: consumeTargets now contains the new Group(consumer = Consumer A, channels = {3 channels}) and size is incremented by 3.

**5. Preconditions & Postconditions:** 
- Preconditions: `consumeTargets` is an existing list of Group objects; `channels` must be a valid Channels object; `consumer` must be a valid IConsumer object.
- Postconditions: The `consumeTargets` list contains the new Group; `size` reflects the total number of Channels.
---
```"
636767871a6d9265ec01846d,createConfigurationDirectory,"public static void createConfigurationDirectory(){
  String home=System.getProperty(""user.home"");
  String sep=System.getProperty(""file.separator"");
  File f=new File(home + sep + ""lf5"");
  if (!f.exists()) {
    try {
      f.mkdir();
    }
 catch (    SecurityException e) {
      e.printStackTrace();
    }
  }
}
","/** 
 * Creates the directory where the MRU file list will be written. The ""lf5"" directory is created in the Documents and Settings directory on Windows 2000 machines and where ever the user.home variable points on all other platforms.
 */
","Create the ""lf5"" directory in the Documents and Settings directory on Windows machines, or the user.home variable points on all other platforms.","```
---
**1. One-line summary:** Creates a directory named ""lf5"" in the user's home directory if it doesn't exist.
**2. Function behavior:** This function retrieves the user's home directory path and the file separator, constructs a path for a subdirectory ""lf5"", checks if this directory exists, and creates it if it does not, handling any security exceptions during creation.
**3. Function signature:** The function takes no parameters and returns no value (void).
**4. Examples:** 
   - If executed in a system where the user's home directory is ""/home/user"", it will check for ""/home/user/lf5"" and create it if missing.
**5. Preconditions & Postconditions:** Preconditions: Must have permission to access the home directory. Postconditions: The ""lf5"" directory exists in the user's home directory unless a security exception prevented its creation.
---
```"
636766f81a6d9265ec01775b,readLong,"public long readLong(final int offset){
  long l1=readInt(offset);
  long l0=readInt(offset + 4) & 0xFFFFFFFFL;
  return (l1 << 32) | l0;
}
","/** 
 * Reads a signed long value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
 * @param offset the start offset of the value to be read in this {@link ClassReader}.
 * @return the read value.
 */
",Read a signed long value.,"```
---
**1. One-line summary:** Combines two 32-bit integers into a single 64-bit long value.

**2. Function behavior:** The function reads two consecutive 32-bit integers from a specified offset, treating the first as the higher order and the second as the lower order, and combines them into a single 64-bit long by shifting the first 32 bits left and doing a bitwise OR with the second 32 bits.

**3. Function signature:** Accepts an integer offset as a parameter and returns a long integer value.

**4. Examples:** 
readLong(0); // Reads Int at offset 0 and 4, combines to long
readLong(8); // Reads Int at offset 8 and 12, combines to long

**5. Preconditions & Postconditions:** The function assumes that the offsets are valid within the available data range and that the method `readInt(int offset)` correctly retrieves 32-bit integers. It does not handle errors from invalid offsets or incorrect reads and produces undefined behavior if such assumptions are violated.
---
```"
636767a51a6d9265ec01859d,equals,"public boolean equals(final byte[] data,int offset,final int len){
  final byte[] bytes=this.bytes;
  if (len != bytes.length)   return false;
  for (int i=0; i < len; ) {
    if (bytes[i++] != data[offset++]) {
      return false;
    }
  }
  return true;
}
","/** 
 * Returns true if the contents of the internal array and the provided array match.
 */
",Return true if the contents of the internal array bytes and the provided array data match.,"```
---
**1. One-line summary:** Compares a byte array slice to an instance's byte array for equality.
**2. Function behavior:** The function checks if the length of the `data` slice matches the instance's `bytes` array; if not, it returns false. Then it iterates through the slice and compares each byte against `bytes`, returning false if any mismatch is found. If all bytes match, it returns true.
**3. Function signature:** The function takes a byte array `data`, an `int` offset, and an `int` len, and returns a boolean.
**4. Examples:** 
- `equals(new byte[]{1, 2, 3}, 0, 3)` -> true (if `bytes` is {1, 2, 3})
- `equals(new byte[]{1, 2, 3}, 1, 2)` -> false
- `equals(new byte[]{1, 2, 4}, 0, 3)` -> false
**5. Preconditions & Postconditions:** 
- Preconditions: `offset` and `offset + len` must be valid indices within `data`.
- Postconditions: Returns false if lengths do not match or any byte does not match; true otherwise.
---
```"
6367670b1a6d9265ec0179ff,nullToEmpty,"public static Byte[] nullToEmpty(final Byte[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
",Return an EMPTY_BYTE_OBJECT_ARRAY array for a null or empty input array.,"```
---
**1. One-line summary:** Converts null or empty Byte array to a predefined empty array.  
**2. Function behavior:** The function checks if the input Byte array is null or has zero length and returns a predefined empty array in such cases. Otherwise, it returns the original array.  
**3. Function signature:** Takes a Byte array `array` and returns a Byte array.  
**4. Examples:**  
   Input: null; Output: ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY  
   Input: new Byte[]{}; Output: ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY  
   Input: new Byte[]{1, 2}; Output: new Byte[]{1, 2}  
**5. Preconditions & Postconditions:**  
   Preconditions: Input could be null or any Byte array.  
   Postconditions: Returns a non-null Byte array, guarantees an empty array if input is null or empty; otherwise, returns the input array.
---
```"
6367677f1a6d9265ec018347,send,"public synchronized void send(final String message){
  Iterator ce=connections.iterator();
  for (Iterator e=writers.iterator(); e.hasNext(); ) {
    ce.next();
    PrintWriter writer=(PrintWriter)e.next();
    writer.print(message);
    if (writer.checkError()) {
      ce.remove();
      e.remove();
    }
  }
}
","/** 
 * sends a message to each of the clients in telnet-friendly output. 
 */
",Send a message to each of the connections in telnet-friendly output. ,"```
---
**1. One-line summary:** Send a message to all connected writers, removing those with errors.
**2. Function behavior:** Iterates over a list of PrintWriter objects sending a given message; removes writers with errors from the list.
**3. Function signature:** The function takes a String `message` as a parameter and returns void.
**4. Examples:** send(""Hello""); // sends ""Hello"" to all connected and functioning writers.
**5. Preconditions & Postconditions:** Each writer should handle the message sending without errors; writers with errors get removed from the list.
---
```"
6367670a1a6d9265ec0179e8,nullToEmpty,"public static Boolean[] nullToEmpty(final Boolean[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
",Return an EMPTY_BOOLEAN_OBJECT_ARRAY array for a null or empty input array.,"```
---
**1. One-line summary:** Converts null or empty Boolean array to an empty array constant.
**2. Function behavior:** The function checks if the input array is null or has zero length and returns a constant empty Boolean array if true; otherwise, it returns the input array unchanged.
**3. Function signature:** Takes a Boolean array `array` as input and returns a Boolean array.
**4. Examples:** 
    - Input: null, Output: ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY 
    - Input: new Boolean[]{}, Output: ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY
    - Input: new Boolean[]{true, false}, Output: new Boolean[]{true, false}
**5. Preconditions & Postconditions:** 
    - Preconditions: Input can be a null or any Boolean array.
    - Postconditions: Always returns a Boolean array, input remains unchanged unless it's null or empty.
---
```"
6367677f1a6d9265ec01834b,put,"public void put(LoggingEvent o){
  if (numElements != maxSize) {
    buf[next]=o;
    if (++next == maxSize) {
      next=0;
    }
    numElements++;
  }
}
","/** 
 * Place a  {@link LoggingEvent} in the buffer. If the buffer is fullthen the event is <b>silently dropped</b>. It is the caller's responsability to make sure that the buffer has free space.  
 */
",Place a  LoggingEvent in the buffer buf.,"```
---
**1. One-line summary:** Adds a LoggingEvent to a circular buffer if it isn't full.
**2. Function behavior:** The function inserts a LoggingEvent object into the buffer at the current `next` position, updates the `next` index to wrap around if it reaches `maxSize`, and increments the number of elements until it reaches `maxSize`.
**3. Function signature:** The function takes a LoggingEvent object `o` as a parameter and has no return value.
**4. Examples:** 
   - If the buffer has space and a LoggingEvent `event1` is added, it will be placed at the `next` index, and `next` and `numElements` are updated.
   - If `maxSize` is 5 and `numElements` is 4, adding a new event places it at the `next` index then resets `next` to 0.
**5. Preconditions & Postconditions:** Preconditions: `numElements` must be less than or equal to `maxSize`, and `buf` must be an initialized array with a set `maxSize`. Postconditions: If `numElements` is less than `maxSize`, `buf` contains the new event at `next` position, `next` is updated; if `numElements` equals `maxSize`, no changes occur.
---
```"
636767df1a6d9265ec018744,buildTimeRanges,"protected List<TimeRange> buildTimeRanges(long start,long end){
  if (start >= end) {
    return null;
  }
  end+=1;
  final List<TimeRange> timeRanges=new ArrayList<>();
  do {
    long batchEnd=Math.min(start + FETCH_DATA_DURATION,end);
    timeRanges.add(new TimeRange(start,batchEnd));
    start=batchEnd;
  }
 while (start < end);
  return timeRanges;
}
","/** 
 * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}
 */
",Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.,"```
---
**1. One-line summary:** Splits a time range into sub-ranges based on a fixed duration limit.

**2. Function behavior:** The function creates a list of `TimeRange` objects by sequentially dividing a given start and end time into smaller sub-ranges, each with a maximum duration defined by `FETCH_DATA_DURATION`. Starting from the `start` time, it iteratively calculates a `batchEnd` time which is either `start + FETCH_DATA_DURATION` or `end`, whichever is smaller, to construct each `TimeRange`. These sub-ranges are added to a list, which is returned at the end.

**3. Function signature:** The function `buildTimeRanges` takes two long integer parameters, `start` and `end`, and returns a `List` of `TimeRange`.

**4. Examples:** 
- Input: `start = 0`, `end = 50`, `FETCH_DATA_DURATION = 20`; Output: `[{0, 20}, {20, 40}, {40, 51}]`
- Input: `start = 1`, `end = 3`, `FETCH_DATA_DURATION = 5`; Output: `[{1, 4}]`
- Input: `start = 10`, `end = 10`, `FETCH_DATA_DURATION = 5`; Output: `null`

**5. Preconditions & Postconditions:** 
- Preconditions: `start` should be less than `end` for a valid result; otherwise, it returns `null`.
- Postconditions: Returns a list of `TimeRange` objects where each range has a maximum length of `FETCH_DATA_DURATION`, except potentially the last one, and all ranges are continuous without gaps between them. If `start` is not less than `end`, it returns `null`.
---
```"
636767031a6d9265ec0178e6,toPrimitive,"public static byte[] toPrimitive(final Byte[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_BYTE_ARRAY;
  }
  final byte[] result=new byte[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].byteValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Bytes to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Byte</code> array, may be <code>null</code>
 * @return a <code>byte</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Convert an array of object Bytes to primitives, return null for a null input array.","
---
**1. One-line summary:** Converts an array of Byte objects into corresponding byte primitives.

**2. Function behavior:** The function checks if the input array of Byte objects is null, returning null if true. If the array is empty, it returns a predefined empty byte array using `ArrayUtils.EMPTY_BYTE_ARRAY`. Otherwise, it initializes a new byte array with the same length as the input and iterates through each element, converting each Byte object to a byte using `byteValue()` and storing it in the result array. Finally, it returns the populated byte array.

**3. Function signature:** The function takes a single parameter, `array`, an array of Byte objects, and returns an array of byte primitives.

**4. Examples:** 
- Input: `toPrimitive(new Byte[]{Byte.valueOf(""1""), Byte.valueOf(""2"")})` Output: `byte[]{1, 2}`
- Input: `toPrimitive(null)` Output: `null`
- Input: `toPrimitive(new Byte[]{})` Output: `ArrayUtils.EMPTY_BYTE_ARRAY` (an empty byte array)

**5. Preconditions & Postconditions:** Preconditions: The input can be null or an array of Byte objects with any length, including zero. Postconditions: The output is a byte array with the same values as the input but in primitive form, or null if the input was null. If input is empty, an empty byte array is returned. If any element is null, a NullPointerException may occur during iteration.
---"
636767dc1a6d9265ec0186be,compressTimeBucket,"static long compressTimeBucket(long timeBucket,int dayStep){
  if (dayStep > 1) {
    DateTime time=TIME_BUCKET_FORMATTER.parseDateTime("""" + timeBucket);
    int days=Days.daysBetween(DAY_ONE,time).getDays();
    int groupBucketOffset=days % dayStep;
    return Long.parseLong(time.minusDays(groupBucketOffset).toString(TIME_BUCKET_FORMATTER));
  }
 else {
    return timeBucket;
  }
}
","/** 
 * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123
 */
","Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.","```
---
**1. One-line summary:** Adjusts time buckets by the specified day step groupings.
**2. Function behavior:** Parses a long timeBucket into a DateTime, determines current grouping offset using dayStep, adjusts the date to the start of the group, and returns new long formatted date; if dayStep is 1 or less, returns original timeBucket.
**3. Function signature:** compressTimeBucket(long timeBucket, int dayStep) -> long
**4. Examples:** 
   - Input: timeBucket = 20230101, dayStep = 3; Output: 20230101
   - Input: timeBucket = 20230104, dayStep = 3; Output: 20230102
**5. Preconditions & Postconditions:** 
   - Preconditions: timeBucket must be formatted valid for parsing, dayStep should be a positive integer.
   - Postconditions: Returns a long representing the adjusted starting date of the group or the original if dayStep is 1 or less.
---
```"
636767a41a6d9265ec01856c,computeUTF8Size,"public static int computeUTF8Size(final CharSequence str,final int index,final int len){
  int size=len;
  for (int i=index; i < len; i++) {
    final char c=str.charAt(i);
    if (c < 0x0080)     continue;
    if (c < 0x0800)     size++;
 else     size+=2;
  }
  return size;
}
","/** 
 * Computes the size of the utf8 string beginning at the specified  {@code index} with the specified {@code length}.
 */
",Compute the size of the utf8 string beginning at the specified  index  with the specified length.,"```markdown
---
**1. One-line summary:** Computes the byte size of a UTF-8 encoded substring.

**2. Function behavior:** The function iterates over the characters of a substring and calculates the size of its UTF-8 byte representation; characters < 0x0080 are 1 byte, characters < 0x0800 are 2 bytes, and others are 3 bytes.

**3. Function signature:** Takes a CharSequence `str`, and two integers `index` and `len`; returns an integer representing the UTF-8 size.

**4. Examples:** 
- Input: (`""hello""`, 0, 5); Output: `5`
- Input: (`""hÃ©lloÃ²""`, 0, 6); Output: `7`
- Input: (`""ä¸ç""`, 0, 2); Output: `6`

**5. Preconditions & Postconditions:** 
- Preconditions: `index` and `len` must be valid and within the bounds of `str`; `len` should be greater than `index`.
- Postconditions: Returns the byte count as an integer; if input is invalid, behavior is undefined.
---
```"
636766f01a6d9265ec017639,asList,"public static <T>List<T> asList(T[] a){
  if (a == null)   return Collections.emptyList();
  return Arrays.asList(a);
}
","/** 
 * Array to List. <p> Works like  {@link Arrays#asList(Object)}, but handles null arrays.
 * @return a list backed by the array.
 */
","Convert an array to list, return empty list for null array.","```
---
**1. One-line summary:** Converts an array to a List.
**2. Function behavior:** The function converts an array to a List, returning an empty List if the array is null.
**3. Function signature:** Takes a generic array T[] a as input and returns a List<T>.
**4. Examples:** 
   Input: asList(new Integer[]{1, 2, 3}) 
   Output: [1, 2, 3]
   Input: asList(null) 
   Output: []
**5. Preconditions & Postconditions:** The function assumes the input is a generic array or null and returns an empty List if null; no exceptions are thrown.
---
```"
6367672d1a6d9265ec017c74,remove,"public boolean remove(int val){
  if (map.containsKey(val)) {
    map.remove(val);
    values.remove(values.indexOf(val));
    return true;
  }
  return false;
}
","/** 
 * Removes a value from the set. Returns true if the set contained the specified element. 
 */
","Remove a value from the values if the map keys contains the val. Returns true if actually removed, and false otherwise.","```
---
**1. One-line summary:** Removes an integer value from a map and a list if it exists.

**2. Function behavior:** The function removes the given integer value from a map and a list if the map contains the key for the specified value. If the value is successfully removed from both, it returns true; otherwise, it returns false.

**3. Function signature:** public boolean remove(int val) - Takes an integer value as input and returns a boolean.

**4. Examples:** 
- Input: 5 (Assuming `map` contains 5)
  Output: true 
- Input: 3 (Assuming `map` doesn't contain 3)
  Output: false

**5. Preconditions & Postconditions:** 
- Preconditions: The map and the list are initialized and may or may not contain the specified integer value. 
- Postconditions: If the value is present in the map, it is removed from both map and list, and the function returns true; otherwise, the map and list remain unchanged and the function returns false.
---
```"
6367676b1a6d9265ec0181df,startsWithIgnoreCase,"public static boolean startsWithIgnoreCase(String str,String prefix){
  if (str == null || prefix == null) {
    return false;
  }
  if (str.startsWith(prefix)) {
    return true;
  }
  if (str.length() < prefix.length()) {
    return false;
  }
  String lcStr=str.substring(0,prefix.length()).toLowerCase();
  String lcPrefix=prefix.toLowerCase();
  return lcStr.equals(lcPrefix);
}
","/** 
 * Returns  {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.
 * @param str the String to check
 * @param prefix the prefix to look for
 * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.
 * @see java.lang.String#startsWith
 */
","Return true if the given string starts with the specified case-insensitive prefix, false otherwise.","```
---
**1. One-line summary:** Check if a string starts with a given prefix, ignoring case.
**2. Function behavior:** The function returns true if the input string starts with the specified prefix, ignoring case differences, or false if either input is null or if the prefix is longer than the string. The function uses `startsWith` if case sensitivity is applicable; otherwise, it compares the lower-case versions of relevant parts of the string and the prefix.
**3. Function signature:** The function takes two strings, `str` and `prefix`, as parameters and returns a boolean.
**4. Examples:** 
- Input: (""ExampleString"", ""exa""), Output: true
- Input: (""HelloWorld"", ""HELLO""), Output: true
- Input: (""Test"", ""Testing""), Output: false
- Input: (null, ""test""), Output: false
- Input: (""check"", null), Output: false
**5. Preconditions & Postconditions:** Strings can be null, leading to an immediate false return. Outputs are strictly boolean indicating if the prefix matches the start of the given string when case is ignored. If the length of the prefix exceeds that of the string, the function will return false.
---
```"
636767001a6d9265ec017873,reverse,"public static String reverse(final String str){
  if (str == null) {
    return null;
  }
  return new StringBuilder(str).reverse().toString();
}
","/** 
 * <p>Reverses a String as per  {@link StringBuilder#reverse()}.</p> <p>A <code>null</code> String returns <code>null</code>.</p> <pre> StringUtils.reverse(null)  = null StringUtils.reverse("""")    = """" StringUtils.reverse(""bat"") = ""tab"" </pre>
 * @param str  the String to reverse, may be null
 * @return the reversed String, <code>null</code> if null String input
 */
",Reverse the given String as per.,"```
---
**1. One-line summary:** Reverses a given string.
**2. Function behavior:** The function checks if the input string is null, returning null if true; otherwise, it uses `StringBuilder` to reverse the string and returns the reversed version as a new string.
**3. Function signature:** Takes a single `String` parameter `str` and returns a `String`.
**4. Examples:** 
   Input: ""hello"" Output: ""olleh""
   Input: ""12345"" Output: ""54321""
   Input: null Output: null
   Input: """" Output: """"
**5. Preconditions & Postconditions:** 
   - Preconditions: The input can be a valid string or null.
   - Postconditions: Returns the reversed string or null if the input is null.
---
```"
636766ff1a6d9265ec01783b,sub,"public static String sub(String str,int start,int end){
  return StringUtils.substring(str,start,end);
}
","/** 
 * Gets a substring from the specified String avoiding exceptions. 
 */
",Get a substring from the specified String avoiding exceptions. ,"
---
**1. One-line summary:** Returns a substring from a given string between specified indices.

**2. Function behavior:** The function uses `StringUtils.substring` to obtain a part of the input string `str`, starting from index `start` up to, but not including, the index `end`.

**3. Function signature:** Takes a `String` and two `int` parameters (`start` and `end`), returns a `String`.

**4. Examples:** 
   - Input: `(""hello"", 1, 4)`, Output: `""ell""`
   - Input: `(""world"", 0, 3)`, Output: `""wor""`
   - Input: `(""example"", 2, 5)`, Output: `""amp""`

**5. Preconditions & Postconditions:** 
   - Preconditions: `str` is a non-null string, `start` and `end` are valid indices within the length of `str`, and `start <= end`.
   - Postconditions: Returns a substring of `str` from `start` to `end-1`; handles index out of bounds as per `StringUtils.substring` behavior.
---"
6367671a1a6d9265ec017c15,putByteArray,"public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){
  if (length + byteLength > data.length) {
    enlarge(byteLength);
  }
  if (byteArrayValue != null) {
    System.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);
  }
  length+=byteLength;
  return this;
}
","/** 
 * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.
 * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.
 * @param byteOffset index of the first byte of byteArrayValue that must be copied.
 * @param byteLength number of bytes of byteArrayValue that must be copied.
 * @return this byte vector.
 */
","Put an array of bytes into this byte vector, enlarge the byte vector automatically if necessary.","
---
**1. One-line summary:** Appends a segment of a byte array into a ByteVector, enlarging it if necessary.

**2. Function behavior:** The function copies a specified segment of the given byte array into the ByteVector's internal data array starting from a specific offset, enlarging the array if needed to accommodate the additional bytes. 

**3. Function signature:** The function takes a byte array, a starting offset, and a length of bytes to copy as parameters, and returns a ByteVector object.

**4. Examples:** 
- Input: putByteArray(new byte[]{1, 2, 3, 4}, 1, 2), Output: ByteVector containing [2, 3]
- Input: putByteArray(new byte[]{5, 6, 7, 8}, 0, 4), Output: ByteVector containing [5, 6, 7, 8]

**5. Preconditions & Postconditions:** 
- Preconditions: `byteOffset` and `byteLength` must be within the bounds of `byteArrayValue`.
- Postconditions: The resulting ByteVector's length will increase by `byteLength`, accommodating the new bytes.
---"
6367675c1a6d9265ec01805b,removeFromTreeEdgeList,"public void removeFromTreeEdgeList(){
  for (int dir=0; dir < 2; dir++) {
    if (prev[dir] != null) {
      prev[dir].next[dir]=next[dir];
    }
 else {
      head[1 - dir].first[dir]=next[dir];
    }
    if (next[dir] != null) {
      next[dir].prev[dir]=prev[dir];
    }
  }
  head[0]=head[1]=null;
}
","/** 
 * Removes this edge from both doubly linked lists of tree edges.
 */
",Remove this edge from both doubly linked lists of the tree edges.,"```
---
**1. One-line summary:** Disconnects a node from a bidirectional linked list.
**2. Function behavior:** This function iterates over two directions, updating the previous and next pointers of adjacent nodes to bypass the current node, effectively removing it from the list, and sets list heads to null.
**3. Function signature:** The function does not accept any parameters and has a return type of void.
**4. Examples:** 
Input: A node connected between nodes A and B in a bidirectional linked list.
Output: Node A's next pointer points to Node B, and Node B's previous pointer points to Node A; the removed node's head pointers are null.
**5. Preconditions & Postconditions:** 
- Preconditions: The current node is part of a valid bidirectional linked list.
- Postconditions: The node is removed from the list without disrupting the list's integrity, and its head pointers are set to null. Function does not return any value.
---
```"
636767791a6d9265ec01826d,findAndSubst,"public static String findAndSubst(String key,Properties props){
  String value=props.getProperty(key);
  if (value == null)   return null;
  try {
    return substVars(value,props);
  }
 catch (  IllegalArgumentException e) {
    LogLog.error(""Bad option value ["" + value + ""]."",e);
    return value;
  }
}
","/** 
 * Find the value corresponding to <code>key</code> in <code>props</code>. Then perform variable substitution on the found value.
 */
","Find the value corresponding to key in props, then perform variable substitution on the found value. Return the substitution result, or the value in case of exception. ","```
---
**1. One-line summary:** Retrieve and substitute variables within a string from a properties key.
**2. Function behavior:** The function attempts to retrieve a property's value using the given key, and then substitutes variables within the value using other properties; logs errors if substitution fails.
**3. Function signature:** (String key, Properties props) -> String
**4. Examples:** 
   - Input: key = ""path"", props = {""path"": ""${base}/bin""}, returns: ""/usr/bin"" if base property is set as ""/usr"".
   - Input: key = ""name"", props = {""name"": ""John""}, returns: ""John"".
   - Input: key = ""unknown"", props = {""name"": ""John""}, returns: null.
**5. Preconditions & Postconditions:** Preconditions: key is a non-null string; props is a valid Properties object. Postconditions: Returns the substituted string or the original value on error, null if the key is not found.
---
```"
636766fe1a6d9265ec017834,sessionId,"public static String sessionId(){
  HttpSession httpSession=servletSession();
  if (httpSession == null) {
    return null;
  }
  return httpSession.getId();
}
","/** 
 * Session ID. 
 */
",Return the servlet session id,"
---
**1. One-line summary:** Retrieves the current session ID or returns null.

**2. Function behavior:** The function `sessionId` attempts to obtain the current HTTP session using `servletSession()`. If a session is present, it returns the session's ID as a string. If no session exists (i.e., `httpSession` is null), it returns null.

**3. Function signature:** This function takes no parameters and returns a `String`, which can be null.

**4. Examples:** 
- Input: (session exists) Output: `""a1b2c3d4e5""`
- Input: (session does not exist) Output: `null`

**5. Preconditions & Postconditions:** Preconditions include the presence or absence of an active HTTP session. Postconditions dictate that if a session exists, its ID string is returned; otherwise, null is returned.
---"
636766ff1a6d9265ec01784b,isDigits,"public static boolean isDigits(String str){
  if ((str == null) || (str.length() == 0)) {
    return false;
  }
  for (int i=0; i < str.length(); i++) {
    if (!Character.isDigit(str.charAt(i))) {
      return false;
    }
  }
  return true;
}
","/** 
 * <p>Checks whether the <code>String</code> contains only digit characters.</p> <p><code>Null</code> and empty String will return <code>false</code>.</p>
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if str contains only unicode numeric
 */
","Check whether a character string is a dight. If yes, true is returned. Otherwise, false is returned.","```
---
**1. One-line summary:** Checks if a string consists solely of digits.

**2. Function behavior:** Iterates through each character of the input string, returning false if any character is not a digit; returns true if all characters are digits.

**3. Function signature:** Takes a string as input and returns a boolean.

**4. Examples:** 
- Input: ""12345"" Output: true
- Input: ""123a5"" Output: false
- Input: """" Output: false
- Input: null Output: false

**5. Preconditions & Postconditions:** The function expects the input to be a string, returning false for null or empty input, and only returning true if all characters in the string are digits.
---
```"
636766fc1a6d9265ec0177da,isParameterSeparator,"private static boolean isParameterSeparator(final char c){
  if (Character.isWhitespace(c)) {
    return true;
  }
  for (  char separator : PARAMETER_SEPARATORS) {
    if (c == separator) {
      return true;
    }
  }
  return false;
}
","/** 
 * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. 
 */
","Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.","```  
---
**1. One-line summary:** Checks if a character is a parameter separator.

**2. Function behavior:** The function returns true if the input character is either a whitespace or matches any character in the `PARAMETER_SEPARATORS` array; otherwise, it returns false.

**3. Function signature:** The input parameter is a `char`, and the return type is `boolean`.

**4. Examples:** 
Input: ' '  
Output: true

Input: ',' (assuming ',' is in `PARAMETER_SEPARATORS`)  
Output: true

Input: 'a'  
Output: false

**5. Preconditions & Postconditions:** 
Preconditions: `PARAMETER_SEPARATORS` is an array containing characters considered separators.  
Postconditions: Returns true only if the character is either whitespace or a separator; otherwise, returns false.
---
```  "
6367670c1a6d9265ec017a35,endsWith,"private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){
  if (str == null || suffix == null) {
    return str == null && suffix == null;
  }
  if (suffix.length() > str.length()) {
    return false;
  }
  int strOffset=str.length() - suffix.length();
  return str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());
}
","/** 
 * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>
 * @see String#endsWith(String)
 * @param str  the String to check, may be null
 * @param suffix the suffix to find, may be null
 * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.
 * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>
 */
",Determines whether a character string ends with a specified suffix.,"```
---
**1. One-line summary:** Checks if a string ends with a specified suffix considering case sensitivity.
**2. Function behavior:** The function returns true if the given string `str` ends with the specified `suffix`, optionally ignoring case sensitivity based on the `ignoreCase` parameter. It uses the `regionMatches` method to compare the end region of the `str` with the `suffix`.
**3. Function signature:** `endsWith(String str, String suffix, boolean ignoreCase) -> boolean`
**4. Examples:** 
  - `endsWith(""HelloWorld"", ""World"", false)` -> `true`
  - `endsWith(""HelloWorld"", ""world"", true)` -> `true`
  - `endsWith(""HelloWorld"", ""world"", false)` -> `false`
  - `endsWith(null, null, false)` -> `true`
  - `endsWith(null, ""suffix"", false)` -> `false`
**5. Preconditions & Postconditions:** 
  - Preconditions: `str` and `suffix` can be null.
  - Preconditions: `ignoreCase` is a boolean indicating whether to ignore case.
  - Postcondition: Returns true if `str` ends with `suffix` according to `ignoreCase`; false otherwise.
  - Failure cases: Returns false if `str` is null and `suffix` is not null or if `suffix` is longer than `str`.
---
```"
6367667f1a6d9265ec01745d,decodePath,"public static List<PathSegmentImpl> decodePath(URI u,boolean decode){
  String rawPath=u.getRawPath();
  if (rawPath != null && rawPath.length() > 0 && rawPath.charAt(0) == '/') {
    rawPath=rawPath.substring(1);
  }
  return decodePath(rawPath,decode);
}
","/** 
 * Decode the path component of a URI as path segments.
 * @param u the URI. If the path component is an absolute path componentthen the leading '/' is ignored and is not considered a delimiator of a path segment.
 * @param decode true if the path segments of the path componentshould be in decoded form.
 * @return the list of path segments.
 */
",Decode the raw path.,"---
**1. One-line summary:** Processes a URI path and optionally decodes it.  
**2. Function behavior:** The function takes a URI object `u` and checks its raw path; if the path exists and starts with '/', it removes this leading character before passing it along with a decode flag `decode` to another `decodePath` method for further processing.  
**3. Function signature:** `(URI u, boolean decode) -> List<PathSegmentImpl>`  
**4. Examples:**  
   Input: `decodePath(new URI(""http://example.com/some/path""), true)`  
   Output: (depends on `decodePath` implementation)  
   Input: `decodePath(new URI(""http://example.com/path""), false)`  
   Output: (depends on `decodePath` implementation)  
   Input: `decodePath(new URI(""http://example.com/""), true)`  
   Output: (depends on `decodePath` implementation)  
**5. Preconditions & Postconditions:**  
   - Preconditions: The URI `u` should contain a valid scheme and path.
   - Postconditions: Returns a List of `PathSegmentImpl` obtained by processing the raw path with optional decoding, or passes an empty string if no path.  
---"
636766f11a6d9265ec017651,nullToEmpty,"public static Character[] nullToEmpty(final Character[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
","If array is null or its length is 0, convert array to EMPTY_CHARACTER_OBJECT_ARRAY. Otherwise, return array itself.","```
---
**1. One-line summary:** Returns an empty character array if input is null or empty.
**2. Function behavior:** The function checks if the input array is null or has zero length; it returns a constant empty Character array if true, otherwise returns the original array.
**3. Function signature:** Takes an array of Character objects as input and returns an array of Character objects.
**4. Examples:** 
   - Input: null; Output: ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY
   - Input: {}; Output: ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY
   - Input: {'a', 'b'}; Output: {'a', 'b'}
**5. Preconditions & Postconditions:** Preconditions: Input can be null or a Character array. Postconditions: Always returns a non-null Character array; returns a specific empty array when input is null or empty.
---
```"
636767821a6d9265ec0183ab,hasThrown,"public boolean hasThrown(){
  Throwable thrown=getThrown();
  if (thrown == null) {
    return false;
  }
  String thrownString=thrown.toString();
  return thrownString != null && thrownString.trim().length() != 0;
}
","/** 
 * @return true if getThrown().toString() is a non-empty string.
 */
",Check whether there is a thrown,"---
**1. One-line summary:** Checks if a Throwable object exists and is non-empty.

**2. Function behavior:** This function retrieves a Throwable object using `getThrown()`. If the Throwable is null, it returns false. Otherwise, it converts the Throwable to a string and returns true if this string is not null, non-empty, and not just whitespace.

**3. Function signature:** No parameters; returns a boolean.

**4. Examples:** 
- Input: Throwable is null, Output: false
- Input: Throwable is an exception with message ""Error"", Output: true
- Input: Throwable is an exception with empty message, Output: false

**5. Preconditions & Postconditions:** 
- Preconditions: A method `getThrown()` must exist and return a Throwable or null.
- Postconditions: Returns true if Throwable is non-null and its string representation is non-empty, otherwise false.
---"
636767831a6d9265ec0183c9,peek,"public static String peek(){
  Stack stack=getCurrentStack();
  if (stack != null && !stack.isEmpty())   return ((DiagnosticContext)stack.peek()).message;
 else   return """";
}
","/** 
 * Looks at the last diagnostic context at the top of this NDC without removing it. <p>The returned value is the value that was pushed last. If no context is available, then the empty string """" is returned.
 * @return String The innermost diagnostic context.
 */
",Return the value at the top of the stack,"---
**1. One-line summary:** Retrieves the message from the top of a stack if it exists.

**2. Function behavior:** The function accesses the current stack using getCurrentStack(). It checks if the stack is not null and not empty; if true, it returns the message of the DiagnosticContext object at the top of the stack. If the stack is null or empty, it returns an empty string.

**3. Function signature:** The function takes no parameters and returns a String.

**4. Examples:** 
- Input: Stack contains DiagnosticContext objects, where top object has message=""Error""
  Output: ""Error""
- Input: Stack is empty
  Output: """"
- Input: Stack is null
  Output: """"

**5. Preconditions & Postconditions:** The function assumes that getCurrentStack() returns a Stack object or null. DiagnosticContext objects in the stack must have a 'message' attribute. If the stack is null or empty, the function will return an empty string."
636767de1a6d9265ec01871c,valueAccumulation,"public void valueAccumulation(String key,Long value){
  Long element=data.get(key);
  if (element == null) {
    element=value;
  }
 else {
    element+=value;
  }
  data.put(key,element);
}
","/** 
 * Accumulate the value with existing value in the same given key.
 */
",Add the value to the original value of the key.,"```
---
**1. One-line summary:** Accumulates values in a map by summing them with existing entries.
**2. Function behavior:** The function retrieves a value associated with a key from a map; if no value exists, it inserts the provided value; if a value exists, it adds the provided value to the existing one, updating the map.
**3. Function signature:** The function takes a `String` key and a `Long` value as parameters and returns nothing.
**4. Examples:** 
   Input: key = ""a"", value = 5, map data = {""a"": 10}
   Output map data: {""a"": 15}

   Input: key = ""b"", value = 20, map data = {}
   Output map data: {""b"": 20}

**5. Preconditions & Postconditions:** 
   Preconditions: The map `data` is defined and accessible; the key is non-null; value is a Long integer.
   Postconditions: The map `data` is updated with either a new entry or an incremented existing entry.
---
```"
6367677e1a6d9265ec01832e,exists,"public Logger exists(String name){
  Object o=ht.get(new CategoryKey(name));
  if (o instanceof Logger) {
    return (Logger)o;
  }
 else {
    return null;
  }
}
","/** 
 * Check if the named logger exists in the hierarchy. If so return its reference, otherwise returns <code>null</code>.
 * @param name The name of the logger to search for.
 */
","Check if the named logger exists. If so return its reference, otherwise returns null.","```
---
**1. One-line summary:** Checks for the existence of a Logger object by name.

**2. Function behavior:** The function retrieves an object associated with the given name from a Hashtable, and if it's an instance of Logger, returns it; otherwise, it returns null.

**3. Function signature:** The function takes a String parameter 'name' and returns a Logger object or null.

**4. Examples:** 
Input: ""exampleLogger"", Output: Logger instance (if exists); null (if does not exist)

**5. Preconditions & Postconditions:** 
Preconditions: 'ht' must be a valid Hashtable and 'CategoryKey(name)' should properly hash to fetch relevant entries. 
Postconditions: Returns a Logger object if it exists in 'ht' with the specified name as a key; returns null if the key doesn't exist or if it is not a Logger instance.
---
```"
6367670a1a6d9265ec0179e7,lookup,"public Converter lookup(final Class<?> clazz){
  Converter conv=(Converter)this.converters.get(clazz);
  if (conv != null) {
    return conv;
  }
  for (  Object regType : this.converters.keySet()) {
    if (((Class<?>)regType).isAssignableFrom(clazz)) {
      return (Converter)this.converters.get(regType);
    }
  }
  return null;
}
","/** 
 * Look up and return any registered  {@link Converter} for the specifieddestination class; if there is no registered Converter, return <code>null</code>.
 * @param clazz Class for which to return a registered Converter
 * @return The registered {@link Converter} or <code>null</code> if not found
 */
","Check whether the specified converter exists in converters. If yes, converter is returned. If no, null is returned.","```
---
**1. One-line summary:** Looks up a converter for a given class from a map-like structure.
**2. Function behavior:** The function attempts to find a `Converter` object associated with the given `Class` object by first checking if an exact match exists in the `converters` map and returning it if found. If not, it iterates through the stored keys to find a compatible converter by checking if any registered class can be assigned from the given class, returning the first match found. If no suitable converter is found, it returns `null`.
**3. Function signature:** The function takes a single parameter `clazz`, which is of type `Class<?>`, and returns an object of type `Converter`.
**4. Examples:** `lookup(String.class)` might return a `StringConverter` or null if not found.
**5. Preconditions & Postconditions:** Preconditions include that `clazz` is not null, and the `converters` map is properly initialized. Postconditions include returning a `Converter` if one is found, or `null` if no suitable converter is detected.
---
```"
636767a41a6d9265ec018572,readRawVarint64,"public long readRawVarint64() throws IOException {
  int shift=0;
  long result=0;
  while (shift < 64) {
    final byte b=readRawByte();
    result|=(long)(b & 0x7F) << shift;
    if ((b & 0x80) == 0) {
      return result;
    }
    shift+=7;
  }
  throw ProtobufException.malformedVarint();
}
","/** 
 * Read a raw Varint from the stream.
 */
",Read raw varint,"```
---
**1. One-line summary:** Reads a raw Varint-encoded 64-bit integer from input.

**2. Function behavior:** The function reads bytes one by one, each containing 7 bits of data and a continuation bit, accumulating the result, and stops when a byte with the continuation bit unset is read, or a malformed Varint causes an exception after 64 bits.

**3. Function signature:** `public long readRawVarint64()` throws `IOException`

**4. Examples:** No direct input; it depends on bytes read. E.g., if bytes [0x96, 0x01] are read: Output is `150`.

**5. Preconditions & Postconditions:** Preconditions: Input stream must be properly formatted Varint-encoded data. Postconditions: Returns decoded 64-bit integer or throws `ProtobufException` if data is malformed or exceeds bounds.
---
```"
636767021a6d9265ec0178bb,nullToEmpty,"public static Double[] nullToEmpty(final Double[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
","If the double type array is null or its length is 0, convert array to EMPTY_CHARACTER_OBJECT_ARRAY. Otherwise, return array itself.","   
---
**1. One-line summary:** Returns an empty Double array if input is null or empty.

**2. Function behavior:** The function checks if the input Double array is null or has zero length; if so, it returns a predefined constant empty Double array from `ArrayUtils`. Otherwise, it returns the input array as is.

**3. Function signature:** The function takes a single parameter, `array`, which is a Double array, and returns a Double array.

**4. Examples:** 
- Input: `null`; Output: `ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY`
- Input: `new Double[0]`; Output: `ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY`
- Input: `new Double[]{1.0, 2.0}`; Output: `new Double[]{1.0, 2.0}`

**5. Preconditions & Postconditions:** 
- Preconditions: The input can be a null reference or an array of Double objects.
- Postconditions: Returns `ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY` if the input is null or empty, otherwise returns the same input reference; no exceptions are thrown.
---"
636767021a6d9265ec0178b2,pop,"private void pop(final String descriptor){
  char firstDescriptorChar=descriptor.charAt(0);
  if (firstDescriptorChar == '(') {
    pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);
  }
 else   if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {
    pop(2);
  }
 else {
    pop(1);
  }
}
","/** 
 * Pops as many abstract types from the output frame stack as described by the given descriptor.
 * @param descriptor a type or method descriptor (in which case its argument types are popped).
 */
",Pop the various value according to the first character of the descriptor.,"```
---
**1. One-line summary:** Adjusts stack size based on descriptor type in Java bytecode.

**2. Function behavior:** The function determines the number of stack elements to pop based on the given string descriptor. If the descriptor starts with '(', it calculates the stack change for method arguments using a bit shift operation on the result of `Type.getArgumentsAndReturnSizes(descriptor)`, subtracting 1. If the descriptor starts with 'J' or 'D', it calls pop(2); otherwise, pop(1) is called.

**3. Function signature:** Takes a single `String` argument called `descriptor`, with no return value (void method).

**4. Examples:** 
- Input: ""ID""; Output: pops 1 element.
- Input: ""(II)V""; Output: pops value calculated by `((Type.getArgumentsAndReturnSizes(""(II)V"") >> 2) - 1)`.
- Input: ""J""; Output: pops 2 elements.

**5. Preconditions & Postconditions:** Assumes `descriptor` is a valid Java type descriptor. It doesn't account for invalid descriptors and expects `Type.getArgumentsAndReturnSizes(descriptor)` to properly compute sizes. Outputs dictate stack adjustments but do not produce direct output values.
---
```"
636766f91a6d9265ec01776e,write,"@Override public void write(final byte b[],final int off,final int len) throws IOException {
  if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {
    throw new IndexOutOfBoundsException();
  }
 else   if (len == 0) {
    return;
  }
  if (this.count + len > this.buf.length) {
    this.encodePendingBytes(false);
  }
  System.arraycopy(b,off,this.buf,this.count,len);
  this.count+=len;
}
","/** 
 * Writes <code>len</code> bytes from the specified byte array starting at offset <code>off</code> to this byte array output stream.
 * @param b   the data.
 * @param off the start offset in the data.
 * @param len the number of bytes to write.
 */
",Write bytes of length len from a byte array,"---
**1. One-line summary:** Writes a subarray of bytes into a buffer, handling possible overflow.

**2. Function behavior:** This function writes a portion of a byte array `b` starting from `off` and spanning `len` bytes into an internal buffer `buf`. It first checks boundary conditions to ensure valid indices. If the proposed write operation would exceed the current buffer size, it invokes `encodePendingBytes(false)` presumably to handle or flush the existing data before writing. It then uses `System.arraycopy` to transfer the specified portion of the array `b` to the `buf` starting at the current buffer `count` position and updates the `count` to reflect the new length after the write.

**3. Function signature:** The method `write` takes an array of bytes `b`, an integer `off`, another integer `len`, and returns void. The method can throw an `IOException`.

**4. Examples:**
- Input: `b = [1, 2, 3, 4, 5], off = 1, len = 3` (if buffer can accommodate)
  Output: Internal buffer may now contain `[2, 3, 4]` replacing respective parts.
- Input: `b = [1, 2], off = 0, len = 0`
  Output: No change to the buffer, function returns.

**5. Preconditions & Postconditions:** 
- Preconditions: `off` should be non-negative and less than or equal to `b.length`. `len` must be non-negative. Combined, `off + len` should be a valid range within `b[]`.
- Postconditions: If constraints are violated, `IndexOutOfBoundsException` is thrown. If `len` is zero, nothing is written to the buffer. If `this.count + len` exceeds buffer capacity, `encodePendingBytes(false)` is invoked prior to the write.
---"
636767551a6d9265ec017f3f,swap,"public static final <V>void swap(V[] arr,int i,int j){
  V tmp=arr[j];
  arr[j]=arr[i];
  arr[i]=tmp;
}
","/** 
 * Swaps the two elements at the specified indices in the given array.
 * @param < V > the type of elements in the array
 * @param arr the array
 * @param i the index of the first element
 * @param j the index of the second element
 */
",Swap values at indexes i and j in arr,"```
---
**1. One-line summary:** Swaps two elements in an array.
**2. Function behavior:** The function temporarily stores the element at index `j`, assigns the element at index `i` to index `j`, and then assigns the temporary value to index `i`, thus swapping the two elements in the array.
**3. Function signature:** The function takes an array of type `V`, and two integers, `i` and `j`, indicating the positions to swap; it does not return a value (void).
**4. Examples:** 
   - Input: swap(new Integer[]{1, 2, 3}, 0, 2) Output: [3, 2, 1]
   - Input: swap(new String[]{""apple"", ""orange"", ""banana""}, 1, 2) Output: [""apple"", ""banana"", ""orange""]
**5. Preconditions & Postconditions:** Preconditions: The integers `i` and `j` must be valid indices within the array bounds. Postconditions: The elements at indices `i` and `j` are swapped; if `i` is equal to `j`, the array remains unchanged.
---
```"
636766ae1a6d9265ec0175dc,isPartialContentResponse,"public Boolean isPartialContentResponse(){
  Integer limit=drc.getLimit() == null ? 0 : drc.getLimit();
  Long count=drc.getCount() == null ? 0 : drc.getCount();
  return !((limit + 1) >= count);
}
","/** 
 * Check if the actual response is a Partial Content (HTTP 206 code)
 * @return is partial content or not
 */
",Determine whether the actual response is a Partial Content,"---
**1. One-line summary:** Checks if response contains partial content.

**2. Function behavior:** The function determines if a response is considered ""partial content"" by comparing a limit and count from the `drc` object. It defaults these values to 0 if null and returns true if the limit incremented by one is less than the count.

**3. Function signature:** `Boolean isPartialContentResponse()`

**4. Examples:** 
- Input: `drc.getLimit() = 4, drc.getCount() = 7` Output: `true`
- Input: `drc.getLimit() = 6, drc.getCount() = 6` Output: `false`
- Input: `drc.getLimit() = null, drc.getCount() = 0` Output: `false`

**5. Preconditions & Postconditions:** 
- Preconditions: The `drc` object must be accessible and have `getLimit()` and `getCount()` methods that may return null.
- Postconditions: Returns a boolean indicating whether the response is partial based on limit and count values; returns false if limit is less than count, otherwise true.
---"
636766f01a6d9265ec01762e,isEmpty,"public static boolean isEmpty(final double[] array){
  return array == null || array.length == 0;
}
","/** 
 * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */
",Check whether the array of the double type is empty.,"```
---
**1. One-line summary:** Checks if a double array is null or has no elements.
**2. Function behavior:** The function returns true if the given double array is either null or has a length of zero, indicating it is empty or uninitialized; otherwise, it returns false.
**3. Function signature:** The function takes a single parameter: a double array (double[] array) and returns a boolean value.
**4. Examples:** 
    - Input: null; Output: true
    - Input: []; Output: true
    - Input: [1.0, 2.0]; Output: false
**5. Preconditions & Postconditions:** Preconditions are that the input should be a double array which can be null; postconditions ensure that it returns true for null or empty arrays, and false otherwise.
---
```"
6367667e1a6d9265ec01743a,lastWriteTimeStampInMilliseconds,"public long lastWriteTimeStampInMilliseconds(){
  return lastWrite == -1 ? System.currentTimeMillis() : lastWrite;
}
","/** 
 * The last time, in milliseconds, a write operation occurred.
 * @return this
 */
","Check whether lastwrite is - 1. If yes, return - 1. Otherwise, return System.currentTimeMillis().","```
---
**1. One-line summary:** Returns the last write timestamp or current time if uninitialized.
**2. Function behavior:** The function checks a variable `lastWrite`; if it is `-1`, it returns the current system time in milliseconds; otherwise, it returns the value of `lastWrite`.
**3. Function signature:** The function takes no parameters and returns a long integer.
**4. Examples:** 
   - Input: lastWrite = -1; Output: current system time in milliseconds.
   - Input: lastWrite = 1696500000000L; Output: 1696500000000L.
**5. Preconditions & Postconditions:** `lastWrite` should be initialized to either `-1` or a valid timestamp in milliseconds; if it is uninitialized (i.e., `-1`), the function returns the current system time, ensuring a valid timestamp is always returned.
---
```"
636766821a6d9265ec0174c9,classPath,"private static File[] classPath(){
  final String[] fileNames=System.getProperty(""java.class.path"").split(File.pathSeparator);
  final File[] files=new File[fileNames.length];
  for (int i=0; i < files.length; ++i) {
    files[i]=new File(fileNames[i]);
  }
  return files;
}
","/** 
 * Returns the class path of the current JVM instance as an array of  {@link File} objects.
 */
",Creates an array of the file type based on all file names in java.class.path and returns the array.,"---
**1. One-line summary:** Converts Java class path to an array of File objects.

**2. Function behavior:** The function retrieves the Java class path as a system property, splits it by the path separator, converts each path to a File object, and returns an array of these File objects.

**3. Function signature:** The function takes no parameters and returns an array of File objects (File[]).

**4. Examples:** 
Input: N/A  
Output: [File(""/path/to/class1""), File(""/path/to/class2""), ...] (assuming class path includes ""/path/to/class1"" and ""/path/to/class2"")

**5. Preconditions & Postconditions:** 
- Preconditions: The Java class path must be properly set in the system properties.
- Postconditions: Returns File objects corresponding to each path in the class path; potential failure if paths are invalid or inaccessible. 
---"
636767041a6d9265ec0178f8,copyStrings,"private static String[] copyStrings(final String[] src){
  String[] dst=new String[src.length];
  for (int i=0; i < src.length; ++i) {
    dst[i]=src[i].toLowerCase();
  }
  return dst;
}
","/** 
 * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.
 */
",Copy the source string and transfer each character to lowecase.,"```
---
**1. One-line summary:** Converts an array of strings to lowercase and returns the new array.
**2. Function behavior:** The function takes a source array of strings, creates a new destination array of the same length, converts each string from the source array to lowercase, assigns it to the destination array, and returns the destination array. 
**3. Function signature:** Takes a final String array as input and returns a String array.
**4. Examples:** Input: [""Hello"", ""WORLD""], Output: [""hello"", ""world""]
**5. Preconditions & Postconditions:** Preconditions: The input is a non-null array of strings. Postconditions: The output is a new array of strings in lowercase; input remains unchanged.
---
```"
636767521a6d9265ec017ecc,splitAlongXAxis,"public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){
  double newWidth=box.getWidth() / 2d;
  double height=box.getHeight();
  return Pair.of(Box2D.of(box.getMinX(),box.getMinY(),newWidth,height),Box2D.of(box.getMinX() + newWidth,box.getMinY(),newWidth,height));
}
","/** 
 * Split a box along the x axis into two equal boxes.
 * @param box the box to split
 * @return a pair with the two resulting boxes
 */
",Divide a box into two equal boxes on the x axis.,"---
**1. One-line summary:** Splits a Box2D object into two equal halves along the x-axis.

**2. Function behavior:** The function takes a Box2D object, calculates half of its width, and then creates two new Box2D objects with these widths. The first Box2D starts at the original minimum x-coordinate, and the second Box2D starts at the middle of the original box.

**3. Function signature:** The function takes a Box2D object as a parameter and returns a Pair containing two Box2D objects.

**4. Examples:** 
- Input: Box2D with minX=0, minY=0, width=4, height=2 
  Output: Pair(Box2D with minX=0, minY=0, width=2, height=2, Box2D with minX=2, minY=0, width=2, height=2)

**5. Preconditions & Postconditions:** 
- Preconditions: The input Box2D must have a width that can be divided by 2. 
- Postconditions: Returns two Box2D objects, each having half the width of the input Box2D; does not handle cases where width is zero or not divisible by 2. 
---"
636766a91a6d9265ec0175c1,enlarge,"private void enlarge(final int size){
  int doubleCapacity=2 * data.length;
  int minimalCapacity=length + size;
  byte[] newData=new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];
  System.arraycopy(data,0,newData,0,length);
  data=newData;
}
","/** 
 * Enlarges this byte vector so that it can receive 'size' more bytes.
 * @param size number of additional bytes that this byte vector should be able to receive.
 */
",Convert the original data array to a longer array.,"```
---
**1. One-line summary:** Resizes a byte array to accommodate additional elements.

**2. Function behavior:** The function recalculates the necessary size for the `data` array based on the current length and an additional `size` input. It creates a new array that's either twice the current length or just large enough to handle the additional size, whichever is larger. The contents of the current `data` array are copied into the new array, which then replaces the old `data`.

**3. Function signature:** The function takes an integer `size` as a parameter and returns nothing (void).

**4. Examples:** 
   - Input: `size = 5` with `data.length = 10` and `length = 8`; Outcome: New `data.length = 20`
   - Input: `size = 10` with `data.length = 10` and `length = 5`; Outcome: New `data.length = 20`
   - Input: `size = 20` with `data.length = 10` and `length = 5`; Outcome: New `data.length = 25`

**5. Preconditions & Postconditions:** Preconditions include having a non-null `data` array and valid integer `length` which is the number of initialized elements in `data`. Postconditions ensure the `data` array is resized appropriately to hold existing elements plus the additional `size`. Function does not handle the case where `data` is null or when `length` is not a valid index in `data`.
---
```"
6367674a1a6d9265ec017dab,compare,"@Override public int compare(Double o1,Double o2){
  if (Math.abs(o1 - o2) < epsilon) {
    return 0;
  }
 else {
    return Double.compare(o1,o2);
  }
}
","/** 
 * Compares two floating point values. Returns 0 if they are equal, -1 if  {@literal o1 < o2}, 1 otherwise
 * @param o1 the first value
 * @param o2 the second value
 * @return 0 if they are equal, -1 if {@literal o1 < o2}, 1 otherwise
 */
","Compares two values. If the difference between the two values is less than epsilon, 0 is returned. Otherwise, Double.compare is invoked.","```
---
**1. One-line summary:** Compares two doubles considering a small tolerance for equality.

**2. Function behavior:** The function compares two Double objects by first checking if their absolute difference is smaller than a predefined threshold (epsilon); if so, they are considered equal, otherwise, their natural order is defined using `Double.compare`.

**3. Function signature:** The parameters are two Double objects, and the return type is an int (0 if they are considered equal, a negative or positive number based on their relative order).

**4. Examples:** 
   - Input: compare(1.0, 1.0 + epsilon * 0.5) Output: 0
   - Input: compare(1.0, 2.0) Output: -1
   - Input: compare(2.0, 1.0) Output: 1

**5. Preconditions & Postconditions:** Preconditions include the availability of the constant epsilon; postconditions ensure correct ordering or equality within the epsilon range. No failure cases provided epsilon is defined correctly.
---
```"
6367672d1a6d9265ec017c78,insert,"public boolean insert(int val){
  if (!map.containsKey(val)) {
    map.put(val,val);
    values.add(val);
    return true;
  }
 else {
    return false;
  }
}
","/** 
 * Inserts a value to the set. Returns true if the set did not already contain the specified element. 
 */
","If the key whose value is val does not exist in the map, add (val, val) to the map and return true. Otherwise, return false.","---
**1. One-line summary:** Inserts a value if it doesn't already exist in the map.

**2. Function behavior:** The function checks if the input value is not present in a map; if absent, it adds the value to the map and a list, then returns true. If present, it returns false without altering the data structures.

**3. Function signature:** Takes an integer `val` as a parameter and returns a boolean.

**4. Examples:** 
- Input: `insert(3)`; Output: `true`
- Input: `insert(3)`; Output: `false`
- Input: `insert(5)`; Output: `true`

**5. Preconditions & Postconditions:** 
- Preconditions: `val` is an integer.
- Postconditions: Returns true and modifies the map and list if `val` is new; returns false if `val` already exists in the map.
---"
636766821a6d9265ec0174bf,capitalize,"public static String capitalize(String name){
  if (name == null || name.length() == 0) {
    return name;
  }
  char chars[]=name.toCharArray();
  chars[0]=Character.toUpperCase(chars[0]);
  return new String(chars);
}
","/** 
 * Reverse of Introspector.decapitalize
 */
",Converts a name of the string type to a character array and converts the first letter to an uppercase letter.,"---
**1. One-line summary:** Capitalizes the first character of a string.

**2. Function behavior:** The function checks if the input string is null or empty, and if so, returns it immediately. Otherwise, it converts the string to a character array, capitalizes the first character, and then converts the array back to a string, returning the modified string.

**3. Function signature:** Takes a single String parameter `name` and returns a String.

**4. Examples:** 
- Input: ""hello"", Output: ""Hello""
- Input: ""java"", Output: ""Java""
- Input: """", Output: """"
- Input: null, Output: null

**5. Preconditions & Postconditions:** Does not handle non-letter starting characters uniquely; no change if null or empty; only first character conversion applied, others unchanged.
---"
636766f21a6d9265ec017677,isNotTrue,"public static boolean isNotTrue(Boolean bool){
  return !isTrue(bool);
}
","/** 
 * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>true</code>, handling <code>null</code> by returning <code>true</code>.</p> <pre> BooleanUtils.isNotTrue(Boolean.TRUE)  = false BooleanUtils.isNotTrue(Boolean.FALSE) = true BooleanUtils.isNotTrue(null)          = true </pre>
 * @param bool  the boolean to check, null returns <code>true</code>
 * @return <code>true</code> if the input is null or false
 * @since 2.3
 */
",Check whether the parameter bool is not true.,"```
---
**1. One-line summary:** Returns the logical negation of a Boolean value determined by another method called isTrue.
**2. Function behavior:** The function calls another method isTrue, passing the parameter bool to it, and returns the opposite of the Boolean result from isTrue.
**3. Function signature:** Takes a Boolean object as a parameter and returns a boolean primitive type.
**4. Examples:** Input: Boolean.TRUE Output: false; Input: Boolean.FALSE Output: true
**5. Preconditions & Postconditions:** Assumes the existence of a method isTrue that takes a Boolean and returns a boolean; the function returns true if isTrue returns false, and false if isTrue returns true; if calling isTrue leads to an error, this function will also fail.
---
```"
6367674f1a6d9265ec017e74,toString,"public String toString(){
  StringBuilder s=new StringBuilder();
  for (int j=i; j < n; j++)   s.append(vs[j]).append("" "");
  return s.toString();
}
","/** 
 * Returns a textual representation of the queue.
 * @return a textual representation of the queue.
 */
",Convert a value in a vs array to a string,"```
---
**1. One-line summary:** Converts elements of an array to a space-separated string.
**2. Function behavior:** The function iterates over an array from index `i` to `n-1`, appending each element to a `StringBuilder` with a space after each element. It then returns the constructed string.
**3. Function signature:** The function takes no parameters and returns a `String`.
**4. Examples:**
   - With `vs = {""apple"", ""banana"", ""cherry""}`, `i = 0`, `n = 3`, the output is `""apple banana cherry ""`.
   - With `vs = {""a"", ""b"", ""c"", ""d""}`, `i = 1`, `n = 4`, the output is `""b c d ""`.
**5. Preconditions & Postconditions:** 
   - Preconditions: `i` and `n` should be valid indices within the bounds of `vs`, and `i` should be less than `n`.
   - Postconditions: Outputs a string with elements from index `i` to `n-1` from `vs`, separated by spaces, including a trailing space.
---
```"
6367675c1a6d9265ec018058,createStringSupplier,"@SuppressWarnings(""unchecked"") public static Supplier<String> createStringSupplier(int start){
  int[] container=new int[]{start};
  return (Supplier<String> & Serializable)() -> String.valueOf(container[0]++);
}
","/** 
 * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.
 * @param start where to start the sequence
 * @return a string supplier
 */
",Create a string supplier which returns unique integer strings starting from the given start.,"    ---
    **1. One-line summary:** Supplier of incrementing integer strings from a starting value.
    **2. Function behavior:** The function returns a `Supplier<String>` that, when invoked, converts an integer stored in a single-element array to a string, returns it, and then increments the integer in the array.
    **3. Function signature:** The function accepts an `int` parameter `start` and returns a `Supplier<String>`.
    **4. Examples:** Input: `createStringSupplier(5)`, Output sequence: `""5""`, `""6""`, `""7""` (each call to the supplier returns the next stringified integer).
    **5. Preconditions & Postconditions:** Preconditions: The input is an integer. Postconditions: Each call to the returned supplier provides a string representation of the next integer in sequence, starting from the `start` value. The function assumes successful execution in a Java environment with adequate resources, and any deviations, like environment constraints, are not handled.
    ---"
6367677b1a6d9265ec0182bd,format,"public String format(final LoggingEvent event){
  StringBuffer buf=new StringBuffer();
  for (PatternConverter c=head; c != null; c=c.next) {
    c.format(buf,event);
  }
  return buf.toString();
}
","/** 
 * Formats a logging event to a writer.
 * @param event logging event to be formatted.
 */
",Formats LoggingEvent as a fixed-format string,"    ---
    **1. One-line summary:** Converts a LoggingEvent into a formatted string using pattern converters.
    **2. Function behavior:** The function iterates over a linked list of PatternConverter objects, appending the result of each one's format method to a StringBuffer, and then returns the resulting string.
    **3. Function signature:** Takes a LoggingEvent object and returns a String.
    **4. Examples:** LoggingEvent event -> ""Formatted string representation of event""
    **5. Preconditions & Postconditions:** Preconditions: `head` is a non-null reference to the start of a linked list of PatternConverter objects. Postconditions: The output is a formatted string representation of the LoggingEvent, combining contributions from each PatternConverter; the function returns a non-null string. 
    ---"
636766ff1a6d9265ec017842,toPrimitive,"public static double[] toPrimitive(final Double[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_DOUBLE_ARRAY;
  }
  final double[] result=new double[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].doubleValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Doubles to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Double</code> array, may be <code>null</code>
 * @return a <code>double</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","If the length of the array is 0, return EMPTY_DOUBLE_ARAY. Otherwise, convert the array to an array of the double type.","```
---
**1. One-line summary:** Converts an array of Double objects into an array of primitive doubles.
**2. Function behavior:** The function takes an array of Double objects, checks for null or empty state, and iterates to convert and return a corresponding array of primitive double values.
**3. Function signature:** Takes a Double array as input and returns a double array.
**4. Examples:** Input: [Double(1.0), Double(2.0)], Output: [1.0, 2.0]
**5. Preconditions & Postconditions:** The input array can be null, which returns null; elements can be null, potentially causing runtime exceptions.
---
```"
636766fa1a6d9265ec0177a9,addInitializedType,"private void addInitializedType(final int abstractType){
  if (initializations == null) {
    initializations=new int[2];
  }
  int initializationsLength=initializations.length;
  if (initializationCount >= initializationsLength) {
    int[] newInitializations=new int[Math.max(initializationCount + 1,2 * initializationsLength)];
    System.arraycopy(initializations,0,newInitializations,0,initializationsLength);
    initializations=newInitializations;
  }
  initializations[initializationCount++]=abstractType;
}
","/** 
 * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.
 * @param abstractType an abstract type on a which a constructor is invoked.
 */
",Add abstractType to the initializations variable.,"```
---
**1. One-line summary:** Adds an abstract type to an initialized list.
**2. Function behavior:** The function checks if initializations array is null and initializes it if necessary. It checks if the current initialization count exceeds the array length and doubles or increases the array size if needed. Finally, it adds the abstract type to the list and increments the counter.
**3. Function signature:** The function takes a single integer parameter and modifies an internal integer array; it does not return any value.
**4. Examples:** 
   Input: abstractType = 5 (initializations = null), Output: initializations = [5]
   Input: abstractType = 7 (initializations = [5, 0], initializationCount = 1), Output: initializations = [5, 7]
**5. Preconditions & Postconditions:** The precondition is that the function assumes an integer array and a count are present to manage the initialization process; postcondition is that the array contains the newly added type. The function may fail if the system runs out of memory or if initializations is not properly managed.
---
```"
6367670a1a6d9265ec0179dc,putAbstractTypes,"private void putAbstractTypes(final int start,final int end){
  for (int i=start; i < end; ++i) {
    Frame.putAbstractType(symbolTable,currentFrame[i],stackMapTableEntries);
  }
}
","/** 
 * Puts some abstract types of  {@link #currentFrame} in {@link #stackMapTableEntries} , using theJVMS verification_type_info format used in StackMapTable attributes.
 * @param start index of the first type in {@link #currentFrame} to write.
 * @param end index of last type in {@link #currentFrame} to write (exclusive).
 */
",Add the elements indexed from start to end in currentFrame to Frame.,"```
---
**1. One-line summary:** Iterates from start to end to process and store abstract types.

**2. Function behavior:** The function iterates over a range defined by the parameters `start` and `end`, and for each index `i`, it calls `Frame.putAbstractType` with `symbolTable`, `currentFrame[i]`, and `stackMapTableEntries` as arguments to store abstract types.

**3. Function signature:** The function `putAbstractTypes` takes two integer parameters, `start` and `end`, and does not return a value (void return type).

**4. Examples:** 
   - Input: start=0, end=5 (Assuming necessary setup has been done for the `Frame.putAbstractType` method)
     Operation: Calls `Frame.putAbstractType` for indices 0 through 4.

**5. Preconditions & Postconditions:** 
   - Preconditions: `start` and `end` are valid indices; `end` is greater than `start`; `currentFrame` has indices from `start` to `end-1`; `Frame.putAbstractType` is appropriately defined.
   - Postconditions: Abstract types for each index from `start` to `end-1` are processed using `Frame.putAbstractType`.
---
```"
6367670a1a6d9265ec0179d8,write,"@Override public void write(final byte[] b) throws IOException {
  if (this.encoding == null) {
    this.writer.write(new String(b));
  }
 else {
    this.writer.write(new String(b,this.encoding));
  }
}
","/** 
 * @see OutputStream#write(byte[]) 
 */
",Write the byte array b to the buffer based on the encoding.,"```
---
**1. One-line summary:** Writes byte data to a writer, optionally using a specified encoding.

**2. Function behavior:** The function checks if the encoding is null. If so, it converts the byte array `b` to a string using the platform's default encoding and writes it using a `writer`. If an encoding is specified, it converts the byte array `b` to a string using the specified encoding before writing it out with the `writer`.

**3. Function signature:** `public void write(final byte[] b) throws IOException` - This method takes an array of bytes as input `b` and does not return a value; it throws `IOException` if an I/O error occurs.

**4. Examples:** 
- Input: `write(new byte[]{72, 101, 108, 108, 111});` Output: Writes `""Hello""` using the default encoding.
- Input: `write(new byte[]{72, 101, 108, 108, 111}, ""UTF-8"");` Output: Writes `""Hello""` using UTF-8 encoding.

**5. Preconditions & Postconditions:** 
- Preconditions: Byte array `b` should not be null; `writer` should be initialized.
- Postconditions: Data is correctly written to `writer`; throws `IOException` if writing fails.
---
```"
636767021a6d9265ec0178bf,convertToType,"@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {
  String string=value.toString();
  if (string.length() == 0) {
    return BeanUtils.getDefaultValue(type);
  }
 else {
    return string.charAt(0);
  }
}
","/** 
 * <p>Convert the input object into a java.lang.Character.</p>
 * @param type Data type to which this value should be converted.
 * @param value The input value to be converted.
 * @return The converted value.
 * @throws Exception if conversion cannot be performed successfully
 * @since 1.8.0
 */
","If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.","```
---
**1. One-line summary:** Converts input value to default value or first character.
**2. Function behavior:** The function converts an input value to the type specified by returning the first character of the string representation of the value, or a default value if the string is empty.
**3. Function signature:** The function takes a Class<?> type, an Object value as parameters, and returns an Object.
**4. Examples:** Input: (Character.class, ""Hello"") Output: 'H'; Input: (Integer.class, """") Output: 0;
**5. Preconditions & Postconditions:** Preconditions: The input type must be a valid class object reference, and value must be non-null. Postconditions: If the string is empty, the default value for the specified type is returned. Potential failure is throwing an exception if value is null.
---
```"
6367670b1a6d9265ec017a0f,containsAnyIgnoreCase,"public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){
  if (StringUtils.isEmpty(str) || searchStrArray == null || searchStrArray.isEmpty()) {
    return false;
  }
  for (  String item : searchStrArray) {
    if (containsIgnoreCase(str,item)) {
      return true;
    }
  }
  return false;
}
","/** 
 * Case in-sensitive Checks if the String contains any character in the given set of string. 
 */
","Check whether str contains elements in searchStrArray. If yes, true is returned. If no, false is returned.","```
---
**1. One-line summary:** Checks if any of the strings in a list appear in a specified string, case-insensitively.
**2. Function behavior:** The function iterates over a list of strings, checking if each string is contained in the given string while ignoring case differences. If a match is found, it returns true; otherwise, it returns false.
**3. Function signature:** The function takes a string `str` and a list of strings `searchStrArray` as parameters and returns a boolean value.
**4. Examples:** 
   Input: containsAnyIgnoreCase(""Hello World"", Arrays.asList(""world"", ""java"")) 
   Output: true
   
   Input: containsAnyIgnoreCase(""Hello World"", Arrays.asList(""java"", ""code"")) 
   Output: false
**5. Preconditions & Postconditions:** 
   - Preconditions: `str` can be an empty or null string; `searchStrArray` can be null or empty.
   - Postconditions: Returns false if `str` or `searchStrArray` is empty or null; otherwise, returns true if any of the strings in `searchStrArray` is found in `str` irrespective of case.
---
```"
636766a81a6d9265ec01758e,nextPrime,"public static int nextPrime(int desiredCapacity){
  if (desiredCapacity >= largestPrime) {
    return largestPrime;
  }
  int i=Arrays.binarySearch(primeCapacities,desiredCapacity);
  if (i < 0) {
    i=-i - 1;
  }
  return primeCapacities[i];
}
","/** 
 * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code> (within 11% if <code>desiredCapacity &gt;= 1000</code>).
 * @param desiredCapacity the capacity desired by the user.
 * @return the capacity which should be used for a hashtable.
 */
",Returns the element at the location specified by desiredCapacity in primeCapacities.,"---
**1. One-line summary:** Finds the next prime number greater than or equal to the given capacity from a predefined list.

**2. Function behavior:** The function takes a desired capacity as input, checks if it exceeds the largest prime in a pre-defined list, and returns the largest prime if it does. Otherwise, it uses binary search to find the smallest prime in the list that is greater than or equal to the given capacity and returns that prime.

**3. Function signature:** `public static int nextPrime(int desiredCapacity)`; it takes an integer `desiredCapacity` as input and returns an integer.

**4. Examples:** 
- Input: `10`, Output: `11`
- Input: `24`, Output: `29`
- Input: `largestPrime`, Output: `largestPrime`
- Input: `1000000`, Output: `largestPrime`

**5. Preconditions & Postconditions:** 
- Preconditions: `desiredCapacity` is a non-negative integer.
- Postconditions: Returns the next prime in the list if `desiredCapacity` is smaller than `largestPrime`; otherwise, returns `largestPrime`. The function assumes that `primeCapacities` is a sorted array of prime numbers and `largestPrime` is the maximum value in that array.
---"
6367670a1a6d9265ec0179cf,toChar,"public static char toChar(final Character ch,final char defaultValue){
  if (ch == null) {
    return defaultValue;
  }
  return ch.charValue();
}
","/** 
 * <p>Converts the Character to a char handling <code>null</code>.</p> <pre> CharUtils.toChar(null, 'X') = 'X' CharUtils.toChar(' ', 'X')  = ' ' CharUtils.toChar('A', 'X')  = 'A' </pre>
 * @param ch  the character to convert
 * @param defaultValue  the value to use if the  Character is null
 * @return the char value of the Character or the default if null
 */
","Obtains the character value of ch. If ch is null, defaultValue is returned.","---
**1. One-line summary:** Converts a `Character` to `char`, providing a default for `null`.

**2. Function behavior:** The function checks if the input `Character` object is `null`; if so, it returns a specified default `char` value. Otherwise, it returns the primitive `char` value of the `Character` object using `charValue()`.

**3. Function signature:** Parameters: `Character ch` (the character to convert), `char defaultValue` (default character if `ch` is `null`); Return type: `char`.

**4. Examples:** 
- Input: `(null, 'a')` Output: `'a'`
- Input: `('b', 'a')` Output: `'b'`

**5. Preconditions & Postconditions:** Preconditions: The `ch` parameter can be `null`, and `defaultValue` is a valid `char`. Postconditions: Returns a `char` value; handles `null` by returning `defaultValue`.
---"
6367676b1a6d9265ec0181e2,findFirstMatch,"public static Object findFirstMatch(Collection source,Collection candidates){
  if (isEmpty(source) || isEmpty(candidates)) {
    return null;
  }
  for (  Object candidate : candidates) {
    if (source.contains(candidate)) {
      return candidate;
    }
  }
  return null;
}
","/** 
 * Return the first element in '<code>candidates</code>' that is contained in '<code>source</code>'. If no element in '<code>candidates</code>' is present in '<code>source</code>' returns <code>null</code>. Iteration order is {@link Collection} implementation specific.
 * @param source the source Collection
 * @param candidates the candidates to search for
 * @return the first present object, or <code>null</code> if not found
 */
",Returns the first element in candidates that matches the source.,"```
---
**1. One-line summary:** Finds the first matching element between two collections.

**2. Function behavior:** Iterates over the candidates collection, returning the first element that exists in the source collection, or null if none do.

**3. Function signature:** Takes two collections as parameters and returns an object that is the first common element or null.

**4. Examples:** 
   Input: source = [1, 2, 3], candidates = [4, 5, 3] 
   Output: 3
   Input: source = [""apple"", ""banana""], candidates = [""cherry"", ""banana""]
   Output: ""banana""
   Input: source = [true, false], candidates = [false, true] 
   Output: false

**5. Preconditions & Postconditions:** 
   - Preconditions: Both source and candidates should be collections; can be null or empty.
   - Postconditions: Returns the first matching object if found; otherwise, null.
---
```"
6367676b1a6d9265ec0181ee,trimTrailingWhitespace,"public static String trimTrailingWhitespace(String str){
  if (!hasLength(str)) {
    return str;
  }
  StringBuilder sb=new StringBuilder(str);
  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {
    sb.deleteCharAt(sb.length() - 1);
  }
  return sb.toString();
}
","/** 
 * Trim trailing whitespace from the given String.
 * @param str the String to check
 * @return the trimmed String
 * @see java.lang.Character#isWhitespace
 */
",Trim the end space of the str.,"---
**1. One-line summary:** Removes trailing whitespace from a string.

**2. Function behavior:** The function checks if the input string is non-empty. It then iteratively removes trailing whitespace characters from the end of the string using a StringBuilder, continuing until no more trailing whitespace characters remain.

**3. Function signature:** Input is a single string (`String str`); returns a string (`String`).

**4. Examples:** 
- Input: `""hello world   ""`, Output: `""hello world""`
- Input: `""   abc   ""`, Output: `""   abc""`
- Input: `""no whitespace""`, Output: `""no whitespace""`
- Input: `""""`, Output: `""""`

**5. Preconditions & Postconditions:** 
- Preconditions: The input is a string.
- Postconditions: Returns the input string with trailing whitespace removed, or the original string if it has no length.
---"
636767dc1a6d9265ec0186cb,init,"public void init(){
  File dist=new File(analyzeResultDist);
  if (!dist.exists()) {
    dist.mkdirs();
    return;
  }
  if (dist.isFile()) {
    throw new IllegalArgumentException(analyzeResultDist + "" must be a directory"");
  }
}
","/** 
 * initialize config, such as check dist path
 */
",Initializes a directory.,"```markdown
---
**1. One-line summary:** Initializes a directory for storing analysis results.

**2. Function behavior:** The function checks if the directory specified by `analyzeResultDist` exists; if not, it creates it. If it exists and is a file, it raises an exception; otherwise, it ensures it's a directory for storing results.

**3. Function signature:** The function takes no parameters and returns no value. It operates based on the `analyzeResultDist` field within its class context.

**4. Examples:** 
Input: Directory doesn't exist  
Output: Directory is created

Input: Directory exists  
Output: No action

Input: File exists with the same name  
Output: IllegalArgumentException is thrown

**5. Preconditions & Postconditions:** 
Preconditions: The variable `analyzeResultDist` must be externally defined within the class scope as a valid file path.
Postconditions: After execution, the specified path is a directory; if it was a file, an exception interrupts execution.
---
```"
636767a31a6d9265ec018552,readString,"@Override public String readString() throws IOException {
  final int size=readRawVarint32();
  if (size <= (bufferSize - bufferPos) && size > 0) {
    final String result=STRING.deser(buffer,bufferPos,size);
    bufferPos+=size;
    return result;
  }
 else {
    return STRING.deser(readRawBytes(size));
  }
}
","/** 
 * Read a  {@code string} field value from the stream.
 */
",Read string from a buffer.,"```
---
**1. One-line summary:** Reads a string from a buffer or input source with error handling.

**2. Function behavior:** The function reads a variable-length integer to determine the size of a string, then attempts to deserialize the string from the buffer if possible, or reads bytes from the input source if necessary. It returns the deserialized string and manages buffer positions accordingly.

**3. Function signature:** The function takes no parameters and returns a `String`. It throws an `IOException`.

**4. Examples:** 
Example 1: With bufferSize = 50, bufferPos = 10, buffer containing data -> returns a deserialized string.
Example 2: When size exceeds bufferSize - bufferPos -> reads from input source and returns a deserialized string.

**5. Preconditions & Postconditions:** 
- Preconditions: A valid buffer and defined `bufferSize` and `bufferPos` must exist. The function assumes a valid buffer filled with appropriate raw data to deserialize.
- Postconditions: Returns the correctly deserialized string or throws an `IOException` if an error occurs during reading the necessary data.
---
```"
636767a61a6d9265ec0185b7,digitValue,"private static int digitValue(final char c){
  if ('0' <= c && c <= '9') {
    return c - '0';
  }
 else   if ('a' <= c && c <= 'z') {
    return c - 'a' + 10;
  }
 else {
    return c - 'A' + 10;
  }
}
","/** 
 * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()} but we don't accept non-ASCII digits.
 */
",Obtains the number corresponding to the character c.,"```
---
**1. One-line summary:** Converts a character to its numeric value for digit or alphabetic order.  
**2. Function behavior:** The function converts a character representing a decimal digit or letter into a corresponding integer value, with digits ('0'-'9') mapping to 0-9, lowercase letters ('a'-'z') mapping to 10-35, and uppercase letters ('A'-'Z') also mapping to 10-35.  
**3. Function signature:** The function takes a single character `c` as input and returns an integer.  
**4. Examples:** '5' -> 5, 'a' -> 10, 'z' -> 35, 'A' -> 10, 'Z' -> 35.  
**5. Preconditions & Postconditions:** Input should be a character representing a digit or an alphabetic character, else the output may not hold meaningful results.
---
```"
636767e01a6d9265ec018755,buildContent,"private Map<String,Object> buildContent(JsonObject jsonObject){
  Map<String,Object> content=new HashMap<>();
  content.put(""msg_type"",jsonObject.get(""msg_type"").getAsString());
  if (jsonObject.get(""ats"") != null) {
    String ats=jsonObject.get(""ats"").getAsString();
    String text=jsonObject.get(""content"").getAsJsonObject().get(""text"").getAsString();
    List<String> collect=Arrays.stream(ats.split("","")).map(String::trim).collect(Collectors.toList());
    for (    String userId : collect) {
      text+=""<at user_id=\"""" + userId + ""\""></at>"";
    }
    jsonObject.get(""content"").getAsJsonObject().addProperty(""text"",text);
  }
  content.put(""content"",jsonObject.get(""content"").getAsJsonObject());
  return content;
}
","/** 
 * build content,if it has ats someone set the ats
 */
","Put the ""content"" from the  jsonObject to the content.","---
**1. One-line summary:** Build a content map with message type and enriched content text.

**2. Function behavior:** The function constructs a map from a given JsonObject, extracting the ""msg_type"" and modifying the ""text"" field in the ""content"" JsonObject if ""ats"" is present; for each user ID in ""ats"", it appends an <at> tag to the ""text"".

**3. Function signature:** The function takes a JsonObject as a parameter and returns a Map<String, Object>.

**4. Examples:** 
- Input: `{""msg_type"": ""text"", ""ats"": ""123,456"", ""content"": {""text"": ""hello""}}`
  Output: `{""msg_type"": ""text"", ""content"": {""text"": ""hello<at user_id=\""123\""></at><at user_id=\""456\""></at>""}}`
- Input: `{""msg_type"": ""text"", ""content"": {""text"": ""hello""}}`
  Output: `{""msg_type"": ""text"", ""content"": {""text"": ""hello""}}`

**5. Preconditions & Postconditions:** 
- Preconditions: The input JsonObject should contain ""msg_type"" and optionally ""ats"" and ""content"" with ""text"" inside it.
- Postconditions: Returns a Map with possibly modified ""text"" content; fails if the JsonObject is malformed or missing required fields. 
---"
636767a21a6d9265ec018517,toByteArray,"public final byte[] toByteArray(){
  LinkedBuffer node=head;
  int offset=0, len;
  final byte[] buf=new byte[size];
  do {
    if ((len=node.offset - node.start) > 0) {
      System.arraycopy(node.buffer,node.start,buf,offset,len);
      offset+=len;
    }
  }
 while ((node=node.next) != null);
  return buf;
}
","/** 
 * Returns a single byte array containg all the contents written to the buffer(s).
 */
",Copy bytes from LinkedBuffer and return.,"---
**1. One-line summary:** Converts a linked list of buffers into a single byte array.

**2. Function behavior:** The function initializes a byte array of size `size` and iterates through a linked list of `LinkedBuffer` nodes starting from `head`. For each node, it calculates the length of data between `start` and `offset`, then copies that data from the node's buffer to the resulting byte array. This process continues until all nodes have been processed and the final byte array, containing the concatenated data, is returned.

**3. Function signature:** `public final byte[] toByteArray()` - It takes no parameters and returns a byte array.

**4. Examples:** 
- Input: Linked list with nodes containing buffers with data; Output: byte array with concatenated data from all linked buffers.
- Input: Empty linked list; Output: `byte[] {}` (empty byte array).

**5. Preconditions & Postconditions:** Preconditions are that `head` is not `null` and `size` accurately reflects the total number of bytes across all nodes. Nodes contain valid offsets and start indices with proper byte data. Postconditions are that the returned byte array precisely reflects the concatenation of byte sequences from each linked buffer node without any data corruption or omission. Failure cases may include incorrect memory copying if node offsets are misconfigured."
6367667d1a6d9265ec017401,unescapeJava,"public static String unescapeJava(String str) throws Exception {
  if (str == null) {
    return null;
  }
  StringWriter writer=new StringWriter(str.length());
  unescapeJava(writer,str);
  return writer.toString();
}
","/** 
 * <p>Unescapes any Java literals found in the <code>String</code>. For example, it will turn a sequence of <code>'\'</code> and <code>'n'</code> into a newline character, unless the <code>'\'</code> is preceded by another <code>'\'</code>.</p>
 * @param str the <code>String</code> to unescape, may be null
 * @return a new unescaped <code>String</code>, <code>null</code> if null string input
 */
",Unescapes Java that found in the String.,"```
---
**1. One-line summary:** Converts Java escape sequences in a string to their literal characters.
**2. Function behavior:** The function checks if the input string is null; if not, it initializes a StringWriter with the length of the string, uses a helper function to process the string and append unescaped characters to the writer, then returns the writer's content as a string.
**3. Function signature:** Takes a String as input and returns a String; may throw an Exception.
**4. Examples:** 
   Input: ""Hello\\nWorld""
   Output: ""Hello\nWorld""

   Input: ""Tab\\tCharacter""
   Output: ""Tab\tCharacter""
**5. Preconditions & Postconditions:** 
   Preconditions: Input string can be null or contain valid Java escape sequences.
   Postconditions: Returns a string with escape sequences unescaped; if input is null, returns null; may throw an Exception for processing failures.
---
```"
636766f01a6d9265ec01763e,javaCharset,"private static String javaCharset(String charset){
  if (charset == null) {
    return null;
  }
  String mappedCharset=MIME2JAVA.get(charset.toLowerCase(Locale.ENGLISH));
  if (mappedCharset == null) {
    return charset;
  }
  return mappedCharset;
}
","/** 
 * Translate a MIME standard character set name into the Java equivalent.
 * @param charset The MIME standard name.
 * @return The Java equivalent for this name.
 */
",Translate a MIME standard charset name into the Java equivalent.,"```
---
**1. One-line summary:** Maps MIME charset names to Java charset names if mapping exists.
**2. Function behavior:** Converts a given charset name to its Java equivalent using a pre-defined mapping, returning the original if no mapping is found.
**3. Function signature:** Takes a single String argument 'charset' and returns a String.
**4. Examples:** 
   - Input: ""utf-8"" Output: ""UTF-8""
   - Input: ""iso-8859-1"" Output: ""ISO-8859-1""
   - Input: ""unknown"" Output: ""unknown""
   - Input: null Output: null
**5. Preconditions & Postconditions:** 
   - Preconditions: 'charset' may be null or a non-null string.
   - Postconditions: Returns a Java equivalent if mapping exists, otherwise returns the original string or null if input is null.
---
```"
6367676a1a6d9265ec0181bf,quoteIfString,"public static Object quoteIfString(Object obj){
  return (obj instanceof String ? quote((String)obj) : obj);
}
","/** 
 * Turn the given Object into a String with single quotes if it is a String; keeping the Object as-is else.
 * @param obj the input Object (e.g. ""myString"")
 * @return the quoted String (e.g. ""'myString'""),or the input object as-is if not a String
 */
",Check whether an obj variable is of the String type.,"```
---
**1. One-line summary:** Quotes a string if the object is a String type.
**2. Function behavior:** The function checks if the given object is an instance of the String class; if true, it returns the string wrapped in quotes using the `quote` method, otherwise, it returns the object itself unchanged.
**3. Function signature:** Takes a single `Object` parameter and returns an `Object`.
**4. Examples:** 
   - Input: ""hello"", Output: ""\""hello\""""
   - Input: 123, Output: 123
   - Input: null, Output: null
**5. Preconditions & Postconditions:** 
   - Precondition: `obj` can be any valid object or null.
   - Postcondition: Returns quoted string if input is a String, otherwise returns the input object.
---
```"
636767501a6d9265ec017e86,previousNode,"@Override public ListNode<E> previousNode(){
  checkForComodification();
  if (!hasPrevious()) {
    throw new NoSuchElementException();
  }
  last=next=next.prev;
  nextIndex--;
  return last;
}
","/** 
 * {@inheritDoc}
 */
",Returns the previous ListNode.,"---
**1. One-line summary:** Returns the previous node in a doubly-linked list and updates pointer positions.

**2. Function behavior:** The function checks for modifications, verifies if a previous node exists, updates pointers to move to the previous node, decrements the index, and returns the last node visited.

**3. Function signature:** The method takes no parameters and returns a `ListNode<E>`.

**4. Examples:** 
- Calling `previousNode()` when `next` is pointing to B in A <-> B <-> C returns A.
- Calling `previousNode()` when `next` is pointing to the first node throws NoSuchElementException.

**5. Preconditions & Postconditions:** Preconditions include a functional doubly-linked list and current pointing `next`. Postconditions are that the list remains unchanged but the current index decreases by one. If no previous node exists, it throws a NoSuchElementException.
---"
636766f21a6d9265ec017667,readShort,"public short readShort(final int offset){
  byte[] classBuffer=classFileBuffer;
  return (short)(((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF));
}
","/** 
 * Reads a signed short value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
 * @param offset the start offset of the value to be read in this {@link ClassReader}.
 * @return the read value.
 */
",Read a short value from classFileBuffer,"```
---
**1. One-line summary:** Reads a short integer from byte array at given offset.
**2. Function behavior:** The function retrieves two consecutive bytes from the `classFileBuffer` array starting at the specified `offset`, combines them into a single short value by performing a bitwise operation and returns it.
**3. Function signature:** Parameter is an integer `offset`, and it returns a short.
**4. Examples:** Input: offset = 0, classFileBuffer = [0x01, 0x02, ...]; Output: 258
**5. Preconditions & Postconditions:** Preconditions: offset must be within bounds such that `classBuffer[offset + 1]` is valid. Postconditions: Returns a short integer representation; behavior is undefined for out-of-bounds access.
---
```"
636767031a6d9265ec0178ef,copyArrayGrow1,"private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){
  if (array != null) {
    int arrayLength=Array.getLength(array);
    Object newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength + 1);
    System.arraycopy(array,0,newArray,0,arrayLength);
    return newArray;
  }
  return Array.newInstance(newArrayComponentType,1);
}
","/** 
 * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.
 * @param array The array to copy, must not be <code>null</code>.
 * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.
 * @return A new copy of the array of size 1 greater than the input.
 */
",Copy the given array and add a default value at the end.,"
---
**1. One-line summary:** Copies an array and increases its length by one.

**2. Function behavior:** The function checks if the input array is not null, then creates a new array one element longer than the input array's length and copies the elements from the old array into the new one. If the input array is null, it returns a new array with a single element of the specified component type.

**3. Function signature:** The function takes an Object representing an array and a Class object representing the new component type; it returns an Object representing the new array.

**4. Examples:** 
Input: `[1, 2, 3]`, `Integer.class`  
Output: `[1, 2, 3, null]`  
Input: `null`, `Integer.class`  
Output: `[null]`

**5. Preconditions & Postconditions:** The function assumes the input is either a valid array or null. If the array is valid, it returns a new array with an increased length by one that contains all original elements. If null, it returns a new array of the given component type with length 1. The function fails if the input is not an array or if `newArrayComponentType` is incompatible.
---"
636767611a6d9265ec018116,intersection,"private Set<V> intersection(Set<V> set1,Set<V> set2){
  Set<V> a;
  Set<V> b;
  if (set1.size() <= set2.size()) {
    a=set1;
    b=set2;
  }
 else {
    a=set2;
    b=set1;
  }
  return a.stream().filter(b::contains).collect(Collectors.toSet());
}
","/** 
 * Efficient way to compute the intersection between two sets
 * @param set1 set $1$
 * @param set2 set $2$
 * @return intersection of set $1$ and $2$
 */
",Return the intersection between two sets.,"```
---
**1. One-line summary:** Returns a set containing common elements from two sets.

**2. Function behavior:** The function takes two sets, determines the smaller set, and filters its elements to collect those present in both sets, then returns these elements as a new set.

**3. Function signature:** The function takes two sets (Set<V> set1, Set<V> set2) as parameters and returns a set (Set<V>).

**4. Examples:** 
Input: set1 = {1, 2, 3}, set2 = {3, 4, 5}  
Output: {3}

Input: set1 = {""a"", ""b""}, set2 = {""b"", ""c"", ""d""}  
Output: {""b""}

**5. Preconditions & Postconditions:** 
Preconditions: Both inputs, set1 and set2, should be valid sets and may contain any type of comparable elements. They cannot be null.  
Postconditions: The result is a set containing elements found in both input sets or an empty set if there are no common elements.
---
```"
636766f71a6d9265ec017730,toNoNullStringArray,"static String[] toNoNullStringArray(Collection<?> collection){
  if (collection == null) {
    return ArrayUtils.EMPTY_STRING_ARRAY;
  }
  return toNoNullStringArray(collection.toArray());
}
","/** 
 * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element is <code>null</code>.
 * @param collection The collection to convert
 * @return A new array of Strings.
 */
","If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array. ???","```
---
**1. One-line summary:** Converts a collection to a non-null array of strings.
**2. Function behavior:** The function checks if the given collection is null, returning an empty string array if true; otherwise, it converts the collection to an array and processes it further using the `toNoNullStringArray` method.
**3. Function signature:** Takes a `Collection<?>` as input and returns a `String[]`.
**4. Examples:** 
   Input: null
   Output: []

   Input: [""apple"", null, ""banana""]
   Output: [""apple"", """", ""banana""]
**5. Preconditions & Postconditions:** Input can be a null or non-null collection; returns an empty string array for null input and ensures no nulls in the output array, replacing them with an empty string.
---
```"
636767081a6d9265ec0179a2,isAllZeros,"private static boolean isAllZeros(String s){
  if (s == null) {
    return true;
  }
  for (int i=s.length() - 1; i >= 0; i--) {
    if (s.charAt(i) != '0') {
      return false;
    }
  }
  return s.length() > 0;
}
","/** 
 * <p>Utility method for  {@link #createNumber(String)}.</p> <p>Returns <code>true</code> if s is <code>null</code>.</p>
 * @param s the String to check
 * @return if it is all zeros or <code>null</code>
 */
",Check whether a character string is all consist of zero. ,"```
---
**1. One-line summary:** Checks if a string is non-null and composed entirely of '0' characters.
**2. Function behavior:** The function returns true if the input string is null or consists solely of '0' characters; otherwise, it returns false. It iterates over the string from the last character to the first, verifying each character is '0'.
**3. Function signature:** The function takes a single String parameter `s` and returns a boolean.
**4. Examples:** 
  - Input: ""0000"", Output: true
  - Input: ""1230"", Output: false
  - Input: """", Output: false
  - Input: null, Output: true
**5. Preconditions & Postconditions:** The function handles null inputs by returning true. An empty string is considered not all zeros, so it returns false. The function assumes ASCII character set where '0' is applicable.
---
```"
636767e01a6d9265ec018764,convertProperties,"private JsonObject convertProperties(List<KeyStringValuePair> properties){
  final JsonObject result=new JsonObject();
  for (  KeyStringValuePair kv : properties) {
    result.addProperty(kv.getKey(),kv.getValue());
  }
  return result;
}
","/** 
 * Convert process properties to source data
 */
",Convert process properties to the JsonObject.,"```
---
**1. One-line summary:** Converts a list of key-value pairs into a JSON object.
**2. Function behavior:** Iterates over a list of `KeyStringValuePair` objects, adding each key-value pair to a new `JsonObject` and returns it.
**3. Function signature:** Takes a `List<KeyStringValuePair>` and returns a `JsonObject`.
**4. Examples:** Input: `[KeyStringValuePair(""name"", ""John""), KeyStringValuePair(""age"", ""30"")]`; Output: `{""name"":""John"",""age"":""30""}`
**5. Preconditions & Postconditions:** Preconditions: The input list is non-null and may be empty; Postconditions: Returns a `JsonObject` with all key-value pairs from the list, or an empty `JsonObject` if the list is empty.
---
```"
636766ff1a6d9265ec017853,readLabel,"protected Label readLabel(final int bytecodeOffset,final Label[] labels){
  if (labels[bytecodeOffset] == null) {
    labels[bytecodeOffset]=new Label();
  }
  return labels[bytecodeOffset];
}
","/** 
 * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.
 * @param bytecodeOffset a bytecode offset in a method.
 * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.
 * @return a non null Label, which must be equal to labels[bytecodeOffset].
 */
","Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.","```
---
**1. One-line summary:** Accesses or initializes a Label at a specific index in an array.

**2. Function behavior:** The function checks if a Label at the specified bytecodeOffset in the labels array is null. If it is null, it initializes a new Label at that position, and then it returns the Label at that position.

**3. Function signature:** (int bytecodeOffset, Label[] labels) -> Label

**4. Examples:** 
- Input: (2, new Label[]{null, null, null, null}) Output: new Label()
- Input: (0, new Label[]{label1, label2, label3}) Output: label1

**5. Preconditions & Postconditions:** 
- Preconditions: bytecodeOffset must be a valid index within the labels array.
- Postconditions: Returns a non-null Label object at the specified index; the array is modified if the original entry was null.
---
```"
6367677d1a6d9265ec0182fd,toBoolean,"public static boolean toBoolean(String value,boolean dEfault){
  if (value == null)   return dEfault;
  String trimmedVal=value.trim();
  if (""true"".equalsIgnoreCase(trimmedVal))   return true;
  if (""false"".equalsIgnoreCase(trimmedVal))   return false;
  return dEfault;
}
","/** 
 * If <code>value</code> is ""true"", then <code>true</code> is returned. If <code>value</code> is ""false"", then <code>true</code> is returned. Otherwise, <code>default</code> is returned. <p>Case of value is unimportant.  
 */
","Check whether a string is true or false after ignore cases and trim the whitespaces at both ends. If so, its boolean value is returned. Otherwise, dEfault is returned.","---
**1. One-line summary:** Converts a string to a boolean based on its content or returns a default value.

**2. Function behavior:** The function checks if the input string value is null, returning a default boolean if true. If not, it trims the string and compares it case-insensitively to ""true"" and ""false"", returning true or false respectively if matched. For other cases, it returns the default boolean.

**3. Function signature:** The function takes a String `value` and a boolean `dEfault` as parameters, and returns a boolean.

**4. Examples:** 
- `toBoolean(""true"", false)` returns `true`.
- `toBoolean(""false"", true)` returns `false`.
- `toBoolean(""  TRUE  "", false)` returns `true`.
- `toBoolean(null, true)` returns `true`.
- `toBoolean(""yes"", false)` returns `false`.

**5. Preconditions & Postconditions:** 
- Preconditions: Input `value` can be null, and `dEfault` is a boolean.
- Postconditions: Always returns a boolean. If `value` doesn't represent ""true"" or ""false"", it returns `dEfault`.
---"
6367676a1a6d9265ec0181cd,trimLeadingWhitespace,"public static String trimLeadingWhitespace(String str){
  if (!hasLength(str)) {
    return str;
  }
  StringBuilder sb=new StringBuilder(str);
  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {
    sb.deleteCharAt(0);
  }
  return sb.toString();
}
","/** 
 * Trim leading whitespace from the given String.
 * @param str the String to check
 * @return the trimmed String
 * @see java.lang.Character#isWhitespace
 */
",Trim the leading whitespaces in a string.,"```
---
**1. One-line summary:** Trims leading whitespace from a string.
**2. Function behavior:** The function checks if the input string has content and iteratively removes leading whitespace characters using a StringBuilder until the first character is not whitespace.
**3. Function signature:** Takes a single string parameter `str` and returns a string.
**4. Examples:** 
   Input: ""  Hello World"" Output: ""Hello World""
   Input: ""\t\nTest"" Output: ""Test""
   Input: ""NoLeadingSpace"" Output: ""NoLeadingSpace""
**5. Preconditions & Postconditions:** 
   - Preconditions: Input is a string, may include any character.
   - Postconditions: Returns the string with all leading whitespace removed, or the original string if empty or null.
---
```"
636766fe1a6d9265ec01782a,readUtf,"final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){
  String value=constantUtf8Values[constantPoolEntryIndex];
  if (value != null) {
    return value;
  }
  int cpInfoOffset=cpInfoOffsets[constantPoolEntryIndex];
  return constantUtf8Values[constantPoolEntryIndex]=readUtf(cpInfoOffset + 2,readUnsignedShort(cpInfoOffset),charBuffer);
}
","/** 
 * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}.
 * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pooltable.
 * @param charBuffer the buffer to be used to read the string. This buffer must be sufficientlylarge. It is not automatically resized.
 * @return the String corresponding to the specified CONSTANT_Utf8 entry.
 */
",Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.,"```
---
**1. One-line summary:** Retrieve or read a UTF-8 string from a constant pool.
**2. Function behavior:** The function returns a UTF-8 string from `constantUtf8Values` if already available; otherwise, it reads and stores it by calculating offsets using `cpInfoOffsets` and returns the stored value.
**3. Function signature:** The function takes a constant pool entry index as an integer and a character buffer as input, and returns a string.
**4. Examples:** Input: (0, new char[100]); Output: ""Example String""
**5. Preconditions & Postconditions:** Preconditions: `constantUtf8Values` and `cpInfoOffsets` are initialized arrays; the index is valid; `charBuffer` has sufficient length. Postconditions: Returns a valid UTF-8 string or may throw an exception if handling fails.
---
```"
636766851a6d9265ec01751b,decodeHexNibble,"private static char decodeHexNibble(final char c){
  if ('0' <= c && c <= '9') {
    return (char)(c - '0');
  }
 else   if ('a' <= c && c <= 'f') {
    return (char)(c - 'a' + 10);
  }
 else   if ('A' <= c && c <= 'F') {
    return (char)(c - 'A' + 10);
  }
 else {
    return Character.MAX_VALUE;
  }
}
","/** 
 * Helper to decode half of a hexadecimal number from a string.
 * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}.
 * @return The hexadecimal value represented in the ASCII charactergiven, or  {@link Character#MAX_VALUE} if the character is invalid.
 */
",Convert a hexadecimal number to binary and return its character type.,"```
---
**1. One-line summary:** Converts a hexadecimal character to its integer value.
**2. Function behavior:** Takes a single hexadecimal character and returns the integer it represents; returns `Character.MAX_VALUE` if the input is not a valid hexadecimal character.
**3. Function signature:** Takes a `char` parameter `c` and returns a `char`.
**4. Examples:** `'1' -> 1`, `'a' -> 10`, `'F' -> 15`, `'G' -> \uFFFF`
**5. Preconditions & Postconditions:** Input is a character; a valid hex character will return its value as a numerical character, invalid will return `Character.MAX_VALUE`.
---
```"
636766f21a6d9265ec01767d,toString,"public static String toString(Object object){
  return (object == null) ? null : object.toString();
}
","/** 
 * Object to String ,when null object then null else return toString(); 
 */
","Convert object to string  if the object is not null. Otherwise, null is returned.","---
**1. One-line summary:** Converts an object to its string representation.

**2. Function behavior:** The function checks if the provided object is null; if it is, it returns null. Otherwise, it calls the `toString()` method on the object and returns the resulting string.

**3. Function signature:** Takes one parameter of type `Object` and returns a `String`.

**4. Examples:** 
- Input: `null`, Output: `null`
- Input: `123`, Output: `""123""`
- Input: `""Hello""`, Output: `""Hello""`

**5. Preconditions & Postconditions:** The object parameter can be any type, including null; if null, returns null, otherwise a valid string representation.
---"
636767581a6d9265ec017fc4,factorial,"public static long factorial(int n){
  long multi=1;
  for (int i=1; i <= n; i++) {
    multi=multi * i;
  }
  return multi;
}
","/** 
 * Calculate the factorial of $n$.
 * @param n the input number
 * @return the factorial
 */
",Calculate the factorial of the given number.,"---
**1. One-line summary:** Computes the factorial of a non-negative integer.

**2. Function behavior:** The function calculates the product of all positive integers up to and including `n` by multiplying each integer from 1 to `n` sequentially and storing the result in `multi`, which is then returned.

**3. Function signature:** Takes an integer `n` as input and returns a long integer representing the factorial of `n`.

**4. Examples:** 
- Input: `5`, Output: `120`
- Input: `0`, Output: `1`
- Input: `3`, Output: `6`

**5. Preconditions & Postconditions:** 
- Preconditions: `n` is a non-negative integer (0 or greater).
- Postconditions: Returns a long value; if `n` is 0, the function returns 1, as `0!` is defined to be 1. The function might not handle very large values of `n` due to limitations on the `long` data type.
---"
636767511a6d9265ec017eb6,selectOnOuterFace,"private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){
  OuterFaceCirculator circulator=start.iterator(dir);
  Node current=circulator.next();
  while (current != stop && !predicate.test(current)) {
    current=circulator.next();
  }
  return circulator;
}
","/** 
 * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate} or returns a circulator to the {@code stop} node.
 * @param predicate the condition the desired node should satisfy
 * @param start the node to start the search from
 * @param stop the node to end the search with
 * @param dir the direction to start the traversal in
 * @return a circulator to the node satisfying the {@code predicate} or to the {@code stop} node
 */
",Find a circulator to the node that satisfies the Interface predicate.,"```
---
**1. One-line summary:** Finds a node on the outer face matching a given condition, iterating from start to stop.
**2. Function behavior:** The function creates a circulator from the start node in the given direction, iterates through nodes until it reaches the stop node or finds a node that satisfies the predicate, and returns the circulator.
**3. Function signature:** The function takes a Predicate<Node> `predicate`, two Node objects `start` and `stop`, an integer `dir`, and returns an OuterFaceCirculator.
**4. Examples:** 
   - Input: (n -> n.isValid(), startNode, endNode, 1); Output: Circulator pointing to first valid node or endNode.
   - Input: (n -> n.hasValue(5), startNode, stopNode, -1); Output: Circulator pointing to first node with value 5 or stopNode.
**5. Preconditions & Postconditions:** The nodes and circulator are non-null; iteration is stopped when reaching either the stop node or the conditionally matching node; does not handle circular references or infinite loops outside defined stop node.
---
```"
636767841a6d9265ec0183e8,add,"public void add(LoggingEvent event){
  ea[last]=event;
  if (++last == maxSize)   last=0;
  if (numElems < maxSize)   numElems++;
 else   if (++first == maxSize)   first=0;
}
","/** 
 * Add an <code>event</code> as the last event in the buffer.
 */
",Add an event as the last event in the buffer.,"```
---
**1. One-line summary:** Adds an event to a circular buffer.

**2. Function behavior:** The function inserts a new event into a circular array `ea` at the position indicated by `last`, then updates the `last` index, wrapping it to the beginning if it reaches `maxSize`. If the buffer isn't full (`numElems < maxSize`), it increments the count of elements; otherwise, it updates the `first` index to wrap around when necessary.

**3. Function signature:** The function takes a single parameter `event` of type `LoggingEvent` and returns void.

**4. Examples:** 
   - Input: Buffer = [E1, E2, E3], maxSize = 3, first = 0, last = 2, numElems = 3, event = E4
     Output: Buffer = [E4, E2, E3], first = 1, last = 0, numElems = 3
   - Input: Buffer = [null, null, null], maxSize = 3, first = 0, last = 0, numElems = 0, event = E1
     Output: Buffer = [E1, null, null], first = 0, last = 1, numElems = 1

**5. Preconditions & Postconditions:** Preconditions: `ea` is initialized with a size of `maxSize`; `first`, `last`, and `numElems` are valid indices and counts. Postconditions: `ea` contains the new event at the correct position, and `first`, `last`, `numElems` are appropriately updated. No output is produced; only internal state changes.
---
```"
636767a41a6d9265ec01857e,compareSigned,"private static int compareSigned(long a,long b){
  return (a < b) ? -1 : ((a > b) ? 1 : 0);
}
","/** 
 * Compares the two specified  {@code long} values. The sign of the value returned is the same as that of{@code ((Long) a).compareTo(b)}. <p> <b>Note for Java 7 and later:</b> this method should be treated as deprecated; use the equivalent {@link Long#compare} method instead.
 * @param a the first  {@code long} to compare
 * @param b the second  {@code long} to compare
 * @return a negative value if {@code a} is less than {@code b}; a positive value if  {@code a} is greater than{@code b}; or zero if they are equal
 */
",Compare two numbers.,"---
**1. One-line summary:** Compares two long integers and returns their order relation.

**2. Function behavior:** The function takes two long integers as input; if the first (a) is less than the second (b), it returns -1. If a is greater than b, it returns 1. If they are equal, it returns 0.

**3. Function signature:** The function takes two long parameters (a, b) and returns an int.

**4. Examples:** 
- Input: (5, 10) Output: -1
- Input: (15, 5) Output: 1
- Input: (7, 7) Output: 0

**5. Preconditions & Postconditions:** 
- Preconditions: a and b are long integers.
- Postconditions: The function returns -1, 0, or 1 depending on the comparison.
---"
636766a91a6d9265ec0175ae,putByteArray,"public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){
  if (length + byteLength > data.length) {
    enlarge(byteLength);
  }
  if (byteArrayValue != null) {
    System.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);
  }
  length+=byteLength;
  return this;
}
","/** 
 * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.
 * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.
 * @param byteOffset     index of the first byte of byteArrayValue that must be copied.
 * @param byteLength     number of bytes of byteArrayValue that must be copied.
 * @return this byte vector.
 */
",Add a byte array into the byte vector.,"```
---
**1. One-line summary:** Appends a byte array slice to the ByteVector.

**2. Function behavior:** The function appends a specified portion of an input byte array to the ByteVector, enlarging the internal buffer if necessary, using System.arraycopy to efficiently copy the data.

**3. Function signature:** Takes a byte array (byteArrayValue), an integer offset (byteOffset), and an integer length (byteLength); returns a modified ByteVector object.

**4. Examples:** 
- Input: byteArrayValue = [0x01, 0x02, 0x03, 0x04], byteOffset = 1, byteLength = 2; Result: ByteVector with appended data [0x02, 0x03].
- Input: byteArrayValue = [0x05, 0x06], byteOffset = 0, byteLength = 2; Result: ByteVector with appended data [0x05, 0x06].

**5. Preconditions & Postconditions:** Preconditions: byteOffset and byteLength must specify a valid range within the byteArrayValue; byteArrayValue can be null. Postconditions: ByteVector contains the specified byte array portion; enlarges internal array if needed.
---
```"
636766f11a6d9265ec01764f,values,"public Collection<Object> values(){
  ArrayList<Object> answer=new ArrayList<>(readMethods.size());
  for (Iterator<Object> iter=valueIterator(); iter.hasNext(); ) {
    answer.add(iter.next());
  }
  return Collections.unmodifiableList(answer);
}
","/** 
 * Returns the values for the BeanMap.
 * @return values for the BeanMap. The returned collection is not modifiable.
 */
",Return an unmodifiable list that contains all methods in the BeanMap.,"```
---
**1. One-line summary:** Return a collection of all values from a source as an unmodifiable list.

**2. Function behavior:** The function initializes an ArrayList sized to the number of readable methods, iterates through a value iterator, adds each element to the list, and then returns it as an unmodifiable list.

**3. Function signature:** The function takes no parameters and returns a Collection<Object>.

**4. Examples:** 
Input: None (method call)
Output: A collection containing the list of objects retrieved from the value iterator.

**5. Preconditions & Postconditions:** 
Preconditions: The valueIterator() method must be initialized and have values to iterate over.
Postconditions: The returned list is immutable; modifications are not allowed after it is returned.
---
```"
636766f81a6d9265ec017758,hashCode,"@Override public int hashCode(){
  int hashCode=13 * (sort == INTERNAL ? OBJECT : sort);
  if (sort >= ARRAY) {
    for (int i=valueBegin, end=valueEnd; i < end; i++) {
      hashCode=17 * (hashCode + valueBuffer.charAt(i));
    }
  }
  return hashCode;
}
","/** 
 * Returns a hash code value for this type.
 * @return a hash code value for this type.
 */
",Compute a hash code according to the type.,"```
---
**1. One-line summary:** Computes a hash code based on object type and character values.

**2. Function behavior:** It calculates a hash code starting from a base value of 13 times a constant depending on the `sort` value; if `sort` is greater than or equal to `ARRAY`, it iterates through `valueBuffer` from `valueBegin` to `valueEnd`, modifying the hash code by adding each character's value multiplied by 17.

**3. Function signature:** The function takes no parameters and returns an `int`.

**4. Examples:** 
- If `sort = INTERNAL`, `valueBegin = 0`, `valueEnd = 3`, `valueBuffer = ""abc""`, `ARRAY = 1`, `OBJECT = 1`: Output could be a computed hash code like 949.
- If `sort = ARRAY`, `valueBegin = 0`, `valueEnd = 0`, `valueBuffer = """"`, `ARRAY = 3`, `OBJECT = 2`: Output will be a base hash code like 39.

**5. Preconditions & Postconditions:** `sort`, `OBJECT`, `ARRAY`, `valueBegin`, `valueEnd`, and a proper `valueBuffer` should be appropriately initialized; the function returns a deterministic integer based on these parameters. No exceptions should be thrown if constraints are met.
---
```"
6367676c1a6d9265ec01820b,deleteAny,"public static String deleteAny(String inString,String charsToDelete){
  if (!hasLength(inString) || !hasLength(charsToDelete)) {
    return inString;
  }
  StringBuilder sb=new StringBuilder();
  for (int i=0; i < inString.length(); i++) {
    char c=inString.charAt(i);
    if (charsToDelete.indexOf(c) == -1) {
      sb.append(c);
    }
  }
  return sb.toString();
}
","/** 
 * Delete any character in a given String.
 * @param inString the original String
 * @param charsToDelete a set of characters to delete.E.g. ""az\n"" will delete 'a's, 'z's and new lines.
 * @return the resulting String
 */
",Delete characters that exists in the intersection between two character strings of the first character string and return the first character string that is modified.,"```
---
**1. One-line summary:** Removes specified characters from a string.

**2. Function behavior:** The function iterates over each character in the input string `inString` and appends any character not found in the `charsToDelete` string to a `StringBuilder` object to construct a new string where all occurrences of specified characters are removed.

**3. Function signature:** The function takes two parameters, `inString` (a string to be processed) and `charsToDelete` (a string containing characters to be removed) and returns a new string without the specified characters.

**4. Examples:** 
- Input: (""hello"", ""l""), Output: ""heo""
- Input: (""world"", ""xyz""), Output: ""world""
- Input: (""abracadabra"", ""ab""), Output: ""rcdr""

**5. Preconditions & Postconditions:** 
- Preconditions: `inString` and `charsToDelete` can be any strings, including empty strings.
- Postconditions: The output string will have all instances of characters found in `charsToDelete` removed from `inString`. If either input string is empty, the original `inString` is returned.
---
```"
636766861a6d9265ec01755a,match,"public final MatchResult match(CharSequence uri){
  if (uri == null || uri.length() == 0)   return (regexPattern == null) ? EMPTY_STRING_MATCH_RESULT : null;
 else   if (regexPattern == null)   return null;
  Matcher m=regexPattern.matcher(uri);
  if (!m.matches())   return null;
  return (groupIndexes.length > 0) ? new GroupIndexMatchResult(m) : m;
}
","/** 
 * Match a URI against the pattern.
 * @param uri the uri to match against the template.
 * @return the match result, otherwise null if no match occurs.
 */
","If the match between the url and the pattern occurs, return the match result. Otherwise, return null.","```
---
**1. One-line summary:** Matches a URI against a regex pattern and returns the match result.

**2. Function behavior:** This function checks if a given URI matches a pre-defined regex pattern. If the URI is null or empty and no pattern is defined, it returns an empty match result constant; otherwise, it returns null. If a regex pattern exists, it uses it to create a Matcher object for the URI. If the URI doesn't match, it returns null. If it matches, depending on the presence of group indexes, it returns a GroupIndexMatchResult or the matcher itself.

**3. Function signature:** The function takes a CharSequence `uri` as a parameter and returns a MatchResult object or null.

**4. Examples:** 
- Input: `match(null)`, regexPattern is undefined â Output: `EMPTY_STRING_MATCH_RESULT`
- Input: `match(""example"")`, regexPattern defined matches ""example"" â Output: `MatchResult`
- Input: `match(""nomatch"")`, regexPattern defined does not match ""nomatch"" â Output: `null`

**5. Preconditions & Postconditions:** Preconditions: The `uri` parameter can be null or any sequence of characters; the function relies on a pre-defined regexPattern and non-detailed groupIndexes. Postconditions: Output results vary based on matches; returns `null` for unmatched cases, and either `EMPTY_STRING_MATCH_RESULT` or a match result for successful matches.
---
```"
636766f91a6d9265ec01777d,convertHexDigit,"public static byte convertHexDigit(byte b){
  if ((b >= '0') && (b <= '9'))   return (byte)(b - '0');
  if ((b >= 'a') && (b <= 'f'))   return (byte)(b - 'a' + 10);
  if ((b >= 'A') && (b <= 'F'))   return (byte)(b - 'A' + 10);
  throw new IllegalArgumentException(""!hex:"" + Integer.toHexString(0xff & b));
}
","/** 
 * @param b An ASCII encoded character 0-9 a-f A-F
 * @return The byte value of the character 0-16.
 */
",Convert an ASCII encoded character to hex.,"```
---
**1. One-line summary:** Convert a hexadecimal digit to its byte value.
**2. Function behavior:** The function checks if a byte input is a valid hexadecimal digit ('0'-'9', 'a'-'f', 'A'-'F'), converts it to its numerical value, and returns the corresponding byte; if invalid, it throws an exception.
**3. Function signature:** The function takes a single byte `b` as input and returns a byte.
**4. Examples:** 
    - Input: (byte) '1'; Output: (byte) 1
    - Input: (byte) 'a'; Output: (byte) 10
    - Input: (byte) 'F'; Output: (byte) 15
**5. Preconditions & Postconditions:** Preconditions: The input `b` must be a single ASCII-encoded character. Postconditions: Returns the numerical byte representation for valid hex digits; throws an IllegalArgumentException for invalid inputs.
---
```"
636767861a6d9265ec01844c,removeAppender,"public void removeAppender(String name){
  if (name == null || appenderList == null)   return;
  int size=appenderList.size();
  for (int i=0; i < size; i++) {
    if (name.equals(((Appender)appenderList.elementAt(i)).getName())) {
      appenderList.removeElementAt(i);
      break;
    }
  }
}
","/** 
 * Remove the appender with the name passed as parameter form the list of appenders.  
 */
",Remove the appender by the given name from the list of appenders.,"---
**1. One-line summary:** Removes an appender from a list by its name.

**2. Function behavior:** The function iterates through a list of appenders, and if it finds an appender with a matching name, it removes that appender from the list and stops further iteration.

**3. Function signature:** The function takes a single String parameter `name` and returns void.

**4. Examples:** 
- Input: `removeAppender(""myAppender"")` with `appenderList` containing an appender named ""myAppender""; Output: ""myAppender"" is removed from `appenderList`.
- Input: `removeAppender(""nonExistingAppender"")` with `appenderList` not containing ""nonExistingAppender""; Output: `appenderList` remains unchanged.

**5. Preconditions & Postconditions:** Preconditions include `name` can be null, and `appenderList` should be initialized. The function does nothing if either `name` is null or `appenderList` is null. The function removes the first occurrence of an appender with the specified name, if it exists, and leaves the list unchanged if no match is found.
---"
6367670c1a6d9265ec017a2a,toPrimitive,"public static int[] toPrimitive(final Integer[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_INT_ARRAY;
  }
  final int[] result=new int[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].intValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Integers to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Integer</code> array, may be <code>null</code>
 * @return an <code>int</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Convert the given Integer array to primitives. Return ArrayUtils.EMPTY_INT_ARRAY for an empty array, return null for null array.","```
---
**1. One-line summary:** Converts an Integer array to a primitive int array.
**2. Function behavior:** The function checks if the input array is null, returning null if true; if the array is empty, it returns a predefined empty int array; otherwise, it iterates over the Integer array, converting each element to a primitive int and storing it in a new int array, which is then returned.
**3. Function signature:** The function takes a single parameter, an Integer array (Integer[]), and returns an int array (int[]).
**4. Examples:** 
   - Input: Integer[] array = {1, 2, 3}; Output: int[] = {1, 2, 3}
   - Input: Integer[] array = {}; Output: int[] = {}
   - Input: Integer[] array = {null}; Output: NullPointerException
   - Input: Integer[] array = null; Output: null
**5. Preconditions & Postconditions:** Preconditions include that the input can be a null Integer array; Postconditions are that the function returns a converted int array or null. The function will throw a NullPointerException if an individual element in the array is null.
---
```"
636767041a6d9265ec017911,register,"static void register(Object value){
  if (value != null) {
    Map m=getRegistry();
    if (m == null) {
      m=new WeakHashMap();
      REGISTRY.set(m);
    }
    m.put(value,null);
  }
}
","/** 
 * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>
 * @param value The object to register.
 */
",Register the value in REGISTRY if the value is not null.,"---
**1. One-line summary:** Registers a non-null object in a thread-local weak hashmap.  
**2. Function behavior:** The function checks if the provided value is non-null and then retrieves or initializes a thread-local WeakHashMap. The WeakHashMap is used to weakly reference objects, meaning that their memory will be reclaimed if no strong references exist. If the map does not exist, it is created; then, the value is added to this map with a null as its value.  
**3. Function signature:** The function takes a single parameter of type Object and returns void.  
**4. Examples:** 
    - Input: register(""example""); Outcome: The string ""example"" is added to the WeakHashMap associated with the current thread.
    - Input: register(null); Outcome: Nothing happens as the value is null.  
**5. Preconditions & Postconditions:** The input value must be non-null to be registered. If the thread-local registry map is null, it is initialized as a WeakHashMap. The function assumes that REGISTRY is a thread-local variable and it does not check for concurrency issues beyond this thread-local context. If executed with a null input, the function performs no operation.  
---"
636767511a6d9265ec017eb0,nonZeros,"public int nonZeros(int row){
  assert row >= 0 && row < rowOffsets.length;
  return rowOffsets[row + 1] - rowOffsets[row];
}
","/** 
 * Get the number of non-zero entries of a row.
 * @param row the row
 * @return the number of non-zero entries of a row
 */
",Return the number of non-zero entries of a row.,"---
**1. One-line summary:** Returns the number of non-zero elements in a specified row.

**2. Function behavior:** The function calculates the number of non-zero elements in a given row of a matrix represented in compressed row storage format by subtracting the row offset of the current row from the row offset of the next row.

**3. Function signature:** The function takes an integer `row` as a parameter, representing the index of the row, and returns an integer value.

**4. Examples:** 
- Input: `row = 2`, `rowOffsets = [0, 3, 6, 8, ...]`; Output: `2`
- Input: `row = 0`, `rowOffsets = [0, 3, 6, 8, ...]`; Output: `3`
- Input: `row = 1`, `rowOffsets = [0, 3, 6, 8, ...]`; Output: `3`

**5. Preconditions & Postconditions:** The function assumes the `row` index is valid and within the bounds of the `rowOffsets` array (0 <= `row` < `rowOffsets.length - 1`); otherwise, an assertion failure occurs. It expects `rowOffsets` to be a valid array with non-decreasing values. The output is an integer indicating the number of non-zero elements in the specified row.
---"
6367676c1a6d9265ec018223,containsInstance,"public static boolean containsInstance(Collection collection,Object element){
  if (collection != null) {
    for (    Object candidate : collection) {
      if (candidate == element) {
        return true;
      }
    }
  }
  return false;
}
","/** 
 * Check whether the given Collection contains the given element instance. <p>Enforces the given instance to be present, rather than returning <code>true</code> for an equal element as well.
 * @param collection the Collection to check
 * @param element the element to look for
 * @return <code>true</code> if found, <code>false</code> else
 */
",Check whether the element exists in the collection. ,"    ---
    **1. One-line summary:** Checks if a collection contains a specific instance of an element.
    **2. Function behavior:** Iterates through the collection and returns true if the reference of any element matches the given object; otherwise, returns false.
    **3. Function signature:** Takes a Collection and an Object as parameters and returns a boolean.
    **4. Examples:** Input: [1, 2, 3], element: 2. Output: false; Input: [""a"", new String(""a"")], element: ""a"". Output: true.
    **5. Preconditions & Postconditions:** The collection can be null; if null, returns false. Compares object references, not using equals().
    ---"
636766fa1a6d9265ec01779d,isAsciiControl,"public static boolean isAsciiControl(final char ch){
  return ch < 32 || ch == 127;
}
","/** 
 * <p>Checks whether the character is ASCII 7 bit control.</p> <pre> CharUtils.isAsciiControl('a')  = false CharUtils.isAsciiControl('A')  = false CharUtils.isAsciiControl('3')  = false CharUtils.isAsciiControl('-')  = false CharUtils.isAsciiControl('\n') = true CharUtils.isAsciiControl('&copy;') = false </pre>
 * @param ch  the character to check
 * @return true if less than 32 or equals 127
 */
",Check whether the character is ASCII 7 bit control.,"
---
**1. One-line summary:** Checks if a character is an ASCII control character.

**2. Function behavior:** The function returns true if the input character's ASCII value is less than 32 or equals 127, indicating it's a control character, and false otherwise.

**3. Function signature:** Takes a single `char` as input and returns a `boolean`.

**4. Examples:**
- Input: '\n' Output: true
- Input: 'A' Output: false
- Input: ' ' Output: false
- Input: 127 Output: true

**5. Preconditions & Postconditions:** Input is a valid character. Output is true for control characters and false otherwise. Does not handle non-char inputs.
---"
6367670b1a6d9265ec0179f2,containsKey,"@Override public boolean containsKey(final Object key){
  if (this.fast) {
    return this.map.containsKey(key);
  }
 else {
synchronized (this.map) {
      return this.map.containsKey(key);
    }
  }
}
","/** 
 * Return <code>true</code> if this map contains a mapping for the specified key.
 * @param key  the key to be searched for
 * @return true if the map contains the key
 */
",Check whether a map contains a mapping for the specified key.,"---
**1. One-line summary:** Checks for the presence of a key in a map.

**2. Function behavior:** The function checks if the specified key is present in the map. If `fast` is true, it directly checks using `map.containsKey(key)`. If not, it synchronizes on the map and then performs the check.

**3. Function signature:** The function takes one parameter `key` of type `Object` and returns a `boolean`.

**4. Examples:** Input: key = ""exampleKey""; Output: true/false based on map state.

**5. Preconditions & Postconditions:** The map must be initialized before calling this function. The function returns `true` if the key is found, otherwise `false`. It may fail if the key or map are null, leading to exceptions.
---"
636766fa1a6d9265ec017796,toObject,"public static Boolean[] toObject(final boolean[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;
  }
  final Boolean[] result=new Boolean[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i] ? Boolean.TRUE : Boolean.FALSE;
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive booleans to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>boolean</code> array
 * @return a <code>Boolean</code> array, <code>null</code> if null array input
 */
",Convert an array of primitive booleans to objects.,"```
---
**1. One-line summary:** Converts a boolean array to a Boolean object array.
**2. Function behavior:** The function converts a given primitive boolean array to an array of Boolean objects, returning null if the input array is null, or an empty Boolean object array if the input is empty.
**3. Function signature:** The function takes a single parameter, a boolean array, and returns a Boolean object array.
**4. Examples:** 
   Input: [true, false, true]
   Output: [Boolean.TRUE, Boolean.FALSE, Boolean.TRUE]

   Input: []
   Output: ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY

   Input: null
   Output: null
**5. Preconditions & Postconditions:** The input is a boolean array which can be null or empty, and the output is either null when the input is null, an empty Boolean object array when the input is empty, or a converted Boolean object array.
---
```"
636767aa1a6d9265ec01864a,toByteArray,"public byte[] toByteArray(){
  final int size=bytes.length;
  final byte[] copy=new byte[size];
  System.arraycopy(bytes,0,copy,0,size);
  return copy;
}
","/** 
 * Copies bytes to a  {@code byte[]}.
 */
",Copy bytes to a byte array.,"```
---
**1. One-line summary:** Creates and returns a copy of the byte array.

**2. Function behavior:** The function initializes a new byte array, 'copy', of the same length as the 'bytes' array, uses `System.arraycopy` to copy the contents of 'bytes' into 'copy', and returns 'copy'.

**3. Function signature:** The function takes no parameters and returns a byte array.

**4. Examples:** 
Input: (Assuming 'bytes' is `[1, 2, 3]`)
Output: `[1, 2, 3]`

**5. Preconditions & Postconditions:** 
Preconditions: The 'bytes' array must be initialized and should not be null.
Postconditions: Returns a new byte array that is an exact copy of the original 'bytes' array. If 'bytes' is empty, returns an empty byte array.
---
```"
636767561a6d9265ec017f7c,edgeSetToTour,"protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){
  List<V> vertices=new ArrayList<>(tour.size() + 1);
  MaskSubgraph<V,E> tourGraph=new MaskSubgraph<>(graph,v -> false,e -> !tour.contains(e));
  new DepthFirstIterator<>(tourGraph).forEachRemaining(vertices::add);
  return vertexListToTour(vertices,graph);
}
","/** 
 * Transform from a Set representation to a graph path.
 * @param tour a set containing the edges of the tour
 * @param graph the graph
 * @return a graph path
 */
",Convert a set representation to a graph path.,"```
---
**1. One-line summary:** Converts a set of edges into a tour path in a graph.

**2. Function behavior:** The function takes a set of edges representing a tour within a graph, creates a subgraph containing only those edges, performs a depth-first traversal to collect the vertices, and then constructs a tour from these vertices using another function.

**3. Function signature:** The function takes a Set<E> of edges and a Graph<V,E> as input parameters, and returns a GraphPath<V,E>.

**4. Examples:** 
   Input: tour = {e1, e2, e3}, graph = complete graph with vertices {v1, v2, v3, v4} 
   Output: tour path using vertices {v1, v2, v3, v1}
   
**5. Preconditions & Postconditions:** 
   - Preconditions: The input 'tour' should be a valid set of edges within the given 'graph'.
   - Postconditions: The function returns a GraphPath that represents a tour if possible; otherwise, the behavior depends on vertexListToTour's handling of incomplete tours.
---
```"
6367670a1a6d9265ec0179f1,toObject,"public static Short[] toObject(final short[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;
  }
  final Short[] result=new Short[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=new Short(array[i]);
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive shorts to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>short</code> array
 * @return a <code>Short</code> array, <code>null</code> if null array input
 */
",Convert an array of primitive shorts to objects.,"---
**1. One-line summary:** Converts a primitive short array to an array of Short objects.

**2. Function behavior:** The function checks if the input array is null, returning null if so. If the array is empty, it returns a predefined empty Short array. Otherwise, it converts each element of the input array into a Short object and stores them in a new array of Short objects, which is then returned.

**3. Function signature:** Takes a primitive short array as input (short[]) and returns an array of Short objects (Short[]).

**4. Examples:** 
- Input: [1, 2, 3] 
  Output: [Short(1), Short(2), Short(3)]
- Input: [] 
  Output: ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY

**5. Preconditions & Postconditions:** The input array must be potentially null or contain primitive short elements. If the input is null, the output is null. If the array is empty, the output is a predefined empty Short array. Otherwise, the output is a new array of Short objects corresponding to each element in the input array.
---"
6367676c1a6d9265ec018204,concatenateStringArrays,"public static String[] concatenateStringArrays(String[] array1,String[] array2){
  if (Objects.isEmpty(array1)) {
    return array2;
  }
  if (Objects.isEmpty(array2)) {
    return array1;
  }
  String[] newArr=new String[array1.length + array2.length];
  System.arraycopy(array1,0,newArr,0,array1.length);
  System.arraycopy(array2,0,newArr,array1.length,array2.length);
  return newArr;
}
","/** 
 * Concatenate the given String arrays into one, with overlapping array elements included twice. <p>The order of elements in the original arrays is preserved.
 * @param array1 the first array (can be <code>null</code>)
 * @param array2 the second array (can be <code>null</code>)
 * @return the new array (<code>null</code> if both given arrays were <code>null</code>)
 */
",Concatenate two string arrays into one.,"```
---
**1. One-line summary:** Concatenates two string arrays into one.
**2. Function behavior:** The function checks if either of the input arrays is empty; if so, it returns the non-empty array or an empty array. Otherwise, it combines both arrays into a new array with a length equal to the combined lengths of the two input arrays and returns this new array.
**3. Function signature:** The function takes two parameters, `array1` and `array2`, both of which are arrays of strings (`String[]`), and returns a new array of strings (`String[]`).
**4. Examples:** 
   - Input: `concatenateStringArrays(new String[]{""a"", ""b""}, new String[]{""c"", ""d""})` 
     Output: `new String[]{""a"", ""b"", ""c"", ""d""}`
   - Input: `concatenateStringArrays(new String[]{}, new String[]{""x"", ""y""})` 
     Output: `new String[]{""x"", ""y""}`
   - Input: `concatenateStringArrays(new String[]{""e"", ""f""}, new String[]{})` 
     Output: `new String[]{""e"", ""f""}`
   - Input: `concatenateStringArrays(new String[]{}, new String[]{})` 
     Output: `new String[]{}`
**5. Preconditions & Postconditions:** 
   - Preconditions: Input arrays can be null or empty; `Objects.isEmpty()` checks handle these cases.
   - Postconditions: Returns a new concatenated array or one of the original arrays if the other is empty; returns an empty array if both are empty.
---
```"
6367676a1a6d9265ec0181d4,addStringToArray,"public static String[] addStringToArray(String[] array,String str){
  if (Objects.isEmpty(array)) {
    return new String[]{str};
  }
  String[] newArr=new String[array.length + 1];
  System.arraycopy(array,0,newArr,0,array.length);
  newArr[array.length]=str;
  return newArr;
}
","/** 
 * Append the given String to the given String array, returning a new array consisting of the input array contents plus the given String.
 * @param array the array to append to (can be <code>null</code>)
 * @param str the String to append
 * @return the new array (never <code>null</code>)
 */
",Append a string to a string array.,"```
---
**1. One-line summary:** Appends a string to a string array.
**2. Function behavior:** The function checks if the input array is null or empty, creates a new array with one additional slot, copies the contents of the original array into it, adds the new string at the end, and returns the new array.
**3. Function signature:** Takes a string array `array` and a string `str` as input, returns a string array.
**4. Examples:** 
   - Input: `[""a"", ""b"", ""c""], ""d""` Output: `[""a"", ""b"", ""c"", ""d""]`
   - Input: `[], ""foo""` Output: `[""foo""]`
**5. Preconditions & Postconditions:** 
   - Preconditions: The `array` parameter can be null or a valid array of strings, `str` is a non-null string.
   - Postconditions: Returns a new array containing all elements of the input array plus the appended string; if input is null, returns an array with one element.
---
```"
6367676b1a6d9265ec0181dd,countOccurrencesOf,"public static int countOccurrencesOf(String str,String sub){
  if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {
    return 0;
  }
  int count=0;
  int pos=0;
  int idx;
  while ((idx=str.indexOf(sub,pos)) != -1) {
    ++count;
    pos=idx + sub.length();
  }
  return count;
}
","/** 
 * Returns the number of occurrences the substring  {@code sub} appears in string {@code str}.
 * @param str string to search in. Return 0 if this is null.
 * @param sub string to search for. Return 0 if this is null.
 * @return the number of occurrences the substring {@code sub} appears in string {@code str}.
 */
",Return the frequencies that the substring appears in the string.,"```
---
**1. One-line summary:** Counts the occurrences of a substring within a string.  
**2. Function behavior:** The function iteratively searches for a substring within a string, starting from the last found position, increments a counter each time the substring is found, and moves the search position to the end of the found substring until no more occurrences are found.  
**3. Function signature:** Takes two strings as parameters (the main string `str` and the substring `sub`) and returns an integer indicating the count of occurrences of `sub` in `str`.  
**4. Examples:**  
    countOccurrencesOf(""hello world"", ""o"") -> 2  
    countOccurrencesOf(""abababa"", ""aba"") -> 2  
    countOccurrencesOf(""aaaa"", ""aa"") -> 3  
    countOccurrencesOf(""abc"", ""d"") -> 0  
    countOccurrencesOf("""", ""a"") -> 0  
**5. Preconditions & Postconditions:**  
    Preconditions: Both `str` and `sub` are non-null strings; `sub` can be empty but will result in a count of 0.  
    Postconditions: Returns a non-negative integer representing the number of non-overlapping occurrences of `sub` in `str`; if either input is empty, returns 0.
---
```"
636766fe1a6d9265ec017821,appendDetail,"protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){
  buffer.append(arrayStart);
  for (int i=0; i < array.length; i++) {
    if (i > 0) {
      buffer.append(arraySeparator);
    }
    appendDetail(buffer,fieldName,array[i]);
  }
  buffer.append(arrayEnd);
}
","/** 
 * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>
 * @param buffer  the <code>StringBuffer</code> to populate
 * @param fieldName  the field name, typically not used as already appended
 * @param array  the array to add to the <code>toString</code>,not <code>null</code>
 */
",Append a byte array to a buffer.,"
---
**1. One-line summary:** Appends a byte array to a StringBuffer with start and end markers, separated by a delimiter.

**2. Function behavior:** The function iterates over each byte in the given array, appending it to the StringBuffer with a separator between elements, and wraps the entire sequence with specified start and end markers.

**3. Function signature:** `protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array)`

**4. Examples:** 
   - Input: `buffer = new StringBuffer(), fieldName = ""field"", array = new byte[]{1, 2, 3}`
   - Output: If `arrayStart = ""["", arraySeparator = "", "", arrayEnd = ""]""`, then `buffer.toString()` becomes `""[1, 2, 3]""`.

**5. Preconditions & Postconditions:** 
   - Preconditions: `arrayStart`, `arraySeparator`, and `arrayEnd` must be defined outside this function; `array` must not be null; `buffer` is already instantiated.
   - Postconditions: `buffer` is modified to include the string representation of the `array` with defined markers and separators."
636767561a6d9265ec017f63,hasNext,"@Override public boolean hasNext(){
  if (current != null) {
    return true;
  }
  current=advance();
  if (current != null && nListeners != 0) {
    fireVertexTraversed(createVertexTraversalEvent(current));
  }
  return current != null;
}
","/** 
 * Checks whether there exist unvisited vertices.
 * @return true if there exist unvisited vertices.
 */
","Check whether there are unvisited vertices. If so, return true. Otherwise, return false.","```
---
**1. One-line summary:** Checks if there is a next element in an iteration.

**2. Function behavior:** The function checks if the current element is non-null; if so, it returns true. Otherwise, it tries to advance to the next element by calling `advance()`. If the new `current` is not null and there are listeners (`nListeners` is not zero), it triggers the `fireVertexTraversed` method with a traversal event. The function ultimately returns true if there's a next element (`current` is not null), and false otherwise.

**3. Function signature:** The function has no parameters and returns a boolean indicating the presence of a next element.

**4. Examples:** N/A (The function's behavior depends on the internal state and operations of methods like `advance()` and `fireVertexTraversed()` which don't have explicit input-output examples in the given code.)

**5. Preconditions & Postconditions:** 
- Preconditions: `current`, `advance()`, `nListeners`, and `fireVertexTraversed()` should be properly defined and usable within the class context.
- Postconditions: Returns true if there's another element to iterate over, false otherwise; if an element is traversed, a traversal event may be fired.
---
```"
636766a81a6d9265ec017586,pop,"private void pop(final int elements){
  if (outputStackTop >= elements) {
    outputStackTop-=elements;
  }
 else {
    outputStackStart-=elements - outputStackTop;
    outputStackTop=0;
  }
}
","/** 
 * Pops the given number of abstract types from the output frame stack.
 * @param elements the number of abstract types that must be popped.
 */
",Pop the given number of elements from the stack.,"```
---
**1. One-line summary:** Adjusts stack pointers by a number of elements specified.

**2. Function behavior:** The function decreases `outputStackTop` by the `elements` count if it is sufficient, otherwise, adjusts `outputStackStart` by the difference and resets `outputStackTop` to zero.

**3. Function signature:** The function takes an integer parameter `elements` and returns void (no return value).

**4. Examples:**
   - Input: outputStackTop = 10, outputStackStart = 0, elements = 5; Output: outputStackTop = 5, outputStackStart = 0
   - Input: outputStackTop = 3, outputStackStart = 0, elements = 5; Output: outputStackTop = 0, outputStackStart = -2

**5. Preconditions & Postconditions:** 
   - Preconditions: `outputStackTop` and `outputStackStart` are initialized non-negative integers; `elements` is a non-negative integer.
   - Postconditions: `outputStackTop` and `outputStackStart` are adjusted; no return value.
   - Failure cases: Negative results on indices may occur, behavior with negative values is not specified.
---
```"
636767e11a6d9265ec018795,isCompatible,"public boolean isCompatible(DataTable dataset){
  final List<String> sortedKeys=dataset.sortedKeys(new HeatMap.KeyComparator(true));
  long[] existedBuckets=new long[sortedKeys.size()];
  for (int i=0; i < sortedKeys.size(); i++) {
    String key=sortedKeys.get(i);
    if (key.equals(Bucket.INFINITE_NEGATIVE)) {
      existedBuckets[i]=Long.MIN_VALUE;
    }
 else {
      if (key.contains("":"")) {
        key=StringUtils.substringAfterLast(key,"":"");
      }
      existedBuckets[i]=Long.parseLong(key);
    }
  }
  return Arrays.equals(buckets,existedBuckets);
}
","/** 
 * @return true if the bucket is same.
 */
",Check whether the existed buckets are the same as the buckets.,"```
---
**1. One-line summary:** Checks if dataset buckets match a predefined sequence.
**2. Function behavior:** The function retrieves sorted keys from a DataTable object, converting each to a long integer or special value for specific cases, and compares the sequence to a predefined array.
**3. Function signature:** The function takes a DataTable object as input and returns a boolean.
**4. Examples:** Input: dataset with keys [""1"", ""2:3"", ""-â""], Output: true/false depending on predefined buckets.
**5. Preconditions & Postconditions:** Preconditions: The dataset must have keys convertible to long or be a special case. Postconditions: Returns true if the converted keys match a predefined order, otherwise false.
---
```"
636767611a6d9265ec018112,provideNextVertex,"@Override protected V provideNextVertex(){
  V v=super.provideNextVertex();
  for (int i=path.size() - 1; i >= 0; --i) {
    if (graph.containsEdge(path.get(i),v)) {
      break;
    }
    path.remove(i);
  }
  path.add(v);
  return v;
}
","/** 
 * {@inheritDoc}
 */
",Get next vertext from a graph.,"---
**1. One-line summary:** Retrieves the next vertex and adjusts the path in a graph.  
**2. Function behavior:** The function calls its superclass method to get a vertex `v`, removes vertices from the path until an edge exists between the vertex at the current position in the path and `v`, then adds `v` to the path and returns it.  
**3. Function signature:** (): V (No parameters; returns a vertex of type V.)  
**4. Examples:**  
   - Input: path = [A, B, C], graph has edges (B, D), superclass provides D.  
     Output: Updated path = [A, B, D]. Returns D.  
   - Input: path = [X, Y, Z], graph has no edges to superclass's vertex U.  
     Output: Updated path = [], Returns U.  
**5. Preconditions & Postconditions:**  
   - Preconditions: `path` is a non-null list of vertices; `graph` is a non-null graph object; `super.provideNextVertex()` returns a non-null vertex `v`.  
   - Postconditions: The path is adjusted such that all subsequent vertices from a certain point have an edge to the newly added vertex; the updated path is non-empty, containing at least the newly added vertex.
---"
636767131a6d9265ec017b23,addLineNumber,"final void addLineNumber(final int lineNumber){
  if (this.lineNumber == 0) {
    this.lineNumber=(short)lineNumber;
  }
 else {
    if (otherLineNumbers == null) {
      otherLineNumbers=new int[LINE_NUMBERS_CAPACITY_INCREMENT];
    }
    int otherLineNumberIndex=++otherLineNumbers[0];
    if (otherLineNumberIndex >= otherLineNumbers.length) {
      int[] newLineNumbers=new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT];
      System.arraycopy(otherLineNumbers,0,newLineNumbers,0,otherLineNumbers.length);
      otherLineNumbers=newLineNumbers;
    }
    otherLineNumbers[otherLineNumberIndex]=lineNumber;
  }
}
","/** 
 * Adds a source line number corresponding to this label.
 * @param lineNumber a source line number (which should be strictly positive).
 */
",Add the number of lines. ,"---
**1. One-line summary:** This function assigns a line number to an object and manages additional line numbers in an array.

**2. Function behavior:** The function checks if the primary line number is uninitialized (0) and sets it; otherwise, it manages additional line numbers in an expandable array and adds the new line number at the appropriate index.

**3. Function signature:** The function takes an integer `lineNumber` as input and returns nothing.

**4. Examples:** 
Input: addLineNumber(5)  
Effect: Sets `this.lineNumber` to 5 if it was 0, otherwise adds 5 to `otherLineNumbers`.

**5. Preconditions & Postconditions:** Preconditions include that `lineNumber` should be a valid integer, and the function assumes `otherLineNumbers` is either null or properly initialized. Postconditions include that line numbers are properly stored, either in `lineNumber` or extended in `otherLineNumbers`, with capacity increments handled as needed. Failure can occur if memory allocation fails during the array expansion.
---"
636767dd1a6d9265ec0186f3,overrideName,"public void overrideName(String oldName,String newName){
  for (int i=0; i < columns.length; i++) {
    if (columns[i].equals(oldName)) {
      columns[i]=newName;
    }
  }
}
","/** 
 * Keep the same name replacement as  {@link ColumnName#overrideName(String,String)}
 * @param oldName to be replaced.
 * @param newName to use in the storage level.
 */
",Change the elements whose values are oldName to newName in column,"```
---
**1. One-line summary:** Replaces occurrences of old column names with new names in a list.
**2. Function behavior:** The function iterates over an array of column names, comparing each name to the specified old name; if a match is found, it replaces the old name with the new name.
**3. Function signature:** The function takes two String parameters, oldName and newName, with a void return type and modifies an existing array of Strings called columns.
**4. Examples:** 
   Input: columns = [""name"", ""age"", ""location""], oldName = ""age"", newName = ""years""
   Output: columns = [""name"", ""years"", ""location""]
   Input: columns = [""name"", ""age"", ""location""], oldName = ""gender"", newName = ""sex""
   Output: columns = [""name"", ""age"", ""location""]
**5. Preconditions & Postconditions:** 
   - Preconditions: columns is a non-null array of Strings.
   - Postconditions: Modifies the columns array in place, replacing all instances of oldName with newName; no change occurs if oldName is not found.
---
```"
636767631a6d9265ec018171,unlink,"private boolean unlink(ListNodeImpl<E> node){
  ListNodeImpl<E> prev=node.prev;
  ListNodeImpl<E> next=node.next;
  if (removeListNode(node)) {
    if (size == 0) {
      head=null;
    }
 else {
      link(prev,next);
      if (head == node) {
        head=next;
      }
    }
    return true;
  }
  return false;
}
","/** 
 * Remove the non null  {@code node} from the list. 
 */
","Remove the doubly circular linked list node.If success return true,otherwise return false.","---
**1. One-line summary:** Removes a node from a doubly linked list.

**2. Function behavior:** This function takes a node from a doubly linked list and attempts to remove it. It retrieves the node's previous and next nodes and calls `removeListNode` to remove the node from the list. If removed successfully, the function checks if the list is empty to set the head to null. Otherwise, it relinks the previous and next nodes using the `link` method and updates the head if required.

**3. Function signature:** The function takes a `ListNodeImpl<E>` node as a parameter and returns a boolean indicating the success of the removal operation.

**4. Examples:** 
- Input: `unlink(node)`; List: `node1 <-> node2 <-> node3`, where `node` is `node2`.
  Output: Returns `true`, List now: `node1 <-> node3`.
- Input: `unlink(node)`; List: `node1`, where `node` is `node1`.
  Output: Returns `true`, List now: empty.

**5. Preconditions & Postconditions:** 
- Preconditions: The input node must be part of a valid doubly linked list structure.
- Postconditions: The node is removed if it exists in the list, and the list is correctly relinked to exclude it.
- Failure cases: Returns `false` if `removeListNode` fails or if the node does not belong to the list. 
---"
6367676c1a6d9265ec018220,stripFilenameExtension,"public static String stripFilenameExtension(String path){
  if (path == null) {
    return null;
  }
  int extIndex=path.lastIndexOf(EXTENSION_SEPARATOR);
  if (extIndex == -1) {
    return path;
  }
  int folderIndex=path.lastIndexOf(FOLDER_SEPARATOR);
  if (folderIndex > extIndex) {
    return path;
  }
  return path.substring(0,extIndex);
}
","/** 
 * Strip the filename extension from the given path, e.g. ""mypath/myfile.txt"" -&gt; ""mypath/myfile"".
 * @param path the file path (may be <code>null</code>)
 * @return the path with stripped filename extension,or <code>null</code> if none
 */
",Return the path without the extension.,"```markdown
---
**1. One-line summary:** Remove the file extension from a given file path string.
**2. Function behavior:** The function removes the substring starting at the last occurrence of a period, used as an extension separator, in the provided path string unless the period is located before the last folder separator or no period is present.
**3. Function signature:** The function takes a single `String` parameter representing the file path and returns a `String`.
**4. Examples:** 
   Input: ""/home/user/file.txt"" 
   Output: ""/home/user/file""
   
   Input: ""/home.user/file"" 
   Output: ""/home.user/file""
   
   Input: ""file"" 
   Output: ""file""
**5. Preconditions & Postconditions:** The input path should be a valid string or null. If the path is null, the output will also be null. If the path does not contain an extension, or if the folder separator occurs after the last extension separator, the function will return the original path.
---
```"
636766fe1a6d9265ec017838,toPrimitive,"public static char[] toPrimitive(final Character[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_CHAR_ARRAY;
  }
  final char[] result=new char[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].charValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Characters to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Character</code> array, may be <code>null</code>
 * @return a <code>char</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Return a string which is consist of the values of elements in the given array.If array is equal to null,return null,or return ArrayUtils.EMPTY_CHAR_ARRAY if the size of array is equal to zero.","---
**1. One-line summary:** Converts an array of Character objects to a char array.

**2. Function behavior:** The function `toPrimitive` takes an array of `Character` objects and converts it to a primitive `char` array, returning null if the input is null, and an empty char array if the input is empty; otherwise, it iterates through the input array, using `charValue()` to extract the primitive char value from each `Character` object, populating the result array.

**3. Function signature:** `Character[] array` (Input: an array of `Character` objects), `returns` `char[]` (Output: a primitive char array).

**4. Examples:** 
   - Input: `[Character('a'), Character('b'), Character('c')]`; Output: `['a', 'b', 'c']`
   - Input: `[]`; Output: `[]`
   - Input: `null`; Output: `null`

**5. Preconditions & Postconditions:** 
   - Preconditions: The input is an array of `Character` objects, which can be null or non-null with possible null elements.
   - Postconditions: If the input is null, the function returns null; if the array is empty, it returns an empty char array; otherwise, it returns a char array containing the primitive values of the input `Character` objects.
---"
636766fa1a6d9265ec01779c,parseToken,"private String parseToken(final char[] terminators){
  char ch;
  i1=pos;
  i2=pos;
  while (hasChar()) {
    ch=chars[pos];
    if (isOneOf(ch,terminators)) {
      break;
    }
    i2++;
    pos++;
  }
  return getToken(false);
}
","/** 
 * Parses out a token until any of the given terminators is encountered.
 * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token
 * @return the token
 */
",Parses out a token until any of the given terminators is encountered and then return the token.,"```
---
**1. One-line summary:** Parses characters until a terminator is found.
**2. Function behavior:** The function `parseToken` iterates over a character array starting from a current position, `pos`, and advances `pos` and `i2` until a character matching any of the specified terminators is encountered or no more characters are available. Once a terminator is found or the end is reached, it returns a token through a call to `getToken(false)`, where `i1` marks the start and `i2` the end of the token.
**3. Function signature:** The function takes an array of characters `terminators` as input and returns a `String`.
**4. Examples:** 
   - Given `chars = {'a', 'b', 'c', 'x', 'y'}` and `terminators = {'x', 'y'}`, starting at `pos = 0`, it returns `""abc""`.
   - With `chars = {'1', '2', '3', ',', '4'}` and `terminators = {','}`, starting at `pos = 0`, it returns `""123""`.
**5. Preconditions & Postconditions:** The function assumes `chars` is a properly initialized array and that `pos` is within the bounds of `chars`. If `terminators` is empty, it processes until the end of `chars`. The behavior is undefined if `pos` is out of bounds. The returned string contains characters from `i1` to `i2` in `chars`.
---
```"
636767691a6d9265ec0181a7,trimLeadingCharacter,"public static String trimLeadingCharacter(String str,char leadingCharacter){
  if (!hasLength(str)) {
    return str;
  }
  StringBuilder sb=new StringBuilder(str);
  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {
    sb.deleteCharAt(0);
  }
  return sb.toString();
}
","/** 
 * Trim all occurrences of the supplied leading character from the given String.
 * @param str the String to check
 * @param leadingCharacter the leading character to be trimmed
 * @return the trimmed String
 */
","Trim all the characters which are equal to the given character and appear at the beginning of the given string,and return the trimmed string.","
---
**1. One-line summary:** Removes all leading occurrences of a specified character from a string.

**2. Function behavior:** The function checks if the given string is non-null and has content; if it does, it iterates through the string from the start, removing the specified leading character until encountering a different character or the string is empty.

**3. Function signature:** The function takes a `String str` and a `char leadingCharacter` as parameters and returns a `String`.

**4. Examples:**
   - Input: `(""###hello"", '#')` Output: `""hello""`
   - Input: `(""apple"", 'a')` Output: `""pple""`
   - Input: `(""banana"", 'b')` Output: `""anana""`
   - Input: `(""carrot"", 'x')` Output: `""carrot""`
   - Input: `("""", 'z')` Output: `""""`

**5. Preconditions & Postconditions:** The function assumes `str` is a valid string and `leadingCharacter` is a valid character. It returns the original string if it's empty or contains no leading instances of the specified character. If `str` is null or not of sufficient length as checked by `hasLength`, the function may not behave as intended without a defined `hasLength` method.
---"
636767041a6d9265ec01790f,toObject,"public static Integer[] toObject(final int[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;
  }
  final Integer[] result=new Integer[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=new Integer(array[i]);
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive ints to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  an <code>int</code> array
 * @return an <code>Integer</code> array, <code>null</code> if null array input
 */
",Return an array of Integer objects which are converted from an array of primitive ints.,"```
---
**1. One-line summary:** Converts a primitive int array to an Integer array.

**2. Function behavior:** The function takes an input array of primitive integers, checks for null and emptiness, and then iterates over the array converting each int element to an Integer object, storing the result in a new Integer array.

**3. Function signature:** Accepts one parameter: an array of `int` and returns an array of `Integer`.

**4. Examples:** 
   - Input: `int[] array = {1, 2, 3}`; Output: `Integer[] result = {1, 2, 3}`
   - Input: `int[] array = {}`; Output: `Integer[] result = ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY`
   - Input: `int[] array = null`; Output: `null`

**5. Preconditions & Postconditions:** The input array may be `null`, empty, or contain any integer. The function should return `null` for a null input, an empty array object for an empty array, and an Integer array with corresponding values for a non-empty input.
---
```"
636766fa1a6d9265ec0177a4,toObject,"public static Double[] toObject(final double[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;
  }
  final Double[] result=new Double[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=new Double(array[i]);
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive doubles to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>double</code> array
 * @return a <code>Double</code> array, <code>null</code> if null array input
 */
",Return an array of Double objects which are converted from an array of primitive doubles.,"```
---
**1. One-line summary:** Converts a primitive double array to a Double object array.
**2. Function behavior:** The function checks if the input array is null, returning null, then checks if it's empty, returning a constant empty Double array, otherwise it initializes a new Double array of the same length as the input and populates it with Double objects from the input array elements.
**3. Function signature:** The function takes a primitive double array as input and returns a Double object array.
**4. Examples:** 
   - Input: {1.0, 2.0, 3.0} -> Output: [1.0, 2.0, 3.0]
   - Input: {} -> Output: []
   - Input: null -> Output: null
**5. Preconditions & Postconditions:** Assumes input is a valid primitive double array or null, outputs a Double array equivalent or returns null if input is null; function fails when ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY is not defined or incorrect.
---
```"
636767461a6d9265ec017d0e,computeSuffixSum,"private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){
  List<Integer> suffixSum=new ArrayList<>(Collections.nCopies(bounds.size(),0));
  long sum=0;
  for (int i=bounds.size() - 1; i >= 0; i--) {
    suffixSum.set(i,(int)Math.min(Integer.MAX_VALUE,sum));
    sum+=bounds.get(i);
  }
  return Pair.of(suffixSum,sum);
}
","/** 
 * Computes a suffix sum of the  {@code bounds}. Returns computed suffix sum and the sum of all elements in the  {@code bounds list}.
 * @param bounds list of integers.
 * @return computed pair of suffix sum list and a sum of all elements.
 */
",Return a pair of the list of suffix sum and the sum of all elements of bounds.,"    ---
    **1. One-line summary:** Computes suffix sum array and total sum of a list of integers.

    **2. Function behavior:** The function creates a suffix sum list where each element at index `i` is the sum of the elements from index `i+1` to the end of the list `bounds`. It also calculates the total sum of the list. The suffix sum for the last element is always set to zero, and it attempts to cast each suffix sum element to an integer, capped at `Integer.MAX_VALUE`.

    **3. Function signature:** Accepts a list of integers `bounds` and returns a pair consisting of a list of integers and a long value.

    **4. Examples:** 
    - Input: `[1, 2, 3]` Output: `([5, 3, 0], 6)`
    - Input: `[4, 5, 6]` Output: `([11, 6, 0], 15)`
    - Input: `[100]` Output: `([0], 100)`

    **5. Preconditions & Postconditions:** 
    - Preconditions: The input list `bounds` contains integers and may be empty.
    - Postconditions: The output pair consists of a suffix sum list (each element cast to integer with a max of `Integer.MAX_VALUE`) and a long representing the total sum of the list.
    ---"
636767491a6d9265ec017d90,reverse,"public static final <V>void reverse(V[] arr,int from,int to){
  for (int i=from, j=to; i < j; ++i, --j) {
    swap(arr,i,j);
  }
}
","/** 
 * Reverses the order of the elements in the specified range within the given array.
 * @param < V > the type of elements in the array
 * @param arr the array
 * @param from the index of the first element (inclusive) inside the range to reverse
 * @param to the index of the last element (inclusive) inside the range to reverse
 */
",Reverse the order of the given elements in the specified range.,"---
**1. One-line summary:** Reverses a portion of an array in-place.

**2. Function behavior:** The function reverses the elements of an array between the indices 'from' and 'to', inclusive, by swapping elements symmetrically from both ends of the range until the middle is reached.

**3. Function signature:** The function takes an array of a generic type 'V', and two integers 'from' and 'to', indicating the start and end indices of the range to reverse; it has no return value.

**4. Examples:** 
- Example 1: Given arr: [1, 2, 3, 4], from: 1, to: 3, after execution: arr: [1, 4, 3, 2]
- Example 2: Given arr: ['a', 'b', 'c', 'd'], from: 0, to: 2, after execution: arr: ['c', 'b', 'a', 'd']

**5. Preconditions & Postconditions:** Preconditions: ""from"" and ""to"" must be valid indices within the array and ""from"" should be less than or equal to ""to"". Postconditions: The segment of the array from ""from"" to ""to"" will be reversed, while the rest of the array remains unchanged.
---"
6367674a1a6d9265ec017da9,moveAllListNodes,"private void moveAllListNodes(DoublyLinkedList<E> list){
  for (ListNodeIteratorImpl it=list.new ListNodeIteratorImpl(0); it.hasNext(); ) {
    ListNodeImpl<E> node=it.nextNode();
    assert node.list == list;
    node.list=this;
  }
  size+=list.size;
  list.size=0;
  modCount++;
  list.modCount++;
}
","/** 
 * Atomically moves all  {@link ListNode ListNodes} from {@code list} to this list as if eachnode was removed with  {@link #removeListNode(ListNodeImpl)} from {@code list} andsubsequently added to this list by  {@link #addListNode(ListNodeImpl)}.
 */
",Move the nodes of the given doubly linked list to a new list sequentially.,"    ---
    **1. One-line summary:** Move all nodes from one doubly linked list to another.
    **2. Function behavior:** The function iterates over all nodes in a given doubly linked list, updates their list reference to the current list, increments the size of the current list by the size of the given list, sets the given list's size to zero, and increases both lists' modification counts.
    **3. Function signature:** The function takes a `DoublyLinkedList<E>` as a parameter and returns `void`.
    **4. Examples:** 
    - Input: currentList = [1, 2, 3], list = [4, 5] 
      Output: currentList = [1, 2, 3, 4, 5], list = []
    - Input: currentList = [], list = [6, 7, 8] 
      Output: currentList = [6, 7, 8], list = []
    **5. Preconditions & Postconditions:** 
    - Preconditions: The list passed as an argument must not be null and should allow iteration from index 0.
    - Postconditions: After execution, all nodes will be part of the current list, the source list will be empty, and modification counts will be incremented.
    ---"
636767151a6d9265ec017b6b,startsWith,"private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){
  if (str == null || prefix == null) {
    return str == null && prefix == null;
  }
  if (prefix.length() > str.length()) {
    return false;
  }
  return str.regionMatches(ignoreCase,0,prefix,0,prefix.length());
}
","/** 
 * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>
 * @see String#startsWith(String)
 * @param str  the String to check, may be null
 * @param prefix the prefix to find, may be null
 * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.
 * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>
 */
","Return true if the given string has the specified prefix with optional cases which can be ignored,or both string and prefix are null.Otherwise return false. ","```
---
**1. One-line summary:** Checks if a string starts with a given prefix with optional case insensitivity.
**2. Function behavior:** The function determines if the input string `str` begins with the specified `prefix`. If either `str` or `prefix` is null, it returns true only if both are null. If `prefix` is longer than `str`, it returns false. Otherwise, it checks if `str` starts with `prefix`, considering case sensitivity as specified by `ignoreCase`.
**3. Function signature:** `startsWith(String str, String prefix, boolean ignoreCase) -> boolean`
**4. Examples:** 
   - Input: `(""HelloWorld"", ""Hello"", true)`, Output: `true`
   - Input: `(""HelloWorld"", ""hello"", false)`, Output: `false`
   - Input: `(null, null, true)`, Output: `true`
   - Input: `(""abc"", ""abcdef"", false)`, Output: `false`
**5. Preconditions & Postconditions:** 
   - Preconditions: `str` and `prefix` can be null.
   - Postconditions: Returns true if `str` starts with `prefix`, considering case sensitivity as per `ignoreCase`; otherwise, false.
---
```"
636766fe1a6d9265ec01781c,toCharacterObject,"public static Character toCharacterObject(final char ch){
  if (ch < CharUtils.CHAR_ARRAY.length) {
    return CharUtils.CHAR_ARRAY[ch];
  }
  return new Character(ch);
}
","/** 
 * <p>Converts the character to a Character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same Character object each time.</p> <pre> CharUtils.toCharacterObject(' ')  = ' ' CharUtils.toCharacterObject('A')  = 'A' </pre>
 * @param ch  the character to convert
 * @return a Character of the specified character
 */
",Return the Character object converted from the given character.,"```
---
**1. One-line summary:** Converts a primitive char to a Character object using a cache or a new instance.
**2. Function behavior:** The function checks if the given character can be found in a pre-defined CHAR_ARRAY and returns the corresponding Character object from this array; if not, it creates and returns a new Character object using the input character.
**3. Function signature:** Takes a single primitive char as input and returns a Character object.
**4. Examples:** 
   Input: 'a'  
   Output: Character object representing 'a'

   Input: '#'  
   Output: Character object representing '#'
**5. Preconditions & Postconditions:** 
   Preconditions: Input is a valid char, and the CharUtils.CHAR_ARRAY is properly defined.
   Postconditions: Returns a Character object; if ch is not found in CHAR_ARRAY, a new Character instance is guaranteed to be created.
---
```"
636766fb1a6d9265ec0177c1,isAsciiAlphaUpper,"public static boolean isAsciiAlphaUpper(final char ch){
  return ch >= 'A' && ch <= 'Z';
}
","/** 
 * <p>Checks whether the character is ASCII 7 bit alphabetic upper case.</p> <pre> CharUtils.isAsciiAlphaUpper('a')  = false CharUtils.isAsciiAlphaUpper('A')  = true CharUtils.isAsciiAlphaUpper('3')  = false CharUtils.isAsciiAlphaUpper('-')  = false CharUtils.isAsciiAlphaUpper('\n') = false CharUtils.isAsciiAlphaUpper('&copy;') = false </pre>
 * @param ch  the character to check
 * @return true if between 65 and 90 inclusive
 */
",Return true if the character is ASCII alphabetic upper case.Otherwise return false.,"---

**1. One-line summary:** Checks if a character is an uppercase ASCII letter.

**2. Function behavior:** The function returns true if the given character falls within the range of 'A' to 'Z' in the ASCII table, indicating it is an uppercase letter, otherwise returns false.

**3. Function signature:** The function takes a single character parameter `ch` of type `char`, and returns a boolean value `true` or `false`.

**4. Examples:** 
- Input: 'A' -> Output: true
- Input: 'Z' -> Output: true
- Input: 'a' -> Output: false
- Input: '1' -> Output: false

**5. Preconditions & Postconditions:** 
- Preconditions: The input is a valid single `char`.
- Postconditions: Returns `true` if 'A' <= character <= 'Z', `false` otherwise. 

---"
636767781a6d9265ec018250,decide,"public int decide(LoggingEvent event){
  String msg=event.getRenderedMessage();
  if (msg == null || stringToMatch == null)   return Filter.NEUTRAL;
  if (msg.indexOf(stringToMatch) == -1) {
    return Filter.NEUTRAL;
  }
 else {
    if (acceptOnMatch) {
      return Filter.ACCEPT;
    }
 else {
      return Filter.DENY;
    }
  }
}
","/** 
 * Returns  {@link Filter#NEUTRAL} is there is no string match.
 */
",Return a decision based on the message generated by the event and whether the given string is matched.,"---
**1. One-line summary:** The function filters logging events based on a message substring match.

**2. Function behavior:** The function checks if `msg` contains a specific substring `stringToMatch` and returns `Filter.ACCEPT` if `acceptOnMatch` is true, otherwise it returns `Filter.DENY`; returns `Filter.NEUTRAL` if there is no match or if `msg` or `stringToMatch` is null.

**3. Function signature:** The function takes a `LoggingEvent` object as a parameter and returns an integer representing a filter decision.

**4. Examples:** 
- Input: msg = ""Error: Connection lost"", stringToMatch = ""Error"", acceptOnMatch = true; Output: Filter.ACCEPT
- Input: msg = ""Warning: Low battery"", stringToMatch = ""Error"", acceptOnMatch = false; Output: Filter.NEUTRAL

**5. Preconditions & Postconditions:** `msg` and `stringToMatch` can be null; the function returns `Filter.NEUTRAL` if either is null or if no match is found; if a match is found, the return value depends on `acceptOnMatch`, being `Filter.ACCEPT` if true or `Filter.DENY` if false.
---"
636766861a6d9265ec017553,isTemplateVariablePresent,"public final boolean isTemplateVariablePresent(String name){
  for (  String s : templateVariables) {
    if (s.equals(name))     return true;
  }
  return false;
}
","/** 
 * Ascertain if a template variable is a member of this template.
 * @param name name The template variable.
 * @return true if the template variable is a member of the template, otherwisefalse.
 */
","Return true if the given name is a member variable of this template,otherwise return false.","
---
**1. One-line summary:** Checks if a specified string is present in a list of template variables.

**2. Function behavior:** Iterates over the `templateVariables` list, returning `true` if an element matches the given string name; otherwise, returns `false`.

**3. Function signature:** Accepts a `String` parameter `name` and returns a `boolean`.

**4. Examples:** 
- Input: `name = ""var1""`, `templateVariables = [""var1"", ""var2""]`; Output: `true`
- Input: `name = ""var3""`, `templateVariables = [""var1"", ""var2""]`; Output: `false`

**5. Preconditions & Postconditions:** 
- Preconditions: `templateVariables` is a list of strings.
- Postconditions: Returns `boolean` indicating presence (`true`) or absence (`false`) of `name` in `templateVariables`.
---"
6367670a1a6d9265ec0179d9,length,"public static int length(final String str){
  return str == null ? 0 : str.length();
}
","/** 
 * Gets a String's length or <code>0</code> if the String is <code>null</code>.
 * @param str a String or <code>null</code>
 * @return String length or <code>0</code> if the String is <code>null</code>.
 * @since 2.4
 */
","Return the given string's length.If the string is null,and zero will be returned.","```
---
**1. One-line summary:** Returns the length of a given string or 0 if null.
**2. Function behavior:** The function checks if the input string is null; if so, it returns 0. Otherwise, it returns the length of the string using the `length()` method.
**3. Function signature:** Takes a `String` as a parameter and returns an `int`.
**4. Examples:** 
   - Input: ""hello"" -> Output: 5
   - Input: """" -> Output: 0
   - Input: null -> Output: 0
**5. Preconditions & Postconditions:** 
   - Preconditions: The input can be any string, including null.
   - Postconditions: Returns an integer representing the length of the string or 0 if the string is null.
---
```"
636767ab1a6d9265ec018676,isHex,"private static boolean isHex(final char c){
  return ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F');
}
","/** 
 * Is this a hex digit?
 */
","Return true if the given character is a hex digit,otherwise return false.","```
---
**1. One-line summary:** Checks if a character is a valid hexadecimal digit.
**2. Function behavior:** The function returns true if the input character is between '0' and '9', 'a' and 'f', or 'A' and 'F'; otherwise, it returns false.
**3. Function signature:** Takes a char as input and returns a boolean.
**4. Examples:** 
   - Input: 'A' Output: true
   - Input: 'g' Output: false
   - Input: '3' Output: true
   - Input: 'G' Output: false
**5. Preconditions & Postconditions:** The input must be a single character, and the output will always be a boolean indicating the hex validity of that character.
---
```"
636766f11a6d9265ec017663,isSameLength,"public static boolean isSameLength(final double[] array1,final double[] array2){
  if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {
    return false;
  }
  return true;
}
","/** 
 * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array
 */
","Return true if the length of array1 is the same as the length of array2 or both them are null,otherwise return false.","```
---
**1. One-line summary:** Checks if two arrays of doubles have the same length or are both null.
**2. Function behavior:** The function returns true if both arrays are null or if they have the same number of elements; otherwise, it returns false.
**3. Function signature:** (double[] array1, double[] array2) -> boolean
**4. Examples:**
   isSameLength(new double[]{1.0, 2.0, 3.0}, new double[]{4.0, 5.0, 6.0}) -> true
   isSameLength(new double[]{1.0, 2.0}, new double[]{4.0, 5.0, 6.0}) -> false
   isSameLength(null, null) -> true
   isSameLength(new double[]{}, null) -> false
**5. Preconditions & Postconditions:** Assumes arrays are valid and may be null; returns true if both are null or have equal length, otherwise false.
---
```"
636767691a6d9265ec0181a6,split,"public static String[] split(String toSplit,String delimiter){
  if (!hasLength(toSplit) || !hasLength(delimiter)) {
    return null;
  }
  int offset=toSplit.indexOf(delimiter);
  if (offset < 0) {
    return null;
  }
  String beforeDelimiter=toSplit.substring(0,offset);
  String afterDelimiter=toSplit.substring(offset + delimiter.length());
  return new String[]{beforeDelimiter,afterDelimiter};
}
","/** 
 * Split a String at the first occurrence of the delimiter. Does not include the delimiter in the result.
 * @param toSplit the string to split
 * @param delimiter to split the string up with
 * @return a two element array with index 0 being before the delimiter, andindex 1 being after the delimiter (neither element includes the delimiter); or <code>null</code> if the delimiter wasn't found in the given input String
 */
","Split the given string toSplit at the first occurrence of the given delimiter,and return two substrings that don't include the delimiter.","---
**1. One-line summary:** Splits a string into two parts based on the first occurrence of a delimiter.

**2. Function behavior:** The function `split` checks if the input string `toSplit` and the `delimiter` are not empty. It finds the first occurrence of the `delimiter` in `toSplit`, and splits `toSplit` into two substrings: one before the `delimiter` and one after it. If the `delimiter` is not found, or if any inputs are invalid (empty or null), it returns null.

**3. Function signature:** The function takes two parameters: `String toSplit` and `String delimiter`. It returns a `String[]` containing two elements.

**4. Examples:** 
- Input: `split(""hello world"", "" "")` Output: `[""hello"", ""world""]`
- Input: `split(""apple-orange"", ""-"")` Output: `[""apple"", ""orange""]`
- Input: `split(""noDelimiterHere"", "","")` Output: `null`

**5. Preconditions & Postconditions:** 
- Preconditions: Both `toSplit` and `delimiter` must be non-null and non-empty strings.
- Postconditions: Returns an array of two strings split by the first occurrence of `delimiter`, or `null` if conditions are not met.
---"
636767601a6d9265ec0180e2,computeGlobalSeparatorList,"private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){
  List<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<>();
  for (  E edge : graph.edgeSet()) {
    V source=graph.getEdgeSource(edge);
    V target=graph.getEdgeTarget(edge);
    if (source != target) {
      List<Set<V>> edgeSeparators=findSeparators(graph,edge);
      globalSeparatorList.addAll(reformatSeparatorList(edgeSeparators,edge));
    }
  }
  return globalSeparatorList;
}
","/** 
 * Computes the global separator list of the  {@code graph}. More precisely, for every edge $e$ in the $G = (V, E)$ computes list of minimal separators $S_e$ in the neighborhood of $e$ and then concatenates these lists. Note: the result may contain duplicates
 * @return the list of minimal separators of every edge $e$ in the inspected graph
 */
","Select an edge which isn't a circle in the graph,compute the list of the minimal separators in the neighborhood of the edge and put the pair of list and edge into the return list.Repeat for each edge in the graph and then return the final list.","```
---
**1. One-line summary:** Computes a list of global separators for each non-loop edge in the graph.
**2. Function behavior:** Iterates over each edge in a graph, finds the separators for the edge if it is not a loop, reformats these separators along with the edge, and adds them to a global list.
**3. Function signature:** (No parameters) -> List<Pair<List<Pair<Integer,Integer>>,E>>
**4. Examples:** 
   Input: A graph object with edges and their corresponding vertices. 
   Output: A list of pairs, where each pair contains a list of edge separators formatted with the edge information.
**5. Preconditions & Postconditions:** 
   - Preconditions: Graph must be initialized with vertices and edges; findSeparators and reformatSeparatorList must be implemented.
   - Postconditions: Returns a list containing reformatted separators for each non-loop edge in the graph; returns an empty list if no separators are found.
---
```"
636766f31a6d9265ec01768f,clone,"public static char[] clone(final char[] array){
  if (array == null) {
    return null;
  }
  return array.clone();
}
","/** 
 * <p>Clones an array returning a typecast result and handling <code>null</code>.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */
",Return a clone of the given array.,"---
**1. One-line summary:** Clones an array of characters.

**2. Function behavior:** This function takes a character array as input, checks if it is null, and returns null if so; otherwise, it returns a new array that is an exact copy of the input array, maintaining the same elements in the same order.

**3. Function signature:** The function accepts a single parameter, `array`, which is a char array (`char[]`) and returns a char array (`char[]`).

**4. Examples:** 
- Input: `{'a', 'b', 'c'}` Output: `{'a', 'b', 'c'}`
- Input: `null` Output: `null`
- Input: `{'x', 'y', 'z'}` Output: `{'x', 'y', 'z'}`

**5. Preconditions & Postconditions:** The input can be a char array or null. If the input is null, the postcondition is that the output will also be null. If the input is a valid char array, the output will be a new array with identical contents. The function will not modify the input array and guarantees a separate copy of the input data.
---"
636766831a6d9265ec0174eb,addReverse,"private void addReverse(final File[] files){
  if (files == null)   return;
  for (int i=files.length - 1; i >= 0; --i) {
    stack.add(files[i]);
  }
}
","/** 
 * Add the specified files in reverse order.
 */
",Put the given array of files into a stack in reverse order. ,"```
---
**1. One-line summary:** Adds files to a stack in reverse order.

**2. Function behavior:** The function checks if the input array of files is null and returns if it is. It then iterates over the array from the last element to the first, adding each file to a stack object.

**3. Function signature:** The function takes an array of `File` objects as a parameter and returns void.

**4. Examples:** 
Input: [fileA, fileB, fileC]
Stack: Initially empty
After execution: Stack contains [fileC, fileB, fileA]

**5. Preconditions & Postconditions:** 
Preconditions: The input array may be null; stack must be initialized and accessible within the scope. 
Postconditions: Files are added to the stack in reverse order if the input is not null.
If array is null, the stack remains unchanged.
---
```"
636766fd1a6d9265ec017814,arrayequals,"public static boolean arrayequals(byte[] a,byte[] b,int count){
  for (int i=0; i < count; i++) {
    if (a[i] != b[i]) {
      return false;
    }
  }
  return true;
}
","/** 
 * Compares <code>count</code> first bytes in the arrays <code>a</code> and <code>b</code>.
 * @param a     The first array to compare.
 * @param b     The second array to compare.
 * @param count How many bytes should be compared.
 * @return <code>true</code> if <code>count</code> first bytes in arrays<code>a</code> and <code>b</code> are equal.
 */
","Given two arrays with the given length count,return true if the array a is equal to array b,otherwise return false.","```
---
**1. One-line summary:** Compares the first 'count' elements of two byte arrays for equality.
**2. Function behavior:** Iterates over the first 'count' elements of two byte arrays 'a' and 'b', checking for element-wise equality; returns false on the first mismatch, or true if all compared elements are equal.
**3. Function signature:** Takes two byte arrays 'a' and 'b', and an integer 'count'; returns a boolean value.
**4. Examples:** 
   Input: arrayequals([1, 2, 3], [1, 2, 3], 3) Output: true
   Input: arrayequals([1, 2, 3], [1, 3, 3], 2) Output: false
   Input: arrayequals([1, 2, 3], [1, 2, 4], 3) Output: false
**5. Preconditions & Postconditions:** Assumes 'count' is non-negative and does not exceed the length of the arrays. Returns false if any of the first 'count' elements differ between the two arrays; true if they are all equal.
---
```"
636767861a6d9265ec018440,abbreviate,"public void abbreviate(final int nameStart,final StringBuffer buf){
  int i=count;
  for (int pos=buf.indexOf(""."",nameStart); pos != -1; pos=buf.indexOf(""."",pos + 1)) {
    if (--i == 0) {
      buf.delete(nameStart,pos + 1);
      break;
    }
  }
}
","/** 
 * Abbreviate name.
 * @param buf buffer to append abbreviation.
 * @param nameStart start of name to abbreviate.
 */
","The given name can be split into several substrings by ""."",and abbreviate the name in the buf by deleting the first count substrings. ","
---
**1. One-line summary:** Abbreviates a string from a specified position by removing certain subsegments.

**2. Function behavior:** The function iterates over all periods (""."") in the `buf` from the `nameStart` index and removes the substring between `nameStart` and the nth period based on the global count variable.

**3. Function signature:** `public void abbreviate(final int nameStart, final StringBuffer buf)`

**4. Examples:** 
- Input: `nameStart=0`, `buf=""a.b.c.d.e""` with `count=2`
  Output: `buf=""c.d.e""`
- Input: `nameStart=2`, `buf=""x.y.z""` with `count=1`
  Output: `buf=""x.z""`
- Input: `nameStart=0`, `buf=""apple.banana.cherry""` with `count=1`
  Output: `buf=""banana.cherry""`

**5. Preconditions & Postconditions:** 
- Preconditions: `buf` must contain at least as many periods as the `count` value for the removal to occur; `nameStart` must be a valid index in `buf`.
- Postconditions: If successful, `buf` has part of its content removed; if the condition isn't met, `buf` remains unchanged."
6367667d1a6d9265ec01741d,resolveBound,"public static Type resolveBound(TypeVariable<?> typeVariable){
  Type[] bounds=typeVariable.getBounds();
  if (bounds.length == 0)   return Unknown.class;
  Type bound=bounds[0];
  if (bound instanceof TypeVariable)   bound=resolveBound((TypeVariable<?>)bound);
  return bound == Object.class ? Unknown.class : bound;
}
","/** 
 * Resolves the first bound for the  {@code typeVariable}, returning  {@code Unknown.class} if nonecan be resolved.
 */
","Resolve the class of the first bound for the typeVariable recursively,return Unknown.class if it can't be resolved.Otherwise return the bound.","---
**1. One-line summary:** Resolves the first bound of a TypeVariable, returning an Unknown class for Object.

**2. Function behavior:** The function retrieves the bounds of a TypeVariable, resolves it to an actual type, and defaults to Unknown if it is Object or no bounds exist.

**3. Function signature:** Takes a TypeVariable of any type and returns a Type.

**4. Examples:** 
Input: TypeVariable with bounds [String, Number]  
Output: String

Input: TypeVariable with bounds []  
Output: Unknown

**5. Preconditions & Postconditions:** The input must be a valid TypeVariable; if no bounds are present, it returns Unknown, and if a bound resolves to Object, it also returns Unknown.
---"
6367675f1a6d9265ec0180cf,isClique,"private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){
  for (  V v1 : vertices) {
    for (    V v2 : vertices) {
      if (!v1.equals(v2) && (graph.getEdge(v1,v2) == null)) {
        return false;
      }
    }
  }
  return true;
}
","/** 
 * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.
 * @param graph the graph.
 * @param vertices the vertices to induce the subgraph from.
 * @return true if the induced subgraph is a clique.
 */
","Return true if the subgraph of the given graph induced by the given vertices is a clique,otherwise return false.","---
**1. One-line summary:** Checks if a set of vertices forms a clique in an undirected graph.

**2. Function behavior:** The function iterates over all pairs of vertices within the given set, and for each pair, checks if there is an edge connecting them. If any pair is not directly connected by an edge, the function returns false. If all pairs are connected, it returns true, confirming that the set is a clique.

**3. Function signature:** The function takes a graph object `Graph<V,E>` and a set of vertices `Set<V>` as parameters and returns a boolean indicating whether the set forms a clique.

**4. Examples:** 
- Input: graph with edges (A-B, B-C, C-A), vertices: {A, B, C} -> Output: true
- Input: graph with edges (A-B, B-C), vertices: {A, B, C} -> Output: false

**5. Preconditions & Postconditions:** Preconditions include the existence of the graph object and the set of vertices being non-null. The function expects the graph to be undirected. Postconditions include returning true if every vertex in the set is connected to every other vertex, otherwise returning false. Failure cases involve missing edges between any pair in the set.
---"
636767431a6d9265ec017c88,computeLowerBounds,"private List<Integer> computeLowerBounds(List<K> keys){
  List<Integer> keyLowerBounds=new ArrayList<>(keys.size());
  for (  K key : keys) {
    int lowerBound=0;
    for (    Function<K,Integer> lowerBoundFunction : lowerBounds) {
      lowerBound=Math.max(lowerBound,lowerBoundFunction.apply(key));
    }
    keyLowerBounds.add(lowerBound);
  }
  return keyLowerBounds;
}
","/** 
 * Finds a maximum lower bound for every key.
 * @param keys list of keys.
 * @return the computed key lower bounds.
 */
","The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.","```
---
**1. One-line summary:** Computes the maximum lower bound for each key using provided functions.
**2. Function behavior:** The function iterates over a list of keys and computes the maximum lower bound for each key by using a set of functions that return an integer lower bound; these maximum lower bounds are stored in a list that is returned as the result.
**3. Function signature:** Takes a list of keys of type `K` and returns a list of integers.
**4. Examples:** 
   Input: keys = [key1, key2], lowerBounds = [f1, f2, f3]; f1(key1)=5, f2(key1)=3, f3(key1)=7, f1(key2)=2, f2(key2)=6, f3(key2)=4
   Output: [7, 6]
**5. Preconditions & Postconditions:** A non-null list of keys and list of functional lower bounds must be provided; the output is a list of integers representing the maximum lower bound for each key. If any function returns a null or an exception, the behavior is unspecified.
---
```"
636766a91a6d9265ec0175c4,pop,"private void pop(final String descriptor){
  char firstDescriptorChar=descriptor.charAt(0);
  if (firstDescriptorChar == '(') {
    pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);
  }
 else   if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {
    pop(2);
  }
 else {
    pop(1);
  }
}
","/** 
 * Pops as many abstract types from the output frame stack as described by the given descriptor.
 * @param descriptor a type or method descriptor (in which case its argument types are popped).
 */
",Pop different value of type based on the first character of the given descriptor.,"---
**1. One-line summary:** Determines how many items to pop from a stack based on a descriptor string.

**2. Function behavior:** The function analyzes the `descriptor` string's first character to determine stack pop operations; it pops multiple items based on function signature or double/long types and a single item otherwise.

**3. Function signature:** Takes a final `String descriptor` as input and uses it to perform stack operations; returns void.

**4. Examples:** 
- Input: ""(I)V"" (assumes Type.getArgumentsAndReturnSizes(""(I)V"") returns 5), Output: pop(0)
- Input: ""J"", Output: pop(2)
- Input: ""I"", Output: pop(1)

**5. Preconditions & Postconditions:** 
- Preconditions: `descriptor` is a valid Java method descriptor or type string.
- Postconditions: Correct number of items are popped from the stack; function does nothing if the descriptor doesn't fit expected types.
---"
636766fb1a6d9265ec0177c3,isAscii,"public static boolean isAscii(final char ch){
  return ch < 128;
}
","/** 
 * <p>Checks whether the character is ASCII 7 bit.</p> <pre> CharUtils.isAscii('a')  = true CharUtils.isAscii('A')  = true CharUtils.isAscii('3')  = true CharUtils.isAscii('-')  = true CharUtils.isAscii('\n') = true CharUtils.isAscii('&copy;') = false </pre>
 * @param ch  the character to check
 * @return true if less than 128
 */
","Return true if the given character is a ASCII seven bit character,otherwise return false.","```
---
**1. One-line summary:** Determines if a character is an ASCII character.

**2. Function behavior:** The function checks if the given character has a Unicode code point less than 128, indicating it is an ASCII character, and returns `true` if so, otherwise `false`.

**3. Function signature:** Takes a single `char` parameter and returns a `boolean`.

**4. Examples:** 
Input: 'A'; Output: true
Input: 'Ã±'; Output: false
Input: '7'; Output: true

**5. Preconditions & Postconditions:** 
- Preconditions: The input must be a valid `char`.
- Postconditions: Returns `true` for valid ASCII characters (code point 0-127), `false` otherwise.
---
```"
636767581a6d9265ec017fb4,computeUpperBounds,"private List<Integer> computeUpperBounds(List<K> keys){
  List<Integer> keyUpperBounds=new ArrayList<>(keys.size());
  for (  K key : keys) {
    int upperBound=Integer.MAX_VALUE;
    for (    Function<K,Integer> upperBoundFunction : upperBounds) {
      upperBound=Math.min(upperBound,upperBoundFunction.apply(key));
    }
    keyUpperBounds.add(upperBound);
  }
  return keyUpperBounds;
}
","/** 
 * Finds a minimum lower bound for every key.
 * @param keys a list of keys.
 * @return the computed key upper bound.
 */
","The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.","```
---
**1. One-line summary:** Computes a list of minimum upper bounds for each key in input list.
**2. Function behavior:** Iterates over each key, calculates its upper bound by finding the minimum result from applying a list of functions, then collects these bounds into a list.
**3. Function signature:** Accepts a List of generic type K (keys) and returns a List of Integers representing upper bounds.
**4. Examples:** Input: [key1, key2], upperBounds contain [func1, func2], Output: [min(func1(key1), func2(key1)), min(func1(key2), func2(key2))]
**5. Preconditions & Postconditions:** Preconditions: 'keys' is a non-null list, 'upperBounds' is a list of functions provided by the context/environment. Postconditions: Output list has the same size as 'keys'. Failures may occur if key application doesn't return an Integer.
---
```"
636766801a6d9265ec017487,encodeTemplateNames,"public static String encodeTemplateNames(String s){
  int i=s.indexOf('{');
  if (i != -1)   s=s.replace(""{"",""%7B"");
  i=s.indexOf('}');
  if (i != -1)   s=s.replace(""}"",""%7D"");
  return s;
}
","/** 
 * Encodes a string with template parameters names present, specifically the characters '{' and '}' will be percent-encoded.
 * @param s the string with zero or more template parameters names
 * @return the string with encoded template parameters names.
 */
","Encoding the given string by changing '{' and '}' to the specified character for each,return the string after encoding.","```
---
**1. One-line summary:** Encodes curly braces in a string with URL encoding.
**2. Function behavior:** The function replaces all occurrences of '{' with ""%7B"" and '}' with ""%7D"" in a given string by checking for their presence and using the replace method.
**3. Function signature:** Takes a single string parameter `s` and returns a modified string.
**4. Examples:** 
   - Input: ""Hello {world}"" Output: ""Hello %7Bworld%7D""
   - Input: ""NoBracesHere"" Output: ""NoBracesHere""
   - Input: ""Start{Middle}End"" Output: ""Start%7BMiddle%7DEnd""
**5. Preconditions & Postconditions:** Assumes input is a valid string; output is the same string with all '{' and '}' replaced with '%7B' and '%7D', respectively, or the original string if no braces are present.
---
```"
636767691a6d9265ec0181ac,applyRelativePath,"public static String applyRelativePath(String path,String relativePath){
  int separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);
  if (separatorIndex != -1) {
    String newPath=path.substring(0,separatorIndex);
    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {
      newPath+=FOLDER_SEPARATOR;
    }
    return newPath + relativePath;
  }
 else {
    return relativePath;
  }
}
","/** 
 * Apply the given relative path to the given path, assuming standard Java folder separation (i.e. ""/"" separators).
 * @param path the path to start from (usually a full file path)
 * @param relativePath the relative path to apply(relative to the full file path above)
 * @return the full file path that results from applying the relative path
 */
","Combine the substring before FOLDER_SEPARATOR of the given path with the given relative path to construct a new full file path,and return the full file path.","---
**1. One-line summary:** Concatenate a base path and a relative path appropriately.

**2. Function behavior:** The function locates the last folder separator in the base path, truncates it there, and appends the relative path, ensuring a single folder separator between them if necessary.

**3. Function signature:** (String path, String relativePath) -> String

**4. Examples:** 
- Input: `applyRelativePath(""/home/user/docs"", ""file.txt"")` Output: `""/home/user/file.txt""`
- Input: `applyRelativePath(""/home/user/docs/"", ""/file.txt"")` Output: `""/home/user/docs/file.txt""`
- Input: `applyRelativePath(""docs"", ""file.txt"")` Output: `""file.txt""`

**5. Preconditions & Postconditions:** 
- Preconditions: `path` and `relativePath` are valid strings. `FOLDER_SEPARATOR` is defined.
- Postconditions: Result is a combined path or just the relative path if no separator is found. Return may not be a valid path if inputs do not represent proper paths.
---"
636767021a6d9265ec0178bc,indexOf,"public static int indexOf(String str,String searchStr){
  if (str == null || searchStr == null) {
    return StringUtils.INDEX_NOT_FOUND;
  }
  return str.indexOf(searchStr);
}
","/** 
 * Finds the first index within a String, handling <code>null</code>. This method uses  {@link String#indexOf(String)}. 
 */
",Return the first index of the searchStr in the given string.,"```
---
**1. One-line summary:** Find the index of the first occurrence of a substring.

**2. Function behavior:** The function returns the index of the first occurrence of `searchStr` in `str`, or returns `INDEX_NOT_FOUND` if either string is null or if the substring is not found.

**3. Function signature:** The function takes two `String` parameters (`str` and `searchStr`) and returns an `int`.

**4. Examples:** 
Input: (""hello world"", ""world"") Output: 6
Input: (""hello world"", ""moon"") Output: -1
Input: (null, ""world"") Output: -1
Input: (""hello world"", null) Output: -1

**5. Preconditions & Postconditions:** The function assumes `str` and `searchStr` can be null; it will not perform a search if either is null but will directly return `INDEX_NOT_FOUND`. If the substring is not found within the string, the function returns `INDEX_NOT_FOUND`.
---
```"
636766fc1a6d9265ec0177ef,toNoNullStringArray,"static String[] toNoNullStringArray(Object[] array){
  ArrayList<String> list=new ArrayList<String>(array.length);
  for (int i=0; i < array.length; i++) {
    Object e=array[i];
    if (e != null) {
      list.add(e.toString());
    }
  }
  return (String[])list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);
}
","/** 
 * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}if an array element is <code>null</code>.
 * @param array The array to check
 * @return The given array or a new array without null.
 */
","Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.","```
---
**1. One-line summary:** Converts a given array of objects to a string array, excluding nulls.
**2. Function behavior:** The function iterates through an array of objects, converts non-null objects to their string representation, and collects them into an ArrayList which is then converted to a string array using ArrayUtils.EMPTY_STRING_ARRAY.
**3. Function signature:** The function takes a single parameter, an Object array, and returns a String array.
**4. Examples:**
   - Input: [1, null, ""hello""] Output: [""1"", ""hello""]
   - Input: [null, null, null] Output: []
   - Input: [""a"", ""b"", null] Output: [""a"", ""b""]
**5. Preconditions & Postconditions:** 
   - Preconditions: The input is an array that can contain objects of various types, including null.
   - Postconditions: The function returns a new array of strings with all non-null elements converted to strings; null elements are omitted.
---
```"
636767061a6d9265ec01794a,indexOfExtension,"public static int indexOfExtension(String filename){
  if (filename == null) {
    return -1;
  }
  int extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);
  int lastSeparator=indexOfLastSeparator(filename);
  return lastSeparator > extensionPos ? -1 : extensionPos;
}
","/** 
 * Returns the index of the last extension separator character, which is a dot. <p> This method also checks that there is no directory separator after the last dot. To do this it uses  {@link #indexOfLastSeparator(String)} which willhandle a file in either Unix or Windows format. <p> The output will be the same irrespective of the machine that the code is running on.
 * @param filename  the filename to find the last path separator in, null returns -1
 * @return the index of the last separator character, or -1 if thereis no such character
 */
","Return the last index of the extension separator in the given filename,it will return -1 if the filename doesn't have the separator or there is a directory separator after it.","```
---
**1. One-line summary:** Finds the index of the extension in a filename.

**2. Function behavior:** The function returns the index of the last occurrence of a period `.` in the given filename if it indicates the start of an extension, provided that it occurs after the last path separator in the filename; otherwise, it returns -1.

**3. Function signature:** `public static int indexOfExtension(String filename)` where `filename` is a String representing the filename to check, and it returns an integer indicating the index of the extension's starting position, or -1 if there's no valid extension.

**4. Examples:**
   - If input is `""file.txt""`, output is `4`.
   - If input is `""archive.tar.gz""`, output is `10`.
   - If input is `""file""`, output is `-1`.
   - If input is `null`, output is `-1`.
   - If input is `""a/b/file""`, output is `-1`.

**5. Preconditions & Postconditions:** Preconditions include `filename` being a valid string or null. The function expects to handle possible null input gracefully. The function returns an integer representing the position of the period marking the start of an extension, or -1 if there is no such extension present. Postconditions ensure that results are accurate based on the presence and position of periods in the input string, considering path separators.
---
```"
636767dd1a6d9265ec0186de,isExpired,"public boolean isExpired(long timestamp,long expiredThreshold){
  return timestamp - lastUpdateTimestamp > expiredThreshold;
}
","/** 
 * @param timestamp        of current time
 * @param expiredThreshold represents the duration between last update time and the time point removing from cache.
 * @return true means this metrics should be removed from cache.
 */
","Return true if the timestamp minus the lastUpdateTimestamp is greater than expiredThreshold,otherwise return false.","---
**1. One-line summary:** Checks if a timestamp is sufficiently outdated.

**2. Function behavior:** The function compares a given `timestamp` with a global `lastUpdateTimestamp` variable and returns `true` if the difference is greater than the `expiredThreshold`, indicating that the timestamp is considered expired.

**3. Function signature:** Parameters are `long timestamp` and `long expiredThreshold`; it returns a `boolean`.

**4. Examples:** 
- Input: `timestamp = 1000, expiredThreshold = 500, lastUpdateTimestamp = 400`
  Output: `true`
- Input: `timestamp = 1000, expiredThreshold = 700, lastUpdateTimestamp = 400`
  Output: `false`

**5. Preconditions & Postconditions:** 
- Preconditions: `timestamp`, `expiredThreshold`, and `lastUpdateTimestamp` are positive long integers.
- Postconditions: Returns `true` if the `timestamp - lastUpdateTimestamp` exceeds `expiredThreshold`; otherwise, returns `false`.
---"
6367675d1a6d9265ec018082,edgeToNext,"Edge edgeToNext(){
  Edge edge=prev.embedded.getFirst();
  Node target=toExistingNode(current);
  Node source=toExistingNode(prev);
  if (edge.getOpposite(source) == target) {
    return edge;
  }
 else {
    return prev.embedded.getLast();
  }
}
","/** 
 * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.
 * @return an edge from the current node to the next node
 */
",Return the edge connecting the previously returned node with the current node.,"```
---
**1. One-line summary:** Return the first edge leading from 'prev' to 'current' or the last edge otherwise.
**2. Function behavior:** The function retrieves the first edge from 'prev.embedded', checks if it leads from the 'prev' node to the 'current' node, and returns it; otherwise, it returns the last edge.
**3. Function signature:** The function takes no parameters and returns an 'Edge' object.
**4. Examples:** 
   - If 'prev.embedded.getFirst()' is an edge from 'prev' to 'current', return 'prev.embedded.getFirst()'.
   - If 'prev.embedded.getFirst()' is not an edge to 'current', return 'prev.embedded.getLast()'.
**5. Preconditions & Postconditions:** 
   - Preconditions: 'prev' and 'current' are valid references; 'prev.embedded' contains at least one edge.
   - Postconditions: Returns an 'Edge' instance, either the first or the last in 'prev.embedded'.
---
```"
6367676b1a6d9265ec0181e9,substringMatch,"public static boolean substringMatch(CharSequence str,int index,CharSequence substring){
  for (int j=0; j < substring.length(); j++) {
    int i=index + j;
    if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {
      return false;
    }
  }
  return true;
}
","/** 
 * Returns  {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.
 * @param str the original string (or StringBuilder)
 * @param index the index in the original string to start matching against
 * @param substring the substring to match at the given index
 * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.
 */
","Return true if starting at the given index,the given string matches the given substring.Otherwise return false.","---
**1. One-line summary:** Checks if a substring matches a portion of a string starting at a given index.

**2. Function behavior:** The function iterates over each character of the substring and compares it to the corresponding character in the main string, offset by the provided index. If any character comparison fails or if the index exceeds the main string's length, it returns false. If all characters match, it returns true.

**3. Function signature:** It takes a `CharSequence` as the main string, an `int` as the starting index, and another `CharSequence` as the substring; returns a `boolean`.

**4. Examples:** 
- Input: (""hello"", 1, ""ell"") -> Output: true
- Input: (""hello"", 2, ""llo"") -> Output: true
- Input: (""hello"", 3, ""lo"") -> Output: true
- Input: (""hello"", 3, ""oo"") -> Output: false
- Input: (""hello"", 5, ""o"") -> Output: false

**5. Preconditions & Postconditions:** 
- Preconditions: `index` must be within the bounds of `str`; `str` and `substring` should not be null.
- Postconditions: Returns true if the substring completely matches the portion of the string starting at the given index; false otherwise.
---"
6367670b1a6d9265ec017a05,toString,"public static String toString(final char ch){
  if (ch < 128) {
    return CharUtils.CHAR_STRING_ARRAY[ch];
  }
  return new String(new char[]{ch});
}
","/** 
 * <p>Converts the character to a String that contains the one character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same String object each time.</p> <pre> CharUtils.toString(' ')  = "" "" CharUtils.toString('A')  = ""A"" </pre>
 * @param ch  the character to convert
 * @return a String containing the one specified character
 */
",Return the String object that contains the given character.,"
---
**1. One-line summary:** Converts a character to its string representation using a pre-defined array for ASCII characters.

**2. Function behavior:** If the character is an ASCII character (less than 128), it returns a pre-existing string representation from the CHAR_STRING_ARRAY; otherwise, it returns a new string created from the character.

**3. Function signature:** The function takes a single character (char ch) as a parameter and returns a String.

**4. Examples:** 
   - Input: `'A'` (ASCII) -> Output: `""A""`
   - Input: `'Ã±'` (non-ASCII) -> Output: `""Ã±""`

**5. Preconditions & Postconditions:** 
   - Preconditions: The input is a single character.
   - Postconditions: The output is a string containing the character.
   - Expected behavior: Efficient conversion for ASCII characters using a pre-existing array.
   - Failure cases: None for valid input; undefined behavior if CHAR_STRING_ARRAY is improperly defined for ASCII characters.
---"
636767a31a6d9265ec01854f,checkIfPackedField,"private void checkIfPackedField() throws IOException {
  if (packedLimit == 0 && WireFormat.getTagWireType(lastTag) == WIRETYPE_LENGTH_DELIMITED) {
    final int length=readRawVarint32();
    if (length < 0)     throw ProtobufException.negativeSize();
    this.packedLimit=getTotalBytesRead() + length;
  }
}
","/** 
 * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that packed fields are being read.
 * @throws IOException
 */
","Check if the field should be packed,if so,read the field and update the internal state. It will throw an exception when the process of reading is wrong.","```
---
**1. One-line summary:** Checks if the current field is a packed repeated field in a Protocol Buffers message.
**2. Function behavior:** This function verifies if the current field is packed by checking if `packedLimit` is 0 and if the last tag's wire type is `WIRETYPE_LENGTH_DELIMITED`. If these conditions are met, it reads the packed field's length with `readRawVarint32()`, throws an exception if the length is negative, and sets `packedLimit` to the sum of the total bytes read and this length.
**3. Function signature:** The function takes no parameters and returns void; it throws an IOException.
**4. Examples:** If `packedLimit = 0`, `lastTag` is of `WIRETYPE_LENGTH_DELIMITED`, and reading the length yields 10, then `packedLimit` is set to 10 plus the current total bytes read.
**5. Preconditions & Postconditions:** Preconditions include `packedLimit` initially being 0 and the function operates correctly when `lastTag` is `WIRETYPE_LENGTH_DELIMITED`. Postcondition sets `packedLimit` correctly based on field length. If negative size occurs, a `ProtobufException` is thrown.
---
```"
636767a81a6d9265ec0185fc,readTag,"public int readTag() throws IOException {
  if (!buffer.hasRemaining()) {
    lastTag=0;
    return 0;
  }
  final int tag=readRawVarint32();
  if (tag >>> TAG_TYPE_BITS == 0) {
    throw ProtobufException.invalidTag();
  }
  lastTag=tag;
  return tag;
}
","/** 
 * Attempt to read a field tag, returning zero if we have reached EOF. Protocol message parsers use this to read tags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.
 */
","Return a field tag, and if reach the EOF the tag will be zero.It will throw an exception when the tag is equal to zero after logical shift right  TAG_TYPE_BITS.","
---
**1. One-line summary:** Reads and returns the next protocol buffer tag from the buffer.

**2. Function behavior:** This function reads a 32-bit integer tag from a buffer and checks if it is valid according to protocol buffer tag rules. If no remaining bytes exist in the buffer, it sets `lastTag` to 0 and returns 0. Otherwise, it retrieves the next raw varint32 from the buffer and checks if the tag is valid by verifying that it has a meaningful tag type. An exception is thrown for invalid tags. If valid, it updates `lastTag` to the tag and returns it.

**3. Function signature:** The function takes no parameters and returns an integer.

**4. Examples:** 
- Input: Buffer is empty, Output: 0
- Input: Buffer has remaining valid tag, Output: (valid tag value, e.g., 1234)
- Input: Buffer has invalid tag, Output: IOException is thrown

**5. Preconditions & Postconditions:** 
- Preconditions: A buffer object with a method `hasRemaining()` to check for remaining data, and `readRawVarint32()` to read the next integer. 
- Postconditions: Outputs 0 if the buffer is empty, updates and returns a valid tag if present, or throws an exception if the tag is invalid.
---"
636766a81a6d9265ec017595,put11,"final ByteVector put11(final int byteValue1,final int byteValue2){
  int currentLength=length;
  if (currentLength + 2 > data.length) {
    enlarge(2);
  }
  byte[] currentData=data;
  currentData[currentLength++]=(byte)byteValue1;
  currentData[currentLength++]=(byte)byteValue2;
  length=currentLength;
  return this;
}
","/** 
 * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.
 * @param byteValue1 a byte.
 * @param byteValue2 another byte.
 * @return this byte vector.
 */
",Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.,"    ---
    **1. One-line summary:** Appends two bytes to the ByteVector data array, resizing if needed.
    **2. Function behavior:** The function checks if there is enough space in the data array to add two bytes; if not, it enlarges the array. Then, it adds the two bytes to the current end of the array, updates the length, and returns the ByteVector object.
    **3. Function signature:** Accepts two integer parameters `byteValue1` and `byteValue2` representing the byte values to add, and returns the modified `ByteVector` object.
    **4. Examples:** Input: byteValue1=5, byteValue2=10; Output: ByteVector with two new bytes added.
    **5. Preconditions & Postconditions:** Preconditions: `byteValue1` and `byteValue2` must be valid byte values (0-255); Postconditions: The data array contains the appended bytes, and if there was insufficient space, the array is resized.
    ---"
636766ae1a6d9265ec0175d8,buildContentRange,"private String buildContentRange(){
  Integer limit=drc.getLimit() == null ? getDefaultNumberPagination() - 1 : drc.getLimit();
  Integer offset=drc.getOffset() == null ? 0 : drc.getOffset();
  Long count=drc.getCount() == null ? 0 : drc.getCount();
  return offset + ""-"" + (limit.equals(0) ? count - 1 : limit)+ ""/""+ count;
}
","/** 
 * Build the 'Content-Range' HTTP Header value.
 * @return 'Content-Range' value
 */
","Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.","---
**1. One-line summary:** Constructs a content range string for pagination.

**2. Function behavior:** The function calculates pagination parameters offset and limit, then returns a string that represents the range of items and total count in the format ""start-end/total"".

**3. Function signature:** No parameters; returns a `String`.

**4. Examples:** 
- If drc.getLimit() is 50, drc.getOffset() is 0, drc.getCount() is 200, then output is ""0-49/200"".
- If drc.getLimit() is null, drc.getOffset() is null, drc.getCount() is 150, and getDefaultNumberPagination() is 100, then output is ""0-99/150"".
- If drc.getLimit() is 0, drc.getOffset() is 10, drc.getCount() is 0, then output is ""10--1/0"".

**5. Preconditions & Postconditions:** 
- Preconditions: Assumes `drc.getLimit()`, `drc.getOffset()`, and `drc.getCount()` return `Integer` or `Long` objects, which may be null.
- Postconditions: Returns a formatted string representing the pagination range: start-end/total, defaults to start as 0 and end as default pagination - 1 if limits and offset are null, failure to retrieve `getCount()` results in ""start--1/0"" when `limit` is 0.
---"
