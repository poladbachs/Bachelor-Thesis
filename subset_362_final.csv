_id,name,code,docstring,human_label,one_line_summary,function_behavior,function_signature,examples,precond_postcond,candidate,exit_code,generated_by
6367676d1a6d9265ec018229,trimArrayElements,"public static String[] trimArrayElements(String[] array){
  if (Objects.isEmpty(array)) {
    return new String[0];
  }
  String[] result=new String[array.length];
  for (int i=0; i < array.length; i++) {
    String element=array[i];
    result[i]=(element != null ? element.trim() : null);
  }
  return result;
}
","/** 
 * Trim the elements of the given String array, calling <code>String.trim()</code> on each of them.
 * @param array the original String array
 * @return the resulting array (of the same size) with trimmed elements
 */
",Trim each element in the given string array and return the resulting array.,Trims whitespace from each element of an array.,"The function trims leading and trailing whitespace from each string in the input array. If the array or its elements are null, it returns an empty string or null respectively.","@param array String[]: The input array of strings to be trimmed.
@return String[]: A new array with trimmed strings.","[""  hello "", "" world  ""] -> [""hello"", ""world""] (trims spaces)
[""foo"", ""bar""] -> [""foo"", ""bar""] (no spaces to trim)
null -> [] (handles null input)","Input array may contain null elements and will be safely handled, resulting in trimmed strings or nulls in the output.","public static String[] trimArrayElements(String[] array){
  if (Objects.isEmpty(array)) {
    return new String[0];
  }
  String[] result=new String[array.length];
  for (int i=0; i < array.length; i++) {
    String element=array[i];
    result[i]=(element != null ? element.trim() : null);
  }
  return result;
}
",0,reference
6367676d1a6d9265ec018229,trimArrayElements,"public static String[] trimArrayElements(String[] array){
  if (Objects.isEmpty(array)) {
    return new String[0];
  }
  String[] result=new String[array.length];
  for (int i=0; i < array.length; i++) {
    String element=array[i];
    result[i]=(element != null ? element.trim() : null);
  }
  return result;
}
","/** 
 * Trim the elements of the given String array, calling <code>String.trim()</code> on each of them.
 * @param array the original String array
 * @return the resulting array (of the same size) with trimmed elements
 */
",Trim each element in the given string array and return the resulting array.,Trims whitespace from each element of an array.,"The function trims leading and trailing whitespace from each string in the input array. If the array or its elements are null, it returns an empty string or null respectively.","@param array String[]: The input array of strings to be trimmed.
@return String[]: A new array with trimmed strings.","[""  hello "", "" world  ""] -> [""hello"", ""world""] (trims spaces)
[""foo"", ""bar""] -> [""foo"", ""bar""] (no spaces to trim)
null -> [] (handles null input)","Input array may contain null elements and will be safely handled, resulting in trimmed strings or nulls in the output.","public static String[] trimArrayElements(String[] array){
    int arrayLength = array.length;
    String[] newArray = new String[arrayLength];
    for (int index = 0; index < arrayLength; index++) {
        newArray[index] = array[index].trim();
    }
    return newArray;
}",1,CodeLlama-7b-Instruct-hf
6367670b1a6d9265ec017a00,isSameLength,"public static boolean isSameLength(final byte[] array1,final byte[] array2){
  if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {
    return false;
  }
  return true;
}
","/** 
 * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array
 */
",Check whether the length of the given two byte arrays is the same.,Checks if two byte arrays have the same length.,"Returns true if both arrays are null or have the same length; otherwise, returns false.","@param array1 byte[]: first byte array
@param array2 byte[]: second byte array
@return boolean: true if same length or both null, false otherwise","null, null -> true (both null)
null, new byte[]{1} -> false (one null, one not)
new byte[]{1,2}, new byte[]{3,4} -> true (same length)
new byte[]{1,2}, new byte[]{3} -> false (different lengths)","Arrays can be null, valid output respecting null and length conditions.","public static boolean isSameLength(final byte[] array1,final byte[] array2){
//Check whether the length of the given two byte arrays is the same.
if(array1==null&&array2==null){
//Check whether two byte arrays are null.
return true;
}
if(array1==null||array2==null){
//Check whether the two byte arrays are not null.
return false;
}
if(array1.length!=array2.length){
//Check whether the length of the given two byte arrays is the same.
return false;
}
return true;
}",0,starcoder2-7b
6367670b1a6d9265ec017a00,isSameLength,"public static boolean isSameLength(final byte[] array1,final byte[] array2){
  if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {
    return false;
  }
  return true;
}
","/** 
 * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array
 */
",Check whether the length of the given two byte arrays is the same.,Checks if two byte arrays have the same length.,"Returns true if both arrays are null or have the same length; otherwise, returns false.","@param array1 byte[]: first byte array
@param array2 byte[]: second byte array
@return boolean: true if same length or both null, false otherwise","null, null -> true (both null)
null, new byte[]{1} -> false (one null, one not)
new byte[]{1,2}, new byte[]{3,4} -> true (same length)
new byte[]{1,2}, new byte[]{3} -> false (different lengths)","Arrays can be null, valid output respecting null and length conditions.","public static boolean isSameLength(final byte[] array1,final byte[] array2){
if(array1.length == array2.length)
return true;
else
return false;
}",1,CodeLlama-7b-Instruct-hf
636766a91a6d9265ec0175c2,pop,"private int pop(){
  if (outputStackTop > 0) {
    return outputStack[--outputStackTop];
  }
 else {
    return STACK_KIND | -(--outputStackStart);
  }
}
","/** 
 * Pops an abstract type from the output frame stack and returns its value.
 * @return the abstract type that has been popped from the output frame stack.
 */
",Pop an abstract type from the output frame stack and return its value.,Returns the top element of the stack or a special code.,"Removes and returns the top element from `outputStack` if there is one, otherwise returns a special code computed with `STACK_KIND` and `outputStackStart`.",@return int: The top element of `outputStack` or a special code.,"(outputStackTop=2, outputStack={5,3})
-> 3 (normal pop)
(outputStackTop=0, outputStackStart=1)
-> STACK_KIND-0 (special case return)",The stack must have non-negative indices; returns stack element or computed special code.,"private int pop(){
  if (outputStackTop > 0) {
    return outputStack[--outputStackTop];
  }
 else {
    return STACK_KIND | -(--outputStackStart);
  }
}
",0,reference
636766a91a6d9265ec0175c2,pop,"private int pop(){
  if (outputStackTop > 0) {
    return outputStack[--outputStackTop];
  }
 else {
    return STACK_KIND | -(--outputStackStart);
  }
}
","/** 
 * Pops an abstract type from the output frame stack and returns its value.
 * @return the abstract type that has been popped from the output frame stack.
 */
",Pop an abstract type from the output frame stack and return its value.,Returns the top element of the stack or a special code.,"Removes and returns the top element from `outputStack` if there is one, otherwise returns a special code computed with `STACK_KIND` and `outputStackStart`.",@return int: The top element of `outputStack` or a special code.,"(outputStackTop=2, outputStack={5,3})
-> 3 (normal pop)
(outputStackTop=0, outputStackStart=1)
-> STACK_KIND-0 (special case return)",The stack must have non-negative indices; returns stack element or computed special code.,"private int pop(){
    if (frameStack.isEmpty()) {
        throw new NoSuchElementException(""Stack is empty. Cannot pop."");
    }
    AbstractType object = frameStack.pop();
    return object.getValue();
}",1,Phi-3-mini-4k-instruct
636767081a6d9265ec017989,toPrimitive,"public static boolean[] toPrimitive(final Boolean[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;
  }
  final boolean[] result=new boolean[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].booleanValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Booleans to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Boolean</code> array, may be <code>null</code>
 * @return a <code>boolean</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Convert the given Boolean array to primitives. Return ArrayUtils.EMPTY_BOOLEAN_ARRAY for an empty array, return null for null array.",Converts a Boolean array to a boolean array.,"Transforms a Boolean array to a primitive boolean array, returning null for null input or an empty array for empty input.","@param array Boolean[]: Array of Boolean objects
@return boolean[]: Array of primitive boolean values","[true, false, true] -> [true, false, true] (convert to primitives)
null -> null (returns null for null input)
[] -> [] (returns empty array for empty input)","Input can be null or empty, output will match nullability and emptiness of input while converting values.","public static boolean[] toPrimitive(final Boolean[] array) {
    if (array == null) {
        return null;
    }
    if (array.length == 0) {
        return ArrayUtils.EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] result = new boolean[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i];
    }
    return result;
}",0,Qwen2.5-Coder-7B-Instruct
636767081a6d9265ec017989,toPrimitive,"public static boolean[] toPrimitive(final Boolean[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;
  }
  final boolean[] result=new boolean[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].booleanValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Booleans to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Boolean</code> array, may be <code>null</code>
 * @return a <code>boolean</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Convert the given Boolean array to primitives. Return ArrayUtils.EMPTY_BOOLEAN_ARRAY for an empty array, return null for null array.",Converts a Boolean array to a boolean array.,"Transforms a Boolean array to a primitive boolean array, returning null for null input or an empty array for empty input.","@param array Boolean[]: Array of Boolean objects
@return boolean[]: Array of primitive boolean values","[true, false, true] -> [true, false, true] (convert to primitives)
null -> null (returns null for null input)
[] -> [] (returns empty array for empty input)","Input can be null or empty, output will match nullability and emptiness of input while converting values.","public static boolean[] toPrimitive(final Boolean[] array){
if(array==null){return ArrayUtils.EMPTY_BOOLEAN_ARRAY;}
final boolean[] bArray=new boolean[array.length];
int i=0;
for(final Boolean e:array){
bArray[i++]=e.booleanValue();
}
return bArray;
}",1,starcoder2-7b
6367672d1a6d9265ec017c73,shouldPrintMessage,"public boolean shouldPrintMessage(int timestamp,String message){
  if (messages.containsKey(message)) {
    if (timestamp - messages.get(message) >= 10) {
      messages.put(message,timestamp);
      return true;
    }
 else {
      return false;
    }
  }
 else {
    messages.put(message,timestamp);
    return true;
  }
}
","/** 
 * Returns true if the message should be printed in the given timestamp, otherwise returns false. If this method returns false, the message will not be printed. The timestamp is in seconds granularity. 
 */
"," If the message does not exist in the dict messages, or it exists but the timestamp (seconds) difference is bigger than 10, put the message and timestamp into messages and return true, otherwise return false.",Checks if a message should be printed based on timestamp criteria.,Determines if a message can be printed based on whether it has been logged within the last 10 seconds. Updates the message timestamp if it can be printed.,"@param timestamp int: The time at which the message is attempted to be printed.
@param message String: The message to be potentially printed.
@return boolean: Returns true if the message should be printed, false otherwise.","(10, ""foo"")
-> true (First time message)
(15, ""foo"")
-> false (Within 10 seconds of last print)
(22, ""foo"")
-> true (After 10 seconds of last print)",Messages are checked against a timestamp map to see if they were logged in the last 10 seconds; timestamps are updated if printed.,"public boolean shouldPrintMessage(int timestamp, String message) {
        if (!messages.containsKey(message) || timestamp - messages.get(message) >= 10) {
            messages.put(message, timestamp);
            return true;
        }
        return false;
    }",0,Qwen2.5-Coder-7B-Instruct
6367672d1a6d9265ec017c73,shouldPrintMessage,"public boolean shouldPrintMessage(int timestamp,String message){
  if (messages.containsKey(message)) {
    if (timestamp - messages.get(message) >= 10) {
      messages.put(message,timestamp);
      return true;
    }
 else {
      return false;
    }
  }
 else {
    messages.put(message,timestamp);
    return true;
  }
}
","/** 
 * Returns true if the message should be printed in the given timestamp, otherwise returns false. If this method returns false, the message will not be printed. The timestamp is in seconds granularity. 
 */
"," If the message does not exist in the dict messages, or it exists but the timestamp (seconds) difference is bigger than 10, put the message and timestamp into messages and return true, otherwise return false.",Checks if a message should be printed based on timestamp criteria.,Determines if a message can be printed based on whether it has been logged within the last 10 seconds. Updates the message timestamp if it can be printed.,"@param timestamp int: The time at which the message is attempted to be printed.
@param message String: The message to be potentially printed.
@return boolean: Returns true if the message should be printed, false otherwise.","(10, ""foo"")
-> true (First time message)
(15, ""foo"")
-> false (Within 10 seconds of last print)
(22, ""foo"")
-> true (After 10 seconds of last print)",Messages are checked against a timestamp map to see if they were logged in the last 10 seconds; timestamps are updated if printed.,"public boolean shouldPrintMessage(int currentTimestamp, String message) {
    if (message != null && !messages.containsKey(message)) {
        messages.put(message, currentTimestamp);
        return true;
    } else if (messages.containsKey(message) && Math.abs(currentTimestamp - messages.get(message)) <= 10) {
        // The message was printed within the last 10 seconds
        return false;
    }
    // The message should be printed as it either doesn't exist or was printed longer than 10 seconds ago
    return true;
}",1,Phi-3-mini-4k-instruct
636766f81a6d9265ec01775c,toString,"public static String toString(Object obj){
  return obj == null ? """" : obj.toString();
}
","/** 
 * <p>Gets the <code>toString</code> of an <code>Object</code> returning an empty string ("""") if <code>null</code> input.</p> <pre> ObjectUtils.toString(null)         = """" ObjectUtils.toString("""")           = """" ObjectUtils.toString(""bat"")        = ""bat"" ObjectUtils.toString(Boolean.TRUE) = ""true"" </pre>
 * @see StringUtils#defaultString(String)
 * @see String#valueOf(Object)
 * @param obj  the Object to <code>toString</code>, may be null
 * @return the passed in Object's toString, or nullStr if <code>null</code> input
 * @since 2.0
 */
","Return the string representation of the given object, return an empty string if the object is null.",Returns object's string representation or empty string if null.,Converts an object to its string representation using `toString()` method. Returns an empty string if the object is null.,"@param obj Object: The object to convert to a string.
   @return String: The string representation of the object or an empty string for null objects.","null -> """" (null object returns empty string)
""Hello"" -> ""Hello"" (string object returns itself)
new Integer(5)
-> ""5"" (integer object returns its string representation)","Accepts any object type, returns a string. Will not throw exceptions or modify the input object.","public static String toString(Object obj){
    return obj == null ? """" : obj.toString();
}",0,Phi-3-mini-4k-instruct
636766f81a6d9265ec01775c,toString,"public static String toString(Object obj){
  return obj == null ? """" : obj.toString();
}
","/** 
 * <p>Gets the <code>toString</code> of an <code>Object</code> returning an empty string ("""") if <code>null</code> input.</p> <pre> ObjectUtils.toString(null)         = """" ObjectUtils.toString("""")           = """" ObjectUtils.toString(""bat"")        = ""bat"" ObjectUtils.toString(Boolean.TRUE) = ""true"" </pre>
 * @see StringUtils#defaultString(String)
 * @see String#valueOf(Object)
 * @param obj  the Object to <code>toString</code>, may be null
 * @return the passed in Object's toString, or nullStr if <code>null</code> input
 * @since 2.0
 */
","Return the string representation of the given object, return an empty string if the object is null.",Returns object's string representation or empty string if null.,Converts an object to its string representation using `toString()` method. Returns an empty string if the object is null.,"@param obj Object: The object to convert to a string.
   @return String: The string representation of the object or an empty string for null objects.","null -> """" (null object returns empty string)
""Hello"" -> ""Hello"" (string object returns itself)
new Integer(5)
-> ""5"" (integer object returns its string representation)","Accepts any object type, returns a string. Will not throw exceptions or modify the input object.","public static String toString(Object obj){
    return new String(""null"");
}",1,starcoder2-7b
6367667f1a6d9265ec017457,decodeOctets,"private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){
  if (bb.limit() == 1 && (bb.get(0) & 0xFF) < 0x80) {
    sb.append((char)bb.get(0));
    return i + 2;
  }
 else {
    CharBuffer cb=UTF_8_CHARSET.decode(bb);
    sb.append(cb);
    return i + bb.limit() * 3 - 1;
  }
}
","/** 
 * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.
 * @return the index to the next unchecked character in the string to decode
 */
","Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.",Decode and append bytes to a StringBuilder.,"The function reads bytes from ByteBuffer, decodes them as a UTF-8 string, appends the result to StringBuilder, and returns an incremented index based on the byte sequence length.","@param i int: The initial index.
@param bb ByteBuffer: The byte buffer containing octets.
@param sb StringBuilder: The StringBuilder to append decoded characters.
@return int: The updated index after decoding.","1 byte with value < 0x80 -> index+2 (decoded single byte)
Multiple bytes -> index + bytes_count*3 - 1 (decoded multiple bytes)","ByteBuffer contains valid UTF-8 encoding, CharBuffer decoding must succeed.","private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){
  if (bb.limit() == 1 && (bb.get(0) & 0xFF) < 0x80) {
    sb.append((char)bb.get(0));
    return i + 2;
  }
 else {
    CharBuffer cb=UTF_8_CHARSET.decode(bb);
    sb.append(cb);
    return i + bb.limit() * 3 - 1;
  }
}
",0,reference
6367667f1a6d9265ec017457,decodeOctets,"private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){
  if (bb.limit() == 1 && (bb.get(0) & 0xFF) < 0x80) {
    sb.append((char)bb.get(0));
    return i + 2;
  }
 else {
    CharBuffer cb=UTF_8_CHARSET.decode(bb);
    sb.append(cb);
    return i + bb.limit() * 3 - 1;
  }
}
","/** 
 * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.
 * @return the index to the next unchecked character in the string to decode
 */
","Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.",Decode and append bytes to a StringBuilder.,"The function reads bytes from ByteBuffer, decodes them as a UTF-8 string, appends the result to StringBuilder, and returns an incremented index based on the byte sequence length.","@param i int: The initial index.
@param bb ByteBuffer: The byte buffer containing octets.
@param sb StringBuilder: The StringBuilder to append decoded characters.
@return int: The updated index after decoding.","1 byte with value < 0x80 -> index+2 (decoded single byte)
Multiple bytes -> index + bytes_count*3 - 1 (decoded multiple bytes)","ByteBuffer contains valid UTF-8 encoding, CharBuffer decoding must succeed.","private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {
        bb.position(i);
        while(bb.hasRemaining()){
            int mark = bb.position();
            int limit = bb.limit();
            while(bb.hasRemaining()){
                byte b = bb.get();
                if((b & 0x80) == 0x00){
                    bb.position(mark);
                    break;
                }
            }

            if(bb.position() == mark){
                bb.position(i);
                break;
            }

            int length = bb.position() - mark;
            byte[] bytes = new byte[length];
            bb.position(mark);
            bb.get(bytes);
            String str = new String(bytes, StandardCharsets.UTF_8);
            sb.append(str);
            i += length;
        }
        return i;
    }",1,deepseek-coder-6.7b-instruct
636766aa1a6d9265ec0175ce,visitFrameStart,"int visitFrameStart(final int offset,final int numLocal,final int numStack){
  int frameLength=3 + numLocal + numStack;
  if (currentFrame == null || currentFrame.length < frameLength) {
    currentFrame=new int[frameLength];
  }
  currentFrame[0]=offset;
  currentFrame[1]=numLocal;
  currentFrame[2]=numStack;
  return 3;
}
","/** 
 * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}.
 * @param offset   the bytecode offset of the instruction to which the frame corresponds.
 * @param numLocal the number of local variables in the frame.
 * @param numStack the number of stack elements in the frame.
 * @return the index of the next element to be written in this frame.
 */
","Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.",Initializes or resizes an integer array for frame data.,"Allocates or resets currentFrame to store offset, numLocal, and numStack values, storing them at specified indices.","@param offset int: Frame offset.
@param numLocal int: Number of local variables.
@param numStack int: Number of stack elements.
@return int: Always returns 3.","5, 2, 3 -> 3 (Initializes currentFrame array of length 8 with given values)
10, 0, 5 -> 3 (Initializes currentFrame array of length 8 with given values)
0, 3, 4 -> 3 (Initializes currentFrame array of length 10 with given values)",Preconditions: numLocal and numStack are non-negative. Postconditions: currentFrame is initialized or resized to correctly hold the frame data.,"int visitFrameStart(final int offset,final int numLocal,final int numStack){
  int frameLength=3 + numLocal + numStack;
  if (currentFrame == null || currentFrame.length < frameLength) {
    currentFrame=new int[frameLength];
  }
  currentFrame[0]=offset;
  currentFrame[1]=numLocal;
  currentFrame[2]=numStack;
  return 3;
}
",0,reference
636766aa1a6d9265ec0175ce,visitFrameStart,"int visitFrameStart(final int offset,final int numLocal,final int numStack){
  int frameLength=3 + numLocal + numStack;
  if (currentFrame == null || currentFrame.length < frameLength) {
    currentFrame=new int[frameLength];
  }
  currentFrame[0]=offset;
  currentFrame[1]=numLocal;
  currentFrame[2]=numStack;
  return 3;
}
","/** 
 * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}.
 * @param offset   the bytecode offset of the instruction to which the frame corresponds.
 * @param numLocal the number of local variables in the frame.
 * @param numStack the number of stack elements in the frame.
 * @return the index of the next element to be written in this frame.
 */
","Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.",Initializes or resizes an integer array for frame data.,"Allocates or resets currentFrame to store offset, numLocal, and numStack values, storing them at specified indices.","@param offset int: Frame offset.
@param numLocal int: Number of local variables.
@param numStack int: Number of stack elements.
@return int: Always returns 3.","5, 2, 3 -> 3 (Initializes currentFrame array of length 8 with given values)
10, 0, 5 -> 3 (Initializes currentFrame array of length 8 with given values)
0, 3, 4 -> 3 (Initializes currentFrame array of length 10 with given values)",Preconditions: numLocal and numStack are non-negative. Postconditions: currentFrame is initialized or resized to correctly hold the frame data.,"int visitFrameStart(final int offset,final int numLocal,final int numStack){

    FrameData currentFrame = new FrameData(offset, numLocal,numStack);

    frameDataMap.put(offset,currentFrame);

    return super.visitFrameStart(offset,numLocal,numStack);
}",1,CodeLlama-7b-Instruct-hf
636767191a6d9265ec017c0f,enlarge,"private void enlarge(final int size){
  int doubleCapacity=2 * data.length;
  int minimalCapacity=length + size;
  byte[] newData=new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];
  System.arraycopy(data,0,newData,0,length);
  data=newData;
}
","/** 
 * Enlarges this byte vector so that it can receive 'size' more bytes.
 * @param size number of additional bytes that this byte vector should be able to receive.
 */
","Enlarge the byte vector data, by increasing it by the given size.",Enlarges byte array to accommodate additional size.,Creates a new byte array with a size that is either double the original or large enough to fit the current data plus an additional size. Copies existing data to the new array and updates the reference.,@param size int: The additional capacity needed.,"data length = 10, size = 5 -> new array of size 20 (capacity doubled)
data length = 10, size = 15 -> new array of size 25 (capacity based on minimal need)",Preconditions: 'data' must be a valid byte array; 'length' is the current data size. Postconditions: 'data' has been enlarged to accommodate additional elements.,"private void enlarge(final int size){
  int doubleCapacity=2 * data.length;
  int minimalCapacity=length + size;
  byte[] newData=new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];
  System.arraycopy(data,0,newData,0,length);
  data=newData;
}
",0,reference
636767191a6d9265ec017c0f,enlarge,"private void enlarge(final int size){
  int doubleCapacity=2 * data.length;
  int minimalCapacity=length + size;
  byte[] newData=new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];
  System.arraycopy(data,0,newData,0,length);
  data=newData;
}
","/** 
 * Enlarges this byte vector so that it can receive 'size' more bytes.
 * @param size number of additional bytes that this byte vector should be able to receive.
 */
","Enlarge the byte vector data, by increasing it by the given size.",Enlarges byte array to accommodate additional size.,Creates a new byte array with a size that is either double the original or large enough to fit the current data plus an additional size. Copies existing data to the new array and updates the reference.,@param size int: The additional capacity needed.,"data length = 10, size = 5 -> new array of size 20 (capacity doubled)
data length = 10, size = 15 -> new array of size 25 (capacity based on minimal need)",Preconditions: 'data' must be a valid byte array; 'length' is the current data size. Postconditions: 'data' has been enlarged to accommodate additional elements.,"private void enlarge(final byte[] data, final int size){
    byte[] newData = new byte[data.length + size];
    System.arraycopy(data, 0, newData, 0, data.length);
    data = newData;
}",1,deepseek-coder-6.7b-instruct
636767821a6d9265ec0183a0,deleteFile,"protected static void deleteFile(String fileName){
  File file=new File(fileName);
  if (file.exists()) {
    file.delete();
  }
}
","/** 
 * Delete's the specified file if it exists 
 */
",Delete the given file if it exists,Deletes a file if it exists.,The function checks if a file with the given name exists and deletes it if present.,@param fileName String: The name of the file to be deleted.,"""test.txt"" -> null (Deletes ""test.txt"" if it exists)
""nonexistent.txt"" -> null (Does nothing if ""nonexistent.txt"" doesn't exist)
""/path/to/file.txt"" -> null (Deletes the file at specified path if it exists)","The file must be present for deletion; after execution, the file is either deleted or remains unchanged if it doesn’t exist.","protected static void deleteFile(String fileName) {
    File file = new File(fileName);
    if (file.exists()) {
        if (file.delete()) {
            System.out.println(""File deleted successfully."");
        } else {
            System.out.println(""Failed to delete file."");
        }
    } else {
        System.out.println(""File does not exist."");
    }
}",0,Qwen2.5-Coder-7B-Instruct
636767821a6d9265ec0183a0,deleteFile,"protected static void deleteFile(String fileName){
  File file=new File(fileName);
  if (file.exists()) {
    file.delete();
  }
}
","/** 
 * Delete's the specified file if it exists 
 */
",Delete the given file if it exists,Deletes a file if it exists.,The function checks if a file with the given name exists and deletes it if present.,@param fileName String: The name of the file to be deleted.,"""test.txt"" -> null (Deletes ""test.txt"" if it exists)
""nonexistent.txt"" -> null (Does nothing if ""nonexistent.txt"" doesn't exist)
""/path/to/file.txt"" -> null (Deletes the file at specified path if it exists)","The file must be present for deletion; after execution, the file is either deleted or remains unchanged if it doesn’t exist.","protected static void deleteFile(String fileName){
if (fileName!= null) {
Path fileToDelete = Paths.get(fileName);
try{
Files.deleteIfExists(fileToDelete);
}
catch(Exception e){
System.err.println(""Could not delete existing file: "" + fileName);
e.printStackTrace(System.err);
}
}
}",1,starcoder2-7b
636767691a6d9265ec0181aa,nullSafeHashCode,"public static int nullSafeHashCode(long[] array){
  if (array == null) {
    return 0;
  }
  int hash=INITIAL_HASH;
  int arraySize=array.length;
  for (int i=0; i < arraySize; i++) {
    hash=MULTIPLIER * hash + hashCode(array[i]);
  }
  return hash;
}
","/** 
 * Return a hash code based on the contents of the specified array. If <code>array</code> is <code>null</code>, this method returns 0.
 * @param array the long array to obtain a hashcode
 * @return the long array's hashcode, which could be 0 if the array is null.
 */
","Compute the hash code of the whole array, by accumulating the multiplication of each element hash code and the  MULTIPLIER.","Computes the hash code for a long array, handling null safely.",Calculates a combined hash code for all elements in the array or returns 0 if the array is null.,"@param array long[]: The array to compute the hash code for.
@return int: The computed hash code or 0 if the array is null.","null -> 0 (array is null)
[1, 2, 3] -> someHash (combines hashes)
[] -> anotherHash (empty array)","Array may be null, result is integer hash code, 0 if null.","public static int nullSafeHashCode(long[] array){
if (array == null) {
return 0;
}
int hash = INITIAL_HASH;

for (int i = 0; i < array.length; i++) {
hash = MULTIPLIER * hash + hashCode(array[i]);
}
return hash;
}",0,CodeLlama-7b-Instruct-hf
636767691a6d9265ec0181aa,nullSafeHashCode,"public static int nullSafeHashCode(long[] array){
  if (array == null) {
    return 0;
  }
  int hash=INITIAL_HASH;
  int arraySize=array.length;
  for (int i=0; i < arraySize; i++) {
    hash=MULTIPLIER * hash + hashCode(array[i]);
  }
  return hash;
}
","/** 
 * Return a hash code based on the contents of the specified array. If <code>array</code> is <code>null</code>, this method returns 0.
 * @param array the long array to obtain a hashcode
 * @return the long array's hashcode, which could be 0 if the array is null.
 */
","Compute the hash code of the whole array, by accumulating the multiplication of each element hash code and the  MULTIPLIER.","Computes the hash code for a long array, handling null safely.",Calculates a combined hash code for all elements in the array or returns 0 if the array is null.,"@param array long[]: The array to compute the hash code for.
@return int: The computed hash code or 0 if the array is null.","null -> 0 (array is null)
[1, 2, 3] -> someHash (combines hashes)
[] -> anotherHash (empty array)","Array may be null, result is integer hash code, 0 if null.","public static int nullSafeHashCode(long[] array){
if(array == null){
return 0;
}
final int len = array.length;
long hash = 1;
for(int i = 0; i < len; i++){
hash = MULTIPLIER * hash + nullSafeHashCode(array[i]);
}
return (int)(hash ^ hash >>> SHIFT);
}",1,starcoder2-7b
636767441a6d9265ec017cc1,rotateRight,"private TreeNode<T> rotateRight(TreeNode<T> node){
  TreeNode<T> left=node.left;
  left.parent=null;
  node.setLeftChild(left.right);
  left.setRightChild(node);
  node.updateHeightAndSubtreeSize();
  left.updateHeightAndSubtreeSize();
  return left;
}
","/** 
 * Performs a right node rotation.
 * @param node a node to rotate
 * @return a new parent of the {@code node}
 */
",Perform a right node rotation on the AVL tree.,Performs a right rotation on a binary tree node.,The function rotates the subtree rooted at the input node to the right by making its left child the new root of the subtree and updates the heights and sizes of the involved nodes.,@return TreeNode<T>: The new root of the rotated subtree.,"node with left child -> left child becomes new root (tree rotates right)
node without left child -> unchanged (rotation not possible)",Input node must have a non-null left child; tree structure and properties adjusted after rotation.,"private TreeNode<T> rotateRight(TreeNode<T> node){
  TreeNode<T> left=node.left;
  left.parent=null;
  node.setLeftChild(left.right);
  left.setRightChild(node);
  node.updateHeightAndSubtreeSize();
  left.updateHeightAndSubtreeSize();
  return left;
}
",0,reference
636767441a6d9265ec017cc1,rotateRight,"private TreeNode<T> rotateRight(TreeNode<T> node){
  TreeNode<T> left=node.left;
  left.parent=null;
  node.setLeftChild(left.right);
  left.setRightChild(node);
  node.updateHeightAndSubtreeSize();
  left.updateHeightAndSubtreeSize();
  return left;
}
","/** 
 * Performs a right node rotation.
 * @param node a node to rotate
 * @return a new parent of the {@code node}
 */
",Perform a right node rotation on the AVL tree.,Performs a right rotation on a binary tree node.,The function rotates the subtree rooted at the input node to the right by making its left child the new root of the subtree and updates the heights and sizes of the involved nodes.,@return TreeNode<T>: The new root of the rotated subtree.,"node with left child -> left child becomes new root (tree rotates right)
node without left child -> unchanged (rotation not possible)",Input node must have a non-null left child; tree structure and properties adjusted after rotation.,"private TreeNode<T> rotateRight(TreeNode<T> node){
    if (node == null || node.left == null) {
        return node; // No need to rotate if node or its left child is null
    }

    TreeNode<T> newRoot = node.left;
    node.left = newRoot.right;
    newRoot.right = node;

    // Update heights
    node.height = Math.max(height(node.left), height(node.right)) + 1;
    newRoot.height = Math.max(height(newRoot.left), node.height) + 1;

    return newRoot;
}",1,Qwen2.5-Coder-7B-Instruct
6367677e1a6d9265ec01830f,format,"public String format(LoggingEvent event){
  if (sbuf.capacity() > MAX_CAPACITY) {
    sbuf=new StringBuffer(BUF_SIZE);
  }
 else {
    sbuf.setLength(0);
  }
  PatternConverter c=head;
  while (c != null) {
    c.format(sbuf,event);
    c=c.next;
  }
  return sbuf.toString();
}
","/** 
 * Produces a formatted string as specified by the conversion pattern.
 */
","Format the buffered string with the pattern converter, and return the result.",Formats a logging event into a string.,The function uses a buffer to construct a formatted string representation of a logging event by utilizing a pattern converter chain. The buffer is reset or recreated based on its capacity before formatting.,"@param event LoggingEvent: The logging event to format.
   @return String: The formatted string representation of the logging event.","event with info level -> ""[INFO] log message"" (formats an info level event)
Event with error level -> ""[ERROR] log message"" (formats an error level event)
Empty event -> """" (handles an empty event gracefully)","Preconditions include a valid LoggingEvent and initialized PatternConverter chain, while postconditions ensure the buffer is appropriately reset and contains the formatted event string.","public String format(LoggingEvent event){
  if (sbuf.capacity() > MAX_CAPACITY) {
    sbuf=new StringBuffer(BUF_SIZE);
  }
 else {
    sbuf.setLength(0);
  }
  PatternConverter c=head;
  while (c != null) {
    c.format(sbuf,event);
    c=c.next;
  }
  return sbuf.toString();
}
",0,reference
6367677e1a6d9265ec01830f,format,"public String format(LoggingEvent event){
  if (sbuf.capacity() > MAX_CAPACITY) {
    sbuf=new StringBuffer(BUF_SIZE);
  }
 else {
    sbuf.setLength(0);
  }
  PatternConverter c=head;
  while (c != null) {
    c.format(sbuf,event);
    c=c.next;
  }
  return sbuf.toString();
}
","/** 
 * Produces a formatted string as specified by the conversion pattern.
 */
","Format the buffered string with the pattern converter, and return the result.",Formats a logging event into a string.,The function uses a buffer to construct a formatted string representation of a logging event by utilizing a pattern converter chain. The buffer is reset or recreated based on its capacity before formatting.,"@param event LoggingEvent: The logging event to format.
   @return String: The formatted string representation of the logging event.","event with info level -> ""[INFO] log message"" (formats an info level event)
Event with error level -> ""[ERROR] log message"" (formats an error level event)
Empty event -> """" (handles an empty event gracefully)","Preconditions include a valid LoggingEvent and initialized PatternConverter chain, while postconditions ensure the buffer is appropriately reset and contains the formatted event string.","public String format(LoggingEvent event) {
        StringBuilder sb = new StringBuilder();
        
        // Example pattern: ""%d %p %c - %m%n""
        
        // Date
        sb.append(dateFormat.format(event.getTimeStamp())).append("" "");
        
        // Priority (level)
        sb.append(event.getLevel()).append("" "");
        
        // Category name
        sb.append(event.getLoggerName()).append("" - "");
        
        // Message
        if (event.getMessage() instanceof Throwable) {
            sb.append(((Throwable) event.getMessage()).getMessage());
        } else {
            sb.append(event.getMessage());
        }
        
        // Newline
        sb.append(""\n"");
        
        return sb.toString();
    }",1,Qwen2.5-Coder-7B-Instruct
636767031a6d9265ec0178dd,contentLength,"public long contentLength(){
  long size;
  try {
    size=Long.parseLong(request.getHeader(FileUpload.CONTENT_LENGTH));
  }
 catch (  NumberFormatException e) {
    size=request.getContentLength();
  }
  return size;
}
","/** 
 * Retrieve the content length of the request.
 * @return The content length of the request.
 * @since 1.3
 */
","Compute and return the length of the request content header, return the content length if NumberFormatException happens.",Returns the content length from request headers.,"Attempts to get content length from the specified header, defaults to request's content length on failure.",@return long: Content length of the request.,"Header value ""1024"" -> 1024 (Parsed header value)
Header value ""invalid"" -> request.getContentLength()
(Fallback to request method on parse failure)
Header absent -> request.getContentLength()
(Fallback to request method on header absence)",Precondition: Request contains a potential content length value. Postcondition: Returns content length as long.,"public long contentLength() throws NumberFormatException {
    String contentLengthHeader = request.getHeader(""Content-Length"");
    if (contentLengthHeader != null) {
        try {
            return Long.parseLong(contentLengthHeader);
        } catch (NumberFormatException e) {
            throw new NumberFormatException(""Invalid Content-Length header format."");
        }
    } else {
        return 0L; // If the header is not present or parsing fails, return 0
    }
}",0,Phi-3-mini-4k-instruct
636767031a6d9265ec0178dd,contentLength,"public long contentLength(){
  long size;
  try {
    size=Long.parseLong(request.getHeader(FileUpload.CONTENT_LENGTH));
  }
 catch (  NumberFormatException e) {
    size=request.getContentLength();
  }
  return size;
}
","/** 
 * Retrieve the content length of the request.
 * @return The content length of the request.
 * @since 1.3
 */
","Compute and return the length of the request content header, return the content length if NumberFormatException happens.",Returns the content length from request headers.,"Attempts to get content length from the specified header, defaults to request's content length on failure.",@return long: Content length of the request.,"Header value ""1024"" -> 1024 (Parsed header value)
Header value ""invalid"" -> request.getContentLength()
(Fallback to request method on parse failure)
Header absent -> request.getContentLength()
(Fallback to request method on header absence)",Precondition: Request contains a potential content length value. Postcondition: Returns content length as long.,"public long contentLength() throws NumberFormatException {
    try {
        String headerValue = request.getHeader(""Content-Length"");
        return Long.parseLong(headerValue);
    } catch (NumberFormatException e) {
        throw new NumberFormatException(""Invalid Content-Length header value"");
    }
}",1,Phi-3-mini-4k-instruct
636766f11a6d9265ec017658,indexOfLastSeparator,"public static int indexOfLastSeparator(String filename){
  if (filename == null) {
    return -1;
  }
  int lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);
  int lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);
  return Math.max(lastUnixPos,lastWindowsPos);
}
","/** 
 * Returns the index of the last directory separator character. <p> This method will handle a file in either Unix or Windows format. The position of the last forward or backslash is returned. <p> The output will be the same irrespective of the machine that the code is running on.
 * @param filename  the filename to find the last path separator in, null returns -1
 * @return the index of the last separator character, or -1 if thereis no such character
 */
","Return the index of the last directory separator character, under Unix or Windows.",Finds the last occurrence of a path separator in a filename.,"The function returns the last position of either a Unix or Windows separator in the given filename. If the filename is null, it returns -1.","@param filename String: Input filename to analyze.
   @return int: Index of the last separator or -1 if none or input is null.","""file/path/to/file.txt"" -> 8 (Last '/' at position 8)
""C:\\path\\to\\file.txt"" -> 11 (Last '\' at position 11)
null -> -1 (Filename is null)",The filename can be null or any string. The return value is the index of the last separator or -1 if none is found or the filename is null.,"public static int indexOfLastSeparator(String filename) {
    int lastIndex = -1;
    if (filename != null) {
        lastIndex = filename.lastIndexOf('/');
        if (lastIndex == -1) {
            lastIndex = filename.lastIndexOf('\\');
        }
    }
    return lastIndex;
}",0,Qwen2.5-Coder-7B-Instruct
636766f11a6d9265ec017658,indexOfLastSeparator,"public static int indexOfLastSeparator(String filename){
  if (filename == null) {
    return -1;
  }
  int lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);
  int lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);
  return Math.max(lastUnixPos,lastWindowsPos);
}
","/** 
 * Returns the index of the last directory separator character. <p> This method will handle a file in either Unix or Windows format. The position of the last forward or backslash is returned. <p> The output will be the same irrespective of the machine that the code is running on.
 * @param filename  the filename to find the last path separator in, null returns -1
 * @return the index of the last separator character, or -1 if thereis no such character
 */
","Return the index of the last directory separator character, under Unix or Windows.",Finds the last occurrence of a path separator in a filename.,"The function returns the last position of either a Unix or Windows separator in the given filename. If the filename is null, it returns -1.","@param filename String: Input filename to analyze.
   @return int: Index of the last separator or -1 if none or input is null.","""file/path/to/file.txt"" -> 8 (Last '/' at position 8)
""C:\\path\\to\\file.txt"" -> 11 (Last '\' at position 11)
null -> -1 (Filename is null)",The filename can be null or any string. The return value is the index of the last separator or -1 if none is found or the filename is null.,"public static int indexOfLastSeparator(String filename){
return indexOfLastSeparator(filename, File.separatorChar);
}",1,starcoder2-7b
636767121a6d9265ec017b0a,parseEndOfLine,"private int parseEndOfLine(String headerPart,int end){
  int index=end;
  for (; ; ) {
    int offset=headerPart.indexOf('\r',index);
    if (offset == -1 || offset + 1 >= headerPart.length()) {
      throw new IllegalStateException(""Expected headers to be terminated by an empty line."");
    }
    if (headerPart.charAt(offset + 1) == '\n') {
      return offset;
    }
    index=offset + 1;
  }
}
","/** 
 * Skips bytes until the end of the current line.
 * @param headerPart The headers, which are being parsed.
 * @param end Index of the last byte, which has yet been processed.
 * @return Index of the \r\n sequence, which indicates end of line.
 */
",Parse the header part starting from the given end position and return the index of the enter sequence. ,Finds the position of a carriage return followed by a newline.,The function scans a string to find a '\r\n' sequence starting from a given index and returns the position of the '\r'.,"@param headerPart String: Header content to be examined  
   @return int: Index of '\r' in the '\r\n' sequence  
   @throws IllegalStateException: If the expected new line after '\r' is not found","""abc\r\ndef"", 0 -> 3 (finds '\r' at index 3)
""abc\rghi"", 0 -> Exception (no '\n' after '\r')",Requires '\r\n' sequence in the input; ensures valid index or exception if not found.,"private int parseEndOfLine(String headerPart,int end){
  int index=end;
  for (; ; ) {
    int offset=headerPart.indexOf('\r',index);
    if (offset == -1 || offset + 1 >= headerPart.length()) {
      throw new IllegalStateException(""Expected headers to be terminated by an empty line."");
    }
    if (headerPart.charAt(offset + 1) == '\n') {
      return offset;
    }
    index=offset + 1;
  }
}
",0,reference
636767121a6d9265ec017b0a,parseEndOfLine,"private int parseEndOfLine(String headerPart,int end){
  int index=end;
  for (; ; ) {
    int offset=headerPart.indexOf('\r',index);
    if (offset == -1 || offset + 1 >= headerPart.length()) {
      throw new IllegalStateException(""Expected headers to be terminated by an empty line."");
    }
    if (headerPart.charAt(offset + 1) == '\n') {
      return offset;
    }
    index=offset + 1;
  }
}
","/** 
 * Skips bytes until the end of the current line.
 * @param headerPart The headers, which are being parsed.
 * @param end Index of the last byte, which has yet been processed.
 * @return Index of the \r\n sequence, which indicates end of line.
 */
",Parse the header part starting from the given end position and return the index of the enter sequence. ,Finds the position of a carriage return followed by a newline.,The function scans a string to find a '\r\n' sequence starting from a given index and returns the position of the '\r'.,"@param headerPart String: Header content to be examined  
   @return int: Index of '\r' in the '\r\n' sequence  
   @throws IllegalStateException: If the expected new line after '\r' is not found","""abc\r\ndef"", 0 -> 3 (finds '\r' at index 3)
""abc\rghi"", 0 -> Exception (no '\n' after '\r')",Requires '\r\n' sequence in the input; ensures valid index or exception if not found.,"public static void main(String[] args) {
        String headerPart = ""Content-Type: application/json\nDate: 2023-04-01"";
        int endPosition = 43; // Starting position after the semicolon of Content-Type
        
        int startOfNextLine = parseEndOfLine(headerPart, endPosition);
        
        if (startOfNextLine != -1) {
            System.out.println(""End of line found at index: "" + startOfNextLine);
        } else {
            System.out.println(""No line found after the given end position."");
        }
    }",1,Phi-3-mini-4k-instruct
636766f61a6d9265ec017701,lastIndexOf,"public static int lastIndexOf(String str,String searchStr){
  if (StringUtils.isEmpty(str)) {
    return StringUtils.INDEX_NOT_FOUND;
  }
  return str.lastIndexOf(searchStr);
}
","/** 
 * Finds the last index within a String, handling <code>null</code>. This method uses  {@link String#lastIndexOf(String)}. 
 */
","Find the last index of the searchStr in str, and return INDEXNOTFOUND if str is empty.",Finds the last index of a substring.,Returns the last index of the search string in the given string or -1 if not found or if the string is empty.,"@param str String: The main string to search within.
@param searchStr String: The substring to find.
@return int: The last index of the search string or -1 if not found.","""hello"", ""l"" -> 3 (last occurrence of 'l')
""hello"", ""x"" -> -1 (not found)
"""", ""any"" -> -1 (empty main string)",Input strings must not be null. The function returns the last index found or -1 if not found.,"public static int lastIndexOf(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return -1;
    }
    return str.lastIndexOf(searchStr);
}",0,gpt-4-turbo
636766f61a6d9265ec017701,lastIndexOf,"public static int lastIndexOf(String str,String searchStr){
  if (StringUtils.isEmpty(str)) {
    return StringUtils.INDEX_NOT_FOUND;
  }
  return str.lastIndexOf(searchStr);
}
","/** 
 * Finds the last index within a String, handling <code>null</code>. This method uses  {@link String#lastIndexOf(String)}. 
 */
","Find the last index of the searchStr in str, and return INDEXNOTFOUND if str is empty.",Finds the last index of a substring.,Returns the last index of the search string in the given string or -1 if not found or if the string is empty.,"@param str String: The main string to search within.
@param searchStr String: The substring to find.
@return int: The last index of the search string or -1 if not found.","""hello"", ""l"" -> 3 (last occurrence of 'l')
""hello"", ""x"" -> -1 (not found)
"""", ""any"" -> -1 (empty main string)",Input strings must not be null. The function returns the last index found or -1 if not found.,"public static int lastIndexOf(String str,String searchStr){
int index = str.lastIndexOf(searchStr);
if(index==-1)return INDEXNOTFOUND;
return index;
}",1,starcoder2-7b
6367670b1a6d9265ec0179fe,write,"@Override public void write(byte b[]) throws IOException {
  checkThreshold(b.length);
  getStream().write(b);
  written+=b.length;
}
","/** 
 * Writes <code>b.length</code> bytes from the specified byte array to this output stream.
 * @param b The array of bytes to be written.
 * @exception IOException if an error occurs.
 */
",Write the given byte array b into the output stream that this class represents.,A function to write data to a stream.,Writes the byte array to an output stream after checking if a size threshold is met. Updates a 'written' counter with the number of bytes written.,"@param b byte[]: Data to be written
   @throws IOException: If an I/O error occurs","byte[]{1, 2, 3} -> writes 3 bytes (if threshold allows)
byte[]{} -> writes 0 bytes (empty array)","Preconditions: A valid byte array is provided, and the stream is open. Postconditions: Data is written to the stream, and 'written' is updated.","@Override public void write(byte b[]) throws IOException {
write(b, 0, b.length);
}",0,starcoder2-7b
6367670b1a6d9265ec0179fe,write,"@Override public void write(byte b[]) throws IOException {
  checkThreshold(b.length);
  getStream().write(b);
  written+=b.length;
}
","/** 
 * Writes <code>b.length</code> bytes from the specified byte array to this output stream.
 * @param b The array of bytes to be written.
 * @exception IOException if an error occurs.
 */
",Write the given byte array b into the output stream that this class represents.,A function to write data to a stream.,Writes the byte array to an output stream after checking if a size threshold is met. Updates a 'written' counter with the number of bytes written.,"@param b byte[]: Data to be written
   @throws IOException: If an I/O error occurs","byte[]{1, 2, 3} -> writes 3 bytes (if threshold allows)
byte[]{} -> writes 0 bytes (empty array)","Preconditions: A valid byte array is provided, and the stream is open. Postconditions: Data is written to the stream, and 'written' is updated.","@Override public void write(byte b[]) throws IOException {

System.out.println(""I/O operation.  Data to be written:  "" +

b.toString());

out.write(b);

}",1,CodeLlama-7b-Instruct-hf
636767df1a6d9265ec01873c,id,"public String id(String entityId){
  if (entityId == null) {
    return String.valueOf(point);
  }
 else {
    return point + Const.ID_CONNECTOR + entityId;
  }
}
","/** 
 * @return the row id
 */
",Return the id by concatenating the point and the entity id with id connector.,Joins a point with entityId using a connector or returns the point.,"Returns a string combining point and entityId with a connector if entityId is not null; otherwise, returns point.",@return String: Resulting concatenated or solo string based on the input.,"null -> ""point_value"" (returns point)
""123"" -> ""point_value-CONNECTOR-123"" (combines point and entityId)
"""" -> ""point_value-CONNECTOR-"" (combines point and empty entityId)",entityId may be null; output will have the structure point or point-CONNECTOR-entityId.,"public String id(String entityId){
  if (entityId == null) {
    return String.valueOf(point);
  }
 else {
    return point + Const.ID_CONNECTOR + entityId;
  }
}
",0,reference
636767df1a6d9265ec01873c,id,"public String id(String entityId){
  if (entityId == null) {
    return String.valueOf(point);
  }
 else {
    return point + Const.ID_CONNECTOR + entityId;
  }
}
","/** 
 * @return the row id
 */
",Return the id by concatenating the point and the entity id with id connector.,Joins a point with entityId using a connector or returns the point.,"Returns a string combining point and entityId with a connector if entityId is not null; otherwise, returns point.",@return String: Resulting concatenated or solo string based on the input.,"null -> ""point_value"" (returns point)
""123"" -> ""point_value-CONNECTOR-123"" (combines point and entityId)
"""" -> ""point_value-CONNECTOR-"" (combines point and empty entityId)",entityId may be null; output will have the structure point or point-CONNECTOR-entityId.,"public String id(String entityId) {
    return entityId + ""_"" + POINT_ID;
}",1,Phi-3-mini-4k-instruct
636766f91a6d9265ec01777f,toBoolean,"public static boolean toBoolean(Boolean bool){
  if (bool == null) {
    return false;
  }
  return bool.booleanValue() ? true : false;
}
","/** 
 * <p>Converts a Boolean to a boolean handling <code>null</code> by returning <code>false</code>.</p> <pre> BooleanUtils.toBoolean(Boolean.TRUE)  = true BooleanUtils.toBoolean(Boolean.FALSE) = false BooleanUtils.toBoolean(null)          = false </pre>
 * @param bool  the boolean to convert
 * @return <code>true</code> or <code>false</code>, <code>null</code> returns <code>false</code>
 */
",Convert a Boolean to a boolean handling null by returning false.,Converts a Boolean object to a primitive boolean.,"Returns false for null values, otherwise returns the boolean value of the Boolean object.","@param bool Boolean: a Boolean object that may be null
   @return boolean: the primitive boolean value, or false if null","true -> true (Boolean true returns true)
false -> false (Boolean false returns false)
null -> false (Null returns false)","Accepts a Boolean object or null, returns a primitive boolean value.","public static boolean toBoolean(Boolean bool){
if(bool == null)return false;
return bool;
}",0,starcoder2-7b
636766f91a6d9265ec01777f,toBoolean,"public static boolean toBoolean(Boolean bool){
  if (bool == null) {
    return false;
  }
  return bool.booleanValue() ? true : false;
}
","/** 
 * <p>Converts a Boolean to a boolean handling <code>null</code> by returning <code>false</code>.</p> <pre> BooleanUtils.toBoolean(Boolean.TRUE)  = true BooleanUtils.toBoolean(Boolean.FALSE) = false BooleanUtils.toBoolean(null)          = false </pre>
 * @param bool  the boolean to convert
 * @return <code>true</code> or <code>false</code>, <code>null</code> returns <code>false</code>
 */
",Convert a Boolean to a boolean handling null by returning false.,Converts a Boolean object to a primitive boolean.,"Returns false for null values, otherwise returns the boolean value of the Boolean object.","@param bool Boolean: a Boolean object that may be null
   @return boolean: the primitive boolean value, or false if null","true -> true (Boolean true returns true)
false -> false (Boolean false returns false)
null -> false (Null returns false)","Accepts a Boolean object or null, returns a primitive boolean value.","public static boolean toBoolean(Boolean bool){
  return bool.booleanValue();
}",1,manual_injection
6367675f1a6d9265ec0180d3,identity,"public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){
  Map<V,V> fMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());
  Map<V,V> bMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());
  for (  V v : graph.vertexSet()) {
    fMap.put(v,v);
    bMap.put(v,v);
  }
  return new IsomorphicGraphMapping<>(fMap,bMap,graph,graph);
}
","/** 
 * Computes an identity automorphism (i.e. a self-mapping of a graph in which each vertex also maps to itself).
 * @param graph the input graph
 * @param < V > the graph vertex type
 * @param < E > the graph edge type
 * @return a mapping from graph to graph
 */
",Compute and return an identity automorphism for the given graph.,Creates an isomorphic mapping of a graph to itself.,"The function creates a mapping where each vertex in the graph maps to itself, establishing an identity isomorphism.","@param <V> : Vertex type
   @param <E> : Edge type
   @return IsomorphicGraphMapping<V,E>: Isomorphic mapping of the graph to itself","graph with vertices {A, B, C} -> identity mapping (each vertex maps to itself)",The graph must not be null; the function returns an identity mapping of the graph.,"public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){
  Map<V,V> fMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());
  Map<V,V> bMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());
  for (  V v : graph.vertexSet()) {
    fMap.put(v,v);
    bMap.put(v,v);
  }
  return new IsomorphicGraphMapping<>(fMap,bMap,graph,graph);
}
",0,reference
6367675f1a6d9265ec0180d3,identity,"public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){
  Map<V,V> fMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());
  Map<V,V> bMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());
  for (  V v : graph.vertexSet()) {
    fMap.put(v,v);
    bMap.put(v,v);
  }
  return new IsomorphicGraphMapping<>(fMap,bMap,graph,graph);
}
","/** 
 * Computes an identity automorphism (i.e. a self-mapping of a graph in which each vertex also maps to itself).
 * @param graph the input graph
 * @param < V > the graph vertex type
 * @param < E > the graph edge type
 * @return a mapping from graph to graph
 */
",Compute and return an identity automorphism for the given graph.,Creates an isomorphic mapping of a graph to itself.,"The function creates a mapping where each vertex in the graph maps to itself, establishing an identity isomorphism.","@param <V> : Vertex type
   @param <E> : Edge type
   @return IsomorphicGraphMapping<V,E>: Isomorphic mapping of the graph to itself","graph with vertices {A, B, C} -> identity mapping (each vertex maps to itself)",The graph must not be null; the function returns an identity mapping of the graph.,"public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {
    return new IsomorphicGraphMapping<>(graph, graph::nodeMap, graph::edgeMap);
}",1,Phi-3-mini-4k-instruct
636766ff1a6d9265ec017851,findByte,"protected int findByte(byte value,int pos){
  for (int i=pos; i < tail; i++) {
    if (buffer[i] == value) {
      return i;
    }
  }
  return -1;
}
","/** 
 * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.
 * @param value The value to find.
 * @param pos   The starting position for searching.
 * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.
 */
","Searche for a byte of the specified value in the buffer, starting at the specified position.",Returns the index of a specified byte in a buffer starting from a given position.,"The function searches for the byte value in the buffer array starting at index pos and returns the index if found, else returns -1.","@param value byte: the byte value to search for
@param pos int: the starting position for the search
@return int: the index of the byte if found, otherwise -1","value=5, pos=0, buffer=[1,2,5,3], tail=4 -> 2 (found at index 2)
value=7, pos=1, buffer=[8,7,6,7], tail=4 -> 1 (found at index 1)
value=2, pos=3, buffer=[9,2,4,5], tail=4 -> -1 (not found)","pos must be non-negative and less than or equal to tail; if the value is found, its index is returned, otherwise -1 is returned.","protected int findByte(byte value,int pos){
for(int i=pos; i<buffer.length; i++){
if(buffer[i]==value){
return i;
}
}
return -1;
}",0,starcoder2-7b
636766ff1a6d9265ec017851,findByte,"protected int findByte(byte value,int pos){
  for (int i=pos; i < tail; i++) {
    if (buffer[i] == value) {
      return i;
    }
  }
  return -1;
}
","/** 
 * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.
 * @param value The value to find.
 * @param pos   The starting position for searching.
 * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.
 */
","Searche for a byte of the specified value in the buffer, starting at the specified position.",Returns the index of a specified byte in a buffer starting from a given position.,"The function searches for the byte value in the buffer array starting at index pos and returns the index if found, else returns -1.","@param value byte: the byte value to search for
@param pos int: the starting position for the search
@return int: the index of the byte if found, otherwise -1","value=5, pos=0, buffer=[1,2,5,3], tail=4 -> 2 (found at index 2)
value=7, pos=1, buffer=[8,7,6,7], tail=4 -> 1 (found at index 1)
value=2, pos=3, buffer=[9,2,4,5], tail=4 -> -1 (not found)","pos must be non-negative and less than or equal to tail; if the value is found, its index is returned, otherwise -1 is returned.","protected int findByte(byte value,int pos){
int length=getPayloadLength();
if(pos>length){
return -1;
}
for(int i=pos;i<length;i++){
if(buffer[i]==value){
return i;
}
}
return -1;
}",1,CodeLlama-7b-Instruct-hf
636767a41a6d9265ec018582,writeDelimitedTo,"public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {
  if (buffer.start != buffer.offset)   throw new IllegalArgumentException(""Buffer previously used and had not been reset."");
  final ProtobufOutput output=new ProtobufOutput(buffer);
  schema.writeTo(output,message);
  final int size=output.getSize();
  ProtobufOutput.writeRawVarInt32Bytes(out,size);
  final int msgSize=LinkedBuffer.writeTo(out,buffer);
  assert size == msgSize;
  return size;
}
","/** 
 * Serializes the  {@code message}, prefixed with its length, into an  {@link OutputStream}.
 * @return the size of the message
 */
","Use ProtobufOutput and the LinkedBuffer to write the message into the given OutputStream out, and return the message size.",Writes a serialized message with a header to an OutputStream.,Serializes a message using a schema and writes it to an output stream with a header representing the message's size.,"@param out OutputStream: The output stream to write the serialized data.
   @param message T: The message to be serialized.
   @param schema Schema<T>: The schema used for message serialization.
   @param buffer LinkedBuffer: The buffer used for holding serialized data.
   @return int: The size of the serialized message.
   @throws IOException: If an I/O error occurs.","out, message, schema, buffer -> size (writes message to output)
out, null, schema, buffer -> exception (null message case)
out, message, null, buffer -> exception (null schema case)",Buffer must be reset before use; function writes size-prefixed serialized message to stream.,"public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {
  if (buffer.start != buffer.offset)   throw new IllegalArgumentException(""Buffer previously used and had not been reset."");
  final ProtobufOutput output=new ProtobufOutput(buffer);
  schema.writeTo(output,message);
  final int size=output.getSize();
  ProtobufOutput.writeRawVarInt32Bytes(out,size);
  final int msgSize=LinkedBuffer.writeTo(out,buffer);
  assert size == msgSize;
  return size;
}
",0,reference
636767a41a6d9265ec018582,writeDelimitedTo,"public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {
  if (buffer.start != buffer.offset)   throw new IllegalArgumentException(""Buffer previously used and had not been reset."");
  final ProtobufOutput output=new ProtobufOutput(buffer);
  schema.writeTo(output,message);
  final int size=output.getSize();
  ProtobufOutput.writeRawVarInt32Bytes(out,size);
  final int msgSize=LinkedBuffer.writeTo(out,buffer);
  assert size == msgSize;
  return size;
}
","/** 
 * Serializes the  {@code message}, prefixed with its length, into an  {@link OutputStream}.
 * @return the size of the message
 */
","Use ProtobufOutput and the LinkedBuffer to write the message into the given OutputStream out, and return the message size.",Writes a serialized message with a header to an OutputStream.,Serializes a message using a schema and writes it to an output stream with a header representing the message's size.,"@param out OutputStream: The output stream to write the serialized data.
   @param message T: The message to be serialized.
   @param schema Schema<T>: The schema used for message serialization.
   @param buffer LinkedBuffer: The buffer used for holding serialized data.
   @return int: The size of the serialized message.
   @throws IOException: If an I/O error occurs.","out, message, schema, buffer -> size (writes message to output)
out, null, schema, buffer -> exception (null message case)
out, message, null, buffer -> exception (null schema case)",Buffer must be reset before use; function writes size-prefixed serialized message to stream.,"public static <T> int writeDelimitedTo(OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {
        if (!(message instanceof Message)) {
            throw new IllegalArgumentException(""The provided message is not an instance of protobuf Message."");
        }
        Message protobufMessage = (Message) message;
        byte[] data;
        try {
            CodedOutputStream cos = CodedOutputStream.newInstance(buffer);
            protobufMessage.writeTo(cos);
            data = cos.toByteArray();
        } catch (IOException e) {
            buffer.clear();
            throw e;
        }

        int messageSize = data.length;
        CodedOutputStream headerCOS = CodedOutputStream.newInstance(new byte[5]);
        headerCOS.writeRawVarint32(messageSize);
        byte[] headerBytes = headerCOS.toByteArray();
        out.write(headerBytes);
        out.write(data);
        buffer.clear();

        return messageSize + headerBytes.length;
    }",1,Qwen2.5-Coder-7B-Instruct
636766821a6d9265ec0174b6,resolveArguments,"public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){
  Class<?>[] result=null;
  if (genericType instanceof ParameterizedType) {
    ParameterizedType paramType=(ParameterizedType)genericType;
    Type[] arguments=paramType.getActualTypeArguments();
    result=new Class[arguments.length];
    for (int i=0; i < arguments.length; i++)     result[i]=resolveClass(arguments[i],targetType);
  }
 else   if (genericType instanceof TypeVariable) {
    result=new Class[1];
    result[0]=resolveClass(genericType,targetType);
  }
  return result;
}
","/** 
 * Resolves the arguments for the  {@code genericType} using the type variable information for the{@code targetType}. Returns  {@code null} if {@code genericType} is not parameterized or ifarguments cannot be resolved.
 */
",Resolve and return the arguments for the genericType using the type variable information for the targetType. Returns null if  genericType is not parameterized or if arguments cannot be resolved.,Resolves generic type arguments to their class types.,"The function converts a generic type to an array of Class objects representing the resolved types, using the target type for context.","@param genericType Type: the generic type to resolve
@param targetType Class<?>: the target class for resolving types
@return Class<?>[]: an array of resolved class types","List<String> -> [String] (resolves List type argument)
Map<K,V> -> [K, V] (resolves Map type arguments)
T extends Number -> [Number] (resolves type variable)","Input types must be valid and compatible, results may be null if input isn't parameterized or a type variable.","public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){
  Class<?>[] result=null;
  if (genericType instanceof ParameterizedType) {
    ParameterizedType paramType=(ParameterizedType)genericType;
    Type[] arguments=paramType.getActualTypeArguments();
    result=new Class[arguments.length];
    for (int i=0; i < arguments.length; i++)     result[i]=resolveClass(arguments[i],targetType);
  }
 else   if (genericType instanceof TypeVariable) {
    result=new Class[1];
    result[0]=resolveClass(genericType,targetType);
  }
  return result;
}
",0,reference
636766821a6d9265ec0174b6,resolveArguments,"public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){
  Class<?>[] result=null;
  if (genericType instanceof ParameterizedType) {
    ParameterizedType paramType=(ParameterizedType)genericType;
    Type[] arguments=paramType.getActualTypeArguments();
    result=new Class[arguments.length];
    for (int i=0; i < arguments.length; i++)     result[i]=resolveClass(arguments[i],targetType);
  }
 else   if (genericType instanceof TypeVariable) {
    result=new Class[1];
    result[0]=resolveClass(genericType,targetType);
  }
  return result;
}
","/** 
 * Resolves the arguments for the  {@code genericType} using the type variable information for the{@code targetType}. Returns  {@code null} if {@code genericType} is not parameterized or ifarguments cannot be resolved.
 */
",Resolve and return the arguments for the genericType using the type variable information for the targetType. Returns null if  genericType is not parameterized or if arguments cannot be resolved.,Resolves generic type arguments to their class types.,"The function converts a generic type to an array of Class objects representing the resolved types, using the target type for context.","@param genericType Type: the generic type to resolve
@param targetType Class<?>: the target class for resolving types
@return Class<?>[]: an array of resolved class types","List<String> -> [String] (resolves List type argument)
Map<K,V> -> [K, V] (resolves Map type arguments)
T extends Number -> [Number] (resolves type variable)","Input types must be valid and compatible, results may be null if input isn't parameterized or a type variable.","public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){
    Argument argument = findMatchingArgument(targetType, genericType);
    if(argument!=null){
        return argument.getResolvedArguments();
    }
    return null;
}",1,starcoder2-7b
636767e11a6d9265ec018781,accept,"@Override public void accept(final METRICS data){
  final String id=data.id();
  final METRICS existed=buffer.get(id);
  if (existed == null) {
    buffer.put(id,data);
  }
 else {
    final boolean isAbandoned=!existed.combine(data);
    if (isAbandoned) {
      buffer.remove(id);
    }
  }
}
","/** 
 * Accept the data into the cache and merge with the existing value. This method is not thread safe, should avoid concurrency calling.
 * @param data to be added potentially.
 */
","Accept the data into the buffer if its id does not exist in the buffer. Otherwise try to combine it with the existing value, and remove it if the combined is abandoned.",Update or remove METRICS data in a buffer.,"The function checks if METRICS data already exists in the buffer, adds it if not, or combines it if it does; it removes the data if it's flagged as abandoned.",@param data METRICS: The METRICS object to be processed.,"new data -> buffer updated (Data added when new)
repeat data, not combined -> buffer unchanged (Data exists and combined)
repeat data, combined, abandoned -> buffer updated (Data removed when abandoned)","Assumes `data` implements `combine` method and `buffer` supports put, get, remove operations, ensures buffer consistently represents current METRICS state.","@Override public void accept(final METRICS data){
  final String id=data.id();
  final METRICS existed=buffer.get(id);
  if (existed == null) {
    buffer.put(id,data);
  }
 else {
    final boolean isAbandoned=!existed.combine(data);
    if (isAbandoned) {
      buffer.remove(id);
    }
  }
}
",0,reference
636767e11a6d9265ec018781,accept,"@Override public void accept(final METRICS data){
  final String id=data.id();
  final METRICS existed=buffer.get(id);
  if (existed == null) {
    buffer.put(id,data);
  }
 else {
    final boolean isAbandoned=!existed.combine(data);
    if (isAbandoned) {
      buffer.remove(id);
    }
  }
}
","/** 
 * Accept the data into the cache and merge with the existing value. This method is not thread safe, should avoid concurrency calling.
 * @param data to be added potentially.
 */
","Accept the data into the buffer if its id does not exist in the buffer. Otherwise try to combine it with the existing value, and remove it if the combined is abandoned.",Update or remove METRICS data in a buffer.,"The function checks if METRICS data already exists in the buffer, adds it if not, or combines it if it does; it removes the data if it's flagged as abandoned.",@param data METRICS: The METRICS object to be processed.,"new data -> buffer updated (Data added when new)
repeat data, not combined -> buffer unchanged (Data exists and combined)
repeat data, combined, abandoned -> buffer updated (Data removed when abandoned)","Assumes `data` implements `combine` method and `buffer` supports put, get, remove operations, ensures buffer consistently represents current METRICS state.","@Override public void accept(final METRICS data){
if (cache.containsKey(data.getKey())) {
        METRICS existing = cache.get(data.getKey());
        existing.merge(data);
        cache.put(data.getKey(), existing);
    } else {
        cache.put(data.getKey(), data);
    }
}",1,gpt-4-turbo
636766f11a6d9265ec017641,available,"@Override public int available() throws IOException {
  return this.index < this.length ? this.length - this.index : this.length >= 0 && this.reader.ready() ? 1 : 0;
}
","/** 
 * @see InputStream#available() 
 */
",Check the available space of this InputStream according to the index.,Returns number of bytes available in stream without blocking.,"The function checks if there are remaining bytes to read; otherwise, it verifies if the underlying reader is ready to provide more data.","@return int: Number of bytes available or a readiness indication.
@throws IOException: If an I/O error occurs.","index=2, length=5, reader.ready()
=false -> 3 (5 - 2 means 3 bytes available)
index=5, length=5, reader.ready()
=true -> 1 (index=length, but reader is ready)
index=5, length=5, reader.ready()
=false -> 0 (no bytes available, reader not ready)",The stream has a defined length and index; returns available bytes or readiness check result; may throw IOException.,"@Override public int available() throws IOException {
  return this.index < this.length ? this.length - this.index : this.length >= 0 && this.reader.ready() ? 1 : 0;
}
",0,reference
636766f11a6d9265ec017641,available,"@Override public int available() throws IOException {
  return this.index < this.length ? this.length - this.index : this.length >= 0 && this.reader.ready() ? 1 : 0;
}
","/** 
 * @see InputStream#available() 
 */
",Check the available space of this InputStream according to the index.,Returns number of bytes available in stream without blocking.,"The function checks if there are remaining bytes to read; otherwise, it verifies if the underlying reader is ready to provide more data.","@return int: Number of bytes available or a readiness indication.
@throws IOException: If an I/O error occurs.","index=2, length=5, reader.ready()
=false -> 3 (5 - 2 means 3 bytes available)
index=5, length=5, reader.ready()
=true -> 1 (index=length, but reader is ready)
index=5, length=5, reader.ready()
=false -> 0 (no bytes available, reader not ready)",The stream has a defined length and index; returns available bytes or readiness check result; may throw IOException.,"@Override public int available() throws IOException {
return index + offset - available;
}",1,starcoder2-7b
636767dd1a6d9265ec0186e5,addNewTarget,"public void addNewTarget(Channels channels,IConsumer consumer){
  Group group=new Group(channels,consumer);
  ArrayList<Group> newList=new ArrayList<Group>();
  for (  Group target : consumeTargets) {
    newList.add(target);
  }
  newList.add(group);
  consumeTargets=newList;
  size+=channels.size();
}
","/** 
 * Add a new target channels.
 */
",Add the given target channels to the consumeTargets.,Adds a new target to the existing list of consume targets.,"Creates a new Group object using provided channels and consumer, adds it to a list, and updates consumeTargets.","@param channels Channels: Channels instance for group.
   @param consumer IConsumer: Consumer instance for group.","addNewTarget(ch1, cons1)
-> adds group to consumeTargets (adds ch1, cons1 to list)","List of consumeTargets must be iterable, increased by one Group object after the function executes.","public void addNewTarget(Channels channels,IConsumer consumer){
  Group group=new Group(channels,consumer);
  ArrayList<Group> newList=new ArrayList<Group>();
  for (  Group target : consumeTargets) {
    newList.add(target);
  }
  newList.add(group);
  consumeTargets=newList;
  size+=channels.size();
}
",0,reference
636767dd1a6d9265ec0186e5,addNewTarget,"public void addNewTarget(Channels channels,IConsumer consumer){
  Group group=new Group(channels,consumer);
  ArrayList<Group> newList=new ArrayList<Group>();
  for (  Group target : consumeTargets) {
    newList.add(target);
  }
  newList.add(group);
  consumeTargets=newList;
  size+=channels.size();
}
","/** 
 * Add a new target channels.
 */
",Add the given target channels to the consumeTargets.,Adds a new target to the existing list of consume targets.,"Creates a new Group object using provided channels and consumer, adds it to a list, and updates consumeTargets.","@param channels Channels: Channels instance for group.
   @param consumer IConsumer: Consumer instance for group.","addNewTarget(ch1, cons1)
-> adds group to consumeTargets (adds ch1, cons1 to list)","List of consumeTargets must be iterable, increased by one Group object after the function executes.","public void addNewTarget(Channels channels, IConsumer consumer) {
        ConsumeTarget consumeTarget = new ConsumeTarget(channels, consumer);
        consumeTargets.add(consumeTarget);
    }",1,Qwen2.5-Coder-7B-Instruct
636767871a6d9265ec01846d,createConfigurationDirectory,"public static void createConfigurationDirectory(){
  String home=System.getProperty(""user.home"");
  String sep=System.getProperty(""file.separator"");
  File f=new File(home + sep + ""lf5"");
  if (!f.exists()) {
    try {
      f.mkdir();
    }
 catch (    SecurityException e) {
      e.printStackTrace();
    }
  }
}
","/** 
 * Creates the directory where the MRU file list will be written. The ""lf5"" directory is created in the Documents and Settings directory on Windows 2000 machines and where ever the user.home variable points on all other platforms.
 */
","Create the ""lf5"" directory in the Documents and Settings directory on Windows machines, or the user.home variable points on all other platforms.","Creates a directory named ""lf5"" in the user's home directory.","Checks if the ""lf5"" directory exists in the user's home directory and creates it if it doesn't. Handles security exceptions if directory creation is restricted.",@throws SecurityException: If the directory cannot be created due to security restrictions.,"Home directory doesn't have ""lf5"" -> Directory ""lf5"" created Home directory has ""lf5"" -> No action taken Directory creation security issue -> Security exception stack trace","Preconditions: The file system supports directory creation; Postconditions: A ""lf5"" directory exists in the user's home directory if it was initially absent.","public static void createConfigurationDirectory() {
        String userHome = System.getProperty(""user.home"");
        File configDir;
        
        if (System.getProperty(""os.name"").toLowerCase().contains(""windows"")) {
            configDir = new File(userHome + ""/Documents and Settings/lf5"");
        } else {
            configDir = new File(userHome + ""/lf5"");
        }
        
        if (!configDir.exists()) {
            if (configDir.mkdirs()) {
                System.out.println(""Configuration directory created successfully."");
            } else {
                System.out.println(""Failed to create configuration directory."");
            }
        } else {
            System.out.println(""Configuration directory already exists."");
        }
    }",0,Qwen2.5-Coder-7B-Instruct
636767871a6d9265ec01846d,createConfigurationDirectory,"public static void createConfigurationDirectory(){
  String home=System.getProperty(""user.home"");
  String sep=System.getProperty(""file.separator"");
  File f=new File(home + sep + ""lf5"");
  if (!f.exists()) {
    try {
      f.mkdir();
    }
 catch (    SecurityException e) {
      e.printStackTrace();
    }
  }
}
","/** 
 * Creates the directory where the MRU file list will be written. The ""lf5"" directory is created in the Documents and Settings directory on Windows 2000 machines and where ever the user.home variable points on all other platforms.
 */
","Create the ""lf5"" directory in the Documents and Settings directory on Windows machines, or the user.home variable points on all other platforms.","Creates a directory named ""lf5"" in the user's home directory.","Checks if the ""lf5"" directory exists in the user's home directory and creates it if it doesn't. Handles security exceptions if directory creation is restricted.",@throws SecurityException: If the directory cannot be created due to security restrictions.,"Home directory doesn't have ""lf5"" -> Directory ""lf5"" created Home directory has ""lf5"" -> No action taken Directory creation security issue -> Security exception stack trace","Preconditions: The file system supports directory creation; Postconditions: A ""lf5"" directory exists in the user's home directory if it was initially absent.","public static void createConfigurationDirectory() {
    String configurationDirectory = ""lf5"";
    String path = Paths.get(System.getProperty(""user.home""), configurationDirectory);
    try {
        Files.createDirectories(path);
    } catch (IOException e) {
        e.printStackTrace();
    }
}",1,Phi-3-mini-4k-instruct
636766f81a6d9265ec01775b,readLong,"public long readLong(final int offset){
  long l1=readInt(offset);
  long l0=readInt(offset + 4) & 0xFFFFFFFFL;
  return (l1 << 32) | l0;
}
","/** 
 * Reads a signed long value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
 * @param offset the start offset of the value to be read in this {@link ClassReader}.
 * @return the read value.
 */
",Read a signed long value.,Concatenates two int values to form a long.,"This function reads two 32-bit integers from a specified offset in memory, combines them into a 64-bit long value, and returns it. The first integer is the most significant, and the second is the least significant part.","@param offset int: The starting position to read from memory.
@return long: The combined 64-bit long value created from two 32-bit integers.","8 -> 34359738368 (two 32-bit ints are combined)
0 -> 1234567890123 (example for non-zero result)
12 -> 0 (zero case result)","Offset should be within bounds of addressable memory, and two 32-bit integers will be correctly combined into one 64-bit long.","public long readLong(final int offset) {
    long high = readInt(offset);
    long low = readInt(offset + 4) & 0xFFFFFFFFL;
    return (high << 32) + low;
}",0,gpt-4-turbo
636766f81a6d9265ec01775b,readLong,"public long readLong(final int offset){
  long l1=readInt(offset);
  long l0=readInt(offset + 4) & 0xFFFFFFFFL;
  return (l1 << 32) | l0;
}
","/** 
 * Reads a signed long value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
 * @param offset the start offset of the value to be read in this {@link ClassReader}.
 * @return the read value.
 */
",Read a signed long value.,Concatenates two int values to form a long.,"This function reads two 32-bit integers from a specified offset in memory, combines them into a 64-bit long value, and returns it. The first integer is the most significant, and the second is the least significant part.","@param offset int: The starting position to read from memory.
@return long: The combined 64-bit long value created from two 32-bit integers.","8 -> 34359738368 (two 32-bit ints are combined)
0 -> 1234567890123 (example for non-zero result)
12 -> 0 (zero case result)","Offset should be within bounds of addressable memory, and two 32-bit integers will be correctly combined into one 64-bit long.","public long readLong(final int offset) {
    long result = 0;
    try {
        result = buffer.getLong(offset);
    } catch (BufferUnderflowException e) {
        // Handle buffer underflow
    }
    return result;
}",1,Phi-3-mini-4k-instruct
636767a51a6d9265ec01859d,equals,"public boolean equals(final byte[] data,int offset,final int len){
  final byte[] bytes=this.bytes;
  if (len != bytes.length)   return false;
  for (int i=0; i < len; ) {
    if (bytes[i++] != data[offset++]) {
      return false;
    }
  }
  return true;
}
","/** 
 * Returns true if the contents of the internal array and the provided array match.
 */
",Return true if the contents of the internal array bytes and the provided array data match.,Compares a subarray of bytes with an instance array.,"The function checks if a segment of the input array `data`, starting at `offset` and of length `len`, matches the instance byte array.","@param data byte[]: Array to compare with instance.
@param offset int: Starting index in data for comparison.
@param len int: Length of subarray in data to compare.
@return boolean: True if the specified segment of data equals the instance array, false otherwise.","[1,2,3], 0, 3 -> true (exact match)
[1,2,3,4], 1, 3 -> false (wrong length)
[1,2,4], 0, 3 -> false (different bytes)","The length of `bytes` must equal `len`, and `offset+len` must be within the bounds of `data`. The method returns true only if the specified segment matches `bytes`.","public boolean equals(final byte[] data, int offset, final int len) {
    // Check if the lengths are the same
    if (bytes.length != len) {
        return false;
    }

    // Iterate through the bytes array to compare with the provided data starting from the given offset
    for (int i = 0; i < bytes.length; i++) {
        if (bytes[i] != data[offset + i]) {
            return false;
        }
    }

    // If all elements match, return true
    return true;
}",0,Qwen2.5-Coder-7B-Instruct
636767a51a6d9265ec01859d,equals,"public boolean equals(final byte[] data,int offset,final int len){
  final byte[] bytes=this.bytes;
  if (len != bytes.length)   return false;
  for (int i=0; i < len; ) {
    if (bytes[i++] != data[offset++]) {
      return false;
    }
  }
  return true;
}
","/** 
 * Returns true if the contents of the internal array and the provided array match.
 */
",Return true if the contents of the internal array bytes and the provided array data match.,Compares a subarray of bytes with an instance array.,"The function checks if a segment of the input array `data`, starting at `offset` and of length `len`, matches the instance byte array.","@param data byte[]: Array to compare with instance.
@param offset int: Starting index in data for comparison.
@param len int: Length of subarray in data to compare.
@return boolean: True if the specified segment of data equals the instance array, false otherwise.","[1,2,3], 0, 3 -> true (exact match)
[1,2,3,4], 1, 3 -> false (wrong length)
[1,2,4], 0, 3 -> false (different bytes)","The length of `bytes` must equal `len`, and `offset+len` must be within the bounds of `data`. The method returns true only if the specified segment matches `bytes`.","public boolean equals(final byte[] data,int offset,final int len){
for(int i = offset, j = 0; j < len; i++, j++) {
if(bytes[i] != data[j])
return false;
}
return true;
}",1,CodeLlama-7b-Instruct-hf
6367670b1a6d9265ec0179ff,nullToEmpty,"public static Byte[] nullToEmpty(final Byte[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
",Return an EMPTY_BYTE_OBJECT_ARRAY array for a null or empty input array.,Converts null or empty Byte arrays to a predefined empty array.,"The function returns a predefined empty Byte array if the input array is null or empty, otherwise it returns the original array.",@return Byte[]: Returns a non-null Byte array.,"null -> predefined empty array (null case)
[] -> predefined empty array (empty case)
[1, 2, 3] -> [1, 2, 3] (non-empty case)",Input can be null or an array of any length. Output is always a non-null Byte array.,"public static Byte[] nullToEmpty(final Byte[] array){
  return array != null && array.length != 0 ? array : EMPTY_BYTE_OBJECT_ARRAY;
}",0,CodeLlama-7b-Instruct-hf
6367670b1a6d9265ec0179ff,nullToEmpty,"public static Byte[] nullToEmpty(final Byte[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
",Return an EMPTY_BYTE_OBJECT_ARRAY array for a null or empty input array.,Converts null or empty Byte arrays to a predefined empty array.,"The function returns a predefined empty Byte array if the input array is null or empty, otherwise it returns the original array.",@return Byte[]: Returns a non-null Byte array.,"null -> predefined empty array (null case)
[] -> predefined empty array (empty case)
[1, 2, 3] -> [1, 2, 3] (non-empty case)",Input can be null or an array of any length. Output is always a non-null Byte array.,"public static Byte[] nullToEmpty(final Byte[] array){
    return array == null || array.length == 0? EMPTY_BYTE_ARRAY : array;
}",1,starcoder2-7b
6367677f1a6d9265ec018347,send,"public synchronized void send(final String message){
  Iterator ce=connections.iterator();
  for (Iterator e=writers.iterator(); e.hasNext(); ) {
    ce.next();
    PrintWriter writer=(PrintWriter)e.next();
    writer.print(message);
    if (writer.checkError()) {
      ce.remove();
      e.remove();
    }
  }
}
","/** 
 * sends a message to each of the clients in telnet-friendly output. 
 */
",Send a message to each of the connections in telnet-friendly output. ,Sends a message to all active connections.,"Iterates through writers to send a message, removing those with errors from the list.",@param message String: The message to send to each connection.,"""Hello"" -> Messages sent (sends ""Hello"" to all connections)
""Test"" -> Errors checked (removes connections if errors detected)
""Update"" -> Connections cleaned (updates connections list)",Message is sent to connections; connections with errors are removed. Connections must be iterable and allow removal during iteration.,"public synchronized void send(final String message){
  Iterator ce=connections.iterator();
  for (Iterator e=writers.iterator(); e.hasNext(); ) {
    ce.next();
    PrintWriter writer=(PrintWriter)e.next();
    writer.print(message);
    if (writer.checkError()) {
      ce.remove();
      e.remove();
    }
  }
}
",0,reference
6367677f1a6d9265ec018347,send,"public synchronized void send(final String message){
  Iterator ce=connections.iterator();
  for (Iterator e=writers.iterator(); e.hasNext(); ) {
    ce.next();
    PrintWriter writer=(PrintWriter)e.next();
    writer.print(message);
    if (writer.checkError()) {
      ce.remove();
      e.remove();
    }
  }
}
","/** 
 * sends a message to each of the clients in telnet-friendly output. 
 */
",Send a message to each of the connections in telnet-friendly output. ,Sends a message to all active connections.,"Iterates through writers to send a message, removing those with errors from the list.",@param message String: The message to send to each connection.,"""Hello"" -> Messages sent (sends ""Hello"" to all connections)
""Test"" -> Errors checked (removes connections if errors detected)
""Update"" -> Connections cleaned (updates connections list)",Message is sent to connections; connections with errors are removed. Connections must be iterable and allow removal during iteration.,"public synchronized void send(final String message){
send(message,null);
}",1,starcoder2-7b
6367670a1a6d9265ec0179e8,nullToEmpty,"public static Boolean[] nullToEmpty(final Boolean[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
",Return an EMPTY_BOOLEAN_OBJECT_ARRAY array for a null or empty input array.,Returns an empty Boolean array if input is null or empty.,"If the input array is null or has no elements, it returns a constant empty Boolean array. Otherwise, it returns the original array.","@param array Boolean[]: input array of Boolean objects
   @return Boolean[]: empty array if input is null or empty, else original array","null -> []
   [] -> [] 
   [true, false] -> [true, false]","Input can be null or an array; output is empty if input is null/empty, unchanged otherwise.","public static Boolean[] nullToEmpty(final Boolean[] array){
     if(array == null)
         return new Boolean[]{};
     return array;
}",0,starcoder2-7b
6367670a1a6d9265ec0179e8,nullToEmpty,"public static Boolean[] nullToEmpty(final Boolean[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
",Return an EMPTY_BOOLEAN_OBJECT_ARRAY array for a null or empty input array.,Returns an empty Boolean array if input is null or empty.,"If the input array is null or has no elements, it returns a constant empty Boolean array. Otherwise, it returns the original array.","@param array Boolean[]: input array of Boolean objects
   @return Boolean[]: empty array if input is null or empty, else original array","null -> []
   [] -> [] 
   [true, false] -> [true, false]","Input can be null or an array; output is empty if input is null/empty, unchanged otherwise.","public static Boolean[] nullToEmpty(final Boolean[] array){
    return isNullOrEmpty(array) ? EMPTY_BOOLEAN_OBJECT_ARRAY : array;
}",1,CodeLlama-7b-Instruct-hf
6367677f1a6d9265ec01834b,put,"public void put(LoggingEvent o){
  if (numElements != maxSize) {
    buf[next]=o;
    if (++next == maxSize) {
      next=0;
    }
    numElements++;
  }
}
","/** 
 * Place a  {@link LoggingEvent} in the buffer. If the buffer is fullthen the event is <b>silently dropped</b>. It is the caller's responsability to make sure that the buffer has free space.  
 */
",Place a  LoggingEvent in the buffer buf.,Inserts a LoggingEvent into a circular buffer.,Adds a LoggingEvent to the next position if the buffer is not full and updates indices. No action if the buffer is full.,@param o LoggingEvent: The event to be logged into the buffer.,"empty buffer, event -> event added at position 0 (position increments, numElements increments)
full buffer, event -> no change (buffer remains full)
50% full buffer, event -> event added to next position (position and numElements increment)","Buffer has a fixed size, elements are added if space is available; buffer indices and element count are maintained.","public void put(LoggingEvent o){
  if (numElements != maxSize) {
    buf[next]=o;
    if (++next == maxSize) {
      next=0;
    }
    numElements++;
  }
}
",0,reference
6367677f1a6d9265ec01834b,put,"public void put(LoggingEvent o){
  if (numElements != maxSize) {
    buf[next]=o;
    if (++next == maxSize) {
      next=0;
    }
    numElements++;
  }
}
","/** 
 * Place a  {@link LoggingEvent} in the buffer. If the buffer is fullthen the event is <b>silently dropped</b>. It is the caller's responsability to make sure that the buffer has free space.  
 */
",Place a  LoggingEvent in the buffer buf.,Inserts a LoggingEvent into a circular buffer.,Adds a LoggingEvent to the next position if the buffer is not full and updates indices. No action if the buffer is full.,@param o LoggingEvent: The event to be logged into the buffer.,"empty buffer, event -> event added at position 0 (position increments, numElements increments)
full buffer, event -> no change (buffer remains full)
50% full buffer, event -> event added to next position (position and numElements increment)","Buffer has a fixed size, elements are added if space is available; buffer indices and element count are maintained.","public void put(LoggingEvent o){
    buf.append(o);
}",1,Qwen2.5-Coder-7B-Instruct
636767df1a6d9265ec018744,buildTimeRanges,"protected List<TimeRange> buildTimeRanges(long start,long end){
  if (start >= end) {
    return null;
  }
  end+=1;
  final List<TimeRange> timeRanges=new ArrayList<>();
  do {
    long batchEnd=Math.min(start + FETCH_DATA_DURATION,end);
    timeRanges.add(new TimeRange(start,batchEnd));
    start=batchEnd;
  }
 while (start < end);
  return timeRanges;
}
","/** 
 * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}
 */
",Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.,Splits a time range into smaller ranges based on a constant duration.,"Divides a start-to-end time range into smaller ranges each with a maximum duration defined by FETCH_DATA_DURATION, returning a list of these ranges.","@param start long: the start of the time range
   @param end long: the end of the time range
   @return List<TimeRange>: list of smaller time ranges","100, 200 -> [TimeRange(100, 160)
, TimeRange(160, 201)
] (time ranges split by FETCH_DATA_DURATION)
150, 150 -> null (start equals end, returns null)
80, 60 -> null (invalid range, start greater than end)","The start must be less than end to return a valid list, otherwise returns null. The list consists of TimeRanges each with a duration up to FETCH_DATA_DURATION.","protected List<TimeRange> buildTimeRanges(long start,long end){
  if (start >= end) {
    return null;
  }
  end+=1;
  final List<TimeRange> timeRanges=new ArrayList<>();
  do {
    long batchEnd=Math.min(start + FETCH_DATA_DURATION,end);
    timeRanges.add(new TimeRange(start,batchEnd));
    start=batchEnd;
  }
 while (start < end);
  return timeRanges;
}
",0,reference
636767df1a6d9265ec018744,buildTimeRanges,"protected List<TimeRange> buildTimeRanges(long start,long end){
  if (start >= end) {
    return null;
  }
  end+=1;
  final List<TimeRange> timeRanges=new ArrayList<>();
  do {
    long batchEnd=Math.min(start + FETCH_DATA_DURATION,end);
    timeRanges.add(new TimeRange(start,batchEnd));
    start=batchEnd;
  }
 while (start < end);
  return timeRanges;
}
","/** 
 * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}
 */
",Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.,Splits a time range into smaller ranges based on a constant duration.,"Divides a start-to-end time range into smaller ranges each with a maximum duration defined by FETCH_DATA_DURATION, returning a list of these ranges.","@param start long: the start of the time range
   @param end long: the end of the time range
   @return List<TimeRange>: list of smaller time ranges","100, 200 -> [TimeRange(100, 160)
, TimeRange(160, 201)
] (time ranges split by FETCH_DATA_DURATION)
150, 150 -> null (start equals end, returns null)
80, 60 -> null (invalid range, start greater than end)","The start must be less than end to return a valid list, otherwise returns null. The list consists of TimeRanges each with a duration up to FETCH_DATA_DURATION.","protected List<TimeRange> buildTimeRanges(long start,long end){
    long t = start;
    List<TimeRange> ret = new ArrayList<>();
    while(end>t){
        long n = t+FetchDataExecutor.FETCH_DATA_DURATION_MILLS-1;
        long e = n>=end?end:n+1;
        TimeRange tR = new TimeRange();
        tR.start = t;
        tR.end = e;
        t = e+1;
        ret.add(tR);
    }
    return ret;
}",1,CodeLlama-7b-Instruct-hf
636767031a6d9265ec0178e6,toPrimitive,"public static byte[] toPrimitive(final Byte[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_BYTE_ARRAY;
  }
  final byte[] result=new byte[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].byteValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Bytes to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Byte</code> array, may be <code>null</code>
 * @return a <code>byte</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Convert an array of object Bytes to primitives, return null for a null input array.",Converts an array of Byte objects to a primitive byte array.,"The method checks for null and empty input, then iterates over an array of Byte objects and converts each element to its primitive byte value.","@param array Byte[]: Array containing Byte objects to convert
@return byte[]: Converted array of primitive byte values","null -> null (in case of null input)
, [] -> [] (empty array results in empty array)
, [Byte(1)
,Byte(2)
] -> [1,2] (conversion from Byte objects to bytes)","Input may be null, output will be null if input is null; otherwise, output is a byte array of the same length as input.","public static byte[] toPrimitive(final Byte[] array) {
    if (array == null) {
        return null;
    }
    int size = array.length;
    byte[] result = new byte[size];
    for (int i = 0; i < size; i++) {
        result[i] = array[i].byteValue();
    }
    return result;
}",0,Phi-3-mini-4k-instruct
636767031a6d9265ec0178e6,toPrimitive,"public static byte[] toPrimitive(final Byte[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_BYTE_ARRAY;
  }
  final byte[] result=new byte[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].byteValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Bytes to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Byte</code> array, may be <code>null</code>
 * @return a <code>byte</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Convert an array of object Bytes to primitives, return null for a null input array.",Converts an array of Byte objects to a primitive byte array.,"The method checks for null and empty input, then iterates over an array of Byte objects and converts each element to its primitive byte value.","@param array Byte[]: Array containing Byte objects to convert
@return byte[]: Converted array of primitive byte values","null -> null (in case of null input)
, [] -> [] (empty array results in empty array)
, [Byte(1)
,Byte(2)
] -> [1,2] (conversion from Byte objects to bytes)","Input may be null, output will be null if input is null; otherwise, output is a byte array of the same length as input.","public static byte[] toPrimitive(final Byte[] array){
    final Object[] primitiveArray = null == array ? null : Arrays.stream(array).map(Byte::byteValue).toArray();
    return (byte[]) primitiveArray;
}",1,CodeLlama-7b-Instruct-hf
636767dc1a6d9265ec0186be,compressTimeBucket,"static long compressTimeBucket(long timeBucket,int dayStep){
  if (dayStep > 1) {
    DateTime time=TIME_BUCKET_FORMATTER.parseDateTime("""" + timeBucket);
    int days=Days.daysBetween(DAY_ONE,time).getDays();
    int groupBucketOffset=days % dayStep;
    return Long.parseLong(time.minusDays(groupBucketOffset).toString(TIME_BUCKET_FORMATTER));
  }
 else {
    return timeBucket;
  }
}
","/** 
 * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123
 */
","Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.",Adjusts the given time bucket to align with a specified day step.,The function calculates a new time bucket by adjusting the input bucket back to the nearest multiple of the given day step. It returns the original bucket if the day step is 1.,"@param timeBucket long: The time bucket value to adjust.
@param dayStep int: The number of days defining the step for bucket alignment.
@return long: The adjusted time bucket.
@throws IllegalArgumentException: If parsing of the time bucket fails.","20230101, 2 -> 20230101 (original value returned)
20230102, 2 -> 20230101 (adjusted to previous day step)
20230110, 3 -> 20230109 (adjusted by day step)",Input must be a valid time representation; output is a valid time bucket aligned to the nearest day step.,"public static long compressTimeBucket(long timeBucket, int dayStep) {
    if (timeBucket < 0) {
        throw new IllegalArgumentException(""Time bucket must be non-negative."");
    }

    long compressedBucket = (timeBucket / dayStep) * dayStep;

    return compressedBucket;
}",0,Phi-3-mini-4k-instruct
636767dc1a6d9265ec0186be,compressTimeBucket,"static long compressTimeBucket(long timeBucket,int dayStep){
  if (dayStep > 1) {
    DateTime time=TIME_BUCKET_FORMATTER.parseDateTime("""" + timeBucket);
    int days=Days.daysBetween(DAY_ONE,time).getDays();
    int groupBucketOffset=days % dayStep;
    return Long.parseLong(time.minusDays(groupBucketOffset).toString(TIME_BUCKET_FORMATTER));
  }
 else {
    return timeBucket;
  }
}
","/** 
 * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123
 */
","Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.",Adjusts the given time bucket to align with a specified day step.,The function calculates a new time bucket by adjusting the input bucket back to the nearest multiple of the given day step. It returns the original bucket if the day step is 1.,"@param timeBucket long: The time bucket value to adjust.
@param dayStep int: The number of days defining the step for bucket alignment.
@return long: The adjusted time bucket.
@throws IllegalArgumentException: If parsing of the time bucket fails.","20230101, 2 -> 20230101 (original value returned)
20230102, 2 -> 20230101 (adjusted to previous day step)
20230110, 3 -> 20230109 (adjusted by day step)",Input must be a valid time representation; output is a valid time bucket aligned to the nearest day step.,"public static long compressTimeBucket(long timeBucket, int dayStep) {
    SimpleDateFormat formatter = new SimpleDateFormat(""yyyyMMdd"");
    Date date = new Date(timeBucket);
    String formattedDate = formatter.format(date);

    // Subtracting dayStep to find the starting of the bucket
    int stepInDays = dayStep / (24 * 60 * 60 * 1000); // Converting dayStep into days
    long timeInMillis = date.getTime() - stepInDays * (24 * 60 * 60 * 1000);

    return timeInMillis;
}",1,Qwen2.5-Coder-7B-Instruct
636767a41a6d9265ec01856c,computeUTF8Size,"public static int computeUTF8Size(final CharSequence str,final int index,final int len){
  int size=len;
  for (int i=index; i < len; i++) {
    final char c=str.charAt(i);
    if (c < 0x0080)     continue;
    if (c < 0x0800)     size++;
 else     size+=2;
  }
  return size;
}
","/** 
 * Computes the size of the utf8 string beginning at the specified  {@code index} with the specified {@code length}.
 */
",Compute the size of the utf8 string beginning at the specified  index  with the specified length.,Calculates UTF-8 encoded size of a substring.,Computes the size in bytes of a Unicode string's UTF-8 encoding for a specified range. Applies size rules based on code points from index to len.,"@param str CharSequence: Input string sequence
@param index int: Start index in the string
@param len int: Number of characters to process
@return int: UTF-8 encoded byte size","""Hello"", 0, 5 -> 5 (All characters < 0x0080)
""©opyright"", 0, 9 -> 10 (© is > 0x0080 and < 0x0800)
""𐍈Test"", 0, 5 -> 10 (𐍈 needs 4 bytes)",The function assumes valid UTF-16 input and that range indices are within bounds. Always returns the byte size for UTF-8 encoding.,"public static int computeUTF8Size(final CharSequence str,final int index,final int len){
  int size=len;
  for (int i=index; i < len; i++) {
    final char c=str.charAt(i);
    if (c < 0x0080)     continue;
    if (c < 0x0800)     size++;
 else     size+=2;
  }
  return size;
}
",0,reference
636767a41a6d9265ec01856c,computeUTF8Size,"public static int computeUTF8Size(final CharSequence str,final int index,final int len){
  int size=len;
  for (int i=index; i < len; i++) {
    final char c=str.charAt(i);
    if (c < 0x0080)     continue;
    if (c < 0x0800)     size++;
 else     size+=2;
  }
  return size;
}
","/** 
 * Computes the size of the utf8 string beginning at the specified  {@code index} with the specified {@code length}.
 */
",Compute the size of the utf8 string beginning at the specified  index  with the specified length.,Calculates UTF-8 encoded size of a substring.,Computes the size in bytes of a Unicode string's UTF-8 encoding for a specified range. Applies size rules based on code points from index to len.,"@param str CharSequence: Input string sequence
@param index int: Start index in the string
@param len int: Number of characters to process
@return int: UTF-8 encoded byte size","""Hello"", 0, 5 -> 5 (All characters < 0x0080)
""©opyright"", 0, 9 -> 10 (© is > 0x0080 and < 0x0800)
""𐍈Test"", 0, 5 -> 10 (𐍈 needs 4 bytes)",The function assumes valid UTF-16 input and that range indices are within bounds. Always returns the byte size for UTF-8 encoding.,"public static int computeUTF8Size(final CharSequence str,final int index,final int len){
return computeUTF8Size(str,index,index+len);
}",1,CodeLlama-7b-Instruct-hf
636766f01a6d9265ec017639,asList,"public static <T>List<T> asList(T[] a){
  if (a == null)   return Collections.emptyList();
  return Arrays.asList(a);
}
","/** 
 * Array to List. <p> Works like  {@link Arrays#asList(Object)}, but handles null arrays.
 * @return a list backed by the array.
 */
","Convert an array to list, return empty list for null array.",Converts an array to a list.,"Converts a given array into a list. If the array is null, returns an empty list.","@param a T[]: The input array.
   @return List<T>: A list representing the elements of the array.","asList(new String[]{""a"", ""b""})
-> [""a"", ""b""] (non-null array converted to list)
asList(null)
-> [] (null array results in an empty list)",Inputs potentially null; output list is based on array content or empty if null.,"public static <T>List<T> asList(T[] a){
    return a == null? Collections.emptyList() : Arrays.asList(a);
}",0,starcoder2-7b
636766f01a6d9265ec017639,asList,"public static <T>List<T> asList(T[] a){
  if (a == null)   return Collections.emptyList();
  return Arrays.asList(a);
}
","/** 
 * Array to List. <p> Works like  {@link Arrays#asList(Object)}, but handles null arrays.
 * @return a list backed by the array.
 */
","Convert an array to list, return empty list for null array.",Converts an array to a list.,"Converts a given array into a list. If the array is null, returns an empty list.","@param a T[]: The input array.
   @return List<T>: A list representing the elements of the array.","asList(new String[]{""a"", ""b""})
-> [""a"", ""b""] (non-null array converted to list)
asList(null)
-> [] (null array results in an empty list)",Inputs potentially null; output list is based on array content or empty if null.,"public static <T> List<T> asList(T[] a) {
    return (a == null) ? new LinkedList<>() : new LinkedList<>(Arrays.asList(a));
}",1,Phi-3-mini-4k-instruct
6367672d1a6d9265ec017c74,remove,"public boolean remove(int val){
  if (map.containsKey(val)) {
    map.remove(val);
    values.remove(values.indexOf(val));
    return true;
  }
  return false;
}
","/** 
 * Removes a value from the set. Returns true if the set contained the specified element. 
 */
","Remove a value from the values if the map keys contains the val. Returns true if actually removed, and false otherwise.",Removes a value from a map and list.,"Checks if the value exists in the map, removes it from both the map and list if present, and returns true. Returns false if the value is not found.","@param val int: The value to be removed.
   @return boolean: True if the removal was successful, false otherwise.","remove(5)
-> true (5 is removed from both map and list)
remove(10)
-> false (10 does not exist)
remove(-3)
-> true (Negative value removal successful if present)","Map and list are non-null, removal updates both structures consistently.","public boolean remove(int val){
  if (map.containsKey(val)) {
    map.remove(val);
    values.remove(values.indexOf(val));
    return true;
  }
  return false;
}
",0,reference
6367672d1a6d9265ec017c74,remove,"public boolean remove(int val){
  if (map.containsKey(val)) {
    map.remove(val);
    values.remove(values.indexOf(val));
    return true;
  }
  return false;
}
","/** 
 * Removes a value from the set. Returns true if the set contained the specified element. 
 */
","Remove a value from the values if the map keys contains the val. Returns true if actually removed, and false otherwise.",Removes a value from a map and list.,"Checks if the value exists in the map, removes it from both the map and list if present, and returns true. Returns false if the value is not found.","@param val int: The value to be removed.
   @return boolean: True if the removal was successful, false otherwise.","remove(5)
-> true (5 is removed from both map and list)
remove(10)
-> false (10 does not exist)
remove(-3)
-> true (Negative value removal successful if present)","Map and list are non-null, removal updates both structures consistently.","public boolean remove(int val) {
    for (Map.Entry<Integer, Object> entry : map.entrySet()) {
        if (entry.getKey() == val) {
            map.remove(entry.getKey());
            return true;
        }
    }
    return false;
}",1,Phi-3-mini-4k-instruct
6367676b1a6d9265ec0181df,startsWithIgnoreCase,"public static boolean startsWithIgnoreCase(String str,String prefix){
  if (str == null || prefix == null) {
    return false;
  }
  if (str.startsWith(prefix)) {
    return true;
  }
  if (str.length() < prefix.length()) {
    return false;
  }
  String lcStr=str.substring(0,prefix.length()).toLowerCase();
  String lcPrefix=prefix.toLowerCase();
  return lcStr.equals(lcPrefix);
}
","/** 
 * Returns  {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.
 * @param str the String to check
 * @param prefix the prefix to look for
 * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.
 * @see java.lang.String#startsWith
 */
","Return true if the given string starts with the specified case-insensitive prefix, false otherwise.",Case-insensitive prefix matching function.,"Checks if a string starts with a given prefix, ignoring case. Ensures null inputs return false.","@param str String: The main string to check.
@param prefix String: The prefix to check against.
@return boolean: True if str starts with prefix ignoring case, false otherwise.","""Hello"", ""he"" -> true (case ignored)
""Hello"", ""Ho"" -> false (different letters)
""test"", ""testers"" -> false (prefix longer)","Both inputs must be non-null for checking, returns false otherwise; handles case insensitivity.","public static boolean startsWithIgnoreCase(String str, String prefix) {
    if (str == null || prefix == null) {
        return (str == null && prefix == null);
    }
    if (prefix.length() > str.length()) {
        return false;
    }
    for (int i = 0; i < prefix.length(); i++) {
        if (Character.toLowerCase(str.charAt(i)) != Character.toLowerCase(prefix.charAt(i))) {
            return false;
        }
    }
    return true;
}",0,deepseek-coder-6.7b-instruct
6367676b1a6d9265ec0181df,startsWithIgnoreCase,"public static boolean startsWithIgnoreCase(String str,String prefix){
  if (str == null || prefix == null) {
    return false;
  }
  if (str.startsWith(prefix)) {
    return true;
  }
  if (str.length() < prefix.length()) {
    return false;
  }
  String lcStr=str.substring(0,prefix.length()).toLowerCase();
  String lcPrefix=prefix.toLowerCase();
  return lcStr.equals(lcPrefix);
}
","/** 
 * Returns  {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.
 * @param str the String to check
 * @param prefix the prefix to look for
 * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.
 * @see java.lang.String#startsWith
 */
","Return true if the given string starts with the specified case-insensitive prefix, false otherwise.",Case-insensitive prefix matching function.,"Checks if a string starts with a given prefix, ignoring case. Ensures null inputs return false.","@param str String: The main string to check.
@param prefix String: The prefix to check against.
@return boolean: True if str starts with prefix ignoring case, false otherwise.","""Hello"", ""he"" -> true (case ignored)
""Hello"", ""Ho"" -> false (different letters)
""test"", ""testers"" -> false (prefix longer)","Both inputs must be non-null for checking, returns false otherwise; handles case insensitivity.","public static boolean startsWithIgnoreCase(String str,String prefix){
    return str.startsWith(prefix.toUpperCase());
}",1,starcoder2-7b
636767001a6d9265ec017873,reverse,"public static String reverse(final String str){
  if (str == null) {
    return null;
  }
  return new StringBuilder(str).reverse().toString();
}
","/** 
 * <p>Reverses a String as per  {@link StringBuilder#reverse()}.</p> <p>A <code>null</code> String returns <code>null</code>.</p> <pre> StringUtils.reverse(null)  = null StringUtils.reverse("""")    = """" StringUtils.reverse(""bat"") = ""tab"" </pre>
 * @param str  the String to reverse, may be null
 * @return the reversed String, <code>null</code> if null String input
 */
",Reverse the given String as per.,Reverses a string.,"This function takes a string and returns a new string with the characters in reverse order. If the input string is null, it returns null.","@param str String: The input string to be reversed
   @return String: The reversed string or null if the input is null","""hello"" -> ""olleh"" (reverses characters)
""12345"" -> ""54321"" (reverses numeric string)
null -> null (null input returns null)",The function expects a string or null as input; it returns a reversed string or null if the input is null.,"public static String reverse(final String str){
    if (str == null) {
        return null;
    }
    return new StringBuilder(str).reverse().toString();
}",0,Qwen2.5-Coder-7B-Instruct
636767001a6d9265ec017873,reverse,"public static String reverse(final String str){
  if (str == null) {
    return null;
  }
  return new StringBuilder(str).reverse().toString();
}
","/** 
 * <p>Reverses a String as per  {@link StringBuilder#reverse()}.</p> <p>A <code>null</code> String returns <code>null</code>.</p> <pre> StringUtils.reverse(null)  = null StringUtils.reverse("""")    = """" StringUtils.reverse(""bat"") = ""tab"" </pre>
 * @param str  the String to reverse, may be null
 * @return the reversed String, <code>null</code> if null String input
 */
",Reverse the given String as per.,Reverses a string.,"This function takes a string and returns a new string with the characters in reverse order. If the input string is null, it returns null.","@param str String: The input string to be reversed
   @return String: The reversed string or null if the input is null","""hello"" -> ""olleh"" (reverses characters)
""12345"" -> ""54321"" (reverses numeric string)
null -> null (null input returns null)",The function expects a string or null as input; it returns a reversed string or null if the input is null.,"public static String reverse(final String str){
    final StringBuilder sb = new StringBuilder();
    for(int i = str.length() - 1; i >= 0; i--){
        sb.append(str.charAt(i));
    }
    return sb.toString();
}",1,CodeLlama-7b-Instruct-hf
636766ff1a6d9265ec01783b,sub,"public static String sub(String str,int start,int end){
  return StringUtils.substring(str,start,end);
}
","/** 
 * Gets a substring from the specified String avoiding exceptions. 
 */
",Get a substring from the specified String avoiding exceptions. ,Extracts a substring from the input string.,"Returns a substring from the given `start` index to the `end` index, exclusive, using `StringUtils.substring`.","@param str String: the input string
@param start int: the starting index for the substring
@param end int: the ending index (exclusive) for the substring
@return String: the extracted substring","""hello"", 0, 2 -> ""he"" (extracts characters from index 0 to 1)
""world"", 1, 4 -> ""orl"" (extracts characters from index 1 to 3)
""java"", 2, 4 -> ""va"" (extracts characters from index 2 to 3)","The input indices should be within the bounds of the string, ensuring extracted substring exists, and original string remains unchanged.","public static String sub(String str,int start,int end){ 
  if(str == null) return null; 
  if(start > end) return """"; 
  if(str.length() <= end) return str.substring(start); 
  return str.substring(start,end); 
}",0,CodeLlama-7b-Instruct-hf
636766ff1a6d9265ec01783b,sub,"public static String sub(String str,int start,int end){
  return StringUtils.substring(str,start,end);
}
","/** 
 * Gets a substring from the specified String avoiding exceptions. 
 */
",Get a substring from the specified String avoiding exceptions. ,Extracts a substring from the input string.,"Returns a substring from the given `start` index to the `end` index, exclusive, using `StringUtils.substring`.","@param str String: the input string
@param start int: the starting index for the substring
@param end int: the ending index (exclusive) for the substring
@return String: the extracted substring","""hello"", 0, 2 -> ""he"" (extracts characters from index 0 to 1)
""world"", 1, 4 -> ""orl"" (extracts characters from index 1 to 3)
""java"", 2, 4 -> ""va"" (extracts characters from index 2 to 3)","The input indices should be within the bounds of the string, ensuring extracted substring exists, and original string remains unchanged.","public static String sub(String str,int start,int end){
    if (start > 0 && end > 0 && start < end) {
     if (end < str.length()) {
        return str.substring(start, end);
     }
     else{
        return str.substring(start);
     }
 }
else{return null;}
}",1,starcoder2-7b
6367671a1a6d9265ec017c15,putByteArray,"public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){
  if (length + byteLength > data.length) {
    enlarge(byteLength);
  }
  if (byteArrayValue != null) {
    System.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);
  }
  length+=byteLength;
  return this;
}
","/** 
 * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.
 * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.
 * @param byteOffset index of the first byte of byteArrayValue that must be copied.
 * @param byteLength number of bytes of byteArrayValue that must be copied.
 * @return this byte vector.
 */
","Put an array of bytes into this byte vector, enlarge the byte vector automatically if necessary.","Inserts a byte array into a ByteVector, enlarging if necessary.","Copies the specified segment of a byte array into the ByteVector's data array starting from the current length, enlarges the array if too small, then updates the length.","@param byteArrayValue byte[]: the source byte array
@param byteOffset int: the starting offset in byteArrayValue
@param byteLength int: the number of bytes to insert
@return ByteVector: the modified ByteVector instance","(byte[], 0, 3)
-> ByteVector instance (inserts first three bytes)
(byte[], 2, 2)
-> ByteVector instance (inserts two bytes starting from index 2)
(null, 0, 0)
-> ByteVector instance (no changes made)",Assumes data array has enough space or can be enlarged; modifies ByteVector and increases length by byteLength.,"public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){
  if (length + byteLength > data.length) {
    enlarge(byteLength);
  }
  if (byteArrayValue != null) {
    System.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);
  }
  length+=byteLength;
  return this;
}
",0,reference
6367671a1a6d9265ec017c15,putByteArray,"public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){
  if (length + byteLength > data.length) {
    enlarge(byteLength);
  }
  if (byteArrayValue != null) {
    System.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);
  }
  length+=byteLength;
  return this;
}
","/** 
 * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.
 * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.
 * @param byteOffset index of the first byte of byteArrayValue that must be copied.
 * @param byteLength number of bytes of byteArrayValue that must be copied.
 * @return this byte vector.
 */
","Put an array of bytes into this byte vector, enlarge the byte vector automatically if necessary.","Inserts a byte array into a ByteVector, enlarging if necessary.","Copies the specified segment of a byte array into the ByteVector's data array starting from the current length, enlarges the array if too small, then updates the length.","@param byteArrayValue byte[]: the source byte array
@param byteOffset int: the starting offset in byteArrayValue
@param byteLength int: the number of bytes to insert
@return ByteVector: the modified ByteVector instance","(byte[], 0, 3)
-> ByteVector instance (inserts first three bytes)
(byte[], 2, 2)
-> ByteVector instance (inserts two bytes starting from index 2)
(null, 0, 0)
-> ByteVector instance (no changes made)",Assumes data array has enough space or can be enlarged; modifies ByteVector and increases length by byteLength.,"public ByteVector putByteArray(final byte[] byteArrayValue, final int byteOffset, final int byteLength){
    // Initialize a new ByteVector
    ByteVector byteVector = new ByteVector();

    // Check if the byte vector needs to be resized
    while (byteVector.size() < byteOffset + byteLength){
        byteVector.resize(byteVector.size() * 2);  // Double the size
    }

    // Copy the byte array values into the ByteVector
    System.arraycopy(byteArrayValue, byteOffset, byteVector.elements(), byteOffset, byteLength);

    return byteVector;
}",1,deepseek-coder-6.7b-instruct
6367675c1a6d9265ec01805b,removeFromTreeEdgeList,"public void removeFromTreeEdgeList(){
  for (int dir=0; dir < 2; dir++) {
    if (prev[dir] != null) {
      prev[dir].next[dir]=next[dir];
    }
 else {
      head[1 - dir].first[dir]=next[dir];
    }
    if (next[dir] != null) {
      next[dir].prev[dir]=prev[dir];
    }
  }
  head[0]=head[1]=null;
}
","/** 
 * Removes this edge from both doubly linked lists of tree edges.
 */
",Remove this edge from both doubly linked lists of the tree edges.,Removes the current node from a doubly-linked list that represents a tree edge list.,The function updates pointers to remove a node from a bidirectional structure by adjusting previous and next links in both directions.,,"Node A with prev and next adjusted -> Node A removed from tree edge list (prev and next are rearranged)
Node B at the start -> Node B's next becomes the new head (start of list changes)
Node C at the end -> Node C's prev becomes new last (end of list changes)","The input structure is a valid doubly-linked list, and after execution, the list remains valid without the removed node.","public void removeFromTreeEdgeList(){
  for (int dir=0; dir < 2; dir++) {
    if (prev[dir] != null) {
      prev[dir].next[dir]=next[dir];
    }
 else {
      head[1 - dir].first[dir]=next[dir];
    }
    if (next[dir] != null) {
      next[dir].prev[dir]=prev[dir];
    }
  }
  head[0]=head[1]=null;
}
",0,reference
6367675c1a6d9265ec01805b,removeFromTreeEdgeList,"public void removeFromTreeEdgeList(){
  for (int dir=0; dir < 2; dir++) {
    if (prev[dir] != null) {
      prev[dir].next[dir]=next[dir];
    }
 else {
      head[1 - dir].first[dir]=next[dir];
    }
    if (next[dir] != null) {
      next[dir].prev[dir]=prev[dir];
    }
  }
  head[0]=head[1]=null;
}
","/** 
 * Removes this edge from both doubly linked lists of tree edges.
 */
",Remove this edge from both doubly linked lists of the tree edges.,Removes the current node from a doubly-linked list that represents a tree edge list.,The function updates pointers to remove a node from a bidirectional structure by adjusting previous and next links in both directions.,,"Node A with prev and next adjusted -> Node A removed from tree edge list (prev and next are rearranged)
Node B at the start -> Node B's next becomes the new head (start of list changes)
Node C at the end -> Node C's prev becomes new last (end of list changes)","The input structure is a valid doubly-linked list, and after execution, the list remains valid without the removed node.","public void removeFromTreeEdgeList(Node node) {
    if(node != null) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
}",1,deepseek-coder-6.7b-instruct
636767791a6d9265ec01826d,findAndSubst,"public static String findAndSubst(String key,Properties props){
  String value=props.getProperty(key);
  if (value == null)   return null;
  try {
    return substVars(value,props);
  }
 catch (  IllegalArgumentException e) {
    LogLog.error(""Bad option value ["" + value + ""]."",e);
    return value;
  }
}
","/** 
 * Find the value corresponding to <code>key</code> in <code>props</code>. Then perform variable substitution on the found value.
 */
","Find the value corresponding to key in props, then perform variable substitution on the found value. Return the substitution result, or the value in case of exception. ",Substitute variables in a property value.,"Retrieves a property by key, substitutes its variables, and returns the updated value. Logs an error and returns the original value on IllegalArgumentException.","@param key String: The key to look up in the properties.
   @param props Properties: The collection of key-value pairs where substitution will occur.
   @return String: The value with substituted variables or null if the key is not found.","key=""path"", props={""path"":""${base}/dir"", ""base"":""/home""} -> ""/home/dir"" (substitution successful)
key=""missing"", props={""path"":""${base}/dir""} -> null (key not found)
key=""invalid"", props={""invalid"":""${foo""} -> ""${foo"" (invalid placeholder)",Keys and properties must be defined. The return is either a substituted string or original/nonexistent value.,"public static String findAndSubst(String key,Properties props){
  String value=props.getProperty(key);
  if (value == null)   return null;
  try {
    return substVars(value,props);
  }
 catch (  IllegalArgumentException e) {
    LogLog.error(""Bad option value ["" + value + ""]."",e);
    return value;
  }
}
",0,reference
636767791a6d9265ec01826d,findAndSubst,"public static String findAndSubst(String key,Properties props){
  String value=props.getProperty(key);
  if (value == null)   return null;
  try {
    return substVars(value,props);
  }
 catch (  IllegalArgumentException e) {
    LogLog.error(""Bad option value ["" + value + ""]."",e);
    return value;
  }
}
","/** 
 * Find the value corresponding to <code>key</code> in <code>props</code>. Then perform variable substitution on the found value.
 */
","Find the value corresponding to key in props, then perform variable substitution on the found value. Return the substitution result, or the value in case of exception. ",Substitute variables in a property value.,"Retrieves a property by key, substitutes its variables, and returns the updated value. Logs an error and returns the original value on IllegalArgumentException.","@param key String: The key to look up in the properties.
   @param props Properties: The collection of key-value pairs where substitution will occur.
   @return String: The value with substituted variables or null if the key is not found.","key=""path"", props={""path"":""${base}/dir"", ""base"":""/home""} -> ""/home/dir"" (substitution successful)
key=""missing"", props={""path"":""${base}/dir""} -> null (key not found)
key=""invalid"", props={""invalid"":""${foo""} -> ""${foo"" (invalid placeholder)",Keys and properties must be defined. The return is either a substituted string or original/nonexistent value.,"public static void main(String[] args) {
        Properties props = new Properties();
        props.setProperty(""name"", ""John Doe"");
        props.setProperty(""age"", ""30"");

        String name = findAndSubst(""name"", props);
        String age = findAndSubst(""age"", props);

        System.out.println(""Name: "" + name);
        System.out.println(""Age: "" + age);
    }",1,deepseek-coder-6.7b-instruct
636766fe1a6d9265ec017834,sessionId,"public static String sessionId(){
  HttpSession httpSession=servletSession();
  if (httpSession == null) {
    return null;
  }
  return httpSession.getId();
}
","/** 
 * Session ID. 
 */
",Return the servlet session id,Retrieves the HTTP session ID.,"Returns the ID of the current HTTP session if it exists, otherwise returns null.",@return String: the session ID or null if no session exists.,"sessionId()
-> ""abc123"" (returns session ID if session exists)
sessionId()
-> null (returns null if no session exists)","No session means the function returns null; otherwise, it provides a valid session ID.","public static String sessionId(){
  HttpSession httpSession=servletSession();
  if (httpSession == null) {
    return null;
  }
  return httpSession.getId();
}
",0,reference
636766fe1a6d9265ec017834,sessionId,"public static String sessionId(){
  HttpSession httpSession=servletSession();
  if (httpSession == null) {
    return null;
  }
  return httpSession.getId();
}
","/** 
 * Session ID. 
 */
",Return the servlet session id,Retrieves the HTTP session ID.,"Returns the ID of the current HTTP session if it exists, otherwise returns null.",@return String: the session ID or null if no session exists.,"sessionId()
-> ""abc123"" (returns session ID if session exists)
sessionId()
-> null (returns null if no session exists)","No session means the function returns null; otherwise, it provides a valid session ID.","public static String sessionId(HttpSession session) {
        return session.getId();
    }",1,Qwen2.5-Coder-7B-Instruct
636766ff1a6d9265ec01784b,isDigits,"public static boolean isDigits(String str){
  if ((str == null) || (str.length() == 0)) {
    return false;
  }
  for (int i=0; i < str.length(); i++) {
    if (!Character.isDigit(str.charAt(i))) {
      return false;
    }
  }
  return true;
}
","/** 
 * <p>Checks whether the <code>String</code> contains only digit characters.</p> <p><code>Null</code> and empty String will return <code>false</code>.</p>
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if str contains only unicode numeric
 */
","Check whether a character string is a dight. If yes, true is returned. Otherwise, false is returned.",Checks if a string contains only digits.,"Determines if a given string is solely composed of digit characters, returning false for null or empty strings.","@param str String: the string to be checked  
@return boolean: true if the string contains only digits, false otherwise","""12345"" -> true (all digits)
""abc123"" -> false (contains non-digit characters)
"""" -> false (empty string)
null -> false (null input)","Input is a string, output is true if all characters are digits; false otherwise, including empty or null strings.","public static boolean isDigits(String str){
    if (str == null || str.isEmpty()) {
        return false;
    }
    for (char c : str.toCharArray()) {
        if (!Character.isDigit(c)) {
            return false;
        }
    }
    return true;
}",0,Qwen2.5-Coder-7B-Instruct
636766ff1a6d9265ec01784b,isDigits,"public static boolean isDigits(String str){
  if ((str == null) || (str.length() == 0)) {
    return false;
  }
  for (int i=0; i < str.length(); i++) {
    if (!Character.isDigit(str.charAt(i))) {
      return false;
    }
  }
  return true;
}
","/** 
 * <p>Checks whether the <code>String</code> contains only digit characters.</p> <p><code>Null</code> and empty String will return <code>false</code>.</p>
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if str contains only unicode numeric
 */
","Check whether a character string is a dight. If yes, true is returned. Otherwise, false is returned.",Checks if a string contains only digits.,"Determines if a given string is solely composed of digit characters, returning false for null or empty strings.","@param str String: the string to be checked  
@return boolean: true if the string contains only digits, false otherwise","""12345"" -> true (all digits)
""abc123"" -> false (contains non-digit characters)
"""" -> false (empty string)
null -> false (null input)","Input is a string, output is true if all characters are digits; false otherwise, including empty or null strings.","public static boolean isDigits(String str){
String result = str;
String s = str.trim();
if(result.length()>0){
try{
Integer.parseInt(s);
return true;
}catch(NumberFormatException nfe){
return false;
}
}
return false;
}",1,starcoder2-7b
636766fc1a6d9265ec0177da,isParameterSeparator,"private static boolean isParameterSeparator(final char c){
  if (Character.isWhitespace(c)) {
    return true;
  }
  for (  char separator : PARAMETER_SEPARATORS) {
    if (c == separator) {
      return true;
    }
  }
  return false;
}
","/** 
 * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. 
 */
","Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.",Checks if a character is a parameter separator.,Determines if the character is whitespace or matches any character in PARAMETER_SEPARATORS.,"@param c char: the character to check
   @return boolean: true if the character is a separator, otherwise false","' ' -> true (whitespace is a separator)
',' -> true (comma is a separator in PARAMETER_SEPARATORS)
'a' -> false (letter is not a separator)",Only single characters are processed; returns a boolean indicating separator status.,"private static boolean isParameterSeparator(final char c) {
    return c == ',' || c == ' ' || c == ';';
}",0,Phi-3-mini-4k-instruct
636766fc1a6d9265ec0177da,isParameterSeparator,"private static boolean isParameterSeparator(final char c){
  if (Character.isWhitespace(c)) {
    return true;
  }
  for (  char separator : PARAMETER_SEPARATORS) {
    if (c == separator) {
      return true;
    }
  }
  return false;
}
","/** 
 * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. 
 */
","Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.",Checks if a character is a parameter separator.,Determines if the character is whitespace or matches any character in PARAMETER_SEPARATORS.,"@param c char: the character to check
   @return boolean: true if the character is a separator, otherwise false","' ' -> true (whitespace is a separator)
',' -> true (comma is a separator in PARAMETER_SEPARATORS)
'a' -> false (letter is not a separator)",Only single characters are processed; returns a boolean indicating separator status.,"private static boolean isParameterSeparator(final char c){
if (c == ';' || c == ':') {
return true;
} else {
return false;
}
}",1,CodeLlama-7b-Instruct-hf
6367670c1a6d9265ec017a35,endsWith,"private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){
  if (str == null || suffix == null) {
    return str == null && suffix == null;
  }
  if (suffix.length() > str.length()) {
    return false;
  }
  int strOffset=str.length() - suffix.length();
  return str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());
}
","/** 
 * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>
 * @see String#endsWith(String)
 * @param str  the String to check, may be null
 * @param suffix the suffix to find, may be null
 * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.
 * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>
 */
",Determines whether a character string ends with a specified suffix.,Check if a string ends with a specific suffix.,"Determines if the given string ends with the specified suffix, optionally ignoring case differences.","@param str String: The main string to check.
@param suffix String: The ending sequence to match.
@param ignoreCase boolean: Whether to ignore case differences in matching.
@return boolean: True if string ends with the suffix, considering case sensitivity.","""hello"", ""lo"", false -> true (matches suffix exactly)
""hello"", ""LO"", true -> true (ignores case and matches)
""hello"", ""HE"", true -> false (suffix length mismatch)",Strings should not be null unless both are. Returns true if suffix length is not greater than string length and matches the end.,"private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {
        if (str == null || suffix == null) {
            return false;
        }
        if (suffix.length() > str.length()) {
            return false;
        }
        int strLength = str.length();
        int suffixLength = suffix.length();
        int toffset = strLength - suffixLength;
        char[] targetCharArray = str.toCharArray();
        char[] suffixCharArray = suffix.toCharArray();
        for (int i = 0; i < suffixLength; i++) {
            char strChar = targetCharArray[toffset + i];
            char suffixChar = suffixCharArray[i];
            if (ignoreCase) {
                if (Character.toLowerCase(strChar) != Character.toLowerCase(suffixChar)) {
                    return false;
                }
            } else {
                if (strChar != suffixChar) {
                    return false;
                }
            }
        }
        return true;
    }",0,Qwen2.5-Coder-7B-Instruct
6367670c1a6d9265ec017a35,endsWith,"private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){
  if (str == null || suffix == null) {
    return str == null && suffix == null;
  }
  if (suffix.length() > str.length()) {
    return false;
  }
  int strOffset=str.length() - suffix.length();
  return str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());
}
","/** 
 * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>
 * @see String#endsWith(String)
 * @param str  the String to check, may be null
 * @param suffix the suffix to find, may be null
 * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.
 * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>
 */
",Determines whether a character string ends with a specified suffix.,Check if a string ends with a specific suffix.,"Determines if the given string ends with the specified suffix, optionally ignoring case differences.","@param str String: The main string to check.
@param suffix String: The ending sequence to match.
@param ignoreCase boolean: Whether to ignore case differences in matching.
@return boolean: True if string ends with the suffix, considering case sensitivity.","""hello"", ""lo"", false -> true (matches suffix exactly)
""hello"", ""LO"", true -> true (ignores case and matches)
""hello"", ""HE"", true -> false (suffix length mismatch)",Strings should not be null unless both are. Returns true if suffix length is not greater than string length and matches the end.,"private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){
	if(str==null||suffix==null) return false;
	int len1=str.length(),len2=suffix.length();
	if(len1<len2) return false;
	for(int i=1,j=0;i<=len2;i++,j++){
		if(ignoreCase){
			int c0=str.charAt(len1-i)&0xff,c1=(suffix.charAt(len2-i)&0xff)-32;
			if(c0-c1!=0) return false;
		}else{
			int c0=str.charAt(len1-i)&0xff,c1=suffix.charAt(len2-i)&0xff;
			if(c0-c1!=0) return false;
		}
	}
	return true;
}",1,CodeLlama-7b-Instruct-hf
6367667f1a6d9265ec01745d,decodePath,"public static List<PathSegmentImpl> decodePath(URI u,boolean decode){
  String rawPath=u.getRawPath();
  if (rawPath != null && rawPath.length() > 0 && rawPath.charAt(0) == '/') {
    rawPath=rawPath.substring(1);
  }
  return decodePath(rawPath,decode);
}
","/** 
 * Decode the path component of a URI as path segments.
 * @param u the URI. If the path component is an absolute path componentthen the leading '/' is ignored and is not considered a delimiator of a path segment.
 * @param decode true if the path segments of the path componentshould be in decoded form.
 * @return the list of path segments.
 */
",Decode the raw path.,Decodes URI paths based on given flag.,"Processes and optionally decodes the path segments of a URI, removing any leading slash, and returns processed segments.","@param u URI: The URI containing the path to decode.  
@param decode boolean: Flag indicating whether to decode the path.  
@return List<PathSegmentImpl>: The list of processed path segments.","URI(""/example/path"", true)
-> List[pathSegment1, pathSegment2] (Decodes and splits path)
URI(""/example/path"", false)
-> List[pathSegment1, pathSegment2] (Splits path, no decoding)
URI("""", true)
-> List[] (Empty path results in empty list)","The input URI can be empty or with leading slash; the output is a list of path segments, optionally decoded.","public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {
    String path = u.getRawPath();
    if (path.startsWith(""/"")) {
        path = path.substring(1);
    }

    List<PathSegmentImpl> pathSegments = new ArrayList<>();
    String[] segments = path.split(""/"");

    for (String segment : segments) {
        String decodedSegment = segment;
        if (decode) {
            try {
                decodedSegment = URLDecoder.decode(segment, StandardCharsets.UTF_8.name());
            } catch (UnsupportedEncodingException e) {
                throw new IllegalArgumentException(""UTF-8 not supported"", e);
            }
        }
        pathSegments.add(new PathSegmentImpl(decodedSegment, decode));
    }

    return pathSegments;
}",0,gpt-4-turbo
6367667f1a6d9265ec01745d,decodePath,"public static List<PathSegmentImpl> decodePath(URI u,boolean decode){
  String rawPath=u.getRawPath();
  if (rawPath != null && rawPath.length() > 0 && rawPath.charAt(0) == '/') {
    rawPath=rawPath.substring(1);
  }
  return decodePath(rawPath,decode);
}
","/** 
 * Decode the path component of a URI as path segments.
 * @param u the URI. If the path component is an absolute path componentthen the leading '/' is ignored and is not considered a delimiator of a path segment.
 * @param decode true if the path segments of the path componentshould be in decoded form.
 * @return the list of path segments.
 */
",Decode the raw path.,Decodes URI paths based on given flag.,"Processes and optionally decodes the path segments of a URI, removing any leading slash, and returns processed segments.","@param u URI: The URI containing the path to decode.  
@param decode boolean: Flag indicating whether to decode the path.  
@return List<PathSegmentImpl>: The list of processed path segments.","URI(""/example/path"", true)
-> List[pathSegment1, pathSegment2] (Decodes and splits path)
URI(""/example/path"", false)
-> List[pathSegment1, pathSegment2] (Splits path, no decoding)
URI("""", true)
-> List[] (Empty path results in empty list)","The input URI can be empty or with leading slash; the output is a list of path segments, optionally decoded.","public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {
    List<PathSegmentImpl> segments = new ArrayList<>();
    String path = u.getPath();
    if (path != null && path.length() > 0) {
        // Remove the leading '/' if the path is absolute.
        if (path.startsWith(""/"")) {
            path = path.substring(1);
        }
        // Split the path into segments.
        String[] rawSegments = path.split(""/"");
        for (String segment : rawSegments) {
            String finalSegment = segment;
            if (decode) {
                try {
                    // Decode each segment if requested.
                    finalSegment = URLDecoder.decode(segment, StandardCharsets.UTF_8.name());
                } catch (UnsupportedEncodingException e) {
                    throw new IllegalStateException(""UTF-8 encoding not supported"", e);
                }
            }
            segments.add(new PathSegmentImpl(finalSegment));
        }
    }
    return segments;
}",1,gpt-4-turbo
636766f11a6d9265ec017651,nullToEmpty,"public static Character[] nullToEmpty(final Character[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
","If array is null or its length is 0, convert array to EMPTY_CHARACTER_OBJECT_ARRAY. Otherwise, return array itself.",Converts null or empty Character arrays to a predefined empty array.,"Returns a predefined empty Character array if the input is null or empty; otherwise, returns the original array.","@param array Character[]: The array to be checked and possibly replaced.
   @return Character[]: The original array or an empty predefined array.","null -> predefined empty array (input is null)
[] -> predefined empty array (input is empty)
['a', 'b'] -> ['a', 'b'] (non-empty input is returned)",Input is a Character array or null; the output is either the input array or a predefined empty array.,"public static Character[] nullToEmpty(final Character[] array) {
    if (array == null || array.length == 0) {
        return new Character[0]; // EMPTY_CHARACTER_OBJECT_ARRAY
    } else {
        return array;
    }
}",0,Qwen2.5-Coder-7B-Instruct
636766f11a6d9265ec017651,nullToEmpty,"public static Character[] nullToEmpty(final Character[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
","If array is null or its length is 0, convert array to EMPTY_CHARACTER_OBJECT_ARRAY. Otherwise, return array itself.",Converts null or empty Character arrays to a predefined empty array.,"Returns a predefined empty Character array if the input is null or empty; otherwise, returns the original array.","@param array Character[]: The array to be checked and possibly replaced.
   @return Character[]: The original array or an empty predefined array.","null -> predefined empty array (input is null)
[] -> predefined empty array (input is empty)
['a', 'b'] -> ['a', 'b'] (non-empty input is returned)",Input is a Character array or null; the output is either the input array or a predefined empty array.,"public static Character[] nullToEmpty(final Character[] array) {
    if (array == null || array.length == 0) {
        array = EMPTY_CHARACTER_OBJECT_ARRAY;
    }
    return array;
}",1,Phi-3-mini-4k-instruct
636767821a6d9265ec0183ab,hasThrown,"public boolean hasThrown(){
  Throwable thrown=getThrown();
  if (thrown == null) {
    return false;
  }
  String thrownString=thrown.toString();
  return thrownString != null && thrownString.trim().length() != 0;
}
","/** 
 * @return true if getThrown().toString() is a non-empty string.
 */
",Check whether there is a thrown,Check if an exception has been thrown and is not an empty string.,Determines if there is a Throwable instance from getThrown(). Checks if its string equivalent is non-empty.,"@return boolean: True if an exception is thrown and its string is not empty, false otherwise.","getThrown()
returns null -> false (no exception)
getThrown()
returns new Throwable("""")
-> false (empty string)
getThrown()
returns new Throwable(""Error"")
-> true (non-empty string)",Preconditions: getThrown() must be defined and return a Throwable or null. Postconditions: Returns true only if an exception was thrown with a non-empty description.,"public boolean hasThrown(){
    try {
        return !getThrown().toString().isEmpty();
    } catch (Exception e) {
        return false;
    }
}",0,gpt-4-turbo
636767821a6d9265ec0183ab,hasThrown,"public boolean hasThrown(){
  Throwable thrown=getThrown();
  if (thrown == null) {
    return false;
  }
  String thrownString=thrown.toString();
  return thrownString != null && thrownString.trim().length() != 0;
}
","/** 
 * @return true if getThrown().toString() is a non-empty string.
 */
",Check whether there is a thrown,Check if an exception has been thrown and is not an empty string.,Determines if there is a Throwable instance from getThrown(). Checks if its string equivalent is non-empty.,"@return boolean: True if an exception is thrown and its string is not empty, false otherwise.","getThrown()
returns null -> false (no exception)
getThrown()
returns new Throwable("""")
-> false (empty string)
getThrown()
returns new Throwable(""Error"")
-> true (non-empty string)",Preconditions: getThrown() must be defined and return a Throwable or null. Postconditions: Returns true only if an exception was thrown with a non-empty description.,"public boolean hasThrown(){
	return true;
}",1,starcoder2-7b
636767831a6d9265ec0183c9,peek,"public static String peek(){
  Stack stack=getCurrentStack();
  if (stack != null && !stack.isEmpty())   return ((DiagnosticContext)stack.peek()).message;
 else   return """";
}
","/** 
 * Looks at the last diagnostic context at the top of this NDC without removing it. <p>The returned value is the value that was pushed last. If no context is available, then the empty string """" is returned.
 * @return String The innermost diagnostic context.
 */
",Return the value at the top of the stack,Returns the message from the top of a stack if not empty.,"Checks the current stack for non-null and non-empty status, then returns the top DiagnosticContext's message. Returns an empty string if conditions are not met.",@return String: The message from the top of the stack or an empty string if the stack is null or empty.,"(stack contains DiagnosticContext with ""Error occurred"")
-> ""Error occurred"" (Stack is non-empty)
(empty stack)
-> """" (Stack is empty)
(null stack)
-> """" (Stack is null)",The stack must be valid or empty before function call; function ensures safe return of message or empty string otherwise.,"public static String peek(){
  Stack stack=getCurrentStack();
  if (stack != null && !stack.isEmpty())   return ((DiagnosticContext)stack.peek()).message;
 else   return """";
}
",0,reference
636767831a6d9265ec0183c9,peek,"public static String peek(){
  Stack stack=getCurrentStack();
  if (stack != null && !stack.isEmpty())   return ((DiagnosticContext)stack.peek()).message;
 else   return """";
}
","/** 
 * Looks at the last diagnostic context at the top of this NDC without removing it. <p>The returned value is the value that was pushed last. If no context is available, then the empty string """" is returned.
 * @return String The innermost diagnostic context.
 */
",Return the value at the top of the stack,Returns the message from the top of a stack if not empty.,"Checks the current stack for non-null and non-empty status, then returns the top DiagnosticContext's message. Returns an empty string if conditions are not met.",@return String: The message from the top of the stack or an empty string if the stack is null or empty.,"(stack contains DiagnosticContext with ""Error occurred"")
-> ""Error occurred"" (Stack is non-empty)
(empty stack)
-> """" (Stack is empty)
(null stack)
-> """" (Stack is null)",The stack must be valid or empty before function call; function ensures safe return of message or empty string otherwise.,"public static String peek(){
   return stack[stackPos-1];
}",1,starcoder2-7b
636767de1a6d9265ec01871c,valueAccumulation,"public void valueAccumulation(String key,Long value){
  Long element=data.get(key);
  if (element == null) {
    element=value;
  }
 else {
    element+=value;
  }
  data.put(key,element);
}
","/** 
 * Accumulate the value with existing value in the same given key.
 */
",Add the value to the original value of the key.,Accumulates values in a map based on a key.,"Adds a Long value to the existing value for a given key in the data map. If the key doesn't exist, it initializes it with the given value.","@param key String: the key for accumulating value in the map
   @param value Long: the value to add to the existing value in the map","""a"", 5L -> updates ""a"" with 5 (key ""a"" is initialized to 5)
""a"", 3L -> updates ""a"" with 8 (key ""a"" sum is updated to 8 if already was 5)
""b"", 2L -> updates ""b"" with 2 (key ""b"" is initialized to 2)","The data map must be initialized; after execution, the key will have an updated accumulated value.","public void valueAccumulation(String key,Long value){
  Long element=data.get(key);
  if (element == null) {
    element=value;
  }
 else {
    element+=value;
  }
  data.put(key,element);
}
",0,reference
636767de1a6d9265ec01871c,valueAccumulation,"public void valueAccumulation(String key,Long value){
  Long element=data.get(key);
  if (element == null) {
    element=value;
  }
 else {
    element+=value;
  }
  data.put(key,element);
}
","/** 
 * Accumulate the value with existing value in the same given key.
 */
",Add the value to the original value of the key.,Accumulates values in a map based on a key.,"Adds a Long value to the existing value for a given key in the data map. If the key doesn't exist, it initializes it with the given value.","@param key String: the key for accumulating value in the map
   @param value Long: the value to add to the existing value in the map","""a"", 5L -> updates ""a"" with 5 (key ""a"" is initialized to 5)
""a"", 3L -> updates ""a"" with 8 (key ""a"" sum is updated to 8 if already was 5)
""b"", 2L -> updates ""b"" with 2 (key ""b"" is initialized to 2)","The data map must be initialized; after execution, the key will have an updated accumulated value.","public void valueAccumulation(String key,Long value){
 if(key.equalsIgnoreCase(""counter"")||key.equalsIgnoreCase(""average"")){
 if(key.equalsIgnoreCase(""counter"")){
 counter++
 }else{
 average = average+value;
 }
 }
}",1,starcoder2-7b
6367677e1a6d9265ec01832e,exists,"public Logger exists(String name){
  Object o=ht.get(new CategoryKey(name));
  if (o instanceof Logger) {
    return (Logger)o;
  }
 else {
    return null;
  }
}
","/** 
 * Check if the named logger exists in the hierarchy. If so return its reference, otherwise returns <code>null</code>.
 * @param name The name of the logger to search for.
 */
","Check if the named logger exists. If so return its reference, otherwise returns null.",Checks if a Logger object exists for a given name.,"Retrieves a Logger from a hashtable based on a name key and returns it if found, otherwise returns null.","@param name String: name of the logger to look for
@return Logger: corresponding Logger object if found, null otherwise","""Logger1"" -> Logger instance (Logger found)
""Logger2"" -> null (Logger not found)",Preconditions: A hashtable named 'ht' contains logger objects. Postconditions: Returns a Logger instance or null if it doesn't exist in 'ht'.,"public Logger exists(String name){
  Object o=ht.get(new CategoryKey(name));
  if (o instanceof Logger) {
    return (Logger)o;
  }
 else {
    return null;
  }
}
",0,reference
6367677e1a6d9265ec01832e,exists,"public Logger exists(String name){
  Object o=ht.get(new CategoryKey(name));
  if (o instanceof Logger) {
    return (Logger)o;
  }
 else {
    return null;
  }
}
","/** 
 * Check if the named logger exists in the hierarchy. If so return its reference, otherwise returns <code>null</code>.
 * @param name The name of the logger to search for.
 */
","Check if the named logger exists. If so return its reference, otherwise returns null.",Checks if a Logger object exists for a given name.,"Retrieves a Logger from a hashtable based on a name key and returns it if found, otherwise returns null.","@param name String: name of the logger to look for
@return Logger: corresponding Logger object if found, null otherwise","""Logger1"" -> Logger instance (Logger found)
""Logger2"" -> null (Logger not found)",Preconditions: A hashtable named 'ht' contains logger objects. Postconditions: Returns a Logger instance or null if it doesn't exist in 'ht'.,"public Logger exists(String name) {
    return LogManager.getLogManager().getLogger(name);
}",1,gpt-4-turbo
6367670a1a6d9265ec0179e7,lookup,"public Converter lookup(final Class<?> clazz){
  Converter conv=(Converter)this.converters.get(clazz);
  if (conv != null) {
    return conv;
  }
  for (  Object regType : this.converters.keySet()) {
    if (((Class<?>)regType).isAssignableFrom(clazz)) {
      return (Converter)this.converters.get(regType);
    }
  }
  return null;
}
","/** 
 * Look up and return any registered  {@link Converter} for the specifieddestination class; if there is no registered Converter, return <code>null</code>.
 * @param clazz Class for which to return a registered Converter
 * @return The registered {@link Converter} or <code>null</code> if not found
 */
","Check whether the specified converter exists in converters. If yes, converter is returned. If no, null is returned.",Retrieves a Converter for a given class type.,"Checks if a converter exists for the exact class type; if not, returns a compatible converter from the map.","@param clazz Class<?>: The class type to find a converter for.
   @return Converter: The appropriate converter for the given class, or null if none exist.","String.class -> StringConverter (exact match)
Number.class -> ObjectConverter (assignable match)
Object.class -> null (no match)",Class type provided is non-null. Returns null if no converter is found.,"public Converter lookup(final Class<?> clazz){
  Converter conv=(Converter)this.converters.get(clazz);
  if (conv != null) {
    return conv;
  }
  for (  Object regType : this.converters.keySet()) {
    if (((Class<?>)regType).isAssignableFrom(clazz)) {
      return (Converter)this.converters.get(regType);
    }
  }
  return null;
}
",0,reference
6367670a1a6d9265ec0179e7,lookup,"public Converter lookup(final Class<?> clazz){
  Converter conv=(Converter)this.converters.get(clazz);
  if (conv != null) {
    return conv;
  }
  for (  Object regType : this.converters.keySet()) {
    if (((Class<?>)regType).isAssignableFrom(clazz)) {
      return (Converter)this.converters.get(regType);
    }
  }
  return null;
}
","/** 
 * Look up and return any registered  {@link Converter} for the specifieddestination class; if there is no registered Converter, return <code>null</code>.
 * @param clazz Class for which to return a registered Converter
 * @return The registered {@link Converter} or <code>null</code> if not found
 */
","Check whether the specified converter exists in converters. If yes, converter is returned. If no, null is returned.",Retrieves a Converter for a given class type.,"Checks if a converter exists for the exact class type; if not, returns a compatible converter from the map.","@param clazz Class<?>: The class type to find a converter for.
   @return Converter: The appropriate converter for the given class, or null if none exist.","String.class -> StringConverter (exact match)
Number.class -> ObjectConverter (assignable match)
Object.class -> null (no match)",Class type provided is non-null. Returns null if no converter is found.,"public Converter lookup(final Class<?> clazz) {
    Converter foundConverter = null;
    for (Converter converter : converters) {
        if (converter.getClass().equals(clazz)) {
            foundConverter = converter;
            break;
        }
    }
    return foundConverter;
}",1,Phi-3-mini-4k-instruct
636767a41a6d9265ec018572,readRawVarint64,"public long readRawVarint64() throws IOException {
  int shift=0;
  long result=0;
  while (shift < 64) {
    final byte b=readRawByte();
    result|=(long)(b & 0x7F) << shift;
    if ((b & 0x80) == 0) {
      return result;
    }
    shift+=7;
  }
  throw ProtobufException.malformedVarint();
}
","/** 
 * Read a raw Varint from the stream.
 */
",Read raw varint,Parses a raw variable-length 64-bit integer.,"Reads bytes to construct a 64-bit integer, stopping when a byte without the continuation bit is found.","@return long: The parsed 64-bit integer.
@throws IOException: If there's an error reading a byte.
@throws ProtobufException: If the varint is malformed (e.g., too long).","binary data -> integer (successful parse)
invalid binary -> throws ProtobufException (malformed varint)
binary ending with 0x00 byte -> integer (final byte indicates end)","Reads must be successful, and the sequence must be valid varint; outputs parsed integer or throws an exception if malformed.","public long readRawVarint64() throws IOException {
  long result = 0;
  for (int shift = 0; shift < 64; shift += 7) {
    final byte b = readRawByte();
    result |= (long)(b & 0x7F) << shift;
    if ((b & 0x80) == 0) {
      return result;
    }
  }
  throw new IllegalStateException(""Malformed varint."");
}",0,CodeLlama-7b-Instruct-hf
636767a41a6d9265ec018572,readRawVarint64,"public long readRawVarint64() throws IOException {
  int shift=0;
  long result=0;
  while (shift < 64) {
    final byte b=readRawByte();
    result|=(long)(b & 0x7F) << shift;
    if ((b & 0x80) == 0) {
      return result;
    }
    shift+=7;
  }
  throw ProtobufException.malformedVarint();
}
","/** 
 * Read a raw Varint from the stream.
 */
",Read raw varint,Parses a raw variable-length 64-bit integer.,"Reads bytes to construct a 64-bit integer, stopping when a byte without the continuation bit is found.","@return long: The parsed 64-bit integer.
@throws IOException: If there's an error reading a byte.
@throws ProtobufException: If the varint is malformed (e.g., too long).","binary data -> integer (successful parse)
invalid binary -> throws ProtobufException (malformed varint)
binary ending with 0x00 byte -> integer (final byte indicates end)","Reads must be successful, and the sequence must be valid varint; outputs parsed integer or throws an exception if malformed.","public long readRawVarint64() throws IOException {
        long result = 0;
        for (int shift = 0; shift < 64; shift += 7) {
            byte b = input.readByte();
            result |= (b & 0x7F) << shift;
            if ((b & 0x80) == 0) {
                return result;
            }
        }
        throw new NumberFormatException(""Number too large."");
    }",1,starcoder2-7b
636767021a6d9265ec0178bb,nullToEmpty,"public static Double[] nullToEmpty(final Double[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
","If the double type array is null or its length is 0, convert array to EMPTY_CHARACTER_OBJECT_ARRAY. Otherwise, return array itself.",Converts null or empty Double arrays to a predefined empty array.,"Returns an empty Double array if the input array is null or empty; otherwise, returns the original array.","@param array Double[]: The input Double array that might be null or empty.
   @return Double[]: The original or an empty Double array.","null -> ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY (null input)
{} -> ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY (empty array input)
{1.2, 3.4} -> {1.2, 3.4} (non-empty input)","Input array can be null; output is never null, always returns a valid Double array.","public static Double[] nullToEmpty(final Double[] array) {
    return (array == null || array.length == 0) ? new Double[0] : array;
}",0,Qwen2.5-Coder-7B-Instruct
636767021a6d9265ec0178bb,nullToEmpty,"public static Double[] nullToEmpty(final Double[] array){
  if (array == null || array.length == 0) {
    return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;
  }
  return array;
}
","/** 
 * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>
 * @param array  the array to check for <code>null</code> or empty
 * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input
 * @since 2.5
 */
","If the double type array is null or its length is 0, convert array to EMPTY_CHARACTER_OBJECT_ARRAY. Otherwise, return array itself.",Converts null or empty Double arrays to a predefined empty array.,"Returns an empty Double array if the input array is null or empty; otherwise, returns the original array.","@param array Double[]: The input Double array that might be null or empty.
   @return Double[]: The original or an empty Double array.","null -> ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY (null input)
{} -> ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY (empty array input)
{1.2, 3.4} -> {1.2, 3.4} (non-empty input)","Input array can be null; output is never null, always returns a valid Double array.","public static Double[] nullToEmpty(final Double[] array) {
    return (array == null || array.length == 0) ? EMPTY_CHARACTER_OBJECT_ARRAY : array;
}",1,deepseek-coder-6.7b-instruct
636767021a6d9265ec0178b2,pop,"private void pop(final String descriptor){
  char firstDescriptorChar=descriptor.charAt(0);
  if (firstDescriptorChar == '(') {
    pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);
  }
 else   if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {
    pop(2);
  }
 else {
    pop(1);
  }
}
","/** 
 * Pops as many abstract types from the output frame stack as described by the given descriptor.
 * @param descriptor a type or method descriptor (in which case its argument types are popped).
 */
",Pop the various value according to the first character of the descriptor.,Simulate stack popping based on descriptor types.,"The function determines the stack slots to pop based on the descriptor's first character. Uses conditional logic to handle method descriptors, long/double types, and others.",@param descriptor String: The type descriptor determining stack behavior.,"""(II)
V"" -> 2 (method with two int arguments and void return)
""J"" -> 2 (long type)
""I"" -> 1 (int type)","Descriptor must not be null, function pops specified stack slots based on descriptor analysis.","private void pop(final String descriptor){
  char firstDescriptorChar=descriptor.charAt(0);
  if (firstDescriptorChar == '(') {
    pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);
  }
 else   if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {
    pop(2);
  }
 else {
    pop(1);
  }
}
",0,reference
636767021a6d9265ec0178b2,pop,"private void pop(final String descriptor){
  char firstDescriptorChar=descriptor.charAt(0);
  if (firstDescriptorChar == '(') {
    pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);
  }
 else   if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {
    pop(2);
  }
 else {
    pop(1);
  }
}
","/** 
 * Pops as many abstract types from the output frame stack as described by the given descriptor.
 * @param descriptor a type or method descriptor (in which case its argument types are popped).
 */
",Pop the various value according to the first character of the descriptor.,Simulate stack popping based on descriptor types.,"The function determines the stack slots to pop based on the descriptor's first character. Uses conditional logic to handle method descriptors, long/double types, and others.",@param descriptor String: The type descriptor determining stack behavior.,"""(II)
V"" -> 2 (method with two int arguments and void return)
""J"" -> 2 (long type)
""I"" -> 1 (int type)","Descriptor must not be null, function pops specified stack slots based on descriptor analysis.","private void pop(final String descriptor) {
    int i = 0;
    char c = descriptor.charAt(i);
    boolean reachedEnd = false;

    if (c == '(') {
        i++; // skip the '(' if it's a method descriptor
        while (descriptor.charAt(i) != ')') {
            if (descriptor.charAt(i) == 'L') {
                // reference type
                while (descriptor.charAt(i) != ';') i++;
                outputFrameStack.pop(); // pop the object reference
            } else if (descriptor.charAt(i) == '[') {
                // array type
                while (descriptor.charAt(i) == '[') i++; // move past all '['
                // move past the element type if it's an object, otherwise just skip element type char
                if (descriptor.charAt(i) == 'L') while (descriptor.charAt(i) != ';') i++;
                outputFrameStack.pop(); // pop the array reference
            } else if (descriptor.charAt(i) == 'D' || descriptor.charAt(i) == 'J') {
                // double or long types (which might occupy two slots in some JVMs)
                outputFrameStack.pop();
                outputFrameStack.pop(); // potentially pop twice for double slots handling
            } else {
                // other primitive types (int, float, short, char, byte, boolean)
                outputFrameStack.pop();
            }
            i++;
        }
    } else {
        // Type descriptor
        if (c == 'L') {
            while (descriptor.charAt(i) != ';') i++;
            outputFrameStack.pop();
        } else if (c == '[') {
            while (descriptor.charAt(i) == '[') i++;
            if (descriptor.charAt(i) == 'L') while (descriptor.charAt(i) != ';') i++;
            outputFrameStack.pop();
        } else if (c == 'D' || c == 'J') {
            outputFrameStack.pop();
            if (!reachedEnd) outputFrameStack.pop();
        } else {
            outputFrameStack.pop();
        }
    }
}",1,gpt-4-turbo
636766f91a6d9265ec01776e,write,"@Override public void write(final byte b[],final int off,final int len) throws IOException {
  if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {
    throw new IndexOutOfBoundsException();
  }
 else   if (len == 0) {
    return;
  }
  if (this.count + len > this.buf.length) {
    this.encodePendingBytes(false);
  }
  System.arraycopy(b,off,this.buf,this.count,len);
  this.count+=len;
}
","/** 
 * Writes <code>len</code> bytes from the specified byte array starting at offset <code>off</code> to this byte array output stream.
 * @param b   the data.
 * @param off the start offset in the data.
 * @param len the number of bytes to write.
 */
",Write bytes of length len from a byte array,Copies bytes from input array to internal buffer with bounds checking.,"This method writes a specified range of bytes from an input array to an internal buffer, performing boundary checks, and handling potential buffer overflows.","@param b byte[]: Input byte array.
   @param off int: Offset in byte array to start copying from.
   @param len int: Number of bytes to copy.
   @throws IOException: If an IO error occurs.
   @throws IndexOutOfBoundsException: If offset or length is out of bounds.","write(byteArray, 0, 5)
-> (successful copy)
write(byteArray, -1, 5)
-> IndexOutOfBoundsException (off < 0)
write(byteArray, 5, 0)
-> (no action taken, len == 0)",Offsets and lengths must be within array bounds; method will update buffer and count if conditions are met.,"@Override public void write(final byte b[],final int off,final int len) throws IOException {
  if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {
    throw new IndexOutOfBoundsException();
  }
 else   if (len == 0) {
    return;
  }
  if (this.count + len > this.buf.length) {
    this.encodePendingBytes(false);
  }
  System.arraycopy(b,off,this.buf,this.count,len);
  this.count+=len;
}
",0,reference
636766f91a6d9265ec01776e,write,"@Override public void write(final byte b[],final int off,final int len) throws IOException {
  if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {
    throw new IndexOutOfBoundsException();
  }
 else   if (len == 0) {
    return;
  }
  if (this.count + len > this.buf.length) {
    this.encodePendingBytes(false);
  }
  System.arraycopy(b,off,this.buf,this.count,len);
  this.count+=len;
}
","/** 
 * Writes <code>len</code> bytes from the specified byte array starting at offset <code>off</code> to this byte array output stream.
 * @param b   the data.
 * @param off the start offset in the data.
 * @param len the number of bytes to write.
 */
",Write bytes of length len from a byte array,Copies bytes from input array to internal buffer with bounds checking.,"This method writes a specified range of bytes from an input array to an internal buffer, performing boundary checks, and handling potential buffer overflows.","@param b byte[]: Input byte array.
   @param off int: Offset in byte array to start copying from.
   @param len int: Number of bytes to copy.
   @throws IOException: If an IO error occurs.
   @throws IndexOutOfBoundsException: If offset or length is out of bounds.","write(byteArray, 0, 5)
-> (successful copy)
write(byteArray, -1, 5)
-> IndexOutOfBoundsException (off < 0)
write(byteArray, 5, 0)
-> (no action taken, len == 0)",Offsets and lengths must be within array bounds; method will update buffer and count if conditions are met.,"@Override     public void write(final byte b[], final int off, final int len) throws IOException {
        if (len < 0 || len > b.length - off) {
            throw new IndexOutOfBoundsException(""Array length ("" + b.length + "") is less than offset plus count ("" + (off + len) + "")"");
        }

        for (int i = off; i < off + len; i++) {
            b[i] = b[i + len];
        }

        ensureCapacity(off + len);
        b[off] = (byte) ((buf[bOffset + off] >>> 8) & 0xFF);
        b[off + 1] = (byte) (buf[bOffset + off + 1] & 0xFF);
        bOffset += len;
    }",1,Phi-3-mini-4k-instruct
636767551a6d9265ec017f3f,swap,"public static final <V>void swap(V[] arr,int i,int j){
  V tmp=arr[j];
  arr[j]=arr[i];
  arr[i]=tmp;
}
","/** 
 * Swaps the two elements at the specified indices in the given array.
 * @param < V > the type of elements in the array
 * @param arr the array
 * @param i the index of the first element
 * @param j the index of the second element
 */
",Swap values at indexes i and j in arr,Swaps elements in an array.,The swap function exchanges elements at indices i and j in an array arr.,"@param arr V[]: The array in which elements will be swapped.
@param i int: The index of the first element to swap.
@param j int: The index of the second element to swap.","swap([""a"", ""b"", ""c""], 0, 2)
-> [""c"", ""b"", ""a""] (Exchanges elements at indices 0 and 2)
swap([""x"", ""y""], 1, 1)
-> [""x"", ""y""] (No change as the indices are the same)
swap([1, 2, 3, 4], 1, 3)
-> [1, 4, 3, 2] (Swaps elements 2 and 4)",Indices i and j must be valid within array bounds; array elements at i and j are swapped if valid.,"public static final <V> void swap(V[] arr, int i, int j) {
    if (i >= 0 && i < arr.length && j >= 0 && j < arr.length) {
        V temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    } else {
        throw new IllegalArgumentException(""Index out of bounds"");
    }
}",0,Qwen2.5-Coder-7B-Instruct
636767551a6d9265ec017f3f,swap,"public static final <V>void swap(V[] arr,int i,int j){
  V tmp=arr[j];
  arr[j]=arr[i];
  arr[i]=tmp;
}
","/** 
 * Swaps the two elements at the specified indices in the given array.
 * @param < V > the type of elements in the array
 * @param arr the array
 * @param i the index of the first element
 * @param j the index of the second element
 */
",Swap values at indexes i and j in arr,Swaps elements in an array.,The swap function exchanges elements at indices i and j in an array arr.,"@param arr V[]: The array in which elements will be swapped.
@param i int: The index of the first element to swap.
@param j int: The index of the second element to swap.","swap([""a"", ""b"", ""c""], 0, 2)
-> [""c"", ""b"", ""a""] (Exchanges elements at indices 0 and 2)
swap([""x"", ""y""], 1, 1)
-> [""x"", ""y""] (No change as the indices are the same)
swap([1, 2, 3, 4], 1, 3)
-> [1, 4, 3, 2] (Swaps elements 2 and 4)",Indices i and j must be valid within array bounds; array elements at i and j are swapped if valid.,"public static final <V>void swap(V[] arr,int i,int j){
swap(arr,i,j);
}",1,CodeLlama-7b-Instruct-hf
636766ae1a6d9265ec0175dc,isPartialContentResponse,"public Boolean isPartialContentResponse(){
  Integer limit=drc.getLimit() == null ? 0 : drc.getLimit();
  Long count=drc.getCount() == null ? 0 : drc.getCount();
  return !((limit + 1) >= count);
}
","/** 
 * Check if the actual response is a Partial Content (HTTP 206 code)
 * @return is partial content or not
 */
",Determine whether the actual response is a Partial Content,Check if response is partial.,Determines whether the response is considered partial by checking if the count exceeds the limit. Returns true if the count is greater than limit + 1.,"@return Boolean: True if the response is partial, false otherwise.","limit=5, count=6 -> true (Partial response)
limit=5, count=5 -> false (Complete response)
limit=5, count=4 -> false (Complete response)",Inputs are non-negative integers; ensures response is flagged partial based on defined criteria.,"public Boolean isPartialContentResponse(){
  Integer limit=drc.getLimit() == null ? 0 : drc.getLimit();
  Long count=drc.getCount() == null ? 0 : drc.getCount();
  return !((limit + 1) >= count);
}
",0,reference
636766ae1a6d9265ec0175dc,isPartialContentResponse,"public Boolean isPartialContentResponse(){
  Integer limit=drc.getLimit() == null ? 0 : drc.getLimit();
  Long count=drc.getCount() == null ? 0 : drc.getCount();
  return !((limit + 1) >= count);
}
","/** 
 * Check if the actual response is a Partial Content (HTTP 206 code)
 * @return is partial content or not
 */
",Determine whether the actual response is a Partial Content,Check if response is partial.,Determines whether the response is considered partial by checking if the count exceeds the limit. Returns true if the count is greater than limit + 1.,"@return Boolean: True if the response is partial, false otherwise.","limit=5, count=6 -> true (Partial response)
limit=5, count=5 -> false (Complete response)
limit=5, count=4 -> false (Complete response)",Inputs are non-negative integers; ensures response is flagged partial based on defined criteria.,"public Boolean isPartialContentResponse(){
return isPartialContentResponse(getResponse().getStatusCode());
}",1,CodeLlama-7b-Instruct-hf
636766f01a6d9265ec01762e,isEmpty,"public static boolean isEmpty(final double[] array){
  return array == null || array.length == 0;
}
","/** 
 * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */
",Check whether the array of the double type is empty.,Check if a double array is null or empty.,"Returns true if the array is null or has no elements, otherwise returns false.","@param array double[]: Array of double values to be checked
@return boolean: True if the array is null or empty, otherwise false","null -> true (Array is null)
[] -> true (Array is empty)
[1.0] -> false (Array has one element)",Input is a double array or null; output is a boolean indicating if the array is null or empty.,"public static boolean isEmpty(final double[] array){
    return (array == null) || (array.length == 0);
}",0,Qwen2.5-Coder-7B-Instruct
636766f01a6d9265ec01762e,isEmpty,"public static boolean isEmpty(final double[] array){
  return array == null || array.length == 0;
}
","/** 
 * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */
",Check whether the array of the double type is empty.,Check if a double array is null or empty.,"Returns true if the array is null or has no elements, otherwise returns false.","@param array double[]: Array of double values to be checked
@return boolean: True if the array is null or empty, otherwise false","null -> true (Array is null)
[] -> true (Array is empty)
[1.0] -> false (Array has one element)",Input is a double array or null; output is a boolean indicating if the array is null or empty.,"public static boolean isEmpty(final double[] array){
int sum = 0;
for (final double element : array) sum += 1;
return sum == 0;
}",1,CodeLlama-7b-Instruct-hf
6367667e1a6d9265ec01743a,lastWriteTimeStampInMilliseconds,"public long lastWriteTimeStampInMilliseconds(){
  return lastWrite == -1 ? System.currentTimeMillis() : lastWrite;
}
","/** 
 * The last time, in milliseconds, a write operation occurred.
 * @return this
 */
","Check whether lastwrite is - 1. If yes, return - 1. Otherwise, return System.currentTimeMillis().",Returns the last write timestamp or the current time if not set.,"If lastWrite equals -1, it returns the current system time in milliseconds; otherwise, it returns lastWrite.",@return long: The last write timestamp or current time in milliseconds.,"lastWrite = -1 -> current time (lastWrite not set)
lastWrite = 1622538093000 -> 1622538093000 (returns lastWrite)
lastWrite = 0 -> 0 (returns lastWrite)","lastWrite is an internal variable, initialized to -1 if unset; returns a valid long timestamp.","public long lastWriteTimeStampInMilliseconds(){
  return lastWrite == -1 ? System.currentTimeMillis() : lastWrite;
}
",0,reference
6367667e1a6d9265ec01743a,lastWriteTimeStampInMilliseconds,"public long lastWriteTimeStampInMilliseconds(){
  return lastWrite == -1 ? System.currentTimeMillis() : lastWrite;
}
","/** 
 * The last time, in milliseconds, a write operation occurred.
 * @return this
 */
","Check whether lastwrite is - 1. If yes, return - 1. Otherwise, return System.currentTimeMillis().",Returns the last write timestamp or the current time if not set.,"If lastWrite equals -1, it returns the current system time in milliseconds; otherwise, it returns lastWrite.",@return long: The last write timestamp or current time in milliseconds.,"lastWrite = -1 -> current time (lastWrite not set)
lastWrite = 1622538093000 -> 1622538093000 (returns lastWrite)
lastWrite = 0 -> 0 (returns lastWrite)","lastWrite is an internal variable, initialized to -1 if unset; returns a valid long timestamp.","public long lastWriteTimeStampInMilliseconds() {
    if (lastwrite == -1) {
        return -1;
    } else {
        return System.currentTimeMillis();
    }
}",1,Qwen2.5-Coder-7B-Instruct
636766821a6d9265ec0174c9,classPath,"private static File[] classPath(){
  final String[] fileNames=System.getProperty(""java.class.path"").split(File.pathSeparator);
  final File[] files=new File[fileNames.length];
  for (int i=0; i < files.length; ++i) {
    files[i]=new File(fileNames[i]);
  }
  return files;
}
","/** 
 * Returns the class path of the current JVM instance as an array of  {@link File} objects.
 */
",Creates an array of the file type based on all file names in java.class.path and returns the array.,Converts the Java class path to an array of Files.,"The function retrieves the Java class path, splits it into individual paths using the system path separator, and creates a File object for each path.",@return File[]: Array of File objects representing Java class path entries.,"java.class.path ""lib1.jar:lib2.jar"" -> [lib1.jar, lib2.jar] (Class paths converted to File array)
java.class.path ""/path/to/lib1:/path/to/lib2"" -> [/path/to/lib1, /path/to/lib2] (Absolute paths as File objects)","System property ""java.class.path"" must be set, output is an array of File objects representing the paths.","private static File[] classPath(){
        String[] classPath = System.getProperty(""java.class.path"").split(""\\;"");
        File[] files = new File[classPath.length];
        for(int i = 0; i<classPath.length; i++) {
            files[i] = new File(classPath[i]);
        }
        return files;
    }",0,CodeLlama-7b-Instruct-hf
636766821a6d9265ec0174c9,classPath,"private static File[] classPath(){
  final String[] fileNames=System.getProperty(""java.class.path"").split(File.pathSeparator);
  final File[] files=new File[fileNames.length];
  for (int i=0; i < files.length; ++i) {
    files[i]=new File(fileNames[i]);
  }
  return files;
}
","/** 
 * Returns the class path of the current JVM instance as an array of  {@link File} objects.
 */
",Creates an array of the file type based on all file names in java.class.path and returns the array.,Converts the Java class path to an array of Files.,"The function retrieves the Java class path, splits it into individual paths using the system path separator, and creates a File object for each path.",@return File[]: Array of File objects representing Java class path entries.,"java.class.path ""lib1.jar:lib2.jar"" -> [lib1.jar, lib2.jar] (Class paths converted to File array)
java.class.path ""/path/to/lib1:/path/to/lib2"" -> [/path/to/lib1, /path/to/lib2] (Absolute paths as File objects)","System property ""java.class.path"" must be set, output is an array of File objects representing the paths.","private static File[] classPath() {
    String classPath = System.getProperty(""java.class.path"");
    File[] filePaths = File.pathSeparator.split(classPath);
    String[] fileNames = filePaths.filter(File::isFile).toArray(new String[0]);
    String[] fileTypes = fileNames.map(name -> getFileType(name)).toArray(String[]::new);
    return fileTypes;
}",1,Phi-3-mini-4k-instruct
636767041a6d9265ec0178f8,copyStrings,"private static String[] copyStrings(final String[] src){
  String[] dst=new String[src.length];
  for (int i=0; i < src.length; ++i) {
    dst[i]=src[i].toLowerCase();
  }
  return dst;
}
","/** 
 * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.
 */
",Copy the source string and transfer each character to lowecase.,Converts an array of strings to lowercase.,"The function creates a new array, converting each string from the input array to lowercase, then returns it.","@param src String[]: Source array of strings.
@return String[]: New array with strings converted to lowercase.","{""Hello"", ""WORLD""} -> {""hello"", ""world""} (Converts to lowercase)
{""JAVA"", ""Python""} -> {""java"", ""python""} (Converts to lowercase)
{""Stay"", ""Positive""} -> {""stay"", ""positive""} (Converts to lowercase)","Input array contains non-null strings, output maintains the same order with all strings in lowercase.","private static String[] copyStrings(final String[] src){
    if(null == src){
        return null;
    }
    final String[] dest = new String[src.length];
    for(int i = 0; i < src.length; i++){
        dest[i] = src[i].toLowerCase();
    }
    return dest;
}",0,CodeLlama-7b-Instruct-hf
636767041a6d9265ec0178f8,copyStrings,"private static String[] copyStrings(final String[] src){
  String[] dst=new String[src.length];
  for (int i=0; i < src.length; ++i) {
    dst[i]=src[i].toLowerCase();
  }
  return dst;
}
","/** 
 * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.
 */
",Copy the source string and transfer each character to lowecase.,Converts an array of strings to lowercase.,"The function creates a new array, converting each string from the input array to lowercase, then returns it.","@param src String[]: Source array of strings.
@return String[]: New array with strings converted to lowercase.","{""Hello"", ""WORLD""} -> {""hello"", ""world""} (Converts to lowercase)
{""JAVA"", ""Python""} -> {""java"", ""python""} (Converts to lowercase)
{""Stay"", ""Positive""} -> {""stay"", ""positive""} (Converts to lowercase)","Input array contains non-null strings, output maintains the same order with all strings in lowercase.","private static String[] copyStrings(final String[] src){
int length = src.length;
String[] dst = new String[length];
for (int i = 0; i < length; i++) {
dst[i] = src[i].toLowerCase();
}
}",1,starcoder2-7b
636767521a6d9265ec017ecc,splitAlongXAxis,"public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){
  double newWidth=box.getWidth() / 2d;
  double height=box.getHeight();
  return Pair.of(Box2D.of(box.getMinX(),box.getMinY(),newWidth,height),Box2D.of(box.getMinX() + newWidth,box.getMinY(),newWidth,height));
}
","/** 
 * Split a box along the x axis into two equal boxes.
 * @param box the box to split
 * @return a pair with the two resulting boxes
 */
",Divide a box into two equal boxes on the x axis.,Splits a Box2D object into two along the x-axis.,Splits the given Box2D into two equal width Box2D objects along the x-axis and returns them as a pair.,"@param box Box2D: The Box2D object to be split.
   @return Pair<Box2D, Box2D>: A pair of Box2D objects split from the original.","Box2D(0,0,8,4)
-> Pair(Box2D(0,0,4,4)
, Box2D(4,0,4,4)
) (splits into two halves)
Box2D(0,0,10,5)
-> Pair(Box2D(0,0,5,5)
, Box2D(5,0,5,5)
) (splits into two halves)
Box2D(1,1,6,3)
-> Pair(Box2D(1,1,3,3)
, Box2D(4,1,3,3)
) (splits into two halves)",Box2D must have positive width and height; returns a Pair with two Box2D objects retaining the original height and each with half the original width.,"public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box){
    double newXWidth = box.getWidth() / 2;
    Box2D leftBox = new Box2D(box.getMinX(), box.getMinY(), newXWidth, box.getHeight());
    Box2D rightBox = new Box2D(box.getMinX() + newXWidth, box.getMinY(), newXWidth, box.getHeight());
    return new Pair<>(leftBox, rightBox);
}",0,gpt-4-turbo
636767521a6d9265ec017ecc,splitAlongXAxis,"public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){
  double newWidth=box.getWidth() / 2d;
  double height=box.getHeight();
  return Pair.of(Box2D.of(box.getMinX(),box.getMinY(),newWidth,height),Box2D.of(box.getMinX() + newWidth,box.getMinY(),newWidth,height));
}
","/** 
 * Split a box along the x axis into two equal boxes.
 * @param box the box to split
 * @return a pair with the two resulting boxes
 */
",Divide a box into two equal boxes on the x axis.,Splits a Box2D object into two along the x-axis.,Splits the given Box2D into two equal width Box2D objects along the x-axis and returns them as a pair.,"@param box Box2D: The Box2D object to be split.
   @return Pair<Box2D, Box2D>: A pair of Box2D objects split from the original.","Box2D(0,0,8,4)
-> Pair(Box2D(0,0,4,4)
, Box2D(4,0,4,4)
) (splits into two halves)
Box2D(0,0,10,5)
-> Pair(Box2D(0,0,5,5)
, Box2D(5,0,5,5)
) (splits into two halves)
Box2D(1,1,6,3)
-> Pair(Box2D(1,1,3,3)
, Box2D(4,1,3,3)
) (splits into two halves)",Box2D must have positive width and height; returns a Pair with two Box2D objects retaining the original height and each with half the original width.,"public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){
	Point2D low_mid=box.getLowerBound().add(box.getUpperBound()).mul(0.5).floor();
	return Pair.of(new Box2D(box.getLowerBound(),low_mid),new Box2D(low_mid,box.getUpperBound()));
}",1,starcoder2-7b
636766a91a6d9265ec0175c1,enlarge,"private void enlarge(final int size){
  int doubleCapacity=2 * data.length;
  int minimalCapacity=length + size;
  byte[] newData=new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];
  System.arraycopy(data,0,newData,0,length);
  data=newData;
}
","/** 
 * Enlarges this byte vector so that it can receive 'size' more bytes.
 * @param size number of additional bytes that this byte vector should be able to receive.
 */
",Convert the original data array to a longer array.,Dynamically resizes a byte array.,Enlarges the byte array to accommodate additional elements by creating a new larger array and copying existing data into it.,@param size int: additional number of elements to fit,"size=5 with data.length=10, length=8 -> enlarges data (fits 13 elements)
size=20 with data.length=15, length=12 -> enlarges data (fits 32 elements)
size=0 with data.length=20, length=18 -> keeps data (no size change needed)",Precondition: data array has existing elements. Postcondition: data array is enlarged to fit additional size requirements.,"private void enlarge(final int size) {
    if (size <= 0) {
        return; // If the requested size is zero or less, do not enlarge.
    }

    int newLength = data.length;
    int sumLength = data.length + size;
    
    // Check if enlargement is needed
    if (sumLength > newLength) {
        // Increase size by doubling it until it's large enough to accommodate the new size request
        while (newLength < sumLength) {
            newLength *= 2;
        }
        
        // Reallocate with the new size and copy existing content
        byte[] newData = new byte[newLength];
        System.arraycopy(data, 0, newData, 0, data.length);
        data = newData;
    }
}",0,gpt-4-turbo
636766a91a6d9265ec0175c1,enlarge,"private void enlarge(final int size){
  int doubleCapacity=2 * data.length;
  int minimalCapacity=length + size;
  byte[] newData=new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];
  System.arraycopy(data,0,newData,0,length);
  data=newData;
}
","/** 
 * Enlarges this byte vector so that it can receive 'size' more bytes.
 * @param size number of additional bytes that this byte vector should be able to receive.
 */
",Convert the original data array to a longer array.,Dynamically resizes a byte array.,Enlarges the byte array to accommodate additional elements by creating a new larger array and copying existing data into it.,@param size int: additional number of elements to fit,"size=5 with data.length=10, length=8 -> enlarges data (fits 13 elements)
size=20 with data.length=15, length=12 -> enlarges data (fits 32 elements)
size=0 with data.length=20, length=18 -> keeps data (no size change needed)",Precondition: data array has existing elements. Postcondition: data array is enlarged to fit additional size requirements.,"private void enlarge(final int size, byte[] originalData) {
    byte[] newData = new byte[originalData.length + size];
    System.arraycopy(originalData, 0, newData, 0, originalData.length);
    // Initialize the new part of the array with some default value, for example, zero
    for (int i = originalData.length; i < newData.length; i++) {
        newData[i] = 0;
    }
    originalData = newData;
}",1,Phi-3-mini-4k-instruct
6367674a1a6d9265ec017dab,compare,"@Override public int compare(Double o1,Double o2){
  if (Math.abs(o1 - o2) < epsilon) {
    return 0;
  }
 else {
    return Double.compare(o1,o2);
  }
}
","/** 
 * Compares two floating point values. Returns 0 if they are equal, -1 if  {@literal o1 < o2}, 1 otherwise
 * @param o1 the first value
 * @param o2 the second value
 * @return 0 if they are equal, -1 if {@literal o1 < o2}, 1 otherwise
 */
","Compares two values. If the difference between the two values is less than epsilon, 0 is returned. Otherwise, Double.compare is invoked.",Compares two Double objects with a tolerance level epsilon.,"Returns 0 if the absolute difference between two doubles is less than epsilon, otherwise returns the result of Double.compare.","@param o1 Double: first double object
@param o2 Double: second double object
@return int: 0 if the doubles are approximately equal, otherwise standard comparison result","1.0, 1.0 -> 0 (Numbers are equal)
1.0, 1.1 -> -1 (1.0 is less than 1.1)
1.1, 1.0 -> 1 (1.1 is greater than 1.0)",The inputs are non-null Double objects; output is an integer indicating approximate equality or comparison result.,"@Override public int compare(Double o1, Double o2) {
    final double EPSILON = 1e-9;
    if (Math.abs(o1 - o2) < EPSILON) {
        return 0;
    } else {
        return Double.compare(o1, o2);
    }
}",0,Qwen2.5-Coder-7B-Instruct
6367674a1a6d9265ec017dab,compare,"@Override public int compare(Double o1,Double o2){
  if (Math.abs(o1 - o2) < epsilon) {
    return 0;
  }
 else {
    return Double.compare(o1,o2);
  }
}
","/** 
 * Compares two floating point values. Returns 0 if they are equal, -1 if  {@literal o1 < o2}, 1 otherwise
 * @param o1 the first value
 * @param o2 the second value
 * @return 0 if they are equal, -1 if {@literal o1 < o2}, 1 otherwise
 */
","Compares two values. If the difference between the two values is less than epsilon, 0 is returned. Otherwise, Double.compare is invoked.",Compares two Double objects with a tolerance level epsilon.,"Returns 0 if the absolute difference between two doubles is less than epsilon, otherwise returns the result of Double.compare.","@param o1 Double: first double object
@param o2 Double: second double object
@return int: 0 if the doubles are approximately equal, otherwise standard comparison result","1.0, 1.0 -> 0 (Numbers are equal)
1.0, 1.1 -> -1 (1.0 is less than 1.1)
1.1, 1.0 -> 1 (1.1 is greater than 1.0)",The inputs are non-null Double objects; output is an integer indicating approximate equality or comparison result.,"int compare(Double o1, Double o2) {
    final double EPSILON = 1e-10; // Example epsilon value, can be adjusted
    double difference = Math.abs(o1 - o2);
    return difference < EPSILON ? 0 : Double.compare(o1, o2);
}",1,Phi-3-mini-4k-instruct
6367672d1a6d9265ec017c78,insert,"public boolean insert(int val){
  if (!map.containsKey(val)) {
    map.put(val,val);
    values.add(val);
    return true;
  }
 else {
    return false;
  }
}
","/** 
 * Inserts a value to the set. Returns true if the set did not already contain the specified element. 
 */
","If the key whose value is val does not exist in the map, add (val, val) to the map and return true. Otherwise, return false.",Inserts a value if it doesn't exist in the map.,"The function checks if the value exists in the map. If not, it adds the value to the map and a list, returning true; otherwise, it returns false.","@param val int: The value to be inserted
   @return boolean: True if the value was added, false if it already existed","insert(5)
-> true (inserts 5 successfully)
insert(7)
-> true (inserts 7 successfully)
insert(5)
-> false (5 already exists, no insertion)","Assumes `map` and `values` are initialized; after execution, `map` contains the value only if it wasn't already there.","public boolean insert(int val){
    if (!map.containsKey(val)){
        map.put(val, val);
        return true;
    }
    return false;
}",0,Qwen2.5-Coder-7B-Instruct
6367672d1a6d9265ec017c78,insert,"public boolean insert(int val){
  if (!map.containsKey(val)) {
    map.put(val,val);
    values.add(val);
    return true;
  }
 else {
    return false;
  }
}
","/** 
 * Inserts a value to the set. Returns true if the set did not already contain the specified element. 
 */
","If the key whose value is val does not exist in the map, add (val, val) to the map and return true. Otherwise, return false.",Inserts a value if it doesn't exist in the map.,"The function checks if the value exists in the map. If not, it adds the value to the map and a list, returning true; otherwise, it returns false.","@param val int: The value to be inserted
   @return boolean: True if the value was added, false if it already existed","insert(5)
-> true (inserts 5 successfully)
insert(7)
-> true (inserts 7 successfully)
insert(5)
-> false (5 already exists, no insertion)","Assumes `map` and `values` are initialized; after execution, `map` contains the value only if it wasn't already there.","public static void main(String[] args) {
        HashMap<Integer, Integer> map = new HashMap<>();
        boolean inserted = insert(map, 1);
        System.out.println(""Inserted: "" + inserted); // Should print true
    }",1,Phi-3-mini-4k-instruct
636766821a6d9265ec0174bf,capitalize,"public static String capitalize(String name){
  if (name == null || name.length() == 0) {
    return name;
  }
  char chars[]=name.toCharArray();
  chars[0]=Character.toUpperCase(chars[0]);
  return new String(chars);
}
","/** 
 * Reverse of Introspector.decapitalize
 */
",Converts a name of the string type to a character array and converts the first letter to an uppercase letter.,Capitalizes the first character of a non-empty string.,Converts the first character of a given string to uppercase. Returns the modified string without altering other characters.,"@param name String: The input string to be capitalized
   @return String: The string with the first character capitalized","""hello"" -> ""Hello"" (capitalizes 'h')
""java"" -> ""Java"" (capitalizes 'j')
"""" -> """" (empty string remains unchanged)
null -> null (returns null for null input)",Input is a string or null; output is the modified string with an uppercase first character or unchanged for empty/null input.,"public static String capitalize(String name) {
    if (name == null || name.isEmpty()) {
        return name;
    }
    char[] chars = name.toCharArray();
    chars[0] = Character.toUpperCase(chars[0]);
    return String.valueOf(chars);
}",0,Phi-3-mini-4k-instruct
636766821a6d9265ec0174bf,capitalize,"public static String capitalize(String name){
  if (name == null || name.length() == 0) {
    return name;
  }
  char chars[]=name.toCharArray();
  chars[0]=Character.toUpperCase(chars[0]);
  return new String(chars);
}
","/** 
 * Reverse of Introspector.decapitalize
 */
",Converts a name of the string type to a character array and converts the first letter to an uppercase letter.,Capitalizes the first character of a non-empty string.,Converts the first character of a given string to uppercase. Returns the modified string without altering other characters.,"@param name String: The input string to be capitalized
   @return String: The string with the first character capitalized","""hello"" -> ""Hello"" (capitalizes 'h')
""java"" -> ""Java"" (capitalizes 'j')
"""" -> """" (empty string remains unchanged)
null -> null (returns null for null input)",Input is a string or null; output is the modified string with an uppercase first character or unchanged for empty/null input.,"public static String capitalize(String name){
	return capitalize(name, false);
}",1,starcoder2-7b
636766f21a6d9265ec017677,isNotTrue,"public static boolean isNotTrue(Boolean bool){
  return !isTrue(bool);
}
","/** 
 * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>true</code>, handling <code>null</code> by returning <code>true</code>.</p> <pre> BooleanUtils.isNotTrue(Boolean.TRUE)  = false BooleanUtils.isNotTrue(Boolean.FALSE) = true BooleanUtils.isNotTrue(null)          = true </pre>
 * @param bool  the boolean to check, null returns <code>true</code>
 * @return <code>true</code> if the input is null or false
 * @since 2.3
 */
",Check whether the parameter bool is not true.,Checks if a Boolean is not true.,The function returns the opposite result of another function isTrue when given a Boolean input.,"@param bool Boolean: Boolean value to check
   @return boolean: true if the input is not true, false otherwise","true -> false (Assumes isTrue(true)
returns true)
   false -> true (Assumes isTrue(false)
returns false)
   null -> true (if isTrue(null)
assumes false)","Input can be true, false, or null; output is the opposite of isTrue result for the input.","public static boolean isNotTrue(Boolean bool) {
    return bool != true;
}",0,Phi-3-mini-4k-instruct
636766f21a6d9265ec017677,isNotTrue,"public static boolean isNotTrue(Boolean bool){
  return !isTrue(bool);
}
","/** 
 * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>true</code>, handling <code>null</code> by returning <code>true</code>.</p> <pre> BooleanUtils.isNotTrue(Boolean.TRUE)  = false BooleanUtils.isNotTrue(Boolean.FALSE) = true BooleanUtils.isNotTrue(null)          = true </pre>
 * @param bool  the boolean to check, null returns <code>true</code>
 * @return <code>true</code> if the input is null or false
 * @since 2.3
 */
",Check whether the parameter bool is not true.,Checks if a Boolean is not true.,The function returns the opposite result of another function isTrue when given a Boolean input.,"@param bool Boolean: Boolean value to check
   @return boolean: true if the input is not true, false otherwise","true -> false (Assumes isTrue(true)
returns true)
   false -> true (Assumes isTrue(false)
returns false)
   null -> true (if isTrue(null)
assumes false)","Input can be true, false, or null; output is the opposite of isTrue result for the input.","public static boolean isNotTrue(boolean bool) {
    return !bool;
}",1,Phi-3-mini-4k-instruct
6367674f1a6d9265ec017e74,toString,"public String toString(){
  StringBuilder s=new StringBuilder();
  for (int j=i; j < n; j++)   s.append(vs[j]).append("" "");
  return s.toString();
}
","/** 
 * Returns a textual representation of the queue.
 * @return a textual representation of the queue.
 */
",Convert a value in a vs array to a string,Converts a section of an array to a space-separated string.,"The function iterates over an array from index `i` to `n`, appending each element followed by a space to a StringBuilder, and returns the resulting string.",@return String: The space-separated string formed by the array elements from index `i` to `n-1`.,"{""a"", ""b"", ""c""}, i=0, n=3 -> ""a b c "" (entire array)
{""x"", ""y"", ""z""}, i=1, n=3 -> ""y z "" (partial array starting at index 1)
{""m"", ""n"", ""o"", ""p""}, i=2, n=4 -> ""o p "" (starts from index 2)",Preconditions: `i` and `n` are valid indices within the bounds of the array. Postconditions: Returns a string representing the desired section of the array.,"public String toString(){
  StringBuilder s=new StringBuilder();
  for (int j=i; j < n; j++)   s.append(vs[j]).append("" "");
  return s.toString();
}
",0,reference
6367674f1a6d9265ec017e74,toString,"public String toString(){
  StringBuilder s=new StringBuilder();
  for (int j=i; j < n; j++)   s.append(vs[j]).append("" "");
  return s.toString();
}
","/** 
 * Returns a textual representation of the queue.
 * @return a textual representation of the queue.
 */
",Convert a value in a vs array to a string,Converts a section of an array to a space-separated string.,"The function iterates over an array from index `i` to `n`, appending each element followed by a space to a StringBuilder, and returns the resulting string.",@return String: The space-separated string formed by the array elements from index `i` to `n-1`.,"{""a"", ""b"", ""c""}, i=0, n=3 -> ""a b c "" (entire array)
{""x"", ""y"", ""z""}, i=1, n=3 -> ""y z "" (partial array starting at index 1)
{""m"", ""n"", ""o"", ""p""}, i=2, n=4 -> ""o p "" (starts from index 2)",Preconditions: `i` and `n` are valid indices within the bounds of the array. Postconditions: Returns a string representing the desired section of the array.,"public String toString() {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < values.length; i++) {
        sb.append(values[i]);
        if (i < values.length - 1) {
            sb.append("", "");
        }
    }
    return sb.toString();
}",1,Phi-3-mini-4k-instruct
6367675c1a6d9265ec018058,createStringSupplier,"@SuppressWarnings(""unchecked"") public static Supplier<String> createStringSupplier(int start){
  int[] container=new int[]{start};
  return (Supplier<String> & Serializable)() -> String.valueOf(container[0]++);
}
","/** 
 * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.
 * @param start where to start the sequence
 * @return a string supplier
 */
",Create a string supplier which returns unique integer strings starting from the given start.,Creates a Supplier that generates a string from an incrementing integer.,"Returns a supplier that provides the next integer in string form, starting from a given integer, and increments the value after each call.",@return Supplier<String>: A supplier that returns the current integer as a string and then increments the integer.,"Supplier created with 5 -> ""5"" (first call)
Supplier created with 5 -> ""6"" (second call)
Supplier created with 0 -> ""0"" (first call)","Initial integer must be a valid int, generating strings from incrementing ints starting at given value.","@SuppressWarnings(""unchecked"") public static Supplier<String> createStringSupplier(int start){
  int[] container=new int[]{start};
  return (Supplier<String> & Serializable)() -> String.valueOf(container[0]++);
}
",0,reference
6367675c1a6d9265ec018058,createStringSupplier,"@SuppressWarnings(""unchecked"") public static Supplier<String> createStringSupplier(int start){
  int[] container=new int[]{start};
  return (Supplier<String> & Serializable)() -> String.valueOf(container[0]++);
}
","/** 
 * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.
 * @param start where to start the sequence
 * @return a string supplier
 */
",Create a string supplier which returns unique integer strings starting from the given start.,Creates a Supplier that generates a string from an incrementing integer.,"Returns a supplier that provides the next integer in string form, starting from a given integer, and increments the value after each call.",@return Supplier<String>: A supplier that returns the current integer as a string and then increments the integer.,"Supplier created with 5 -> ""5"" (first call)
Supplier created with 5 -> ""6"" (second call)
Supplier created with 0 -> ""0"" (first call)","Initial integer must be a valid int, generating strings from incrementing ints starting at given value.","public static void main(String[] args) {
        Supplier<String> stringSupplier = createStringSupplier(1);
        System.out.println(stringSupplier.get()); // prints ""1""
        System.out.println(stringSupplier.get()); // prints ""2""
        System.out.println(stringSupplier.get()); // prints ""3""
    }",1,deepseek-coder-6.7b-instruct
6367677b1a6d9265ec0182bd,format,"public String format(final LoggingEvent event){
  StringBuffer buf=new StringBuffer();
  for (PatternConverter c=head; c != null; c=c.next) {
    c.format(buf,event);
  }
  return buf.toString();
}
","/** 
 * Formats a logging event to a writer.
 * @param event logging event to be formatted.
 */
",Formats LoggingEvent as a fixed-format string,Formats a logging event into a string.,"Iterates over a linked list of PatternConverter objects to format a LoggingEvent object, appending each result to a StringBuffer. Converts the StringBuffer to a String and returns it.",@return String: the formatted string representation of the logging event.,"event1 -> ""ERROR: NullPointerException at line 45"" (formats as error message)
event2 -> ""INFO: User login successful"" (formats as info message)
event3 -> ""DEBUG: Variable x set to 10"" (formats as debug message)","Preconditions: 'head' is not null, and each PatternConverter in the linked list can format the event. Postconditions: Returns a non-null string created from formatted logging event data.","public String format(final LoggingEvent event){
  StringBuffer buf=new StringBuffer();
  for (PatternConverter c=head; c != null; c=c.next) {
    c.format(buf,event);
  }
  return buf.toString();
}
",0,reference
6367677b1a6d9265ec0182bd,format,"public String format(final LoggingEvent event){
  StringBuffer buf=new StringBuffer();
  for (PatternConverter c=head; c != null; c=c.next) {
    c.format(buf,event);
  }
  return buf.toString();
}
","/** 
 * Formats a logging event to a writer.
 * @param event logging event to be formatted.
 */
",Formats LoggingEvent as a fixed-format string,Formats a logging event into a string.,"Iterates over a linked list of PatternConverter objects to format a LoggingEvent object, appending each result to a StringBuffer. Converts the StringBuffer to a String and returns it.",@return String: the formatted string representation of the logging event.,"event1 -> ""ERROR: NullPointerException at line 45"" (formats as error message)
event2 -> ""INFO: User login successful"" (formats as info message)
event3 -> ""DEBUG: Variable x set to 10"" (formats as debug message)","Preconditions: 'head' is not null, and each PatternConverter in the linked list can format the event. Postconditions: Returns a non-null string created from formatted logging event data.","public String format(final LoggingEvent event){
    if (event==null){
        return """";
    }
    return dateFormatter.format(event.timeStamp)+"" ""+ event.getRenderedMessage();
}",1,CodeLlama-7b-Instruct-hf
636766ff1a6d9265ec017842,toPrimitive,"public static double[] toPrimitive(final Double[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_DOUBLE_ARRAY;
  }
  final double[] result=new double[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].doubleValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Doubles to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Double</code> array, may be <code>null</code>
 * @return a <code>double</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","If the length of the array is 0, return EMPTY_DOUBLE_ARAY. Otherwise, convert the array to an array of the double type.",Converts a Double array to a primitive double array.,"Converts a non-null array of Double objects to an array of primitive doubles, handling null and empty cases specifically.","@param array Double[]: Input array of Double objects
@return double[]: Array of primitive doubles","null -> null (input null, output null)
[] -> [] (empty array to empty array)
[1.0, 2.2, 3.3] -> [1.0, 2.2, 3.3] (standard conversion)",Input must be a Double array or null; output is a corresponding double array or null if input is null.,"public static double[] toPrimitive(final Double[] array){
        if( array!= null ) {
        if( array.length == 0) {
        return EMPTY_DOUBLE_ARRAY;
        }
        final double[] primitive = new double[ array.length ];
        for (int index = 0; index < primitive.length; index++) {
        primitive[index] = array[index];
        }
        return primitive;
        }
        return null;
}",0,starcoder2-7b
636766ff1a6d9265ec017842,toPrimitive,"public static double[] toPrimitive(final Double[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_DOUBLE_ARRAY;
  }
  final double[] result=new double[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].doubleValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Doubles to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Double</code> array, may be <code>null</code>
 * @return a <code>double</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","If the length of the array is 0, return EMPTY_DOUBLE_ARAY. Otherwise, convert the array to an array of the double type.",Converts a Double array to a primitive double array.,"Converts a non-null array of Double objects to an array of primitive doubles, handling null and empty cases specifically.","@param array Double[]: Input array of Double objects
@return double[]: Array of primitive doubles","null -> null (input null, output null)
[] -> [] (empty array to empty array)
[1.0, 2.2, 3.3] -> [1.0, 2.2, 3.3] (standard conversion)",Input must be a Double array or null; output is a corresponding double array or null if input is null.,"public static double[] toPrimitive(final Double[] array){
    if (array == null || array.length == 0){
        return new double[0]; // Return an empty array
    }

    double[] result = new double[array.length];
    for (int i = 0; i < array.length; i++){
        result[i] = array[i]; // Auto-unboxing to convert Double to double
    }

    return result;
}",1,deepseek-coder-6.7b-instruct
636766fa1a6d9265ec0177a9,addInitializedType,"private void addInitializedType(final int abstractType){
  if (initializations == null) {
    initializations=new int[2];
  }
  int initializationsLength=initializations.length;
  if (initializationCount >= initializationsLength) {
    int[] newInitializations=new int[Math.max(initializationCount + 1,2 * initializationsLength)];
    System.arraycopy(initializations,0,newInitializations,0,initializationsLength);
    initializations=newInitializations;
  }
  initializations[initializationCount++]=abstractType;
}
","/** 
 * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.
 * @param abstractType an abstract type on a which a constructor is invoked.
 */
",Add abstractType to the initializations variable.,Adds an initialized type to the internal array.,"Checks and resizes the `initializations` array if needed, then adds the given `abstractType` at the next available index.",@param abstractType int: The type to be added to the array.,"abstractType=3 -> array resizes if needed and 3 is added
   abstractType=5 when full -> array extends and 5 is added
   abstractType=2 -> 2 is added at next available position","Assumes `initializations` can be null initially, enlarges array when full, ensures `abstractType` is appended.","private void addInitializedType(final int abstractType){
  if (initializations == null) {
    initializations=new int[2];
  }
  int initializationsLength=initializations.length;
  if (initializationCount >= initializationsLength) {
    int[] newInitializations=new int[Math.max(initializationCount + 1,2 * initializationsLength)];
    System.arraycopy(initializations,0,newInitializations,0,initializationsLength);
    initializations=newInitializations;
  }
  initializations[initializationCount++]=abstractType;
}
",0,reference
636766fa1a6d9265ec0177a9,addInitializedType,"private void addInitializedType(final int abstractType){
  if (initializations == null) {
    initializations=new int[2];
  }
  int initializationsLength=initializations.length;
  if (initializationCount >= initializationsLength) {
    int[] newInitializations=new int[Math.max(initializationCount + 1,2 * initializationsLength)];
    System.arraycopy(initializations,0,newInitializations,0,initializationsLength);
    initializations=newInitializations;
  }
  initializations[initializationCount++]=abstractType;
}
","/** 
 * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.
 * @param abstractType an abstract type on a which a constructor is invoked.
 */
",Add abstractType to the initializations variable.,Adds an initialized type to the internal array.,"Checks and resizes the `initializations` array if needed, then adds the given `abstractType` at the next available index.",@param abstractType int: The type to be added to the array.,"abstractType=3 -> array resizes if needed and 3 is added
   abstractType=5 when full -> array extends and 5 is added
   abstractType=2 -> 2 is added at next available position","Assumes `initializations` can be null initially, enlarges array when full, ensures `abstractType` is appended.","private void addInitializedType(final int abstractType){
    int numberToIncrement = abstractTypeToVariableMap.get(abstractType) + 1;
    final int initializedType = numberToIncrement;
    abstractTypeToVariableMap.put(abstractType, initializedType);

    if (initializedType == numberOfVariables){
        addInitializedType(abstractType + 1);
    }
}",1,CodeLlama-7b-Instruct-hf
6367670a1a6d9265ec0179dc,putAbstractTypes,"private void putAbstractTypes(final int start,final int end){
  for (int i=start; i < end; ++i) {
    Frame.putAbstractType(symbolTable,currentFrame[i],stackMapTableEntries);
  }
}
","/** 
 * Puts some abstract types of  {@link #currentFrame} in {@link #stackMapTableEntries} , using theJVMS verification_type_info format used in StackMapTable attributes.
 * @param start index of the first type in {@link #currentFrame} to write.
 * @param end index of last type in {@link #currentFrame} to write (exclusive).
 */
",Add the elements indexed from start to end in currentFrame to Frame.,Updates a collection of abstract types within a specified range.,Iterates from `start` to `end` and updates each entry with an abstract type using `Frame.putAbstractType`.,"@param start int: Start index for the iteration.
   @param end int: End index for the iteration.","putAbstractTypes(0, 3)
-> (updates entries at indices 0, 1, 2)
putAbstractTypes(2, 5)
-> (updates entries at indices 2, 3, 4)
putAbstractTypes(1, 1)
-> (does not update any entries)",Indices must be valid within the currentFrame; each valid index will have its abstract type updated.,"private void putAbstractTypes(final int start,final int end){
  for (int i=start; i < end; ++i) {
    Frame.putAbstractType(symbolTable,currentFrame[i],stackMapTableEntries);
  }
}
",0,reference
6367670a1a6d9265ec0179dc,putAbstractTypes,"private void putAbstractTypes(final int start,final int end){
  for (int i=start; i < end; ++i) {
    Frame.putAbstractType(symbolTable,currentFrame[i],stackMapTableEntries);
  }
}
","/** 
 * Puts some abstract types of  {@link #currentFrame} in {@link #stackMapTableEntries} , using theJVMS verification_type_info format used in StackMapTable attributes.
 * @param start index of the first type in {@link #currentFrame} to write.
 * @param end index of last type in {@link #currentFrame} to write (exclusive).
 */
",Add the elements indexed from start to end in currentFrame to Frame.,Updates a collection of abstract types within a specified range.,Iterates from `start` to `end` and updates each entry with an abstract type using `Frame.putAbstractType`.,"@param start int: Start index for the iteration.
   @param end int: End index for the iteration.","putAbstractTypes(0, 3)
-> (updates entries at indices 0, 1, 2)
putAbstractTypes(2, 5)
-> (updates entries at indices 2, 3, 4)
putAbstractTypes(1, 1)
-> (does not update any entries)",Indices must be valid within the currentFrame; each valid index will have its abstract type updated.,"private void putAbstractTypes(final int start,final int end){
for(int i=start;i<=end;i++){
final int elt=elements[i];
if(elt!=0){
putAbstractType(elt);
}
}
}",1,CodeLlama-7b-Instruct-hf
6367670a1a6d9265ec0179d8,write,"@Override public void write(final byte[] b) throws IOException {
  if (this.encoding == null) {
    this.writer.write(new String(b));
  }
 else {
    this.writer.write(new String(b,this.encoding));
  }
}
","/** 
 * @see OutputStream#write(byte[]) 
 */
",Write the byte array b to the buffer based on the encoding.,"Writes byte data to a writer, optionally using a specified encoding.",Converts byte array to a String and writes to a writer. Uses default encoding if no encoding is specified.,@throws IOException: If an I/O error occurs during writing.,"byte[] data -> writes ""data"" using default encoding
   byte[] data, ""UTF-8"" -> writes ""data"" using UTF-8 encoding",Requires a writer and a non-null byte array; outputs a String representation of the byte array to the writer.,"@Override public void write(final byte[] b) throws IOException {
if (b == null) {
        throw new NullPointerException();
    }
    write(b, 0, b.length);
}",0,gpt-4-turbo
6367670a1a6d9265ec0179d8,write,"@Override public void write(final byte[] b) throws IOException {
  if (this.encoding == null) {
    this.writer.write(new String(b));
  }
 else {
    this.writer.write(new String(b,this.encoding));
  }
}
","/** 
 * @see OutputStream#write(byte[]) 
 */
",Write the byte array b to the buffer based on the encoding.,"Writes byte data to a writer, optionally using a specified encoding.",Converts byte array to a String and writes to a writer. Uses default encoding if no encoding is specified.,@throws IOException: If an I/O error occurs during writing.,"byte[] data -> writes ""data"" using default encoding
   byte[] data, ""UTF-8"" -> writes ""data"" using UTF-8 encoding",Requires a writer and a non-null byte array; outputs a String representation of the byte array to the writer.,"@Override public void write(final byte[] b) throws IOException {
for (byte aB : b) {
out.write(aB);
}
}",1,CodeLlama-7b-Instruct-hf
636767021a6d9265ec0178bf,convertToType,"@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {
  String string=value.toString();
  if (string.length() == 0) {
    return BeanUtils.getDefaultValue(type);
  }
 else {
    return string.charAt(0);
  }
}
","/** 
 * <p>Convert the input object into a java.lang.Character.</p>
 * @param type Data type to which this value should be converted.
 * @param value The input value to be converted.
 * @return The converted value.
 * @throws Exception if conversion cannot be performed successfully
 * @since 1.8.0
 */
","If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.",Converts an object to its default type or a character.,"Converts a non-empty object to its first character, otherwise returns the default type value.","@param type Class<?>: Class type to convert the object to.
   @param value Object: Object to be converted.
   @return Object: The converted default value or first character.
   @throws Exception: If conversion fails.",""""" -> <default type value> (Empty string returns default type value)
""abc"" -> 'a' (Returns first character of non-empty string)
null -> <default type value> (Null treated as empty)",Input object should be convertible to String; ensures a default or first character output.,"@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {
  String string=value.toString();
  if (string.length() == 0) {
    return BeanUtils.getDefaultValue(type);
  }
 else {
    return string.charAt(0);
  }
}
",0,reference
636767021a6d9265ec0178bf,convertToType,"@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {
  String string=value.toString();
  if (string.length() == 0) {
    return BeanUtils.getDefaultValue(type);
  }
 else {
    return string.charAt(0);
  }
}
","/** 
 * <p>Convert the input object into a java.lang.Character.</p>
 * @param type Data type to which this value should be converted.
 * @param value The input value to be converted.
 * @return The converted value.
 * @throws Exception if conversion cannot be performed successfully
 * @since 1.8.0
 */
","If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.",Converts an object to its default type or a character.,"Converts a non-empty object to its first character, otherwise returns the default type value.","@param type Class<?>: Class type to convert the object to.
   @param value Object: Object to be converted.
   @return Object: The converted default value or first character.
   @throws Exception: If conversion fails.",""""" -> <default type value> (Empty string returns default type value)
""abc"" -> 'a' (Returns first character of non-empty string)
null -> <default type value> (Null treated as empty)",Input object should be convertible to String; ensures a default or first character output.,"@Override protected Object convertToType(final Class<?> type, final Object value) throws Exception {
    if (value == null || ((String) value).length() == 0) {
        return getDefaultForType(type);
    } else {
        String strValue = (String) value;
        return convertCharToType(type, strValue.charAt(0));
    }
}",1,Qwen2.5-Coder-7B-Instruct
6367670b1a6d9265ec017a0f,containsAnyIgnoreCase,"public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){
  if (StringUtils.isEmpty(str) || searchStrArray == null || searchStrArray.isEmpty()) {
    return false;
  }
  for (  String item : searchStrArray) {
    if (containsIgnoreCase(str,item)) {
      return true;
    }
  }
  return false;
}
","/** 
 * Case in-sensitive Checks if the String contains any character in the given set of string. 
 */
","Check whether str contains elements in searchStrArray. If yes, true is returned. If no, false is returned.","Checks if string contains any of the search strings, ignoring case.","Determines if any string in a list appears in a given string, case-insensitively. Returns true if any match is found.","@param str String: The string to search within
@param searchStrArray List<String>: The list of strings to search for
@return boolean: True if any search string is found","""hello world"", [""Hello"", ""world""] -> true (matches ""hello"")
""abc"", [""def"", ""ghi""] -> false (no matches)
""My Test"", [""test"", ""another""] -> true (matches ""Test"")","Str and searchStrArray must be non-null for meaningful results; returns true if any search string is found in str, ignoring case.","public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {
        if (str == null || searchStrArray == null || searchStrArray.isEmpty()) {
            return false;
        }
        
        for (String searchStr : searchStrArray) {
            if (str.equalsIgnoreCase(searchStr)) {
                return true;
            }
        }
        
        return false;
    }",0,Qwen2.5-Coder-7B-Instruct
6367670b1a6d9265ec017a0f,containsAnyIgnoreCase,"public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){
  if (StringUtils.isEmpty(str) || searchStrArray == null || searchStrArray.isEmpty()) {
    return false;
  }
  for (  String item : searchStrArray) {
    if (containsIgnoreCase(str,item)) {
      return true;
    }
  }
  return false;
}
","/** 
 * Case in-sensitive Checks if the String contains any character in the given set of string. 
 */
","Check whether str contains elements in searchStrArray. If yes, true is returned. If no, false is returned.","Checks if string contains any of the search strings, ignoring case.","Determines if any string in a list appears in a given string, case-insensitively. Returns true if any match is found.","@param str String: The string to search within
@param searchStrArray List<String>: The list of strings to search for
@return boolean: True if any search string is found","""hello world"", [""Hello"", ""world""] -> true (matches ""hello"")
""abc"", [""def"", ""ghi""] -> false (no matches)
""My Test"", [""test"", ""another""] -> true (matches ""Test"")","Str and searchStrArray must be non-null for meaningful results; returns true if any search string is found in str, ignoring case.","public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){
    for(String searchStr : searchStrArray){
        if(str.containsIgnoreCase(searchStr)){
            return true;
        }
    }
    return false;
}",1,CodeLlama-7b-Instruct-hf
636766a81a6d9265ec01758e,nextPrime,"public static int nextPrime(int desiredCapacity){
  if (desiredCapacity >= largestPrime) {
    return largestPrime;
  }
  int i=Arrays.binarySearch(primeCapacities,desiredCapacity);
  if (i < 0) {
    i=-i - 1;
  }
  return primeCapacities[i];
}
","/** 
 * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code> (within 11% if <code>desiredCapacity &gt;= 1000</code>).
 * @param desiredCapacity the capacity desired by the user.
 * @return the capacity which should be used for a hashtable.
 */
",Returns the element at the location specified by desiredCapacity in primeCapacities.,Finds the smallest prime greater than or equal to a given number.,"If the desired capacity is larger than or equal to the largest known prime, it returns the largest prime. Otherwise, it returns the next prime from a pre-sorted array.","@param desiredCapacity int: capacity for which to find the next prime.
   @return int: the next prime capacity.","10 -> 11 (10 < 11, next prime)
17 -> 17 (exact match)
100 -> 101 (next prime after 100)",Input is a non-negative integer; output is the smallest prime greater than or equal to the input.,"public static int nextPrime(int desiredCapacity){
  if (desiredCapacity >= largestPrime) {
    return largestPrime;
  }
  int i=Arrays.binarySearch(primeCapacities,desiredCapacity);
  if (i < 0) {
    i=-i - 1;
  }
  return primeCapacities[i];
}
",0,reference
636766a81a6d9265ec01758e,nextPrime,"public static int nextPrime(int desiredCapacity){
  if (desiredCapacity >= largestPrime) {
    return largestPrime;
  }
  int i=Arrays.binarySearch(primeCapacities,desiredCapacity);
  if (i < 0) {
    i=-i - 1;
  }
  return primeCapacities[i];
}
","/** 
 * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code> (within 11% if <code>desiredCapacity &gt;= 1000</code>).
 * @param desiredCapacity the capacity desired by the user.
 * @return the capacity which should be used for a hashtable.
 */
",Returns the element at the location specified by desiredCapacity in primeCapacities.,Finds the smallest prime greater than or equal to a given number.,"If the desired capacity is larger than or equal to the largest known prime, it returns the largest prime. Otherwise, it returns the next prime from a pre-sorted array.","@param desiredCapacity int: capacity for which to find the next prime.
   @return int: the next prime capacity.","10 -> 11 (10 < 11, next prime)
17 -> 17 (exact match)
100 -> 101 (next prime after 100)",Input is a non-negative integer; output is the smallest prime greater than or equal to the input.,"public static int nextPrime(int desiredCapacity){
    int primeCapacity = 1;
    while (primeCapacity <= desiredCapacity)
        primeCapacity += 1;
    if (primeCapacity == desiredCapacity)
        return primeCapacity;
    for (int i = 2*primeCapacity; i < primeCapacity; i++)
        if (isPrime(i))
            return i;
    throw new NoSuchElementException(""Prime does not exist after "" +
            desiredCapacity + "" elements"");
}",1,CodeLlama-7b-Instruct-hf
6367670a1a6d9265ec0179cf,toChar,"public static char toChar(final Character ch,final char defaultValue){
  if (ch == null) {
    return defaultValue;
  }
  return ch.charValue();
}
","/** 
 * <p>Converts the Character to a char handling <code>null</code>.</p> <pre> CharUtils.toChar(null, 'X') = 'X' CharUtils.toChar(' ', 'X')  = ' ' CharUtils.toChar('A', 'X')  = 'A' </pre>
 * @param ch  the character to convert
 * @param defaultValue  the value to use if the  Character is null
 * @return the char value of the Character or the default if null
 */
","Obtains the character value of ch. If ch is null, defaultValue is returned.",Converts a nullable Character to a char using a default if null.,Returns the char value of a Character object or a specified default value if the Character is null.,"@param ch Character: Nullable Character object
   @param defaultValue char: Default character if ch is null
   @return char: Char value or default if null","'A', 'X' -> 'A' (returns char value of Character)
null, 'X' -> 'X' (returns default value when null)","Input Character may be null, output is always a non-null char.","public static char toChar(final Character ch,final char defaultValue){
if (ch == null) return defaultValue;
return ch.charValue();
}",0,starcoder2-7b
6367670a1a6d9265ec0179cf,toChar,"public static char toChar(final Character ch,final char defaultValue){
  if (ch == null) {
    return defaultValue;
  }
  return ch.charValue();
}
","/** 
 * <p>Converts the Character to a char handling <code>null</code>.</p> <pre> CharUtils.toChar(null, 'X') = 'X' CharUtils.toChar(' ', 'X')  = ' ' CharUtils.toChar('A', 'X')  = 'A' </pre>
 * @param ch  the character to convert
 * @param defaultValue  the value to use if the  Character is null
 * @return the char value of the Character or the default if null
 */
","Obtains the character value of ch. If ch is null, defaultValue is returned.",Converts a nullable Character to a char using a default if null.,Returns the char value of a Character object or a specified default value if the Character is null.,"@param ch Character: Nullable Character object
   @param defaultValue char: Default character if ch is null
   @return char: Char value or default if null","'A', 'X' -> 'A' (returns char value of Character)
null, 'X' -> 'X' (returns default value when null)","Input Character may be null, output is always a non-null char.","public static char toChar(final Character ch, final char defaultValue){
  return ch.charValue();
}",1,manual_injection
6367676b1a6d9265ec0181e2,findFirstMatch,"public static Object findFirstMatch(Collection source,Collection candidates){
  if (isEmpty(source) || isEmpty(candidates)) {
    return null;
  }
  for (  Object candidate : candidates) {
    if (source.contains(candidate)) {
      return candidate;
    }
  }
  return null;
}
","/** 
 * Return the first element in '<code>candidates</code>' that is contained in '<code>source</code>'. If no element in '<code>candidates</code>' is present in '<code>source</code>' returns <code>null</code>. Iteration order is {@link Collection} implementation specific.
 * @param source the source Collection
 * @param candidates the candidates to search for
 * @return the first present object, or <code>null</code> if not found
 */
",Returns the first element in candidates that matches the source.,Returns the first matching element from two collections.,It finds and returns the first object in the 'candidates' collection that is also present in the 'source' collection.,"@param source Collection: Collection to check against.
   @param candidates Collection: Collection to find matches from.
   @return Object: The first matching element or null if no match.","[1,2,3], [3,4,5] -> 3 (First match found in both)
[""a"",""b""], [""c"",""d""] -> null (No matches present)
[null], [null] -> null (null considered a non-match)","Collections are non-null, may contain nulls; function returns null if either collection is empty or no matches are found.","public static Object findFirstMatch(Collection source, Collection candidates) {
    if (source == null || candidates == null) {
        return null;
    }

    for (Object candidate : candidates) {
        if (source.contains(candidate)) {
            return candidate;
        }
    }

    return null;
}",0,Qwen2.5-Coder-7B-Instruct
6367676b1a6d9265ec0181e2,findFirstMatch,"public static Object findFirstMatch(Collection source,Collection candidates){
  if (isEmpty(source) || isEmpty(candidates)) {
    return null;
  }
  for (  Object candidate : candidates) {
    if (source.contains(candidate)) {
      return candidate;
    }
  }
  return null;
}
","/** 
 * Return the first element in '<code>candidates</code>' that is contained in '<code>source</code>'. If no element in '<code>candidates</code>' is present in '<code>source</code>' returns <code>null</code>. Iteration order is {@link Collection} implementation specific.
 * @param source the source Collection
 * @param candidates the candidates to search for
 * @return the first present object, or <code>null</code> if not found
 */
",Returns the first element in candidates that matches the source.,Returns the first matching element from two collections.,It finds and returns the first object in the 'candidates' collection that is also present in the 'source' collection.,"@param source Collection: Collection to check against.
   @param candidates Collection: Collection to find matches from.
   @return Object: The first matching element or null if no match.","[1,2,3], [3,4,5] -> 3 (First match found in both)
[""a"",""b""], [""c"",""d""] -> null (No matches present)
[null], [null] -> null (null considered a non-match)","Collections are non-null, may contain nulls; function returns null if either collection is empty or no matches are found.","public static Object findFirstMatch(Collection source,Collection candidates){
//Both arguments can't be null at the same time.
if(source == null && candidates == null){
throw new IllegalArgumentException(""The source and the candidates should not be null at the same time"");
}
//Both arguments cannot be empty
if(source.isEmpty() && candidates.isEmpty()){
throw new IllegalArgumentException(""The source and the candidates should not be empty at the same time"");
}
//Search for matches
for(Object element: candidates){
if(source.contains(element)){
return element;
}
}
return null;
}",1,CodeLlama-7b-Instruct-hf
6367676b1a6d9265ec0181ee,trimTrailingWhitespace,"public static String trimTrailingWhitespace(String str){
  if (!hasLength(str)) {
    return str;
  }
  StringBuilder sb=new StringBuilder(str);
  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {
    sb.deleteCharAt(sb.length() - 1);
  }
  return sb.toString();
}
","/** 
 * Trim trailing whitespace from the given String.
 * @param str the String to check
 * @return the trimmed String
 * @see java.lang.Character#isWhitespace
 */
",Trim the end space of the str.,Trims trailing whitespace from a string.,The function iteratively removes whitespace characters from the end of a given string until no whitespace remains.,@return String: The input string without trailing whitespace.,"""hello "" -> ""hello"" (removes trailing space)
"" world\t"" -> "" world"" (removes trailing tab)
""example"" -> ""example"" (no change)","Input string can be null, resulting string will have no trailing whitespace.","public static String trimTrailingWhitespace(String str) {
    if (str == null) {
        return null;
    }
    int length = str.length();
    int lastNonWhitespaceIndex = length - 1;
    while (lastNonWhitespaceIndex >= 0 && Character.isWhitespace(str.charAt(lastNonWhitespaceIndex))) {
        lastNonWhitespaceIndex--;
    }
    return str.substring(0, lastNonWhitespaceIndex + 1);
}",0,Phi-3-mini-4k-instruct
6367676b1a6d9265ec0181ee,trimTrailingWhitespace,"public static String trimTrailingWhitespace(String str){
  if (!hasLength(str)) {
    return str;
  }
  StringBuilder sb=new StringBuilder(str);
  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {
    sb.deleteCharAt(sb.length() - 1);
  }
  return sb.toString();
}
","/** 
 * Trim trailing whitespace from the given String.
 * @param str the String to check
 * @return the trimmed String
 * @see java.lang.Character#isWhitespace
 */
",Trim the end space of the str.,Trims trailing whitespace from a string.,The function iteratively removes whitespace characters from the end of a given string until no whitespace remains.,@return String: The input string without trailing whitespace.,"""hello "" -> ""hello"" (removes trailing space)
"" world\t"" -> "" world"" (removes trailing tab)
""example"" -> ""example"" (no change)","Input string can be null, resulting string will have no trailing whitespace.","public static String trimTrailingWhitespace(String str){
    int index = str.length();
    while (index > 0){
        index = str.length() - 1;
        if (str.charAt(index) == ' '){
            str = str.substring(0, index);
        }
        else{
            break;
        }
    }
    return str;
}",1,CodeLlama-7b-Instruct-hf
636767dc1a6d9265ec0186cb,init,"public void init(){
  File dist=new File(analyzeResultDist);
  if (!dist.exists()) {
    dist.mkdirs();
    return;
  }
  if (dist.isFile()) {
    throw new IllegalArgumentException(analyzeResultDist + "" must be a directory"");
  }
}
","/** 
 * initialize config, such as check dist path
 */
",Initializes a directory.,Initializes a directory for analysis results.,Creates the directory if it doesn't exist; throws an exception if the path is a file.,@throws IllegalArgumentException: If analyzeResultDist is a file instead of a directory.,"nonexistent_path -> creates directory (creates directory)
existent_directory_path -> does nothing (directory exists, no action)
existent_file_path -> throws IllegalArgumentException (path is a file)",Path must either not exist or be a directory; postcondition is a ready-to-use directory or an exception if invalid.,"public void init(){
  File dist=new File(analyzeResultDist);
  if (!dist.exists()) {
    dist.mkdirs();
    return;
  }
  if (dist.isFile()) {
    throw new IllegalArgumentException(analyzeResultDist + "" must be a directory"");
  }
}
",0,reference
636767dc1a6d9265ec0186cb,init,"public void init(){
  File dist=new File(analyzeResultDist);
  if (!dist.exists()) {
    dist.mkdirs();
    return;
  }
  if (dist.isFile()) {
    throw new IllegalArgumentException(analyzeResultDist + "" must be a directory"");
  }
}
","/** 
 * initialize config, such as check dist path
 */
",Initializes a directory.,Initializes a directory for analysis results.,Creates the directory if it doesn't exist; throws an exception if the path is a file.,@throws IllegalArgumentException: If analyzeResultDist is a file instead of a directory.,"nonexistent_path -> creates directory (creates directory)
existent_directory_path -> does nothing (directory exists, no action)
existent_file_path -> throws IllegalArgumentException (path is a file)",Path must either not exist or be a directory; postcondition is a ready-to-use directory or an exception if invalid.,"public void init(String directoryPath) {
        File directory = new File(directoryPath);
        if (!directory.exists()) {
            if (directory.mkdirs()) {
                System.out.println(""Directory created successfully."");
            } else {
                System.out.println(""Failed to create directory."");
            }
        } else {
            System.out.println(""Directory already exists."");
        }
    }",1,Qwen2.5-Coder-7B-Instruct
636767a31a6d9265ec018552,readString,"@Override public String readString() throws IOException {
  final int size=readRawVarint32();
  if (size <= (bufferSize - bufferPos) && size > 0) {
    final String result=STRING.deser(buffer,bufferPos,size);
    bufferPos+=size;
    return result;
  }
 else {
    return STRING.deser(readRawBytes(size));
  }
}
","/** 
 * Read a  {@code string} field value from the stream.
 */
",Read string from a buffer.,Utility to read and deserialize strings from a byte buffer.,"Reads a variable-length integer to get the byte size of a string, then deserializes and returns the string using a buffer or reads raw bytes.","@return String: The deserialized string from the byte buffer.
@throws IOException: If there's an issue reading bytes from the buffer.","input buffer with ""Hello"" -> ""Hello"" (buffer has string size)
input buffer with ""World!"" -> ""World!"" (buffer lacking fixed size)","Requires non-negative size that does not exceed buffer limits, returns a valid deserialized string.","@Override public String readString() throws IOException {
  final int size=readRawVarint32();
  if (size <= (bufferSize - bufferPos) && size > 0) {
    final String result=STRING.deser(buffer,bufferPos,size);
    bufferPos+=size;
    return result;
  }
 else {
    return STRING.deser(readRawBytes(size));
  }
}
",0,reference
636767a31a6d9265ec018552,readString,"@Override public String readString() throws IOException {
  final int size=readRawVarint32();
  if (size <= (bufferSize - bufferPos) && size > 0) {
    final String result=STRING.deser(buffer,bufferPos,size);
    bufferPos+=size;
    return result;
  }
 else {
    return STRING.deser(readRawBytes(size));
  }
}
","/** 
 * Read a  {@code string} field value from the stream.
 */
",Read string from a buffer.,Utility to read and deserialize strings from a byte buffer.,"Reads a variable-length integer to get the byte size of a string, then deserializes and returns the string using a buffer or reads raw bytes.","@return String: The deserialized string from the byte buffer.
@throws IOException: If there's an issue reading bytes from the buffer.","input buffer with ""Hello"" -> ""Hello"" (buffer has string size)
input buffer with ""World!"" -> ""World!"" (buffer lacking fixed size)","Requires non-negative size that does not exceed buffer limits, returns a valid deserialized string.","@Override public String readString() throws IOException {
    String result = """";
    int ch;
    while ((ch = inputStream.read()) != -1) {
        result += (char) ch;
    }
    return result;
}",1,Phi-3-mini-4k-instruct
636767a61a6d9265ec0185b7,digitValue,"private static int digitValue(final char c){
  if ('0' <= c && c <= '9') {
    return c - '0';
  }
 else   if ('a' <= c && c <= 'z') {
    return c - 'a' + 10;
  }
 else {
    return c - 'A' + 10;
  }
}
","/** 
 * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()} but we don't accept non-ASCII digits.
 */
",Obtains the number corresponding to the character c.,Converts a char to its numeric value.,"The function converts a digit or letter to a numeric value; digits '0'-'9' map to 0-9, lowercase 'a'-'z' and uppercase 'A'-'Z' map to 10-35.","@param c char: The character to convert
   @return int: The numeric value of the character","'3' -> 3 (digit '3' to its numeric value)
'b' -> 11 (lowercase 'b' to its numeric value)
'G' -> 16 (uppercase 'G' to its numeric value)",Input is a single alphanumeric character; output is its corresponding numeric value.,"private static int digitValue(final char c){
  if ('0' <= c && c <= '9') {
    return c - '0';
  }
 else   if ('a' <= c && c <= 'z') {
    return c - 'a' + 10;
  }
 else {
    return c - 'A' + 10;
  }
}
",0,reference
636767a61a6d9265ec0185b7,digitValue,"private static int digitValue(final char c){
  if ('0' <= c && c <= '9') {
    return c - '0';
  }
 else   if ('a' <= c && c <= 'z') {
    return c - 'a' + 10;
  }
 else {
    return c - 'A' + 10;
  }
}
","/** 
 * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()} but we don't accept non-ASCII digits.
 */
",Obtains the number corresponding to the character c.,Converts a char to its numeric value.,"The function converts a digit or letter to a numeric value; digits '0'-'9' map to 0-9, lowercase 'a'-'z' and uppercase 'A'-'Z' map to 10-35.","@param c char: The character to convert
   @return int: The numeric value of the character","'3' -> 3 (digit '3' to its numeric value)
'b' -> 11 (lowercase 'b' to its numeric value)
'G' -> 16 (uppercase 'G' to its numeric value)",Input is a single alphanumeric character; output is its corresponding numeric value.,"private static int digitValue(final char c){
    switch (Character.toLowerCase(c)){
        case 'a':
        case 'e':
        case 'i':
        case 'o':
        case 'u':
            return 1;
        case 'b':
        case 'f':
        case 'p':
        case 'v':
            return 2;
        case 'c':
        case 'g':
        case 'q':
        case 'x':
            return 3;
        case 'd':
        case 'h':
        case 'k':
        case 'y':
            return 4;
        case 'j':
        case 'm':
        case 'z':
            return 5;
        case 'l':
            return 6;
        case 'n':
            return 7;
        case 'r':
            return 8;
        default:
            return 0;
    }
}",1,CodeLlama-7b-Instruct-hf
636767e01a6d9265ec018755,buildContent,"private Map<String,Object> buildContent(JsonObject jsonObject){
  Map<String,Object> content=new HashMap<>();
  content.put(""msg_type"",jsonObject.get(""msg_type"").getAsString());
  if (jsonObject.get(""ats"") != null) {
    String ats=jsonObject.get(""ats"").getAsString();
    String text=jsonObject.get(""content"").getAsJsonObject().get(""text"").getAsString();
    List<String> collect=Arrays.stream(ats.split("","")).map(String::trim).collect(Collectors.toList());
    for (    String userId : collect) {
      text+=""<at user_id=\"""" + userId + ""\""></at>"";
    }
    jsonObject.get(""content"").getAsJsonObject().addProperty(""text"",text);
  }
  content.put(""content"",jsonObject.get(""content"").getAsJsonObject());
  return content;
}
","/** 
 * build content,if it has ats someone set the ats
 */
","Put the ""content"" from the  jsonObject to the content.",Constructs a content map from a JSON object.,"The function extracts ""msg_type"" and a modified ""content"" from a JsonObject, adding <at> tags for user IDs found in the ""ats"" field.","@param jsonObject JsonObject: The input JSON object containing the required fields.
   @return Map<String,Object>: A map with keys ""msg_type"" and ""content"".","{""msg_type"":""text"",""ats"":""1,2,3"",""content"":{""text"":""Hello""}} -> {""msg_type"":""text"",""content"":{""text"":""Hello<at user_id=\""1\""></at><at user_id=\""2\""></at><at user_id=\""3\""></at>""}}
   {""msg_type"":""text"",""ats"":null,""content"":{""text"":""Hello""}} -> {""msg_type"":""text"",""content"":{""text"":""Hello""}}
   {""msg_type"":""image"",""content"":{""url"":""image_url""}} -> {""msg_type"":""image"",""content"":{""url"":""image_url""}}","Assumes valid JsonObject input and modifies the ""content"" field with user ID mentions if ""ats"" is present.","private Map<String,Object> buildContent(JsonObject jsonObject){
  Map<String,Object> content=new HashMap<>();
  content.put(""msg_type"",jsonObject.get(""msg_type"").getAsString());
  if (jsonObject.get(""ats"") != null) {
    String ats=jsonObject.get(""ats"").getAsString();
    String text=jsonObject.get(""content"").getAsJsonObject().get(""text"").getAsString();
    List<String> collect=Arrays.stream(ats.split("","")).map(String::trim).collect(Collectors.toList());
    for (    String userId : collect) {
      text+=""<at user_id=\"""" + userId + ""\""></at>"";
    }
    jsonObject.get(""content"").getAsJsonObject().addProperty(""text"",text);
  }
  content.put(""content"",jsonObject.get(""content"").getAsJsonObject());
  return content;
}
",0,reference
636767e01a6d9265ec018755,buildContent,"private Map<String,Object> buildContent(JsonObject jsonObject){
  Map<String,Object> content=new HashMap<>();
  content.put(""msg_type"",jsonObject.get(""msg_type"").getAsString());
  if (jsonObject.get(""ats"") != null) {
    String ats=jsonObject.get(""ats"").getAsString();
    String text=jsonObject.get(""content"").getAsJsonObject().get(""text"").getAsString();
    List<String> collect=Arrays.stream(ats.split("","")).map(String::trim).collect(Collectors.toList());
    for (    String userId : collect) {
      text+=""<at user_id=\"""" + userId + ""\""></at>"";
    }
    jsonObject.get(""content"").getAsJsonObject().addProperty(""text"",text);
  }
  content.put(""content"",jsonObject.get(""content"").getAsJsonObject());
  return content;
}
","/** 
 * build content,if it has ats someone set the ats
 */
","Put the ""content"" from the  jsonObject to the content.",Constructs a content map from a JSON object.,"The function extracts ""msg_type"" and a modified ""content"" from a JsonObject, adding <at> tags for user IDs found in the ""ats"" field.","@param jsonObject JsonObject: The input JSON object containing the required fields.
   @return Map<String,Object>: A map with keys ""msg_type"" and ""content"".","{""msg_type"":""text"",""ats"":""1,2,3"",""content"":{""text"":""Hello""}} -> {""msg_type"":""text"",""content"":{""text"":""Hello<at user_id=\""1\""></at><at user_id=\""2\""></at><at user_id=\""3\""></at>""}}
   {""msg_type"":""text"",""ats"":null,""content"":{""text"":""Hello""}} -> {""msg_type"":""text"",""content"":{""text"":""Hello""}}
   {""msg_type"":""image"",""content"":{""url"":""image_url""}} -> {""msg_type"":""image"",""content"":{""url"":""image_url""}}","Assumes valid JsonObject input and modifies the ""content"" field with user ID mentions if ""ats"" is present.","private Map<String, Object> buildContent(JsonObject jsonObject) {
    Map<String, Object> content = new HashMap<>();

    for (String key : jsonObject.keySet()) {
        content.put(key, jsonObject.get(key));
    }

    return content;
}",1,deepseek-coder-6.7b-instruct
636767a21a6d9265ec018517,toByteArray,"public final byte[] toByteArray(){
  LinkedBuffer node=head;
  int offset=0, len;
  final byte[] buf=new byte[size];
  do {
    if ((len=node.offset - node.start) > 0) {
      System.arraycopy(node.buffer,node.start,buf,offset,len);
      offset+=len;
    }
  }
 while ((node=node.next) != null);
  return buf;
}
","/** 
 * Returns a single byte array containg all the contents written to the buffer(s).
 */
",Copy bytes from LinkedBuffer and return.,Converts linked buffers to a single byte array.,This function copies data from a sequence of linked buffers into a new byte array and returns it.,@return byte[]: A byte array containing the concatenated data from all linked buffers.,"LinkedBuffer with data [1, 2] and [3, 4] -> [1, 2, 3, 4] (Concatenated output)
Single LinkedBuffer with data [5, 6] -> [5, 6] (Direct copy)
Empty LinkedBuffer sequence -> [] (Empty array)",Linked buffers are non-null; returns a contiguous byte array representing all data.,"public final byte[] toByteArray(){
  LinkedBuffer node=head;
  int offset=0, len;
  final byte[] buf=new byte[size];
  do {
    if ((len=node.offset - node.start) > 0) {
      System.arraycopy(node.buffer,node.start,buf,offset,len);
      offset+=len;
    }
  }
 while ((node=node.next) != null);
  return buf;
}
",0,reference
636767a21a6d9265ec018517,toByteArray,"public final byte[] toByteArray(){
  LinkedBuffer node=head;
  int offset=0, len;
  final byte[] buf=new byte[size];
  do {
    if ((len=node.offset - node.start) > 0) {
      System.arraycopy(node.buffer,node.start,buf,offset,len);
      offset+=len;
    }
  }
 while ((node=node.next) != null);
  return buf;
}
","/** 
 * Returns a single byte array containg all the contents written to the buffer(s).
 */
",Copy bytes from LinkedBuffer and return.,Converts linked buffers to a single byte array.,This function copies data from a sequence of linked buffers into a new byte array and returns it.,@return byte[]: A byte array containing the concatenated data from all linked buffers.,"LinkedBuffer with data [1, 2] and [3, 4] -> [1, 2, 3, 4] (Concatenated output)
Single LinkedBuffer with data [5, 6] -> [5, 6] (Direct copy)
Empty LinkedBuffer sequence -> [] (Empty array)",Linked buffers are non-null; returns a contiguous byte array representing all data.,"public final byte[] toByteArray(){
    if (offset == length) {
        return EMPTY_BYTE_ARRAY;
    }
    byte[] result = new byte[length - offset];
    System.arraycopy(buffer.array(), buffer.offset() + offset, result, 0, result.length);
    return result;
}",1,Qwen2.5-Coder-7B-Instruct
6367667d1a6d9265ec017401,unescapeJava,"public static String unescapeJava(String str) throws Exception {
  if (str == null) {
    return null;
  }
  StringWriter writer=new StringWriter(str.length());
  unescapeJava(writer,str);
  return writer.toString();
}
","/** 
 * <p>Unescapes any Java literals found in the <code>String</code>. For example, it will turn a sequence of <code>'\'</code> and <code>'n'</code> into a newline character, unless the <code>'\'</code> is preceded by another <code>'\'</code>.</p>
 * @param str the <code>String</code> to unescape, may be null
 * @return a new unescaped <code>String</code>, <code>null</code> if null string input
 */
",Unescapes Java that found in the String.,Convert Java escape sequences in a string to actual characters.,"Transforms escape sequences (like \n, \t) in the input string to their respective characters, writing the result to a StringWriter.","@param str String: input string containing Java escape sequences
   @return String: string with escape sequences converted
   @throws Exception: if an error occurs during transformation","""Hello\\nWorld"" -> ""Hello\nWorld"" (newline converted)
""Tab\\tSeparated"" -> ""Tab\tSeparated"" (tab converted)
""\\\\"" -> ""\\"" (backslash preserved)",Input string may have escape sequences and the output will have them converted to respective characters.,"public static String unescapeJava(String str) throws Exception {
    if (str == null) {
        return null;
    }

    StringBuilder sb = new StringBuilder();
    boolean hadSlash = false;

    for (int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);

        if (hadSlash) {
            switch (c) {
                case '\\':
                    sb.append('\\');
                    break;
                case 'n':
                    sb.append('\n');
                    break;
                case 't':
                    sb.append('\t');
                    break;
                case 'r':
                    sb.append('\r');
                    break;
                case 'b':
                    sb.append('\b');
                    break;
                case 'f':
                    sb.append('\f');
                    break;
                case '""':
                    sb.append('\""');
                    break;
                case '\'':
                    sb.append('\'');
                    break;
                default:
                    throw new IllegalArgumentException(""Illegal escape sequence: \\"" + c);
            }
            hadSlash = false;
        } else if (c == '\\') {
            hadSlash = true;
        } else {
            sb.append(c);
        }
    }

    if (hadSlash) {
        throw new IllegalArgumentException(""Last character cannot be backslash in unescaped string."");
    }

    return sb.toString();
}",0,gpt-4-turbo
6367667d1a6d9265ec017401,unescapeJava,"public static String unescapeJava(String str) throws Exception {
  if (str == null) {
    return null;
  }
  StringWriter writer=new StringWriter(str.length());
  unescapeJava(writer,str);
  return writer.toString();
}
","/** 
 * <p>Unescapes any Java literals found in the <code>String</code>. For example, it will turn a sequence of <code>'\'</code> and <code>'n'</code> into a newline character, unless the <code>'\'</code> is preceded by another <code>'\'</code>.</p>
 * @param str the <code>String</code> to unescape, may be null
 * @return a new unescaped <code>String</code>, <code>null</code> if null string input
 */
",Unescapes Java that found in the String.,Convert Java escape sequences in a string to actual characters.,"Transforms escape sequences (like \n, \t) in the input string to their respective characters, writing the result to a StringWriter.","@param str String: input string containing Java escape sequences
   @return String: string with escape sequences converted
   @throws Exception: if an error occurs during transformation","""Hello\\nWorld"" -> ""Hello\nWorld"" (newline converted)
""Tab\\tSeparated"" -> ""Tab\tSeparated"" (tab converted)
""\\\\"" -> ""\\"" (backslash preserved)",Input string may have escape sequences and the output will have them converted to respective characters.,"public static void main(String[] args) throws Exception {
        System.out.println(unescapeJava(""Hello\\t\\n\\r\\f\\\\\\'\\\""""));
    }",1,deepseek-coder-6.7b-instruct
636766f01a6d9265ec01763e,javaCharset,"private static String javaCharset(String charset){
  if (charset == null) {
    return null;
  }
  String mappedCharset=MIME2JAVA.get(charset.toLowerCase(Locale.ENGLISH));
  if (mappedCharset == null) {
    return charset;
  }
  return mappedCharset;
}
","/** 
 * Translate a MIME standard character set name into the Java equivalent.
 * @param charset The MIME standard name.
 * @return The Java equivalent for this name.
 */
",Translate a MIME standard charset name into the Java equivalent.,Map MIME charset names to Java charset names.,Transforms a given charset name into its Java equivalent using a predefined mapping; returns the original if no mapping exists.,"@param charset String: The charset name to map.
@return String: The corresponding Java charset name or original.","""UTF-8"" -> ""UTF8"" (maps MIME to Java names)
""ISO-8859-1"" -> ""ISO8859_1"" (maps MIME to Java names)
""custom-charset"" -> ""custom-charset"" (no mapping exists)","Input charset may be null; mapped or original charset is returned, handle case insensitively.","private static String javaCharset(String charset){
  if (charset == null) {
    return null;
  }
  String mappedCharset=MIME2JAVA.get(charset.toLowerCase(Locale.ENGLISH));
  if (mappedCharset == null) {
    return charset;
  }
  return mappedCharset;
}
",0,reference
636766f01a6d9265ec01763e,javaCharset,"private static String javaCharset(String charset){
  if (charset == null) {
    return null;
  }
  String mappedCharset=MIME2JAVA.get(charset.toLowerCase(Locale.ENGLISH));
  if (mappedCharset == null) {
    return charset;
  }
  return mappedCharset;
}
","/** 
 * Translate a MIME standard character set name into the Java equivalent.
 * @param charset The MIME standard name.
 * @return The Java equivalent for this name.
 */
",Translate a MIME standard charset name into the Java equivalent.,Map MIME charset names to Java charset names.,Transforms a given charset name into its Java equivalent using a predefined mapping; returns the original if no mapping exists.,"@param charset String: The charset name to map.
@return String: The corresponding Java charset name or original.","""UTF-8"" -> ""UTF8"" (maps MIME to Java names)
""ISO-8859-1"" -> ""ISO8859_1"" (maps MIME to Java names)
""custom-charset"" -> ""custom-charset"" (no mapping exists)","Input charset may be null; mapped or original charset is returned, handle case insensitively.","private static String javaCharset(String charset){
    if (charset == null) {
        return null;
    }
    String javaCharset = java.nio.charset.Charset.forName(charset).name();
    return javaCharset;
}",1,gpt-4-turbo
6367676a1a6d9265ec0181bf,quoteIfString,"public static Object quoteIfString(Object obj){
  return (obj instanceof String ? quote((String)obj) : obj);
}
","/** 
 * Turn the given Object into a String with single quotes if it is a String; keeping the Object as-is else.
 * @param obj the input Object (e.g. ""myString"")
 * @return the quoted String (e.g. ""'myString'""),or the input object as-is if not a String
 */
",Check whether an obj variable is of the String type.,Returns quoted string if input is a string.,"Checks if the object is a String and returns the quoted string; otherwise, returns the object unchanged.","@param obj Object: Input object to check.
   @return Object: Quoted string if input is a String; original object otherwise.","""hello"" -> ""\""hello\"""" (input is a string)
5 -> 5 (input is an integer)
null -> null (input is null)","Input can be any object type; if it's a String, it gets quoted, otherwise returned as is.","public static Object quoteIfString(Object obj){
if (obj instanceof String) {
return quote(obj.toString());
}
return obj;
}",0,starcoder2-7b
6367676a1a6d9265ec0181bf,quoteIfString,"public static Object quoteIfString(Object obj){
  return (obj instanceof String ? quote((String)obj) : obj);
}
","/** 
 * Turn the given Object into a String with single quotes if it is a String; keeping the Object as-is else.
 * @param obj the input Object (e.g. ""myString"")
 * @return the quoted String (e.g. ""'myString'""),or the input object as-is if not a String
 */
",Check whether an obj variable is of the String type.,Returns quoted string if input is a string.,"Checks if the object is a String and returns the quoted string; otherwise, returns the object unchanged.","@param obj Object: Input object to check.
   @return Object: Quoted string if input is a String; original object otherwise.","""hello"" -> ""\""hello\"""" (input is a string)
5 -> 5 (input is an integer)
null -> null (input is null)","Input can be any object type; if it's a String, it gets quoted, otherwise returned as is.","public static Object quoteIfString(Object obj) {
    if (obj instanceof String) {
        return ""\"""" + obj + ""\"""";
    } else {
        return obj;
    }
}",1,Phi-3-mini-4k-instruct
636767501a6d9265ec017e86,previousNode,"@Override public ListNode<E> previousNode(){
  checkForComodification();
  if (!hasPrevious()) {
    throw new NoSuchElementException();
  }
  last=next=next.prev;
  nextIndex--;
  return last;
}
","/** 
 * {@inheritDoc}
 */
",Returns the previous ListNode.,Returns the previous node in a doubly linked list.,"Checks for concurrent modifications, verifies availability of a previous node, then updates and returns the previous node.","@return ListNode<E>: The previous node in the list.
   @throws NoSuchElementException: If no previous node exists.","current node -> previous node (navigates backwards)
start of list -> NoSuchElementException (no previous node)","List must not be concurrently modified, cursor must not be at the list start; post-execution, cursor steps back one node.","@Override public ListNode<E> previousNode(){
  checkForComodification();
  if (!hasPrevious()) {
    throw new NoSuchElementException();
  }
  last=next=next.prev;
  nextIndex--;
  return last;
}
",0,reference
636767501a6d9265ec017e86,previousNode,"@Override public ListNode<E> previousNode(){
  checkForComodification();
  if (!hasPrevious()) {
    throw new NoSuchElementException();
  }
  last=next=next.prev;
  nextIndex--;
  return last;
}
","/** 
 * {@inheritDoc}
 */
",Returns the previous ListNode.,Returns the previous node in a doubly linked list.,"Checks for concurrent modifications, verifies availability of a previous node, then updates and returns the previous node.","@return ListNode<E>: The previous node in the list.
   @throws NoSuchElementException: If no previous node exists.","current node -> previous node (navigates backwards)
start of list -> NoSuchElementException (no previous node)","List must not be concurrently modified, cursor must not be at the list start; post-execution, cursor steps back one node.","@Override public ListNode<E> previousNode() {
    if (previous == null) {
        throw new NoSuchElementException(""No previous node available."");
    }
    return previous;
}",1,Qwen2.5-Coder-7B-Instruct
636766f21a6d9265ec017667,readShort,"public short readShort(final int offset){
  byte[] classBuffer=classFileBuffer;
  return (short)(((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF));
}
","/** 
 * Reads a signed short value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
 * @param offset the start offset of the value to be read in this {@link ClassReader}.
 * @return the read value.
 */
",Read a short value from classFileBuffer,Reads a 16-bit signed integer from a byte array at a specified offset.,This function extracts two bytes from a byte array starting at a given offset and converts them into a short value.,"@param offset int: Index in the byte array to start reading from
   @return short: The 16-bit signed integer value from the byte array","offset=0, classBuffer={0x01, 0x02} -> 258 (reads bytes {0x01, 0x02})
offset=1, classBuffer={0x00, 0x01, 0x02} -> 258 (reads bytes {0x01, 0x02})
offset=0, classBuffer={0xFF, 0xFF} -> -1 (reads bytes {0xFF, 0xFF})",The byte array must have at least two bytes available starting at the offset; converts two bytes to a short integer.,"public short readShort(final int offset){
    return (short) ((classFileBuffer[offset] & 0xFF) << 8 | (classFileBuffer[offset + 1] & 0xFF));
}",0,Qwen2.5-Coder-7B-Instruct
636766f21a6d9265ec017667,readShort,"public short readShort(final int offset){
  byte[] classBuffer=classFileBuffer;
  return (short)(((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF));
}
","/** 
 * Reads a signed short value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
 * @param offset the start offset of the value to be read in this {@link ClassReader}.
 * @return the read value.
 */
",Read a short value from classFileBuffer,Reads a 16-bit signed integer from a byte array at a specified offset.,This function extracts two bytes from a byte array starting at a given offset and converts them into a short value.,"@param offset int: Index in the byte array to start reading from
   @return short: The 16-bit signed integer value from the byte array","offset=0, classBuffer={0x01, 0x02} -> 258 (reads bytes {0x01, 0x02})
offset=1, classBuffer={0x00, 0x01, 0x02} -> 258 (reads bytes {0x01, 0x02})
offset=0, classBuffer={0xFF, 0xFF} -> -1 (reads bytes {0xFF, 0xFF})",The byte array must have at least two bytes available starting at the offset; converts two bytes to a short integer.,"public short readShort(final int offset){
return (short)((classFileBuffer[offset] << 8) + classFileBuffer[offset + 1]);
}",1,starcoder2-7b
636767031a6d9265ec0178ef,copyArrayGrow1,"private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){
  if (array != null) {
    int arrayLength=Array.getLength(array);
    Object newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength + 1);
    System.arraycopy(array,0,newArray,0,arrayLength);
    return newArray;
  }
  return Array.newInstance(newArrayComponentType,1);
}
","/** 
 * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.
 * @param array The array to copy, must not be <code>null</code>.
 * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.
 * @return A new copy of the array of size 1 greater than the input.
 */
",Copy the given array and add a default value at the end.,Adds one element to the end of an array.,Creates a copy of the input array with an extra element added to its end; returns a new array of specified type if input is null.,"@param array Object: The array to copy and grow.
   @param newArrayComponentType Class<?>: The component type for a new array if the input array is null.
   @return Object: The new array with one additional element.","[1, 2, 3], Integer.class -> [1, 2, 3, null] (adds null to int array)
null, Integer.class -> [null] (creates new int array with one null element)
['a', 'b'], Character.class -> ['a', 'b', null] (adds null to char array)","Input is an array or null; returns a new array with one more element, possibly null.","public static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType){
    if(array == null) {
        return Array.newInstance(newArrayComponentType, 1);
    }
    
    int length = Array.getLength(array);
    Object newArray = Array.newInstance(newArrayComponentType, length + 1);

    System.arraycopy(array, 0, newArray, 0, length);
    
    return newArray;
}",0,deepseek-coder-6.7b-instruct
636767031a6d9265ec0178ef,copyArrayGrow1,"private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){
  if (array != null) {
    int arrayLength=Array.getLength(array);
    Object newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength + 1);
    System.arraycopy(array,0,newArray,0,arrayLength);
    return newArray;
  }
  return Array.newInstance(newArrayComponentType,1);
}
","/** 
 * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.
 * @param array The array to copy, must not be <code>null</code>.
 * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.
 * @return A new copy of the array of size 1 greater than the input.
 */
",Copy the given array and add a default value at the end.,Adds one element to the end of an array.,Creates a copy of the input array with an extra element added to its end; returns a new array of specified type if input is null.,"@param array Object: The array to copy and grow.
   @param newArrayComponentType Class<?>: The component type for a new array if the input array is null.
   @return Object: The new array with one additional element.","[1, 2, 3], Integer.class -> [1, 2, 3, null] (adds null to int array)
null, Integer.class -> [null] (creates new int array with one null element)
['a', 'b'], Character.class -> ['a', 'b', null] (adds null to char array)","Input is an array or null; returns a new array with one more element, possibly null.","private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){
return copyArrayGrow(array,newArrayComponentType,1);
}",1,starcoder2-7b
636767611a6d9265ec018116,intersection,"private Set<V> intersection(Set<V> set1,Set<V> set2){
  Set<V> a;
  Set<V> b;
  if (set1.size() <= set2.size()) {
    a=set1;
    b=set2;
  }
 else {
    a=set2;
    b=set1;
  }
  return a.stream().filter(b::contains).collect(Collectors.toSet());
}
","/** 
 * Efficient way to compute the intersection between two sets
 * @param set1 set $1$
 * @param set2 set $2$
 * @return intersection of set $1$ and $2$
 */
",Return the intersection between two sets.,Finds the intersection of two sets.,Returns a set containing elements present in both input sets. Optimizes processing by iterating over the smaller set.,"@param set1 Set<V>: The first set of elements.
   @param set2 Set<V>: The second set of elements.
   @return Set<V>: A set containing the common elements of set1 and set2.","{1, 2, 3}, {3, 4, 5} -> {3} (3 is common)
{a, b}, {b, c, d} -> {b} (b is common)
{}, {x, y} -> {} (no intersection)","Both input sets must be non-null, and the result set will have elements common to both input sets.","private Set<V> intersection(Set<V> set1,Set<V> set2){
        Set<V> result = new HashSet<V>();
        result.addAll(set1);
        result.retainAll(set2);
        return result;
}",0,starcoder2-7b
636767611a6d9265ec018116,intersection,"private Set<V> intersection(Set<V> set1,Set<V> set2){
  Set<V> a;
  Set<V> b;
  if (set1.size() <= set2.size()) {
    a=set1;
    b=set2;
  }
 else {
    a=set2;
    b=set1;
  }
  return a.stream().filter(b::contains).collect(Collectors.toSet());
}
","/** 
 * Efficient way to compute the intersection between two sets
 * @param set1 set $1$
 * @param set2 set $2$
 * @return intersection of set $1$ and $2$
 */
",Return the intersection between two sets.,Finds the intersection of two sets.,Returns a set containing elements present in both input sets. Optimizes processing by iterating over the smaller set.,"@param set1 Set<V>: The first set of elements.
   @param set2 Set<V>: The second set of elements.
   @return Set<V>: A set containing the common elements of set1 and set2.","{1, 2, 3}, {3, 4, 5} -> {3} (3 is common)
{a, b}, {b, c, d} -> {b} (b is common)
{}, {x, y} -> {} (no intersection)","Both input sets must be non-null, and the result set will have elements common to both input sets.","private static <V> Set<V> intersection(Set<V> set1, Set<V> set2) {
    Set<V> intersection = new HashSet<>(set1);
    intersection.retainAll(set2);
    return intersection;
}",1,deepseek-coder-6.7b-instruct
636766f71a6d9265ec017730,toNoNullStringArray,"static String[] toNoNullStringArray(Collection<?> collection){
  if (collection == null) {
    return ArrayUtils.EMPTY_STRING_ARRAY;
  }
  return toNoNullStringArray(collection.toArray());
}
","/** 
 * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element is <code>null</code>.
 * @param collection The collection to convert
 * @return A new array of Strings.
 */
","If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array. ???",Converts a collection to a string array excluding nulls.,"Converts a Collection to a String array, removing null elements, or returns an empty array if the collection is null.",@param collection Collection<?>: The collection to be converted @return String[]: A non-null string array after conversion,"null -> [] (null input returns an empty array)
[""a"", null, ""b""] -> [""a"", ""b""] (removes nulls)
[] -> [] (empty collection returns empty array)",The input collection can be null or contain nulls; the output array contains only non-null strings or is empty.,"public static String[] toNoNullStringArray(Collection<?> collection){
    if (collection == null) {
        return new String[0];
    } else {
        ArrayList<String> stringList = new ArrayList<>();
        for (Object item : collection) {
            if (item != null && item instanceof String) {
                stringList.add((String) item);
            }
        }
        return stringList.toArray(new String[0]);
    }
}",0,Phi-3-mini-4k-instruct
636766f71a6d9265ec017730,toNoNullStringArray,"static String[] toNoNullStringArray(Collection<?> collection){
  if (collection == null) {
    return ArrayUtils.EMPTY_STRING_ARRAY;
  }
  return toNoNullStringArray(collection.toArray());
}
","/** 
 * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element is <code>null</code>.
 * @param collection The collection to convert
 * @return A new array of Strings.
 */
","If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array. ???",Converts a collection to a string array excluding nulls.,"Converts a Collection to a String array, removing null elements, or returns an empty array if the collection is null.",@param collection Collection<?>: The collection to be converted @return String[]: A non-null string array after conversion,"null -> [] (null input returns an empty array)
[""a"", null, ""b""] -> [""a"", ""b""] (removes nulls)
[] -> [] (empty collection returns empty array)",The input collection can be null or contain nulls; the output array contains only non-null strings or is empty.,"public static String[] toNoNullStringArray(Collection<?> collection) {
    if (collection == null) {
        return new String[0];
    }
    Object[] objects = collection.toArray();
    String[] strings = new String[objects.length];
    for (int i = 0; i < objects.length; i++) {
        strings[i] = Objects.toString(objects[i]);
    }
    return strings;
}",1,Qwen2.5-Coder-7B-Instruct
636767081a6d9265ec0179a2,isAllZeros,"private static boolean isAllZeros(String s){
  if (s == null) {
    return true;
  }
  for (int i=s.length() - 1; i >= 0; i--) {
    if (s.charAt(i) != '0') {
      return false;
    }
  }
  return s.length() > 0;
}
","/** 
 * <p>Utility method for  {@link #createNumber(String)}.</p> <p>Returns <code>true</code> if s is <code>null</code>.</p>
 * @param s the String to check
 * @return if it is all zeros or <code>null</code>
 */
",Check whether a character string is all consist of zero. ,Checks if a string consists entirely of zeros.,Returns true if the input string is null or contains only zero characters. Returns false if the string has any non-zero characters.,"@param s String: Input string to check
@return boolean: True if the string is null or all zeros, false otherwise","null -> true (input is null)
""000"" -> true (all characters are zeros)
""100"" -> false (contains a non-zero character)","Input can be null; output is true if input is null or contains only zeros, otherwise false.","private static boolean isAllZeros(String s){
  if (s == null) {
    return true;
  }
  for (int i=s.length() - 1; i >= 0; i--) {
    if (s.charAt(i) != '0') {
      return false;
    }
  }
  return s.length() > 0;
}
",0,reference
636767081a6d9265ec0179a2,isAllZeros,"private static boolean isAllZeros(String s){
  if (s == null) {
    return true;
  }
  for (int i=s.length() - 1; i >= 0; i--) {
    if (s.charAt(i) != '0') {
      return false;
    }
  }
  return s.length() > 0;
}
","/** 
 * <p>Utility method for  {@link #createNumber(String)}.</p> <p>Returns <code>true</code> if s is <code>null</code>.</p>
 * @param s the String to check
 * @return if it is all zeros or <code>null</code>
 */
",Check whether a character string is all consist of zero. ,Checks if a string consists entirely of zeros.,Returns true if the input string is null or contains only zero characters. Returns false if the string has any non-zero characters.,"@param s String: Input string to check
@return boolean: True if the string is null or all zeros, false otherwise","null -> true (input is null)
""000"" -> true (all characters are zeros)
""100"" -> false (contains a non-zero character)","Input can be null; output is true if input is null or contains only zeros, otherwise false.","public static boolean isAllZeros(String s) {
    for (char c : s.toCharArray()) {
        if (c != '0') {
            return false;
        }
    }
    return true;
}",1,Qwen2.5-Coder-7B-Instruct
636767e01a6d9265ec018764,convertProperties,"private JsonObject convertProperties(List<KeyStringValuePair> properties){
  final JsonObject result=new JsonObject();
  for (  KeyStringValuePair kv : properties) {
    result.addProperty(kv.getKey(),kv.getValue());
  }
  return result;
}
","/** 
 * Convert process properties to source data
 */
",Convert process properties to the JsonObject.,Converts a list of key-value pairs to a JsonObject.,The function iterates over a list of KeyStringValuePair objects and adds each key-value pair as a property in a new JsonObject. The resulting JsonObject contains all the key-value pairs from the input list.,"@param properties List<KeyStringValuePair>: List containing key-value pairs to be converted.
   @return JsonObject: JsonObject containing the converted properties.","[{""key"":""name"",""value"":""John""}] -> {""name"":""John""} (single pair conversion)
[{""key"":""age"",""value"":""25""}, {""key"":""country"",""value"":""USA""}] -> {""age"":""25"",""country"":""USA""} (multiple pairs conversion)
[] -> {} (empty list to empty JsonObject)",Properties list should not contain null keys; result JsonObject will have all input key-value pairs.,"private JsonObject convertProperties(List<KeyStringValuePair> properties) {
    JsonObject jsonObject = new JsonObject();

    for (KeyStringValuePair property : properties) {
        jsonObject.addProperty(property.getKey(), property.getValue());
    }

    return jsonObject;
}",0,deepseek-coder-6.7b-instruct
636767e01a6d9265ec018764,convertProperties,"private JsonObject convertProperties(List<KeyStringValuePair> properties){
  final JsonObject result=new JsonObject();
  for (  KeyStringValuePair kv : properties) {
    result.addProperty(kv.getKey(),kv.getValue());
  }
  return result;
}
","/** 
 * Convert process properties to source data
 */
",Convert process properties to the JsonObject.,Converts a list of key-value pairs to a JsonObject.,The function iterates over a list of KeyStringValuePair objects and adds each key-value pair as a property in a new JsonObject. The resulting JsonObject contains all the key-value pairs from the input list.,"@param properties List<KeyStringValuePair>: List containing key-value pairs to be converted.
   @return JsonObject: JsonObject containing the converted properties.","[{""key"":""name"",""value"":""John""}] -> {""name"":""John""} (single pair conversion)
[{""key"":""age"",""value"":""25""}, {""key"":""country"",""value"":""USA""}] -> {""age"":""25"",""country"":""USA""} (multiple pairs conversion)
[] -> {} (empty list to empty JsonObject)",Properties list should not contain null keys; result JsonObject will have all input key-value pairs.,"private JsonObject convertProperties(List<KeyStringValuePair> properties){
	if(properties == null || properties.size() == 0){
		return null;
	}
	JsonObject json = new JsonObject();
	for(KeyStringValuePair prop : properties){
		json.put(prop.getKey(), prop.getValue());
	}
	return json;
}",1,starcoder2-7b
636766ff1a6d9265ec017853,readLabel,"protected Label readLabel(final int bytecodeOffset,final Label[] labels){
  if (labels[bytecodeOffset] == null) {
    labels[bytecodeOffset]=new Label();
  }
  return labels[bytecodeOffset];
}
","/** 
 * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.
 * @param bytecodeOffset a bytecode offset in a method.
 * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.
 * @return a non null Label, which must be equal to labels[bytecodeOffset].
 */
","Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.",,,,,,"protected Label readLabel(final int bytecodeOffset,final Label[] labels){
	Label label = labels[bytecodeOffset];
	if(null == label){
		labels[bytecodeOffset] = label = new Label();
	}
	return label;
}",0,CodeLlama-7b-Instruct-hf
636766ff1a6d9265ec017853,readLabel,"protected Label readLabel(final int bytecodeOffset,final Label[] labels){
  if (labels[bytecodeOffset] == null) {
    labels[bytecodeOffset]=new Label();
  }
  return labels[bytecodeOffset];
}
","/** 
 * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.
 * @param bytecodeOffset a bytecode offset in a method.
 * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.
 * @return a non null Label, which must be equal to labels[bytecodeOffset].
 */
","Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.",,,,,,"protected Label readLabel(final int bytecodeOffset, final Label[] labels) {
    for (Label label : labels) {
        if (label.getOffset() == bytecodeOffset) {
            return label;
        }
    }
    return new Label(bytecodeOffset);
}",1,Phi-3-mini-4k-instruct
6367677d1a6d9265ec0182fd,toBoolean,"public static boolean toBoolean(String value,boolean dEfault){
  if (value == null)   return dEfault;
  String trimmedVal=value.trim();
  if (""true"".equalsIgnoreCase(trimmedVal))   return true;
  if (""false"".equalsIgnoreCase(trimmedVal))   return false;
  return dEfault;
}
","/** 
 * If <code>value</code> is ""true"", then <code>true</code> is returned. If <code>value</code> is ""false"", then <code>true</code> is returned. Otherwise, <code>default</code> is returned. <p>Case of value is unimportant.  
 */
","Check whether a string is true or false after ignore cases and trim the whitespaces at both ends. If so, its boolean value is returned. Otherwise, dEfault is returned.",Converts a string to a boolean or returns a default if null or unrecognized.,"The function checks if a string is ""true"" or ""false"" (case-insensitive) and returns corresponding boolean; if null or unrecognized, it returns a specified default value.","@param value String: Input string to convert.
@param dEfault boolean: Default return value if input is null or unrecognized.
@return boolean: Converted boolean value or the default.","""true"", false -> true (matches ""true"")
""TrUe"", true -> true (case insensitive match)
""no"", false -> false (unrecognized string, returns default)
null, true -> true (null input, returns default)","Input string can be null; returns a boolean true, false, or the default value if unrecognized.","public static boolean toBoolean(String value,boolean dEfault){
    if(value==null){
        return dEfault;
    }
    value=value.trim();
    value=value.toLowerCase();
    if(""true"".equals(value)){
        return true;
    }else if(""false"".equals(value)){
        return false;
    }else{
        return dEfault;
    }
}",0,CodeLlama-7b-Instruct-hf
6367677d1a6d9265ec0182fd,toBoolean,"public static boolean toBoolean(String value,boolean dEfault){
  if (value == null)   return dEfault;
  String trimmedVal=value.trim();
  if (""true"".equalsIgnoreCase(trimmedVal))   return true;
  if (""false"".equalsIgnoreCase(trimmedVal))   return false;
  return dEfault;
}
","/** 
 * If <code>value</code> is ""true"", then <code>true</code> is returned. If <code>value</code> is ""false"", then <code>true</code> is returned. Otherwise, <code>default</code> is returned. <p>Case of value is unimportant.  
 */
","Check whether a string is true or false after ignore cases and trim the whitespaces at both ends. If so, its boolean value is returned. Otherwise, dEfault is returned.",Converts a string to a boolean or returns a default if null or unrecognized.,"The function checks if a string is ""true"" or ""false"" (case-insensitive) and returns corresponding boolean; if null or unrecognized, it returns a specified default value.","@param value String: Input string to convert.
@param dEfault boolean: Default return value if input is null or unrecognized.
@return boolean: Converted boolean value or the default.","""true"", false -> true (matches ""true"")
""TrUe"", true -> true (case insensitive match)
""no"", false -> false (unrecognized string, returns default)
null, true -> true (null input, returns default)","Input string can be null; returns a boolean true, false, or the default value if unrecognized.","public static boolean toBoolean(String value, boolean dEfault) {
    if (value == null || value.trim().isEmpty()) {
        return dEfault;
    }
    String trimmedValue = value.trim();
    return ""true"".equalsIgnoreCase(trimmedValue);
}",1,Qwen2.5-Coder-7B-Instruct
6367676a1a6d9265ec0181cd,trimLeadingWhitespace,"public static String trimLeadingWhitespace(String str){
  if (!hasLength(str)) {
    return str;
  }
  StringBuilder sb=new StringBuilder(str);
  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {
    sb.deleteCharAt(0);
  }
  return sb.toString();
}
","/** 
 * Trim leading whitespace from the given String.
 * @param str the String to check
 * @return the trimmed String
 * @see java.lang.Character#isWhitespace
 */
",Trim the leading whitespaces in a string.,Removals leading whitespace from a string.,"Iterates through a string and removes spaces from the start until no leading space is left, returning the modified string.",@return String: The trimmed string with no leading whitespace.,"""  hello"" -> ""hello"" (leading spaces removed)
""\thello"" -> ""hello"" (leading tab removed)
""hello"" -> ""hello"" (no leading whitespace present)","Input string is non-null, returns string without leading whitespace.","public static String trimLeadingWhitespace(String str){
	if(str == null)
	{
		return null;
	}
	int length = str.length();
	for (int i = 0; i < length; i++) {
		if (Character.isWhitespace(str.charAt(i))) {
			continue;
		} else {
			return str.substring(i);
		}
	}
	return str;
}",0,starcoder2-7b
6367676a1a6d9265ec0181cd,trimLeadingWhitespace,"public static String trimLeadingWhitespace(String str){
  if (!hasLength(str)) {
    return str;
  }
  StringBuilder sb=new StringBuilder(str);
  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {
    sb.deleteCharAt(0);
  }
  return sb.toString();
}
","/** 
 * Trim leading whitespace from the given String.
 * @param str the String to check
 * @return the trimmed String
 * @see java.lang.Character#isWhitespace
 */
",Trim the leading whitespaces in a string.,Removals leading whitespace from a string.,"Iterates through a string and removes spaces from the start until no leading space is left, returning the modified string.",@return String: The trimmed string with no leading whitespace.,"""  hello"" -> ""hello"" (leading spaces removed)
""\thello"" -> ""hello"" (leading tab removed)
""hello"" -> ""hello"" (no leading whitespace present)","Input string is non-null, returns string without leading whitespace.","public static String trimLeadingWhitespace(String str){
    str = str.replaceAll(""^\\s+"", """");
    return str;
}",1,CodeLlama-7b-Instruct-hf
636766fe1a6d9265ec01782a,readUtf,"final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){
  String value=constantUtf8Values[constantPoolEntryIndex];
  if (value != null) {
    return value;
  }
  int cpInfoOffset=cpInfoOffsets[constantPoolEntryIndex];
  return constantUtf8Values[constantPoolEntryIndex]=readUtf(cpInfoOffset + 2,readUnsignedShort(cpInfoOffset),charBuffer);
}
","/** 
 * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}.
 * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pooltable.
 * @param charBuffer the buffer to be used to read the string. This buffer must be sufficientlylarge. It is not automatically resized.
 * @return the String corresponding to the specified CONSTANT_Utf8 entry.
 */
",Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.,Reads a UTF-8 string from a constant pool.,Retrieves or computes a UTF-8 string from a constant pool using its index and stores it for future access.,"@param constantPoolEntryIndex int: Index of the constant pool entry.
@param charBuffer char[]: Buffer used during string reading.
@return String: The UTF-8 string from the constant pool.","0, [] -> ""exampleString"" (returns stored or computed UTF-8 string)
1, ['a','b'] -> ""anotherString"" (returns stored or computed UTF-8 string)",Requires valid index within constant pool; returns a UTF-8 string or null if not found.,"final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){
  String value=constantUtf8Values[constantPoolEntryIndex];
  if (value != null) {
    return value;
  }
  int cpInfoOffset=cpInfoOffsets[constantPoolEntryIndex];
  return constantUtf8Values[constantPoolEntryIndex]=readUtf(cpInfoOffset + 2,readUnsignedShort(cpInfoOffset),charBuffer);
}
",0,reference
636766fe1a6d9265ec01782a,readUtf,"final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){
  String value=constantUtf8Values[constantPoolEntryIndex];
  if (value != null) {
    return value;
  }
  int cpInfoOffset=cpInfoOffsets[constantPoolEntryIndex];
  return constantUtf8Values[constantPoolEntryIndex]=readUtf(cpInfoOffset + 2,readUnsignedShort(cpInfoOffset),charBuffer);
}
","/** 
 * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}.
 * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pooltable.
 * @param charBuffer the buffer to be used to read the string. This buffer must be sufficientlylarge. It is not automatically resized.
 * @return the String corresponding to the specified CONSTANT_Utf8 entry.
 */
",Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.,Reads a UTF-8 string from a constant pool.,Retrieves or computes a UTF-8 string from a constant pool using its index and stores it for future access.,"@param constantPoolEntryIndex int: Index of the constant pool entry.
@param charBuffer char[]: Buffer used during string reading.
@return String: The UTF-8 string from the constant pool.","0, [] -> ""exampleString"" (returns stored or computed UTF-8 string)
1, ['a','b'] -> ""anotherString"" (returns stored or computed UTF-8 string)",Requires valid index within constant pool; returns a UTF-8 string or null if not found.,"final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){
    final DataInputStream dis = new DataInputStream(new ByteArrayInputStream(classFileBuffer,
            constantPoolEntryIndex,
            readAndCheckInt(constantPoolEntryIndex)));
    return readUtf(dis, charBuffer);
}",1,CodeLlama-7b-Instruct-hf
636766851a6d9265ec01751b,decodeHexNibble,"private static char decodeHexNibble(final char c){
  if ('0' <= c && c <= '9') {
    return (char)(c - '0');
  }
 else   if ('a' <= c && c <= 'f') {
    return (char)(c - 'a' + 10);
  }
 else   if ('A' <= c && c <= 'F') {
    return (char)(c - 'A' + 10);
  }
 else {
    return Character.MAX_VALUE;
  }
}
","/** 
 * Helper to decode half of a hexadecimal number from a string.
 * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}.
 * @return The hexadecimal value represented in the ASCII charactergiven, or  {@link Character#MAX_VALUE} if the character is invalid.
 */
",Convert a hexadecimal number to binary and return its character type.,Converts a hex character to its decimal value or returns a max character.,Maps a hexadecimal character to its integer value or returns a max value character if invalid.,@return char: The corresponding decimal value of the hex character or Character.MAX_VALUE if invalid.,"'0' -> 0, 'a' -> 10, 'F' -> 15, 'g' -> Character.MAX_VALUE (not a valid hex)",Input must be a single character; returns a character representing decimal or max value.,"private static char decodeHexNibble(final char c){
    //treats uppercase and lowercase characters
    if (c >= '0' && c <= '9'){
        return (char)(c - '0');
    } else if (c >= 'A' && c <= 'F'){
        return (char)(c - 'A' + 10);
    } else if (c >= 'a' && c <= 'f'){
        return (char)(c - 'a' + 10);
    } else {
        return (char)-1;
    }
}",0,CodeLlama-7b-Instruct-hf
636766851a6d9265ec01751b,decodeHexNibble,"private static char decodeHexNibble(final char c){
  if ('0' <= c && c <= '9') {
    return (char)(c - '0');
  }
 else   if ('a' <= c && c <= 'f') {
    return (char)(c - 'a' + 10);
  }
 else   if ('A' <= c && c <= 'F') {
    return (char)(c - 'A' + 10);
  }
 else {
    return Character.MAX_VALUE;
  }
}
","/** 
 * Helper to decode half of a hexadecimal number from a string.
 * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}.
 * @return The hexadecimal value represented in the ASCII charactergiven, or  {@link Character#MAX_VALUE} if the character is invalid.
 */
",Convert a hexadecimal number to binary and return its character type.,Converts a hex character to its decimal value or returns a max character.,Maps a hexadecimal character to its integer value or returns a max value character if invalid.,@return char: The corresponding decimal value of the hex character or Character.MAX_VALUE if invalid.,"'0' -> 0, 'a' -> 10, 'F' -> 15, 'g' -> Character.MAX_VALUE (not a valid hex)",Input must be a single character; returns a character representing decimal or max value.,"private static char decodeHexNibble(final char c){
if(Character.isDigit(c)){
return (char)(c + '0');
}
else{
return (char)(c + '7');
}
}",1,starcoder2-7b
636766f21a6d9265ec01767d,toString,"public static String toString(Object object){
  return (object == null) ? null : object.toString();
}
","/** 
 * Object to String ,when null object then null else return toString(); 
 */
","Convert object to string  if the object is not null. Otherwise, null is returned.",Converts an object to a string representation.,Returns the string form of an object or null if the object is null.,@return String: A string representation of the object or null.,"null -> null (Object is null)
""Hello"" -> ""Hello"" (String object)
123 -> ""123"" (Integer converted to string)",Input can be any object; output is string or null.,"public static String toString(Object object){
    return (object != null) ? object.toString() : null;
}",0,Qwen2.5-Coder-7B-Instruct
636766f21a6d9265ec01767d,toString,"public static String toString(Object object){
  return (object == null) ? null : object.toString();
}
","/** 
 * Object to String ,when null object then null else return toString(); 
 */
","Convert object to string  if the object is not null. Otherwise, null is returned.",Converts an object to a string representation.,Returns the string form of an object or null if the object is null.,@return String: A string representation of the object or null.,"null -> null (Object is null)
""Hello"" -> ""Hello"" (String object)
123 -> ""123"" (Integer converted to string)",Input can be any object; output is string or null.,"public static String toString(Object object){
    if (object == null) {
        return ""null"";
    }
    return Arrays.toString(object.toString());
}",1,starcoder2-7b
636767581a6d9265ec017fc4,factorial,"public static long factorial(int n){
  long multi=1;
  for (int i=1; i <= n; i++) {
    multi=multi * i;
  }
  return multi;
}
","/** 
 * Calculate the factorial of $n$.
 * @param n the input number
 * @return the factorial
 */
",Calculate the factorial of the given number.,Computes the factorial of a given integer.,The function multiplies all integers from 1 to n to compute the factorial. The result is returned as a long integer.,"@param n int: The integer for which the factorial is calculated.
@return long: The factorial of the input integer.","5 -> 120 (factorial of 5)
1 -> 1 (factorial of 1)
0 -> 1 (factorial of 0)","The input must be a non-negative integer, and the output will be the factorial of the input.","public static long factorial(int n){
    if (n < 0) {
        throw new IllegalArgumentException(""Factorial of a negative number is undefined."");
    }
    long result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}",0,Phi-3-mini-4k-instruct
636767581a6d9265ec017fc4,factorial,"public static long factorial(int n){
  long multi=1;
  for (int i=1; i <= n; i++) {
    multi=multi * i;
  }
  return multi;
}
","/** 
 * Calculate the factorial of $n$.
 * @param n the input number
 * @return the factorial
 */
",Calculate the factorial of the given number.,Computes the factorial of a given integer.,The function multiplies all integers from 1 to n to compute the factorial. The result is returned as a long integer.,"@param n int: The integer for which the factorial is calculated.
@return long: The factorial of the input integer.","5 -> 120 (factorial of 5)
1 -> 1 (factorial of 1)
0 -> 1 (factorial of 0)","The input must be a non-negative integer, and the output will be the factorial of the input.","public static void main(String[] args) {
        System.out.println(factorial(20));
    }",1,deepseek-coder-6.7b-instruct
636767511a6d9265ec017eb6,selectOnOuterFace,"private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){
  OuterFaceCirculator circulator=start.iterator(dir);
  Node current=circulator.next();
  while (current != stop && !predicate.test(current)) {
    current=circulator.next();
  }
  return circulator;
}
","/** 
 * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate} or returns a circulator to the {@code stop} node.
 * @param predicate the condition the desired node should satisfy
 * @param start the node to start the search from
 * @param stop the node to end the search with
 * @param dir the direction to start the traversal in
 * @return a circulator to the node satisfying the {@code predicate} or to the {@code stop} node
 */
",Find a circulator to the node that satisfies the Interface predicate.,Iterates through nodes on an outer face in a specific direction until a condition is met or a stop node is reached.,"Starts from a node and iterates in a given direction using a circulator, stopping when either a predicate is satisfied or the stop node is reached, returning the circulator.","@param predicate Predicate<Node>: Condition to be satisfied.
   @param start Node: Starting node for iteration.
   @param stop Node: Node where iteration stops unconditionally.
   @param dir int: Direction of iteration.
   @return OuterFaceCirculator: Circulator positioned at the found node or stop node.","predicate matches, start, end, 1 -> circulator (predicate matched)
no match, start, end, 1 -> circulator (reached end)
predicate matches, start, end, -1 -> circulator (predicate matched in reverse)",Preconditions include valid nodes and a direction; postconditions guarantee a circulator on the node satisfying the predicate or on the stop node.,"private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){
  OuterFaceCirculator circulator=start.iterator(dir);
  Node current=circulator.next();
  while (current != stop && !predicate.test(current)) {
    current=circulator.next();
  }
  return circulator;
}
",0,reference
636767511a6d9265ec017eb6,selectOnOuterFace,"private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){
  OuterFaceCirculator circulator=start.iterator(dir);
  Node current=circulator.next();
  while (current != stop && !predicate.test(current)) {
    current=circulator.next();
  }
  return circulator;
}
","/** 
 * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate} or returns a circulator to the {@code stop} node.
 * @param predicate the condition the desired node should satisfy
 * @param start the node to start the search from
 * @param stop the node to end the search with
 * @param dir the direction to start the traversal in
 * @return a circulator to the node satisfying the {@code predicate} or to the {@code stop} node
 */
",Find a circulator to the node that satisfies the Interface predicate.,Iterates through nodes on an outer face in a specific direction until a condition is met or a stop node is reached.,"Starts from a node and iterates in a given direction using a circulator, stopping when either a predicate is satisfied or the stop node is reached, returning the circulator.","@param predicate Predicate<Node>: Condition to be satisfied.
   @param start Node: Starting node for iteration.
   @param stop Node: Node where iteration stops unconditionally.
   @param dir int: Direction of iteration.
   @return OuterFaceCirculator: Circulator positioned at the found node or stop node.","predicate matches, start, end, 1 -> circulator (predicate matched)
no match, start, end, 1 -> circulator (reached end)
predicate matches, start, end, -1 -> circulator (predicate matched in reverse)",Preconditions include valid nodes and a direction; postconditions guarantee a circulator on the node satisfying the predicate or on the stop node.,"public OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate, Node start, Node stop, int dir) {
    OuterFaceCirculator circulator = new OuterFaceCirculator(start);
    
    while (true) {
        if (predicate.test(circulator.current())) {
            return circulator;
        }
        
        circulator.move(dir);
        
        // Check if we reached the stop node or went full circle back to start
        if (circulator.current() == stop || circulator.current() == start && dir != 1) {
            throw new NoSuchElementException(""No node satisfying the predicate found."");
        }
    }
}",1,Qwen2.5-Coder-7B-Instruct
636767841a6d9265ec0183e8,add,"public void add(LoggingEvent event){
  ea[last]=event;
  if (++last == maxSize)   last=0;
  if (numElems < maxSize)   numElems++;
 else   if (++first == maxSize)   first=0;
}
","/** 
 * Add an <code>event</code> as the last event in the buffer.
 */
",Add an event as the last event in the buffer.,Add an event to a circular buffer.,"Inserts a LoggingEvent into a circular array buffer, updating pointers for head and tail as needed, and maintaining size constraints.",@param event LoggingEvent: the event to add to the buffer,"input -> 1st event added (circular buffer initially empty)
input -> 11th event wraps around (buffer size 10, overwriting the oldest)
input -> 5th event added without wrapping (buffer not full yet)",Buffer size maximum is maxSize; elements overwrite older ones when full.,"public void add(LoggingEvent event){
  ea[last]=event;
  if (++last == maxSize)   last=0;
  if (numElems < maxSize)   numElems++;
 else   if (++first == maxSize)   first=0;
}
",0,reference
636767841a6d9265ec0183e8,add,"public void add(LoggingEvent event){
  ea[last]=event;
  if (++last == maxSize)   last=0;
  if (numElems < maxSize)   numElems++;
 else   if (++first == maxSize)   first=0;
}
","/** 
 * Add an <code>event</code> as the last event in the buffer.
 */
",Add an event as the last event in the buffer.,Add an event to a circular buffer.,"Inserts a LoggingEvent into a circular array buffer, updating pointers for head and tail as needed, and maintaining size constraints.",@param event LoggingEvent: the event to add to the buffer,"input -> 1st event added (circular buffer initially empty)
input -> 11th event wraps around (buffer size 10, overwriting the oldest)
input -> 5th event added without wrapping (buffer not full yet)",Buffer size maximum is maxSize; elements overwrite older ones when full.,"public void add(LoggingEvent event) {
    eventBuffer.addLast(event);
}",1,Phi-3-mini-4k-instruct
636767a41a6d9265ec01857e,compareSigned,"private static int compareSigned(long a,long b){
  return (a < b) ? -1 : ((a > b) ? 1 : 0);
}
","/** 
 * Compares the two specified  {@code long} values. The sign of the value returned is the same as that of{@code ((Long) a).compareTo(b)}. <p> <b>Note for Java 7 and later:</b> this method should be treated as deprecated; use the equivalent {@link Long#compare} method instead.
 * @param a the first  {@code long} to compare
 * @param b the second  {@code long} to compare
 * @return a negative value if {@code a} is less than {@code b}; a positive value if  {@code a} is greater than{@code b}; or zero if they are equal
 */
",Compare two numbers.,Compares two long integers.,"Determines if one long integer is less than, greater than, or equal to another. Returns -1, 1, or 0 based on comparison.","@param a long: first integer to compare
   @param b long: second integer to compare
   @return int: -1 if a < b, 1 if a > b, 0 if equal","5L, 10L -> -1 (5 is less than 10)
10L, 5L -> 1 (10 is greater than 5)
10L, 10L -> 0 (10 is equal to 10)",Inputs are long integers; outputs an integer indicating comparison result.,"public static int compareSigned(long a, long b) {
    if (a < b) {
        return -1;
    } else if (a > b) {
        return 1;
    } else {
        return 0;
    }
}",0,Qwen2.5-Coder-7B-Instruct
636767a41a6d9265ec01857e,compareSigned,"private static int compareSigned(long a,long b){
  return (a < b) ? -1 : ((a > b) ? 1 : 0);
}
","/** 
 * Compares the two specified  {@code long} values. The sign of the value returned is the same as that of{@code ((Long) a).compareTo(b)}. <p> <b>Note for Java 7 and later:</b> this method should be treated as deprecated; use the equivalent {@link Long#compare} method instead.
 * @param a the first  {@code long} to compare
 * @param b the second  {@code long} to compare
 * @return a negative value if {@code a} is less than {@code b}; a positive value if  {@code a} is greater than{@code b}; or zero if they are equal
 */
",Compare two numbers.,Compares two long integers.,"Determines if one long integer is less than, greater than, or equal to another. Returns -1, 1, or 0 based on comparison.","@param a long: first integer to compare
   @param b long: second integer to compare
   @return int: -1 if a < b, 1 if a > b, 0 if equal","5L, 10L -> -1 (5 is less than 10)
10L, 5L -> 1 (10 is greater than 5)
10L, 10L -> 0 (10 is equal to 10)",Inputs are long integers; outputs an integer indicating comparison result.,"private static int compareSigned(long a,long b){
	if(a<0) return b>=0?-1:(a-b)>>31;
	if(b<0) return (b-a)>>31;
	return (int)((long)a-(long)b);
}",1,CodeLlama-7b-Instruct-hf
636766a91a6d9265ec0175ae,putByteArray,"public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){
  if (length + byteLength > data.length) {
    enlarge(byteLength);
  }
  if (byteArrayValue != null) {
    System.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);
  }
  length+=byteLength;
  return this;
}
","/** 
 * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.
 * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.
 * @param byteOffset     index of the first byte of byteArrayValue that must be copied.
 * @param byteLength     number of bytes of byteArrayValue that must be copied.
 * @return this byte vector.
 */
",Add a byte array into the byte vector.,Appends a specified subarray to a ByteVector.,"It copies a section of a byte array into a ByteVector, enlarging the storage if needed, and updates the length.","@param byteArrayValue byte[]: The source byte array to be copied.
@param byteOffset int: The starting position in the byte array to begin copying.
@param byteLength int: The number of bytes to copy.
@return ByteVector: Returns the updated ByteVector instance.","[1,2,3,4], 1, 2 -> ByteVector (Copies [2,3] to ByteVector)
null, 0, 3 -> ByteVector (Does nothing if source is null)
[1,2,3], 0, 3 -> ByteVector (Copies entire byte array)",byteArrayValue can be null; byteOffset and byteLength must define a valid range within the byte array; the ByteVector is enlarged as needed during appending.,"public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){
  if (length + byteLength > data.length) {
    enlarge(byteLength);
  }
  if (byteArrayValue != null) {
    System.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);
  }
  length+=byteLength;
  return this;
}
",0,reference
636766a91a6d9265ec0175ae,putByteArray,"public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){
  if (length + byteLength > data.length) {
    enlarge(byteLength);
  }
  if (byteArrayValue != null) {
    System.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);
  }
  length+=byteLength;
  return this;
}
","/** 
 * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.
 * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.
 * @param byteOffset     index of the first byte of byteArrayValue that must be copied.
 * @param byteLength     number of bytes of byteArrayValue that must be copied.
 * @return this byte vector.
 */
",Add a byte array into the byte vector.,Appends a specified subarray to a ByteVector.,"It copies a section of a byte array into a ByteVector, enlarging the storage if needed, and updates the length.","@param byteArrayValue byte[]: The source byte array to be copied.
@param byteOffset int: The starting position in the byte array to begin copying.
@param byteLength int: The number of bytes to copy.
@return ByteVector: Returns the updated ByteVector instance.","[1,2,3,4], 1, 2 -> ByteVector (Copies [2,3] to ByteVector)
null, 0, 3 -> ByteVector (Does nothing if source is null)
[1,2,3], 0, 3 -> ByteVector (Copies entire byte array)",byteArrayValue can be null; byteOffset and byteLength must define a valid range within the byte array; the ByteVector is enlarged as needed during appending.,"public ByteVector putByteArray(final byte[] byteArrayValue, final int byteOffset, final int byteLength){
    ByteVector byteVector = new ByteVector();
    for (int i = byteOffset; i < byteOffset + byteLength; i++) {
        byteVector.addElement(byteArrayValue[i]);
    }
    return byteVector;
}",1,deepseek-coder-6.7b-instruct
636766f11a6d9265ec01764f,values,"public Collection<Object> values(){
  ArrayList<Object> answer=new ArrayList<>(readMethods.size());
  for (Iterator<Object> iter=valueIterator(); iter.hasNext(); ) {
    answer.add(iter.next());
  }
  return Collections.unmodifiableList(answer);
}
","/** 
 * Returns the values for the BeanMap.
 * @return values for the BeanMap. The returned collection is not modifiable.
 */
",Return an unmodifiable list that contains all methods in the BeanMap.,Returns an unmodifiable list of object values.,"The function iterates through a collection, collects object values, and returns them as an unmodifiable list.",@return Collection<Object>: A list of object values that cannot be modified.,"[] -> [] (empty collection returns an empty list)
, [1, 2, 3] -> [1, 2, 3] (returns a list with same elements)
, [null, ""text""] -> [null, ""text""] (includes nulls and strings)",The collection must be iterable; output is unmodifiable and reflects the exact content and order of the input collection.,"public static Collection<Object> values(BeanMap beanMap) {
    return Collections.unmodifiableCollection(beanMap.values());
}",0,deepseek-coder-6.7b-instruct
636766f11a6d9265ec01764f,values,"public Collection<Object> values(){
  ArrayList<Object> answer=new ArrayList<>(readMethods.size());
  for (Iterator<Object> iter=valueIterator(); iter.hasNext(); ) {
    answer.add(iter.next());
  }
  return Collections.unmodifiableList(answer);
}
","/** 
 * Returns the values for the BeanMap.
 * @return values for the BeanMap. The returned collection is not modifiable.
 */
",Return an unmodifiable list that contains all methods in the BeanMap.,Returns an unmodifiable list of object values.,"The function iterates through a collection, collects object values, and returns them as an unmodifiable list.",@return Collection<Object>: A list of object values that cannot be modified.,"[] -> [] (empty collection returns an empty list)
, [1, 2, 3] -> [1, 2, 3] (returns a list with same elements)
, [null, ""text""] -> [null, ""text""] (includes nulls and strings)",The collection must be iterable; output is unmodifiable and reflects the exact content and order of the input collection.,"public Collection<Object> values(){
    return getBeanMap().values();
}",1,starcoder2-7b
636766f81a6d9265ec017758,hashCode,"@Override public int hashCode(){
  int hashCode=13 * (sort == INTERNAL ? OBJECT : sort);
  if (sort >= ARRAY) {
    for (int i=valueBegin, end=valueEnd; i < end; i++) {
      hashCode=17 * (hashCode + valueBuffer.charAt(i));
    }
  }
  return hashCode;
}
","/** 
 * Returns a hash code value for this type.
 * @return a hash code value for this type.
 */
",Compute a hash code according to the type.,Computes hash code for an object based on its sort and value buffer.,"Calculates a hash code by first considering a sort-based multiplier, then iterating over a character buffer to further modify the hash code if the sort type is ARRAY or higher.",@return int: The computed hash code for this object.,"sort=INTERNAL, valueBegin=0, valueEnd=3, valueBuffer=""abc"" -> 552 (based on character values)
sort=EXTERNAL, valueBegin=1, valueEnd=4, valueBuffer=""defgh"" -> varies (different character range)
sort=ARRAY, valueBegin=0, valueEnd=2, valueBuffer=""xy"" -> varies (ARRAY sort affects calculation)","Preconditions: sort is a valid integer, valueBuffer is correctly initialized string. Postconditions: Returns an integer hash code for the object.","@Override public int hashCode(){
  int hashCode=13 * (sort == INTERNAL ? OBJECT : sort);
  if (sort >= ARRAY) {
    for (int i=valueBegin, end=valueEnd; i < end; i++) {
      hashCode=17 * (hashCode + valueBuffer.charAt(i));
    }
  }
  return hashCode;
}
",0,reference
636766f81a6d9265ec017758,hashCode,"@Override public int hashCode(){
  int hashCode=13 * (sort == INTERNAL ? OBJECT : sort);
  if (sort >= ARRAY) {
    for (int i=valueBegin, end=valueEnd; i < end; i++) {
      hashCode=17 * (hashCode + valueBuffer.charAt(i));
    }
  }
  return hashCode;
}
","/** 
 * Returns a hash code value for this type.
 * @return a hash code value for this type.
 */
",Compute a hash code according to the type.,Computes hash code for an object based on its sort and value buffer.,"Calculates a hash code by first considering a sort-based multiplier, then iterating over a character buffer to further modify the hash code if the sort type is ARRAY or higher.",@return int: The computed hash code for this object.,"sort=INTERNAL, valueBegin=0, valueEnd=3, valueBuffer=""abc"" -> 552 (based on character values)
sort=EXTERNAL, valueBegin=1, valueEnd=4, valueBuffer=""defgh"" -> varies (different character range)
sort=ARRAY, valueBegin=0, valueEnd=2, valueBuffer=""xy"" -> varies (ARRAY sort affects calculation)","Preconditions: sort is a valid integer, valueBuffer is correctly initialized string. Postconditions: Returns an integer hash code for the object.","@Override public int hashCode(){
return 1;
}",1,CodeLlama-7b-Instruct-hf
6367676c1a6d9265ec01820b,deleteAny,"public static String deleteAny(String inString,String charsToDelete){
  if (!hasLength(inString) || !hasLength(charsToDelete)) {
    return inString;
  }
  StringBuilder sb=new StringBuilder();
  for (int i=0; i < inString.length(); i++) {
    char c=inString.charAt(i);
    if (charsToDelete.indexOf(c) == -1) {
      sb.append(c);
    }
  }
  return sb.toString();
}
","/** 
 * Delete any character in a given String.
 * @param inString the original String
 * @param charsToDelete a set of characters to delete.E.g. ""az\n"" will delete 'a's, 'z's and new lines.
 * @return the resulting String
 */
",Delete characters that exists in the intersection between two character strings of the first character string and return the first character string that is modified.,Remove specified characters from input string.,The function removes all characters in `charsToDelete` from `inString` and returns the result. It does nothing if either string is empty.,"@param inString String: Input string to process
@param charsToDelete String: Characters to remove from the input string
@return String: Resulting string after removals","""hello"", ""l"" -> ""heo"" (removes 'l' from ""hello"")
""abcdef"", ""xz"" -> ""abcdef"" (removes no characters)
""abcabc"", ""abc"" -> """" (removes all 'a', 'b', and 'c')",Input strings are non-null; output retains input order minus deletions.,"public static String deleteAny(String inString, String charsToDelete) {
    StringBuilder sb = new StringBuilder();
    for (char c : inString.toCharArray()) {
        if (!charsToDelete.contains(Character.toString(c))) {
            sb.append(c);
        }
    }
    return sb.toString();
}",0,Phi-3-mini-4k-instruct
6367676c1a6d9265ec01820b,deleteAny,"public static String deleteAny(String inString,String charsToDelete){
  if (!hasLength(inString) || !hasLength(charsToDelete)) {
    return inString;
  }
  StringBuilder sb=new StringBuilder();
  for (int i=0; i < inString.length(); i++) {
    char c=inString.charAt(i);
    if (charsToDelete.indexOf(c) == -1) {
      sb.append(c);
    }
  }
  return sb.toString();
}
","/** 
 * Delete any character in a given String.
 * @param inString the original String
 * @param charsToDelete a set of characters to delete.E.g. ""az\n"" will delete 'a's, 'z's and new lines.
 * @return the resulting String
 */
",Delete characters that exists in the intersection between two character strings of the first character string and return the first character string that is modified.,Remove specified characters from input string.,The function removes all characters in `charsToDelete` from `inString` and returns the result. It does nothing if either string is empty.,"@param inString String: Input string to process
@param charsToDelete String: Characters to remove from the input string
@return String: Resulting string after removals","""hello"", ""l"" -> ""heo"" (removes 'l' from ""hello"")
""abcdef"", ""xz"" -> ""abcdef"" (removes no characters)
""abcabc"", ""abc"" -> """" (removes all 'a', 'b', and 'c')",Input strings are non-null; output retains input order minus deletions.,"public static String deleteAny(String inString,String charsToDelete){
  return deleteAny(inString,0,inString.length(),charsToDelete);
}",1,CodeLlama-7b-Instruct-hf
636766861a6d9265ec01755a,match,"public final MatchResult match(CharSequence uri){
  if (uri == null || uri.length() == 0)   return (regexPattern == null) ? EMPTY_STRING_MATCH_RESULT : null;
 else   if (regexPattern == null)   return null;
  Matcher m=regexPattern.matcher(uri);
  if (!m.matches())   return null;
  return (groupIndexes.length > 0) ? new GroupIndexMatchResult(m) : m;
}
","/** 
 * Match a URI against the pattern.
 * @param uri the uri to match against the template.
 * @return the match result, otherwise null if no match occurs.
 */
","If the match between the url and the pattern occurs, return the match result. Otherwise, return null.",Matches a URI with a regex pattern.,Matches the given URI against a regex pattern and returns a match result or null if no match is found.,"@param uri CharSequence: The URI to match.
   @return MatchResult: The match result or null if no match is found.","""http://example.com"" -> MatchResult (match successful)
null -> null (null input)
"""" -> null (empty input)","URI may be null or empty, returns a match result if the pattern matches, otherwise null.","public final MatchResult match(CharSequence uri){
  if (uri == null || uri.length() == 0)   return (regexPattern == null) ? EMPTY_STRING_MATCH_RESULT : null;
 else   if (regexPattern == null)   return null;
  Matcher m=regexPattern.matcher(uri);
  if (!m.matches())   return null;
  return (groupIndexes.length > 0) ? new GroupIndexMatchResult(m) : m;
}
",0,reference
636766861a6d9265ec01755a,match,"public final MatchResult match(CharSequence uri){
  if (uri == null || uri.length() == 0)   return (regexPattern == null) ? EMPTY_STRING_MATCH_RESULT : null;
 else   if (regexPattern == null)   return null;
  Matcher m=regexPattern.matcher(uri);
  if (!m.matches())   return null;
  return (groupIndexes.length > 0) ? new GroupIndexMatchResult(m) : m;
}
","/** 
 * Match a URI against the pattern.
 * @param uri the uri to match against the template.
 * @return the match result, otherwise null if no match occurs.
 */
","If the match between the url and the pattern occurs, return the match result. Otherwise, return null.",Matches a URI with a regex pattern.,Matches the given URI against a regex pattern and returns a match result or null if no match is found.,"@param uri CharSequence: The URI to match.
   @return MatchResult: The match result or null if no match is found.","""http://example.com"" -> MatchResult (match successful)
null -> null (null input)
"""" -> null (empty input)","URI may be null or empty, returns a match result if the pattern matches, otherwise null.","public final MatchResult match(CharSequence uri){
    String string = uri.toString();
    String[] segments = segmentize(string);
    int length = segments.length;
    if(length <= 0){
        //Invalid URI.
        return null;
    }
    Map<String, String> args = new HashMap<String, String>();
    //Match result.
    MatchResult result = new MatchResult();
    result.path = string;
    result.handler = _root._handler;
    result.args = args;
    Method method = null;
    //Find method.
    for(int i=length-1;i>=0;i--){
        String currentSegment = segments[i];
        //Found in routing table.
        method = match(currentSegment, method, null, args, _root);
        if(null!= method){
            break;
        }
    }
    if(null == method){
        //If the pattern of root is found.
        method = match("""", method, null, args, _root);
    }
    //Matched successfully, assign the method to result.
    if(null!= method){
        result.handler = method.handler;
        result.args = args;
    }
    return result;
}",1,starcoder2-7b
636766f91a6d9265ec01777d,convertHexDigit,"public static byte convertHexDigit(byte b){
  if ((b >= '0') && (b <= '9'))   return (byte)(b - '0');
  if ((b >= 'a') && (b <= 'f'))   return (byte)(b - 'a' + 10);
  if ((b >= 'A') && (b <= 'F'))   return (byte)(b - 'A' + 10);
  throw new IllegalArgumentException(""!hex:"" + Integer.toHexString(0xff & b));
}
","/** 
 * @param b An ASCII encoded character 0-9 a-f A-F
 * @return The byte value of the character 0-16.
 */
",Convert an ASCII encoded character to hex.,Converts a hexadecimal digit byte to its decimal value.,Takes a byte representation of a hexadecimal digit and returns its decimal value. Throws an exception if the byte is not a valid hex digit.,"@param b byte: hexadecimal digit as a byte
@return byte: decimal value of the hex digit
@throws IllegalArgumentException: if the input is not a valid hex digit","'0' -> 0
'a' -> 10
'F' -> 15","Input must represent a single hex digit. Output is a byte representing the decimal equivalent, exception on invalid input.","public static byte convertHexDigit(byte b){
    if (b >= '0' && b <= '9') {
        return (byte) (b - '0');
    } else if (b >= 'a' && b <= 'f') {
        return (byte) (b - 'a' + 10);
    } else if (b >= 'A' && b <= 'F') {
        return (byte) (b - 'A' + 10);
    }
    return -1; // Invalid input
}",0,gpt-4-turbo
636766f91a6d9265ec01777d,convertHexDigit,"public static byte convertHexDigit(byte b){
  if ((b >= '0') && (b <= '9'))   return (byte)(b - '0');
  if ((b >= 'a') && (b <= 'f'))   return (byte)(b - 'a' + 10);
  if ((b >= 'A') && (b <= 'F'))   return (byte)(b - 'A' + 10);
  throw new IllegalArgumentException(""!hex:"" + Integer.toHexString(0xff & b));
}
","/** 
 * @param b An ASCII encoded character 0-9 a-f A-F
 * @return The byte value of the character 0-16.
 */
",Convert an ASCII encoded character to hex.,Converts a hexadecimal digit byte to its decimal value.,Takes a byte representation of a hexadecimal digit and returns its decimal value. Throws an exception if the byte is not a valid hex digit.,"@param b byte: hexadecimal digit as a byte
@return byte: decimal value of the hex digit
@throws IllegalArgumentException: if the input is not a valid hex digit","'0' -> 0
'a' -> 10
'F' -> 15","Input must represent a single hex digit. Output is a byte representing the decimal equivalent, exception on invalid input.","public static byte convertHexDigit(byte b){
  //if(isDigit(b))
  return (byte)(b-0x30);
  //if(isUpper(b))
  return (byte)(b-0x37);
  //if(isLower(b))
  return (byte)(b-0x57);
}",1,starcoder2-7b
636767861a6d9265ec01844c,removeAppender,"public void removeAppender(String name){
  if (name == null || appenderList == null)   return;
  int size=appenderList.size();
  for (int i=0; i < size; i++) {
    if (name.equals(((Appender)appenderList.elementAt(i)).getName())) {
      appenderList.removeElementAt(i);
      break;
    }
  }
}
","/** 
 * Remove the appender with the name passed as parameter form the list of appenders.  
 */
",Remove the appender by the given name from the list of appenders.,Remove an appender by name from a list.,"This function removes the appender with the specified name from the appenderList if it exists. If the list or the name is null, the function does nothing.",@param name String: The name of the appender to remove.,"""appender1"" -> removes appender1 (if present)
""appender2"" -> does nothing (if not present)
null -> does nothing (null check)",The appenderList must be initialized; it will be modified by removing the specified appender if present.,"public void removeAppender(String name){
  if (name == null || appenderList == null)   return;
  int size=appenderList.size();
  for (int i=0; i < size; i++) {
    if (name.equals(((Appender)appenderList.elementAt(i)).getName())) {
      appenderList.removeElementAt(i);
      break;
    }
  }
}
",0,reference
636767861a6d9265ec01844c,removeAppender,"public void removeAppender(String name){
  if (name == null || appenderList == null)   return;
  int size=appenderList.size();
  for (int i=0; i < size; i++) {
    if (name.equals(((Appender)appenderList.elementAt(i)).getName())) {
      appenderList.removeElementAt(i);
      break;
    }
  }
}
","/** 
 * Remove the appender with the name passed as parameter form the list of appenders.  
 */
",Remove the appender by the given name from the list of appenders.,Remove an appender by name from a list.,"This function removes the appender with the specified name from the appenderList if it exists. If the list or the name is null, the function does nothing.",@param name String: The name of the appender to remove.,"""appender1"" -> removes appender1 (if present)
""appender2"" -> does nothing (if not present)
null -> does nothing (null check)",The appenderList must be initialized; it will be modified by removing the specified appender if present.,"public void removeAppender(String name) {
        Logger rootLogger = Logger.getRootLogger();
        if(rootLogger.isDebugEnabled()) {
            rootLogger.removeAppender(Logger.getAppender(name));
        }
    }",1,deepseek-coder-6.7b-instruct
6367670c1a6d9265ec017a2a,toPrimitive,"public static int[] toPrimitive(final Integer[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_INT_ARRAY;
  }
  final int[] result=new int[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].intValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Integers to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Integer</code> array, may be <code>null</code>
 * @return an <code>int</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Convert the given Integer array to primitives. Return ArrayUtils.EMPTY_INT_ARRAY for an empty array, return null for null array.",Converts Integer array to primitive int array.,The function converts an array of Integer objects to an array of primitive ints. It returns an empty array if the input array is empty.,"@param array Integer[]: The array of Integer objects to convert.
@return int[]: The resulting array of primitive int values.","null -> null (returns null for input null)
[] -> [] (returns empty array for empty input)
[1, 2, 3] -> [1, 2, 3] (converts Integer array to int array)","Input can be null or empty, output matches input length with Integer values converted to ints.","public static int[] toPrimitive(final Integer[] array) {
    if (array == null) {
        return null;
    }
    if (array.length == 0) {
        return ArrayUtils.EMPTY_INT_ARRAY;
    }
    int[] primitiveArray = new int[array.length];
    for (int i = 0; i < array.length; i++) {
        primitiveArray[i] = array[i].intValue();
    }
    return primitiveArray;
}",0,Qwen2.5-Coder-7B-Instruct
6367670c1a6d9265ec017a2a,toPrimitive,"public static int[] toPrimitive(final Integer[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_INT_ARRAY;
  }
  final int[] result=new int[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].intValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Integers to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Integer</code> array, may be <code>null</code>
 * @return an <code>int</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Convert the given Integer array to primitives. Return ArrayUtils.EMPTY_INT_ARRAY for an empty array, return null for null array.",Converts Integer array to primitive int array.,The function converts an array of Integer objects to an array of primitive ints. It returns an empty array if the input array is empty.,"@param array Integer[]: The array of Integer objects to convert.
@return int[]: The resulting array of primitive int values.","null -> null (returns null for input null)
[] -> [] (returns empty array for empty input)
[1, 2, 3] -> [1, 2, 3] (converts Integer array to int array)","Input can be null or empty, output matches input length with Integer values converted to ints.","public static int[] toPrimitive(final Integer[] array) {
    if (array == null) {
        return null;
    }
    if (ArrayUtils.isEmpty(array)) {
        return ArrayUtils.EMPTY_INT_ARRAY;
    }
    return Arrays.stream(array).mapToInt(i -> i).toArray();
}",1,Phi-3-mini-4k-instruct
636767041a6d9265ec017911,register,"static void register(Object value){
  if (value != null) {
    Map m=getRegistry();
    if (m == null) {
      m=new WeakHashMap();
      REGISTRY.set(m);
    }
    m.put(value,null);
  }
}
","/** 
 * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>
 * @param value The object to register.
 */
",Register the value in REGISTRY if the value is not null.,Registers a non-null object into a thread-local registry.,"If the provided object is not null, it retrieves or initializes a WeakHashMap from thread-local storage and inserts the object as a key with a null value.",@param value Object: The object to be registered.,"register(null)
-> no change (value is null)
register(""newValue"")
-> ""newValue"" added (adds non-null value)","Preconditions: `value` is an object. Postconditions: If `value` is non-null, it's added as a key with null value to the registry map.","static void register(Object value){
  if (value != null) {
    Map m=getRegistry();
    if (m == null) {
      m=new WeakHashMap();
      REGISTRY.set(m);
    }
    m.put(value,null);
  }
}
",0,reference
636767041a6d9265ec017911,register,"static void register(Object value){
  if (value != null) {
    Map m=getRegistry();
    if (m == null) {
      m=new WeakHashMap();
      REGISTRY.set(m);
    }
    m.put(value,null);
  }
}
","/** 
 * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>
 * @param value The object to register.
 */
",Register the value in REGISTRY if the value is not null.,Registers a non-null object into a thread-local registry.,"If the provided object is not null, it retrieves or initializes a WeakHashMap from thread-local storage and inserts the object as a key with a null value.",@param value Object: The object to be registered.,"register(null)
-> no change (value is null)
register(""newValue"")
-> ""newValue"" added (adds non-null value)","Preconditions: `value` is an object. Postconditions: If `value` is non-null, it's added as a key with null value to the registry map.","public void register(String key, Object value){
        if(value != null){
            registryMap.put(key, value);
        }
    }",1,deepseek-coder-6.7b-instruct
636767511a6d9265ec017eb0,nonZeros,"public int nonZeros(int row){
  assert row >= 0 && row < rowOffsets.length;
  return rowOffsets[row + 1] - rowOffsets[row];
}
","/** 
 * Get the number of non-zero entries of a row.
 * @param row the row
 * @return the number of non-zero entries of a row
 */
",Return the number of non-zero entries of a row.,Calculates the number of non-zero elements in a specified row.,The function computes the difference between the values of consecutive row offsets to determine non-zero entries in a given row of a sparse matrix.,"@param row int: Index of the matrix row for which non-zero elements are counted.
@return int: The count of non-zero elements in the specified row.
@throws AssertionError: If the row index is out of bounds.","row = 0 -> 5 (if rowOffsets[1] = 5, rowOffsets[0] = 0)
row = 1 -> 3 (if rowOffsets[2] = 8, rowOffsets[1] = 5)
row = 2 -> 2 (if rowOffsets[3] = 10, rowOffsets[2] = 8)","The row index must be within the valid range; on success, the function returns the number of non-zero elements in the specified row.","public int nonZeros(int row){
  assert row >= 0 && row < rowOffsets.length;
  return rowOffsets[row + 1] - rowOffsets[row];
}
",0,reference
636767511a6d9265ec017eb0,nonZeros,"public int nonZeros(int row){
  assert row >= 0 && row < rowOffsets.length;
  return rowOffsets[row + 1] - rowOffsets[row];
}
","/** 
 * Get the number of non-zero entries of a row.
 * @param row the row
 * @return the number of non-zero entries of a row
 */
",Return the number of non-zero entries of a row.,Calculates the number of non-zero elements in a specified row.,The function computes the difference between the values of consecutive row offsets to determine non-zero entries in a given row of a sparse matrix.,"@param row int: Index of the matrix row for which non-zero elements are counted.
@return int: The count of non-zero elements in the specified row.
@throws AssertionError: If the row index is out of bounds.","row = 0 -> 5 (if rowOffsets[1] = 5, rowOffsets[0] = 0)
row = 1 -> 3 (if rowOffsets[2] = 8, rowOffsets[1] = 5)
row = 2 -> 2 (if rowOffsets[3] = 10, rowOffsets[2] = 8)","The row index must be within the valid range; on success, the function returns the number of non-zero elements in the specified row.","public int nonZeros(int row){
    return nonZeroPatternRows.getQuick(row);
}",1,CodeLlama-7b-Instruct-hf
6367676c1a6d9265ec018223,containsInstance,"public static boolean containsInstance(Collection collection,Object element){
  if (collection != null) {
    for (    Object candidate : collection) {
      if (candidate == element) {
        return true;
      }
    }
  }
  return false;
}
","/** 
 * Check whether the given Collection contains the given element instance. <p>Enforces the given instance to be present, rather than returning <code>true</code> for an equal element as well.
 * @param collection the Collection to check
 * @param element the element to look for
 * @return <code>true</code> if found, <code>false</code> else
 */
",Check whether the element exists in the collection. ,Checks if a collection contains a specific instance.,"The function iterates over the collection to see if the specific object instance is present. Returns true if found, false otherwise.","@param collection Collection: the collection to be searched
@param element Object: the specific instance to look for
@return boolean: true if the instance is found, false otherwise","[1, 2, 3], 2 -> false (compares instance, not value equality)
[a, b, c], b -> true (same instance of 'b')
null, anyObject -> false (null collection)","Assumes a non-null collection iterates its elements, only considers instance reference, not value equality. Returns false if the collection is null.","public static boolean containsInstance(Collection collection, Object element) {
    return collection.contains(element);
}",0,Qwen2.5-Coder-7B-Instruct
6367676c1a6d9265ec018223,containsInstance,"public static boolean containsInstance(Collection collection,Object element){
  if (collection != null) {
    for (    Object candidate : collection) {
      if (candidate == element) {
        return true;
      }
    }
  }
  return false;
}
","/** 
 * Check whether the given Collection contains the given element instance. <p>Enforces the given instance to be present, rather than returning <code>true</code> for an equal element as well.
 * @param collection the Collection to check
 * @param element the element to look for
 * @return <code>true</code> if found, <code>false</code> else
 */
",Check whether the element exists in the collection. ,Checks if a collection contains a specific instance.,"The function iterates over the collection to see if the specific object instance is present. Returns true if found, false otherwise.","@param collection Collection: the collection to be searched
@param element Object: the specific instance to look for
@return boolean: true if the instance is found, false otherwise","[1, 2, 3], 2 -> false (compares instance, not value equality)
[a, b, c], b -> true (same instance of 'b')
null, anyObject -> false (null collection)","Assumes a non-null collection iterates its elements, only considers instance reference, not value equality. Returns false if the collection is null.","public static boolean containsInstance(Collection collection,Object element){
    return collection.contains(element)
}",1,CodeLlama-7b-Instruct-hf
636766fa1a6d9265ec01779d,isAsciiControl,"public static boolean isAsciiControl(final char ch){
  return ch < 32 || ch == 127;
}
","/** 
 * <p>Checks whether the character is ASCII 7 bit control.</p> <pre> CharUtils.isAsciiControl('a')  = false CharUtils.isAsciiControl('A')  = false CharUtils.isAsciiControl('3')  = false CharUtils.isAsciiControl('-')  = false CharUtils.isAsciiControl('\n') = true CharUtils.isAsciiControl('&copy;') = false </pre>
 * @param ch  the character to check
 * @return true if less than 32 or equals 127
 */
",Check whether the character is ASCII 7 bit control.,Checks if a character is an ASCII control character.,Determines if a given character is a control character in the ASCII range by returning true if it is less than 32 or equals 127.,"@param ch char: Character to evaluate
   @return boolean: True if the character is an ASCII control character, otherwise false","'A' -> false (Printable character)
'\n' -> true (Newline is a control character)
127 -> true (Delete is a control character)","Accepts a single character as input, returns a boolean indicating control character status within ASCII limits.","public static boolean isAsciiControl(final char ch){
return (ch < 0x20) || (ch > 0x7E);
}",0,starcoder2-7b
636766fa1a6d9265ec01779d,isAsciiControl,"public static boolean isAsciiControl(final char ch){
  return ch < 32 || ch == 127;
}
","/** 
 * <p>Checks whether the character is ASCII 7 bit control.</p> <pre> CharUtils.isAsciiControl('a')  = false CharUtils.isAsciiControl('A')  = false CharUtils.isAsciiControl('3')  = false CharUtils.isAsciiControl('-')  = false CharUtils.isAsciiControl('\n') = true CharUtils.isAsciiControl('&copy;') = false </pre>
 * @param ch  the character to check
 * @return true if less than 32 or equals 127
 */
",Check whether the character is ASCII 7 bit control.,Checks if a character is an ASCII control character.,Determines if a given character is a control character in the ASCII range by returning true if it is less than 32 or equals 127.,"@param ch char: Character to evaluate
   @return boolean: True if the character is an ASCII control character, otherwise false","'A' -> false (Printable character)
'\n' -> true (Newline is a control character)
127 -> true (Delete is a control character)","Accepts a single character as input, returns a boolean indicating control character status within ASCII limits.","public static boolean isAsciiControl(final char ch){
  return (ch & 0xff80) == 0;
}",1,starcoder2-7b
6367670b1a6d9265ec0179f2,containsKey,"@Override public boolean containsKey(final Object key){
  if (this.fast) {
    return this.map.containsKey(key);
  }
 else {
synchronized (this.map) {
      return this.map.containsKey(key);
    }
  }
}
","/** 
 * Return <code>true</code> if this map contains a mapping for the specified key.
 * @param key  the key to be searched for
 * @return true if the map contains the key
 */
",Check whether a map contains a mapping for the specified key.,Check if a key exists in the map.,"Returns true if the key is present in the map, utilizing synchronization if the map is not accessed fast.","@param key Object: Key to check for existence in the map.
   @return boolean: True if the key is present, false otherwise.","""key1"" -> true (key found)
""key2"" -> false (key not found)",Map must be initialized; result reflects key's presence without altering map state.,"@Override public boolean containsKey(final Object key){
if(key==null)
throw new NullPointerException();
return keySet().contains(key);
}",0,CodeLlama-7b-Instruct-hf
6367670b1a6d9265ec0179f2,containsKey,"@Override public boolean containsKey(final Object key){
  if (this.fast) {
    return this.map.containsKey(key);
  }
 else {
synchronized (this.map) {
      return this.map.containsKey(key);
    }
  }
}
","/** 
 * Return <code>true</code> if this map contains a mapping for the specified key.
 * @param key  the key to be searched for
 * @return true if the map contains the key
 */
",Check whether a map contains a mapping for the specified key.,Check if a key exists in the map.,"Returns true if the key is present in the map, utilizing synchronization if the map is not accessed fast.","@param key Object: Key to check for existence in the map.
   @return boolean: True if the key is present, false otherwise.","""key1"" -> true (key found)
""key2"" -> false (key not found)",Map must be initialized; result reflects key's presence without altering map state.,"@Override public boolean containsKey(final Object key){
return myMap.containsKey(key);
}",1,CodeLlama-7b-Instruct-hf
636766fa1a6d9265ec017796,toObject,"public static Boolean[] toObject(final boolean[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;
  }
  final Boolean[] result=new Boolean[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i] ? Boolean.TRUE : Boolean.FALSE;
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive booleans to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>boolean</code> array
 * @return a <code>Boolean</code> array, <code>null</code> if null array input
 */
",Convert an array of primitive booleans to objects.,Converts a primitive boolean array to a Boolean object array.,Returns a Boolean array equivalent of the provided boolean array or null if the input is null. Returns an empty Boolean array if the input array is empty.,"@param array boolean[]: Input array of primitive booleans.
@return Boolean[]: Array of Boolean objects corresponding to input.","null -> null (null input)
[] -> [] (empty input array)
[true, false, true] -> [Boolean.TRUE, Boolean.FALSE, Boolean.TRUE] (conversion of non-empty array)","Input can be null or non-null, returns null, or a converted non-null Boolean array respectively.","public static Boolean[] toObject(final boolean[] array){
if ( array == null )
return null;

Boolean[] object = new Boolean[array.length];

for ( int i=0; i<array.length; i++ )
object[i] = array[i];

return object;
}",0,starcoder2-7b
636766fa1a6d9265ec017796,toObject,"public static Boolean[] toObject(final boolean[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;
  }
  final Boolean[] result=new Boolean[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i] ? Boolean.TRUE : Boolean.FALSE;
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive booleans to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>boolean</code> array
 * @return a <code>Boolean</code> array, <code>null</code> if null array input
 */
",Convert an array of primitive booleans to objects.,Converts a primitive boolean array to a Boolean object array.,Returns a Boolean array equivalent of the provided boolean array or null if the input is null. Returns an empty Boolean array if the input array is empty.,"@param array boolean[]: Input array of primitive booleans.
@return Boolean[]: Array of Boolean objects corresponding to input.","null -> null (null input)
[] -> [] (empty input array)
[true, false, true] -> [Boolean.TRUE, Boolean.FALSE, Boolean.TRUE] (conversion of non-empty array)","Input can be null or non-null, returns null, or a converted non-null Boolean array respectively.","public static Boolean[] toObject(final boolean[] array){
  return Arrays.asList(array).toArray(new Boolean[0]);
}",1,starcoder2-7b
636767aa1a6d9265ec01864a,toByteArray,"public byte[] toByteArray(){
  final int size=bytes.length;
  final byte[] copy=new byte[size];
  System.arraycopy(bytes,0,copy,0,size);
  return copy;
}
","/** 
 * Copies bytes to a  {@code byte[]}.
 */
",Copy bytes to a byte array.,Returns a copy of the byte array.,Creates and returns a new byte array that is a copy of the 'bytes' array.,@return byte[]: A copy of the internal byte array.,"[1, 2, 3] -> [1, 2, 3] (returns a duplicate array)
[] -> [] (returns an empty array)
[10, 20, 30] -> [10, 20, 30] (returns a duplicate array)","Assumes 'bytes' is non-null, returns an identical array copy with the same content.","public byte[] toByteArray(){
  final int size=bytes.length;
  final byte[] copy=new byte[size];
  System.arraycopy(bytes,0,copy,0,size);
  return copy;
}
",0,reference
636767aa1a6d9265ec01864a,toByteArray,"public byte[] toByteArray(){
  final int size=bytes.length;
  final byte[] copy=new byte[size];
  System.arraycopy(bytes,0,copy,0,size);
  return copy;
}
","/** 
 * Copies bytes to a  {@code byte[]}.
 */
",Copy bytes to a byte array.,Returns a copy of the byte array.,Creates and returns a new byte array that is a copy of the 'bytes' array.,@return byte[]: A copy of the internal byte array.,"[1, 2, 3] -> [1, 2, 3] (returns a duplicate array)
[] -> [] (returns an empty array)
[10, 20, 30] -> [10, 20, 30] (returns a duplicate array)","Assumes 'bytes' is non-null, returns an identical array copy with the same content.","public byte[] toByteArray(){
return byteArray;
}",1,CodeLlama-7b-Instruct-hf
636767561a6d9265ec017f7c,edgeSetToTour,"protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){
  List<V> vertices=new ArrayList<>(tour.size() + 1);
  MaskSubgraph<V,E> tourGraph=new MaskSubgraph<>(graph,v -> false,e -> !tour.contains(e));
  new DepthFirstIterator<>(tourGraph).forEachRemaining(vertices::add);
  return vertexListToTour(vertices,graph);
}
","/** 
 * Transform from a Set representation to a graph path.
 * @param tour a set containing the edges of the tour
 * @param graph the graph
 * @return a graph path
 */
",Convert a set representation to a graph path.,Converts a set of edges into a tour path on the graph.,Constructs a tour path from a given set of edges and returns it as a GraphPath. Uses a MaskSubgraph to filter out non-tour edges and performs a depth-first traversal.,"@param tour Set<E>: Set of edges that form the tour.
   @param graph Graph<V,E>: The graph containing vertices and edges.
   @return GraphPath<V,E>: A path object representing the tour through the graph.","Set of edges, complete graph -> a valid tour path (produces a tour using provided edges)
Empty edge set, graph -> empty path (no edges, no tour)",Edges must form a continuous path; the graph must contain vertices and edges. The function outputs a valid graph path based on input edges.,"protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){
  List<V> vertices=new ArrayList<>(tour.size() + 1);
  MaskSubgraph<V,E> tourGraph=new MaskSubgraph<>(graph,v -> false,e -> !tour.contains(e));
  new DepthFirstIterator<>(tourGraph).forEachRemaining(vertices::add);
  return vertexListToTour(vertices,graph);
}
",0,reference
636767561a6d9265ec017f7c,edgeSetToTour,"protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){
  List<V> vertices=new ArrayList<>(tour.size() + 1);
  MaskSubgraph<V,E> tourGraph=new MaskSubgraph<>(graph,v -> false,e -> !tour.contains(e));
  new DepthFirstIterator<>(tourGraph).forEachRemaining(vertices::add);
  return vertexListToTour(vertices,graph);
}
","/** 
 * Transform from a Set representation to a graph path.
 * @param tour a set containing the edges of the tour
 * @param graph the graph
 * @return a graph path
 */
",Convert a set representation to a graph path.,Converts a set of edges into a tour path on the graph.,Constructs a tour path from a given set of edges and returns it as a GraphPath. Uses a MaskSubgraph to filter out non-tour edges and performs a depth-first traversal.,"@param tour Set<E>: Set of edges that form the tour.
   @param graph Graph<V,E>: The graph containing vertices and edges.
   @return GraphPath<V,E>: A path object representing the tour through the graph.","Set of edges, complete graph -> a valid tour path (produces a tour using provided edges)
Empty edge set, graph -> empty path (no edges, no tour)",Edges must form a continuous path; the graph must contain vertices and edges. The function outputs a valid graph path based on input edges.,"protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){
if (graph.getEdgeSet().containsAll(tour)){
GraphPath<V,E> path = new DefaultGraphPath<V,E>();
for (E e : tour){
path.appendPath(graph.getEndpoints(e));
}
return path;
}else{
return null;
}
}",1,starcoder2-7b
6367670a1a6d9265ec0179f1,toObject,"public static Short[] toObject(final short[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;
  }
  final Short[] result=new Short[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=new Short(array[i]);
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive shorts to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>short</code> array
 * @return a <code>Short</code> array, <code>null</code> if null array input
 */
",Convert an array of primitive shorts to objects.,Converts a primitive short array to a Short object array.,"The toObject function converts a given array of primitive shorts into an array of Short objects, returning null or a predefined constant if the input is null or empty, respectively.","@param array short[]: The array of primitive shorts to convert.
@return Short[]: The array of Short objects, or null/constant array if input is null/empty.","null -> null (null input returns null)
[] -> ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY (empty input returns empty constant)
[1, 2, 3] -> [1, 2, 3] (converts to Short objects)","Inputs must be an array of primitive shorts, output will be a corresponding array of Short objects or a specific constant if empty.","public static Short[] toObject(final short[] array) {
    if (array == null) {
        return null;
    }
    Short[] result = new Short[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = Short.valueOf(array[i]);
    }
    return result;
}",0,gpt-4-turbo
6367670a1a6d9265ec0179f1,toObject,"public static Short[] toObject(final short[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;
  }
  final Short[] result=new Short[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=new Short(array[i]);
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive shorts to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>short</code> array
 * @return a <code>Short</code> array, <code>null</code> if null array input
 */
",Convert an array of primitive shorts to objects.,Converts a primitive short array to a Short object array.,"The toObject function converts a given array of primitive shorts into an array of Short objects, returning null or a predefined constant if the input is null or empty, respectively.","@param array short[]: The array of primitive shorts to convert.
@return Short[]: The array of Short objects, or null/constant array if input is null/empty.","null -> null (null input returns null)
[] -> ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY (empty input returns empty constant)
[1, 2, 3] -> [1, 2, 3] (converts to Short objects)","Inputs must be an array of primitive shorts, output will be a corresponding array of Short objects or a specific constant if empty.","public static Short[] toObject(final short[] array){
        return (Short[])new Short[array.length];
    }",1,starcoder2-7b
6367676c1a6d9265ec018204,concatenateStringArrays,"public static String[] concatenateStringArrays(String[] array1,String[] array2){
  if (Objects.isEmpty(array1)) {
    return array2;
  }
  if (Objects.isEmpty(array2)) {
    return array1;
  }
  String[] newArr=new String[array1.length + array2.length];
  System.arraycopy(array1,0,newArr,0,array1.length);
  System.arraycopy(array2,0,newArr,array1.length,array2.length);
  return newArr;
}
","/** 
 * Concatenate the given String arrays into one, with overlapping array elements included twice. <p>The order of elements in the original arrays is preserved.
 * @param array1 the first array (can be <code>null</code>)
 * @param array2 the second array (can be <code>null</code>)
 * @return the new array (<code>null</code> if both given arrays were <code>null</code>)
 */
",Concatenate two string arrays into one.,Concatenates two string arrays.,"This function merges two string arrays into one, returning the combined array. If either array is empty, it returns the non-empty array.","@param array1 String[]: First array of strings to concatenate
@param array2 String[]: Second array of strings to concatenate
@return String[]: New array containing all elements of both input arrays","[""a"", ""b""], [""c"", ""d""] -> [""a"", ""b"", ""c"", ""d""] (combines two non-empty arrays)
[], [""x"", ""y""] -> [""x"", ""y""] (first array is empty)
[""p"", ""q""], [] -> [""p"", ""q""] (second array is empty)","Arrays are non-null; returns a new array with combined elements, preserving order.","public static String[] concatenateStringArrays(String[] array1, String[] array2) {
    if (array1 == null && array2 == null) {
        return null;
    }
    if (array1 == null) {
        return array2.clone();
    }
    if (array2 == null) {
        return array1.clone();
    }
    String[] result = new String[array1.length + array2.length];
    System.arraycopy(array1, 0, result, 0, array1.length);
    System.arraycopy(array2, 0, result, array1.length, array2.length);
    return result;
}",0,gpt-4-turbo
6367676c1a6d9265ec018204,concatenateStringArrays,"public static String[] concatenateStringArrays(String[] array1,String[] array2){
  if (Objects.isEmpty(array1)) {
    return array2;
  }
  if (Objects.isEmpty(array2)) {
    return array1;
  }
  String[] newArr=new String[array1.length + array2.length];
  System.arraycopy(array1,0,newArr,0,array1.length);
  System.arraycopy(array2,0,newArr,array1.length,array2.length);
  return newArr;
}
","/** 
 * Concatenate the given String arrays into one, with overlapping array elements included twice. <p>The order of elements in the original arrays is preserved.
 * @param array1 the first array (can be <code>null</code>)
 * @param array2 the second array (can be <code>null</code>)
 * @return the new array (<code>null</code> if both given arrays were <code>null</code>)
 */
",Concatenate two string arrays into one.,Concatenates two string arrays.,"This function merges two string arrays into one, returning the combined array. If either array is empty, it returns the non-empty array.","@param array1 String[]: First array of strings to concatenate
@param array2 String[]: Second array of strings to concatenate
@return String[]: New array containing all elements of both input arrays","[""a"", ""b""], [""c"", ""d""] -> [""a"", ""b"", ""c"", ""d""] (combines two non-empty arrays)
[], [""x"", ""y""] -> [""x"", ""y""] (first array is empty)
[""p"", ""q""], [] -> [""p"", ""q""] (second array is empty)","Arrays are non-null; returns a new array with combined elements, preserving order.","public static String[] concatenateStringArrays(String[] array1,String[] array2){
    int lengthOfArray1=array1.length;
    int lengthOfArray2=array2.length;
    String[] concatenatedArray=new String[lengthOfArray1+lengthOfArray2];

    System.arraycopy(array1,0,concatenatedArray,0,lengthOfArray1);
    System.arraycopy(array2,0,concatenatedArray,lengthOfArray1,lengthOfArray2);

    return concatenatedArray;
}",1,CodeLlama-7b-Instruct-hf
6367676a1a6d9265ec0181d4,addStringToArray,"public static String[] addStringToArray(String[] array,String str){
  if (Objects.isEmpty(array)) {
    return new String[]{str};
  }
  String[] newArr=new String[array.length + 1];
  System.arraycopy(array,0,newArr,0,array.length);
  newArr[array.length]=str;
  return newArr;
}
","/** 
 * Append the given String to the given String array, returning a new array consisting of the input array contents plus the given String.
 * @param array the array to append to (can be <code>null</code>)
 * @param str the String to append
 * @return the new array (never <code>null</code>)
 */
",Append a string to a string array.,Adds a string to the end of an array.,"The function checks if the given array is empty or null, creates a new array of the original size plus one, copies all elements, adds the given string to the end, and returns the new array.","@param array String[]: The original array to which the string will be added
   @param str String: The string to add to the array
   @return String[]: The new array with the added string","[""a"", ""b""], ""c"" -> [""a"", ""b"", ""c""] (adds ""c"" to array end)
[], ""a"" -> [""a""] (adds ""a"" to new array)
null, ""b"" -> [""b""] (handles null array)",The array can be null or empty; the returned array is always non-null and contains all original elements plus the new string at the end.,"public static String[] addStringToArray(String[] array, String str) {
    String[] newArray = new String[array.length + 1];
    System.arraycopy(array, 0, newArray, 0, array.length);
    newArray[array.length] = str;
    return newArray;
}",0,Phi-3-mini-4k-instruct
6367676a1a6d9265ec0181d4,addStringToArray,"public static String[] addStringToArray(String[] array,String str){
  if (Objects.isEmpty(array)) {
    return new String[]{str};
  }
  String[] newArr=new String[array.length + 1];
  System.arraycopy(array,0,newArr,0,array.length);
  newArr[array.length]=str;
  return newArr;
}
","/** 
 * Append the given String to the given String array, returning a new array consisting of the input array contents plus the given String.
 * @param array the array to append to (can be <code>null</code>)
 * @param str the String to append
 * @return the new array (never <code>null</code>)
 */
",Append a string to a string array.,Adds a string to the end of an array.,"The function checks if the given array is empty or null, creates a new array of the original size plus one, copies all elements, adds the given string to the end, and returns the new array.","@param array String[]: The original array to which the string will be added
   @param str String: The string to add to the array
   @return String[]: The new array with the added string","[""a"", ""b""], ""c"" -> [""a"", ""b"", ""c""] (adds ""c"" to array end)
[], ""a"" -> [""a""] (adds ""a"" to new array)
null, ""b"" -> [""b""] (handles null array)",The array can be null or empty; the returned array is always non-null and contains all original elements plus the new string at the end.,"public static String[] addStringToArray(String[] array,String str){
return null;
}",1,starcoder2-7b
6367676b1a6d9265ec0181dd,countOccurrencesOf,"public static int countOccurrencesOf(String str,String sub){
  if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {
    return 0;
  }
  int count=0;
  int pos=0;
  int idx;
  while ((idx=str.indexOf(sub,pos)) != -1) {
    ++count;
    pos=idx + sub.length();
  }
  return count;
}
","/** 
 * Returns the number of occurrences the substring  {@code sub} appears in string {@code str}.
 * @param str string to search in. Return 0 if this is null.
 * @param sub string to search for. Return 0 if this is null.
 * @return the number of occurrences the substring {@code sub} appears in string {@code str}.
 */
",Return the frequencies that the substring appears in the string.,Count occurrences of a substring within a string.,Iterates through the main string to count non-overlapping occurrences of the given substring.,"@param str String: The main string to search within
@param sub String: The substring to count
@return int: The count of non-overlapping occurrences","""hello"", ""l"" -> 2 (two 'l's in ""hello"")
""banana"", ""na"" -> 2 (""na"" appears twice)
""abc"", ""d"" -> 0 (""d"" is not in ""abc"")",The function assumes non-null input strings and returns a non-negative integer representing the count.,"public static int countOccurrencesOf(String str, String sub) {
        if (str == null || sub == null || str.length() < sub.length()) {
            return 0;
        }

        int count = 0;
        int fromIndex = 0;

        while ((fromIndex = str.indexOf(sub, fromIndex)) != -1) {
            count++;
            fromIndex += sub.length();
        }

        return count;
    }",0,Qwen2.5-Coder-7B-Instruct
6367676b1a6d9265ec0181dd,countOccurrencesOf,"public static int countOccurrencesOf(String str,String sub){
  if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {
    return 0;
  }
  int count=0;
  int pos=0;
  int idx;
  while ((idx=str.indexOf(sub,pos)) != -1) {
    ++count;
    pos=idx + sub.length();
  }
  return count;
}
","/** 
 * Returns the number of occurrences the substring  {@code sub} appears in string {@code str}.
 * @param str string to search in. Return 0 if this is null.
 * @param sub string to search for. Return 0 if this is null.
 * @return the number of occurrences the substring {@code sub} appears in string {@code str}.
 */
",Return the frequencies that the substring appears in the string.,Count occurrences of a substring within a string.,Iterates through the main string to count non-overlapping occurrences of the given substring.,"@param str String: The main string to search within
@param sub String: The substring to count
@return int: The count of non-overlapping occurrences","""hello"", ""l"" -> 2 (two 'l's in ""hello"")
""banana"", ""na"" -> 2 (""na"" appears twice)
""abc"", ""d"" -> 0 (""d"" is not in ""abc"")",The function assumes non-null input strings and returns a non-negative integer representing the count.,"public static int countOccurrencesOf(String str, String sub) {
    int count = 0;
    int strLength = str.length();
    int subLength = sub.length();
    
    // Check each substring of str to see if it is equal to sub
    for (int i = 0; i <= strLength - subLength; i++) {
        if (str.substring(i, i + subLength).equals(sub)) {
            count++;
        }
    }
    
    return count;
}",1,deepseek-coder-6.7b-instruct
636766fe1a6d9265ec017821,appendDetail,"protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){
  buffer.append(arrayStart);
  for (int i=0; i < array.length; i++) {
    if (i > 0) {
      buffer.append(arraySeparator);
    }
    appendDetail(buffer,fieldName,array[i]);
  }
  buffer.append(arrayEnd);
}
","/** 
 * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>
 * @param buffer  the <code>StringBuffer</code> to populate
 * @param fieldName  the field name, typically not used as already appended
 * @param array  the array to add to the <code>toString</code>,not <code>null</code>
 */
",Append a byte array to a buffer.,Appends array details to a StringBuffer.,"Appends the start marker, each byte value separated by a defined separator, and the end marker of a byte array to a StringBuffer. Recursively calls itself for each byte element in the array.","@param buffer StringBuffer: The buffer to append details into
   @param fieldName String: The name of the field being processed
   @param array byte[]: The array whose details are to be appended","byte[] {1, 2} -> StringBuffer containing ""[1,2]"" (basic example)
byte[] {} -> StringBuffer containing ""[]"" (empty array)
byte[] {4} -> StringBuffer containing ""[4]"" (single element)","Assumes arrayStart, arraySeparator, and arrayEnd are predefined strings; ensures fields are correctly appended to buffer.","protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){
  buffer.append(arrayStart);
  for (int i=0; i < array.length; i++) {
    if (i > 0) {
      buffer.append(arraySeparator);
    }
    appendDetail(buffer,fieldName,array[i]);
  }
  buffer.append(arrayEnd);
}
",0,reference
636766fe1a6d9265ec017821,appendDetail,"protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){
  buffer.append(arrayStart);
  for (int i=0; i < array.length; i++) {
    if (i > 0) {
      buffer.append(arraySeparator);
    }
    appendDetail(buffer,fieldName,array[i]);
  }
  buffer.append(arrayEnd);
}
","/** 
 * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>
 * @param buffer  the <code>StringBuffer</code> to populate
 * @param fieldName  the field name, typically not used as already appended
 * @param array  the array to add to the <code>toString</code>,not <code>null</code>
 */
",Append a byte array to a buffer.,Appends array details to a StringBuffer.,"Appends the start marker, each byte value separated by a defined separator, and the end marker of a byte array to a StringBuffer. Recursively calls itself for each byte element in the array.","@param buffer StringBuffer: The buffer to append details into
   @param fieldName String: The name of the field being processed
   @param array byte[]: The array whose details are to be appended","byte[] {1, 2} -> StringBuffer containing ""[1,2]"" (basic example)
byte[] {} -> StringBuffer containing ""[]"" (empty array)
byte[] {4} -> StringBuffer containing ""[4]"" (single element)","Assumes arrayStart, arraySeparator, and arrayEnd are predefined strings; ensures fields are correctly appended to buffer.","protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {
    if (array != null) {
        buffer.append(fieldName).append("": "").append(new String(array));
    } else {
        buffer.append(fieldName).append("": "").append(""null"");
    }
}",1,deepseek-coder-6.7b-instruct
636767561a6d9265ec017f63,hasNext,"@Override public boolean hasNext(){
  if (current != null) {
    return true;
  }
  current=advance();
  if (current != null && nListeners != 0) {
    fireVertexTraversed(createVertexTraversalEvent(current));
  }
  return current != null;
}
","/** 
 * Checks whether there exist unvisited vertices.
 * @return true if there exist unvisited vertices.
 */
","Check whether there are unvisited vertices. If so, return true. Otherwise, return false.",Checks if there is a next element in traversal.,"The function checks if the 'current' element is not null, if so, it returns true. Otherwise, it advances to the next element, possibly triggering events, before checking again.","@return boolean: True if there is a non-null next element, otherwise false.","current != null -> true (as current already points to an element)
current == null, advance()
== null -> false (no next element after advancing)
current == null, advance()
!= null -> true (found a next element after advancing)","The 'current' element starts either null or pointing to an element, and may trigger events when moving to the next element. The function returns whether a subsequent non-null element is available.","@Override public boolean hasNext(){
  if (current != null) {
    return true;
  }
  current=advance();
  if (current != null && nListeners != 0) {
    fireVertexTraversed(createVertexTraversalEvent(current));
  }
  return current != null;
}
",0,reference
636767561a6d9265ec017f63,hasNext,"@Override public boolean hasNext(){
  if (current != null) {
    return true;
  }
  current=advance();
  if (current != null && nListeners != 0) {
    fireVertexTraversed(createVertexTraversalEvent(current));
  }
  return current != null;
}
","/** 
 * Checks whether there exist unvisited vertices.
 * @return true if there exist unvisited vertices.
 */
","Check whether there are unvisited vertices. If so, return true. Otherwise, return false.",Checks if there is a next element in traversal.,"The function checks if the 'current' element is not null, if so, it returns true. Otherwise, it advances to the next element, possibly triggering events, before checking again.","@return boolean: True if there is a non-null next element, otherwise false.","current != null -> true (as current already points to an element)
current == null, advance()
== null -> false (no next element after advancing)
current == null, advance()
!= null -> true (found a next element after advancing)","The 'current' element starts either null or pointing to an element, and may trigger events when moving to the next element. The function returns whether a subsequent non-null element is available.","@Override public boolean hasNext(){
for (int i = 0; i < visited.length; i++) {
        if (!visited[i]) {
            return true;
        }
    }
    return false;
}",1,gpt-4-turbo
636766a81a6d9265ec017586,pop,"private void pop(final int elements){
  if (outputStackTop >= elements) {
    outputStackTop-=elements;
  }
 else {
    outputStackStart-=elements - outputStackTop;
    outputStackTop=0;
  }
}
","/** 
 * Pops the given number of abstract types from the output frame stack.
 * @param elements the number of abstract types that must be popped.
 */
",Pop the given number of elements from the stack.,Reduces output stack size by a specified number of elements.,Decreases `outputStackTop` by `elements` if possible; adjusts `outputStackStart` otherwise.,@param elements int: Number of elements to pop from the stack.,"elements=5, outputStackTop=10 -> outputStackTop=5 (Reduced successfully)
elements=5, outputStackTop=2 -> outputStackTop=0, outputStackStart-3 (Adjusted start)","Assumes `outputStackTop` and `outputStackStart` are initialized and valid, resulting in decreased stack size.","private void pop(final int elements){
		for(int i=0;i<elements;i++){
			pop();}
}",0,starcoder2-7b
636766a81a6d9265ec017586,pop,"private void pop(final int elements){
  if (outputStackTop >= elements) {
    outputStackTop-=elements;
  }
 else {
    outputStackStart-=elements - outputStackTop;
    outputStackTop=0;
  }
}
","/** 
 * Pops the given number of abstract types from the output frame stack.
 * @param elements the number of abstract types that must be popped.
 */
",Pop the given number of elements from the stack.,Reduces output stack size by a specified number of elements.,Decreases `outputStackTop` by `elements` if possible; adjusts `outputStackStart` otherwise.,@param elements int: Number of elements to pop from the stack.,"elements=5, outputStackTop=10 -> outputStackTop=5 (Reduced successfully)
elements=5, outputStackTop=2 -> outputStackTop=0, outputStackStart-3 (Adjusted start)","Assumes `outputStackTop` and `outputStackStart` are initialized and valid, resulting in decreased stack size.","private void pop(final int elements){
     if(stack.size()< elements) throw new IllegalArgumentException(""Stack is empty. Cant remove ""+ elements+ "" element(s)."");
     else{
           stack.removeRange(0,elements);
     }

}",1,CodeLlama-7b-Instruct-hf
636767e11a6d9265ec018795,isCompatible,"public boolean isCompatible(DataTable dataset){
  final List<String> sortedKeys=dataset.sortedKeys(new HeatMap.KeyComparator(true));
  long[] existedBuckets=new long[sortedKeys.size()];
  for (int i=0; i < sortedKeys.size(); i++) {
    String key=sortedKeys.get(i);
    if (key.equals(Bucket.INFINITE_NEGATIVE)) {
      existedBuckets[i]=Long.MIN_VALUE;
    }
 else {
      if (key.contains("":"")) {
        key=StringUtils.substringAfterLast(key,"":"");
      }
      existedBuckets[i]=Long.parseLong(key);
    }
  }
  return Arrays.equals(buckets,existedBuckets);
}
","/** 
 * @return true if the bucket is same.
 */
",Check whether the existed buckets are the same as the buckets.,Checks compatibility of dataset buckets with predefined buckets.,Compares sorted keys from the dataset to predefined bucket values after processing. Returns true if both arrays of buckets match.,"@return boolean: True if dataset buckets match predefined buckets, false otherwise.","dataset with sortedKeys [""INFINITE_NEGATIVE"", ""1""] and buckets [Long.MIN_VALUE, 1] -> true (buckets match)
| dataset with sortedKeys [""INFINITE_NEGATIVE"", ""2""] and buckets [Long.MIN_VALUE, 1] -> false (buckets do not match)
| dataset with sortedKeys [""0:1"", ""2""] and buckets [1, 2] -> true (buckets match)",Dataset keys must be parseable integers after last colon; output is false if arrays differ in length or content.,"public boolean isCompatible(DataTable dataset){
  final List<String> sortedKeys=dataset.sortedKeys(new HeatMap.KeyComparator(true));
  long[] existedBuckets=new long[sortedKeys.size()];
  for (int i=0; i < sortedKeys.size(); i++) {
    String key=sortedKeys.get(i);
    if (key.equals(Bucket.INFINITE_NEGATIVE)) {
      existedBuckets[i]=Long.MIN_VALUE;
    }
 else {
      if (key.contains("":"")) {
        key=StringUtils.substringAfterLast(key,"":"");
      }
      existedBuckets[i]=Long.parseLong(key);
    }
  }
  return Arrays.equals(buckets,existedBuckets);
}
",0,reference
636767e11a6d9265ec018795,isCompatible,"public boolean isCompatible(DataTable dataset){
  final List<String> sortedKeys=dataset.sortedKeys(new HeatMap.KeyComparator(true));
  long[] existedBuckets=new long[sortedKeys.size()];
  for (int i=0; i < sortedKeys.size(); i++) {
    String key=sortedKeys.get(i);
    if (key.equals(Bucket.INFINITE_NEGATIVE)) {
      existedBuckets[i]=Long.MIN_VALUE;
    }
 else {
      if (key.contains("":"")) {
        key=StringUtils.substringAfterLast(key,"":"");
      }
      existedBuckets[i]=Long.parseLong(key);
    }
  }
  return Arrays.equals(buckets,existedBuckets);
}
","/** 
 * @return true if the bucket is same.
 */
",Check whether the existed buckets are the same as the buckets.,Checks compatibility of dataset buckets with predefined buckets.,Compares sorted keys from the dataset to predefined bucket values after processing. Returns true if both arrays of buckets match.,"@return boolean: True if dataset buckets match predefined buckets, false otherwise.","dataset with sortedKeys [""INFINITE_NEGATIVE"", ""1""] and buckets [Long.MIN_VALUE, 1] -> true (buckets match)
| dataset with sortedKeys [""INFINITE_NEGATIVE"", ""2""] and buckets [Long.MIN_VALUE, 1] -> false (buckets do not match)
| dataset with sortedKeys [""0:1"", ""2""] and buckets [1, 2] -> true (buckets match)",Dataset keys must be parseable integers after last colon; output is false if arrays differ in length or content.,"public boolean isCompatible(DataTable dataset) {
        Set<String> existingBuckets = new HashSet<>(dataset.getBucketList());
        Set<String> requiredBuckets = new HashSet<>(getRequiredBuckets());

        // Check if all required buckets exist and no extra buckets are present
        return existingBuckets.equals(requiredBuckets);
    }",1,Qwen2.5-Coder-7B-Instruct
636767611a6d9265ec018112,provideNextVertex,"@Override protected V provideNextVertex(){
  V v=super.provideNextVertex();
  for (int i=path.size() - 1; i >= 0; --i) {
    if (graph.containsEdge(path.get(i),v)) {
      break;
    }
    path.remove(i);
  }
  path.add(v);
  return v;
}
","/** 
 * {@inheritDoc}
 */
",Get next vertext from a graph.,Provides the next vertex for a path in a graph.,"Removes vertices from the path that are not connected to the next vertex, then adds the next vertex to the path and returns it.",@return V: The next vertex added to the path.,"currentPath with edges -> updatedPath (updates path by adding vertex)
path with vertices not connected to v -> pruned path (removes unconnected vertices)
no path changes needed -> same path (path remains unchanged)","Assumes path is non-empty and modifications will maintain path connectivity, output path will have v appended if possible.","@Override protected V provideNextVertex(){
  V v=super.provideNextVertex();
  for (int i=path.size() - 1; i >= 0; --i) {
    if (graph.containsEdge(path.get(i),v)) {
      break;
    }
    path.remove(i);
  }
  path.add(v);
  return v;
}
",0,reference
636767611a6d9265ec018112,provideNextVertex,"@Override protected V provideNextVertex(){
  V v=super.provideNextVertex();
  for (int i=path.size() - 1; i >= 0; --i) {
    if (graph.containsEdge(path.get(i),v)) {
      break;
    }
    path.remove(i);
  }
  path.add(v);
  return v;
}
","/** 
 * {@inheritDoc}
 */
",Get next vertext from a graph.,Provides the next vertex for a path in a graph.,"Removes vertices from the path that are not connected to the next vertex, then adds the next vertex to the path and returns it.",@return V: The next vertex added to the path.,"currentPath with edges -> updatedPath (updates path by adding vertex)
path with vertices not connected to v -> pruned path (removes unconnected vertices)
no path changes needed -> same path (path remains unchanged)","Assumes path is non-empty and modifications will maintain path connectivity, output path will have v appended if possible.","@Override  protected V provideNextVertex() {
    if(hasNext()){
        return iterator.next();
    }
    return null;
}",1,deepseek-coder-6.7b-instruct
636767131a6d9265ec017b23,addLineNumber,"final void addLineNumber(final int lineNumber){
  if (this.lineNumber == 0) {
    this.lineNumber=(short)lineNumber;
  }
 else {
    if (otherLineNumbers == null) {
      otherLineNumbers=new int[LINE_NUMBERS_CAPACITY_INCREMENT];
    }
    int otherLineNumberIndex=++otherLineNumbers[0];
    if (otherLineNumberIndex >= otherLineNumbers.length) {
      int[] newLineNumbers=new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT];
      System.arraycopy(otherLineNumbers,0,newLineNumbers,0,otherLineNumbers.length);
      otherLineNumbers=newLineNumbers;
    }
    otherLineNumbers[otherLineNumberIndex]=lineNumber;
  }
}
","/** 
 * Adds a source line number corresponding to this label.
 * @param lineNumber a source line number (which should be strictly positive).
 */
",Add the number of lines. ,Adds a line number to an internal list.,"The method adds a new line number to a list, initializing or extending the list if necessary.",@param lineNumber int: The line number to be added.,"lineNumber=5, initial=0 -> sets this.lineNumber to 5 (empty initial line number)
lineNumber=10, initial=5, list=null -> initializes otherLineNumbers list and adds 10 (non-zero initial line number)
lineNumber=15, list full -> extends list and adds 15 (list capacity exceeded)",Preconditions: lineNumber is an integer; this.lineNumber and otherLineNumbers exist. Postconditions: The line number is added to the list or initializes the list.,"final void addLineNumber(final int lineNumber){
  if (this.lineNumber == 0) {
    this.lineNumber=(short)lineNumber;
  }
 else {
    if (otherLineNumbers == null) {
      otherLineNumbers=new int[LINE_NUMBERS_CAPACITY_INCREMENT];
    }
    int otherLineNumberIndex=++otherLineNumbers[0];
    if (otherLineNumberIndex >= otherLineNumbers.length) {
      int[] newLineNumbers=new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT];
      System.arraycopy(otherLineNumbers,0,newLineNumbers,0,otherLineNumbers.length);
      otherLineNumbers=newLineNumbers;
    }
    otherLineNumbers[otherLineNumberIndex]=lineNumber;
  }
}
",0,reference
636767131a6d9265ec017b23,addLineNumber,"final void addLineNumber(final int lineNumber){
  if (this.lineNumber == 0) {
    this.lineNumber=(short)lineNumber;
  }
 else {
    if (otherLineNumbers == null) {
      otherLineNumbers=new int[LINE_NUMBERS_CAPACITY_INCREMENT];
    }
    int otherLineNumberIndex=++otherLineNumbers[0];
    if (otherLineNumberIndex >= otherLineNumbers.length) {
      int[] newLineNumbers=new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT];
      System.arraycopy(otherLineNumbers,0,newLineNumbers,0,otherLineNumbers.length);
      otherLineNumbers=newLineNumbers;
    }
    otherLineNumbers[otherLineNumberIndex]=lineNumber;
  }
}
","/** 
 * Adds a source line number corresponding to this label.
 * @param lineNumber a source line number (which should be strictly positive).
 */
",Add the number of lines. ,Adds a line number to an internal list.,"The method adds a new line number to a list, initializing or extending the list if necessary.",@param lineNumber int: The line number to be added.,"lineNumber=5, initial=0 -> sets this.lineNumber to 5 (empty initial line number)
lineNumber=10, initial=5, list=null -> initializes otherLineNumbers list and adds 10 (non-zero initial line number)
lineNumber=15, list full -> extends list and adds 15 (list capacity exceeded)",Preconditions: lineNumber is an integer; this.lineNumber and otherLineNumbers exist. Postconditions: The line number is added to the list or initializes the list.,"final void addLineNumber(final int lineNumber){
  final String line=String.format(""%2d "",lineNumber);
  final int lastIndex=method.indexOf(""}"");
  final int insertIndex=method.indexOf(""{"")+1;
  method=method.substring(0,lastIndex)+line+method.substring(insertIndex);
}",1,starcoder2-7b
636767dd1a6d9265ec0186f3,overrideName,"public void overrideName(String oldName,String newName){
  for (int i=0; i < columns.length; i++) {
    if (columns[i].equals(oldName)) {
      columns[i]=newName;
    }
  }
}
","/** 
 * Keep the same name replacement as  {@link ColumnName#overrideName(String,String)}
 * @param oldName to be replaced.
 * @param newName to use in the storage level.
 */
",Change the elements whose values are oldName to newName in column,Replaces old column names with new ones in an array.,"Iterates over the columns array, replacing occurrences of oldName with newName.","@param oldName String: Existing column name to be replaced
   @param newName String: New column name to set","[""A"", ""B"", ""C""], ""B"", ""D"" -> [""A"", ""D"", ""C""] (B replaced with D)
[""A"", ""A"", ""A""], ""A"", ""Z"" -> [""Z"", ""Z"", ""Z""] (All A's replaced with Z)
[""X"", ""Y""], ""Z"", ""W"" -> [""X"", ""Y""] (No change as Z not found)","Assumes columns is a non-null array of strings. After execution, columns will have all instances of oldName replaced with newName.","public void overrideName(String oldName,String newName){
  for (int i=0; i < columns.length; i++) {
    if (columns[i].equals(oldName)) {
      columns[i]=newName;
    }
  }
}
",0,reference
636767dd1a6d9265ec0186f3,overrideName,"public void overrideName(String oldName,String newName){
  for (int i=0; i < columns.length; i++) {
    if (columns[i].equals(oldName)) {
      columns[i]=newName;
    }
  }
}
","/** 
 * Keep the same name replacement as  {@link ColumnName#overrideName(String,String)}
 * @param oldName to be replaced.
 * @param newName to use in the storage level.
 */
",Change the elements whose values are oldName to newName in column,Replaces old column names with new ones in an array.,"Iterates over the columns array, replacing occurrences of oldName with newName.","@param oldName String: Existing column name to be replaced
   @param newName String: New column name to set","[""A"", ""B"", ""C""], ""B"", ""D"" -> [""A"", ""D"", ""C""] (B replaced with D)
[""A"", ""A"", ""A""], ""A"", ""Z"" -> [""Z"", ""Z"", ""Z""] (All A's replaced with Z)
[""X"", ""Y""], ""Z"", ""W"" -> [""X"", ""Y""] (No change as Z not found)","Assumes columns is a non-null array of strings. After execution, columns will have all instances of oldName replaced with newName.","public void overrideName(String oldName,String newName){
  int foundRow=findRow(oldName);
column[foundRow]=newName;
}",1,starcoder2-7b
636767631a6d9265ec018171,unlink,"private boolean unlink(ListNodeImpl<E> node){
  ListNodeImpl<E> prev=node.prev;
  ListNodeImpl<E> next=node.next;
  if (removeListNode(node)) {
    if (size == 0) {
      head=null;
    }
 else {
      link(prev,next);
      if (head == node) {
        head=next;
      }
    }
    return true;
  }
  return false;
}
","/** 
 * Remove the non null  {@code node} from the list. 
 */
","Remove the doubly circular linked list node.If success return true,otherwise return false.",Unlinks a node from a doubly linked list.,"Removes the specified node from the list and adjusts links accordingly. If the node is successfully removed, it updates the head if necessary.","@return boolean: True if the node was removed, false otherwise.","node in middle -> true (node removed, links updated)
node at head -> true (node removed, head updated)
non-existent node -> false (no change)",The list must contain nodes; the list size decreases if a node is removed.,"private boolean unlink(ListNodeImpl<E> node) {
    if (node == null || node.next == node) {
        return false;
    }
    
    ListNodeImpl<E> prev = node.prev;
    ListNodeImpl<E> next = node.next;
    
    prev.next = next;
    next.prev = prev;
    
    node.prev = null;
    node.next = null;
    
    size--;
    
    return true;
}",0,Qwen2.5-Coder-7B-Instruct
636767631a6d9265ec018171,unlink,"private boolean unlink(ListNodeImpl<E> node){
  ListNodeImpl<E> prev=node.prev;
  ListNodeImpl<E> next=node.next;
  if (removeListNode(node)) {
    if (size == 0) {
      head=null;
    }
 else {
      link(prev,next);
      if (head == node) {
        head=next;
      }
    }
    return true;
  }
  return false;
}
","/** 
 * Remove the non null  {@code node} from the list. 
 */
","Remove the doubly circular linked list node.If success return true,otherwise return false.",Unlinks a node from a doubly linked list.,"Removes the specified node from the list and adjusts links accordingly. If the node is successfully removed, it updates the head if necessary.","@return boolean: True if the node was removed, false otherwise.","node in middle -> true (node removed, links updated)
node at head -> true (node removed, head updated)
non-existent node -> false (no change)",The list must contain nodes; the list size decreases if a node is removed.,"private boolean unlink(ListNodeImpl<E> node){
if (node == null)
return false;
node.prev.next = node.next;
node.next.prev = node.prev;
return true;
}",1,starcoder2-7b
6367676c1a6d9265ec018220,stripFilenameExtension,"public static String stripFilenameExtension(String path){
  if (path == null) {
    return null;
  }
  int extIndex=path.lastIndexOf(EXTENSION_SEPARATOR);
  if (extIndex == -1) {
    return path;
  }
  int folderIndex=path.lastIndexOf(FOLDER_SEPARATOR);
  if (folderIndex > extIndex) {
    return path;
  }
  return path.substring(0,extIndex);
}
","/** 
 * Strip the filename extension from the given path, e.g. ""mypath/myfile.txt"" -&gt; ""mypath/myfile"".
 * @param path the file path (may be <code>null</code>)
 * @return the path with stripped filename extension,or <code>null</code> if none
 */
",Return the path without the extension.,Removes the file extension from a file path string.,The function checks for the last occurrence of a file extension and removes it unless it's part of a folder name.,"@param path String: The input file path.
@return String: The file path without an extension.","""file.txt"" -> ""file"" (removes extension)
""folder/file"" -> ""folder/file"" (no extension found)
""folder.ext/file"" -> ""folder.ext/file"" (extension part of folder)","Input can be null or a valid file path; the output is the path with the extension removed, if present and applicable.","public static String stripFilenameExtension(String path){
    if (path == null) {
        return null;
    }
    int lastDotIndex = path.lastIndexOf('.');
    if (lastDotIndex == -1 || lastDotIndex == 0 || path.lastIndexOf('/') > lastDotIndex) {
        return path;
    }
    return path.substring(0, lastDotIndex);
}",0,gpt-4-turbo
6367676c1a6d9265ec018220,stripFilenameExtension,"public static String stripFilenameExtension(String path){
  if (path == null) {
    return null;
  }
  int extIndex=path.lastIndexOf(EXTENSION_SEPARATOR);
  if (extIndex == -1) {
    return path;
  }
  int folderIndex=path.lastIndexOf(FOLDER_SEPARATOR);
  if (folderIndex > extIndex) {
    return path;
  }
  return path.substring(0,extIndex);
}
","/** 
 * Strip the filename extension from the given path, e.g. ""mypath/myfile.txt"" -&gt; ""mypath/myfile"".
 * @param path the file path (may be <code>null</code>)
 * @return the path with stripped filename extension,or <code>null</code> if none
 */
",Return the path without the extension.,Removes the file extension from a file path string.,The function checks for the last occurrence of a file extension and removes it unless it's part of a folder name.,"@param path String: The input file path.
@return String: The file path without an extension.","""file.txt"" -> ""file"" (removes extension)
""folder/file"" -> ""folder/file"" (no extension found)
""folder.ext/file"" -> ""folder.ext/file"" (extension part of folder)","Input can be null or a valid file path; the output is the path with the extension removed, if present and applicable.","public static String stripFilenameExtension(String path){
    return stripSuffix(path, extensionSeparator);
}",1,starcoder2-7b
636766fe1a6d9265ec017838,toPrimitive,"public static char[] toPrimitive(final Character[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_CHAR_ARRAY;
  }
  final char[] result=new char[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].charValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Characters to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Character</code> array, may be <code>null</code>
 * @return a <code>char</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Return a string which is consist of the values of elements in the given array.If array is equal to null,return null,or return ArrayUtils.EMPTY_CHAR_ARRAY if the size of array is equal to zero.",Convert an array of Character objects to a primitive char array.,"Converts a given Character array to a char array, returning null if input is null and an empty array if input is empty.","@param array Character[]: An array of Character objects to convert.
@return char[]: A primitive char array containing the converted characters.","new Character[]{'a', 'b', 'c'} -> new char[]{'a', 'b', 'c'} (conversion of Character array to char array)
new Character[]{} -> new char[]{} (empty Character array to empty char array)
null -> null (null input returns null)","Input array can be null or empty, output is either null, an empty char array, or a char array of the same length.","public static char[] toPrimitive(final Character[] array){
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return ArrayUtils.EMPTY_CHAR_ARRAY;
    } else {
        char[] primitiveArray = new char[array.length];
        for (int i = 0; i < array.length; i++) {
            primitiveArray[i] = array[i];
        }
        return primitiveArray;
    }
}",0,Qwen2.5-Coder-7B-Instruct
636766fe1a6d9265ec017838,toPrimitive,"public static char[] toPrimitive(final Character[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_CHAR_ARRAY;
  }
  final char[] result=new char[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=array[i].charValue();
  }
  return result;
}
","/** 
 * <p>Converts an array of object Characters to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>Character</code> array, may be <code>null</code>
 * @return a <code>char</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
","Return a string which is consist of the values of elements in the given array.If array is equal to null,return null,or return ArrayUtils.EMPTY_CHAR_ARRAY if the size of array is equal to zero.",Convert an array of Character objects to a primitive char array.,"Converts a given Character array to a char array, returning null if input is null and an empty array if input is empty.","@param array Character[]: An array of Character objects to convert.
@return char[]: A primitive char array containing the converted characters.","new Character[]{'a', 'b', 'c'} -> new char[]{'a', 'b', 'c'} (conversion of Character array to char array)
new Character[]{} -> new char[]{} (empty Character array to empty char array)
null -> null (null input returns null)","Input array can be null or empty, output is either null, an empty char array, or a char array of the same length.","public static char[] toPrimitive(final Character[] array){
return toPrimitive((Object[]) array);
}",1,starcoder2-7b
636766fa1a6d9265ec01779c,parseToken,"private String parseToken(final char[] terminators){
  char ch;
  i1=pos;
  i2=pos;
  while (hasChar()) {
    ch=chars[pos];
    if (isOneOf(ch,terminators)) {
      break;
    }
    i2++;
    pos++;
  }
  return getToken(false);
}
","/** 
 * Parses out a token until any of the given terminators is encountered.
 * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token
 * @return the token
 */
",Parses out a token until any of the given terminators is encountered and then return the token.,Extracts a token from a character array until a terminator is found.,It scans the character array starting at the current position and stops at the first terminator. It then returns the extracted token.,@param terminators char[]: Array of characters that signify the end of a token. @return String: The extracted token from the character array.,"""abc,"" with terminators ',' -> ""abc"" (comma is the terminator)
""hello;world"" with terminators ';' -> ""hello"" (semicolon is the terminator)
""test123"" with terminators ' ' -> ""test123"" (no terminator found, return whole string)",The function assumes the character array and terminators are properly defined. The current position updates after the function processes.,"private String parseToken(final char[] terminators){
  char ch;
  i1=pos;
  i2=pos;
  while (hasChar()) {
    ch=chars[pos];
    if (isOneOf(ch,terminators)) {
      break;
    }
    i2++;
    pos++;
  }
  return getToken(false);
}
",0,reference
636766fa1a6d9265ec01779c,parseToken,"private String parseToken(final char[] terminators){
  char ch;
  i1=pos;
  i2=pos;
  while (hasChar()) {
    ch=chars[pos];
    if (isOneOf(ch,terminators)) {
      break;
    }
    i2++;
    pos++;
  }
  return getToken(false);
}
","/** 
 * Parses out a token until any of the given terminators is encountered.
 * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token
 * @return the token
 */
",Parses out a token until any of the given terminators is encountered and then return the token.,Extracts a token from a character array until a terminator is found.,It scans the character array starting at the current position and stops at the first terminator. It then returns the extracted token.,@param terminators char[]: Array of characters that signify the end of a token. @return String: The extracted token from the character array.,"""abc,"" with terminators ',' -> ""abc"" (comma is the terminator)
""hello;world"" with terminators ';' -> ""hello"" (semicolon is the terminator)
""test123"" with terminators ' ' -> ""test123"" (no terminator found, return whole string)",The function assumes the character array and terminators are properly defined. The current position updates after the function processes.,"private String parseToken(final char[] terminators){
	int current = 0;

	while(current < text.length()){
		char currentChar = text.charAt(current);

		if (Character.isWhitespace(currentChar) || ArrayUtils.contains(terminators, currentChar)){
			break;
		}
		current++;
	}
	return new String(text, 0, current);
}",1,starcoder2-7b
636767691a6d9265ec0181a7,trimLeadingCharacter,"public static String trimLeadingCharacter(String str,char leadingCharacter){
  if (!hasLength(str)) {
    return str;
  }
  StringBuilder sb=new StringBuilder(str);
  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {
    sb.deleteCharAt(0);
  }
  return sb.toString();
}
","/** 
 * Trim all occurrences of the supplied leading character from the given String.
 * @param str the String to check
 * @param leadingCharacter the leading character to be trimmed
 * @return the trimmed String
 */
","Trim all the characters which are equal to the given character and appear at the beginning of the given string,and return the trimmed string.",Removes leading specific characters from a string.,The function removes all occurrences of a specified leading character from the beginning of a given string until a different character is encountered.,"@param str String: The input string from which leading characters are to be removed.
@param leadingCharacter char: The character to remove from the start of the string.
@return String: The modified string with leading characters removed.","""00012345"", '0' -> ""12345"" (removes all '0' from start)
""abcabc"", 'a' -> ""bcabc"" (removes first 'a')
""111111"", '1' -> """" (removes all '1' leaving empty)","Input may be null or empty; if non-empty, only leading specified characters are removed. After execution, the returned string should have no leading specified characters unless not present initially.","public static String trimLeadingCharacter(String str, char leadingCharacter) {
    if (str == null) {
        return null;
    }
    int index = 0;
    while (index < str.length() && str.charAt(index) == leadingCharacter) {
        index++;
    }
    return str.substring(index);
}",0,Phi-3-mini-4k-instruct
636767691a6d9265ec0181a7,trimLeadingCharacter,"public static String trimLeadingCharacter(String str,char leadingCharacter){
  if (!hasLength(str)) {
    return str;
  }
  StringBuilder sb=new StringBuilder(str);
  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {
    sb.deleteCharAt(0);
  }
  return sb.toString();
}
","/** 
 * Trim all occurrences of the supplied leading character from the given String.
 * @param str the String to check
 * @param leadingCharacter the leading character to be trimmed
 * @return the trimmed String
 */
","Trim all the characters which are equal to the given character and appear at the beginning of the given string,and return the trimmed string.",Removes leading specific characters from a string.,The function removes all occurrences of a specified leading character from the beginning of a given string until a different character is encountered.,"@param str String: The input string from which leading characters are to be removed.
@param leadingCharacter char: The character to remove from the start of the string.
@return String: The modified string with leading characters removed.","""00012345"", '0' -> ""12345"" (removes all '0' from start)
""abcabc"", 'a' -> ""bcabc"" (removes first 'a')
""111111"", '1' -> """" (removes all '1' leaving empty)","Input may be null or empty; if non-empty, only leading specified characters are removed. After execution, the returned string should have no leading specified characters unless not present initially.","public static String trimLeadingCharacter(String str,char leadingCharacter){
String trimmedString = """";

//trim any of the given characters which are equal to the given character and appear at the beginning of the given string.
for(int i=0;i<str.length();i++){
if(str.charAt(i) != leadingCharacter){
break;
}else{
trimmedString += str.charAt(i);
}
}

//return the trimmed string.
return trimmedString;
}",1,CodeLlama-7b-Instruct-hf
636767041a6d9265ec01790f,toObject,"public static Integer[] toObject(final int[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;
  }
  final Integer[] result=new Integer[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=new Integer(array[i]);
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive ints to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  an <code>int</code> array
 * @return an <code>Integer</code> array, <code>null</code> if null array input
 */
",Return an array of Integer objects which are converted from an array of primitive ints.,Converts a primitive int array to an Integer object array.,"The function checks for null or empty arrays and returns an array of Integer objects, each representing an element in the input array.","@param array int[]: Array of primitive integers to be converted.
   @return Integer[]: Array of Integer objects equivalent to the input array.","[1, 2, 3] -> [Integer(1)
, Integer(2)
, Integer(3)
] (convert elements)
[] -> [] (empty array conversion)
null -> null (null input returns null)",Input can be null or an array of any length. Output will be an array of Integer objects or null if input is null.,"public static Integer[] toObject(final int[] array){
	if(null == array){
		return null;
	}else{
		final int len = array.length;
		final Integer[] ret = new Integer[len];
		for(int i = 0; i < len; i++){
			ret[i] = array[i];
		}
		return ret;
	}
}",0,CodeLlama-7b-Instruct-hf
636767041a6d9265ec01790f,toObject,"public static Integer[] toObject(final int[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;
  }
  final Integer[] result=new Integer[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=new Integer(array[i]);
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive ints to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  an <code>int</code> array
 * @return an <code>Integer</code> array, <code>null</code> if null array input
 */
",Return an array of Integer objects which are converted from an array of primitive ints.,Converts a primitive int array to an Integer object array.,"The function checks for null or empty arrays and returns an array of Integer objects, each representing an element in the input array.","@param array int[]: Array of primitive integers to be converted.
   @return Integer[]: Array of Integer objects equivalent to the input array.","[1, 2, 3] -> [Integer(1)
, Integer(2)
, Integer(3)
] (convert elements)
[] -> [] (empty array conversion)
null -> null (null input returns null)",Input can be null or an array of any length. Output will be an array of Integer objects or null if input is null.,"public static Integer[] toObject(final int[] array) {
    // Create an array of Integer objects with same size
    Integer[] objArray = new Integer[array.length];

    // Convert each element from int to Integer and assign it to the corresponding index
    for(int i = 0; i < array.length; i++) {
        objArray[i] = Integer.valueOf(array[i]);
    }

    // return the converted array
    return objArray;
}",1,deepseek-coder-6.7b-instruct
636766fa1a6d9265ec0177a4,toObject,"public static Double[] toObject(final double[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;
  }
  final Double[] result=new Double[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=new Double(array[i]);
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive doubles to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>double</code> array
 * @return a <code>Double</code> array, <code>null</code> if null array input
 */
",Return an array of Double objects which are converted from an array of primitive doubles.,Converts a primitive double array to a Double object array.,"The function checks if the input array is null or empty, returning null or an empty Double array respectively. It converts each element to a Double object for non-empty arrays.","@param array double[]: Input array of primitive doubles.
@return Double[]: Converted array of Double objects.","null -> null (Null input returns null)
[] -> [] (Empty array to empty object array)
[1.0, 2.0] -> [1.0, 2.0] (Primitive to object conversion)","Input array can be null or of any length, function outputs null, empty object array, or a fully converted object array.","public static Double[] toObject(final double[] array){
    if(array == null){
        return null;
    }
    Double[] result = new Double[array.length];
    for(int i = 0; i < array.length; i++){
        result[i] = Double.valueOf(array[i]);
    }
    return result;
}",0,CodeLlama-7b-Instruct-hf
636766fa1a6d9265ec0177a4,toObject,"public static Double[] toObject(final double[] array){
  if (array == null) {
    return null;
  }
 else   if (array.length == 0) {
    return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;
  }
  final Double[] result=new Double[array.length];
  for (int i=0; i < array.length; i++) {
    result[i]=new Double(array[i]);
  }
  return result;
}
","/** 
 * <p>Converts an array of primitive doubles to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  a <code>double</code> array
 * @return a <code>Double</code> array, <code>null</code> if null array input
 */
",Return an array of Double objects which are converted from an array of primitive doubles.,Converts a primitive double array to a Double object array.,"The function checks if the input array is null or empty, returning null or an empty Double array respectively. It converts each element to a Double object for non-empty arrays.","@param array double[]: Input array of primitive doubles.
@return Double[]: Converted array of Double objects.","null -> null (Null input returns null)
[] -> [] (Empty array to empty object array)
[1.0, 2.0] -> [1.0, 2.0] (Primitive to object conversion)","Input array can be null or of any length, function outputs null, empty object array, or a fully converted object array.","public static Double[] toObject(final double[] array) {
        Double[] result = new Double[array.length];
        for (int i = 0; i < array.length; i++) {
            result[i] = array[i];
        }
        return result;
    }",1,Qwen2.5-Coder-7B-Instruct
636767461a6d9265ec017d0e,computeSuffixSum,"private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){
  List<Integer> suffixSum=new ArrayList<>(Collections.nCopies(bounds.size(),0));
  long sum=0;
  for (int i=bounds.size() - 1; i >= 0; i--) {
    suffixSum.set(i,(int)Math.min(Integer.MAX_VALUE,sum));
    sum+=bounds.get(i);
  }
  return Pair.of(suffixSum,sum);
}
","/** 
 * Computes a suffix sum of the  {@code bounds}. Returns computed suffix sum and the sum of all elements in the  {@code bounds list}.
 * @param bounds list of integers.
 * @return computed pair of suffix sum list and a sum of all elements.
 */
",Return a pair of the list of suffix sum and the sum of all elements of bounds.,Calculate reverse cumulative sums for a list.,"Computes a list of suffix sums from given bounds, constraining each to Integer.MAX_VALUE, and returns this list with the total sum.","@param bounds List<Integer>: List of integers to compute suffix sums.
@return Pair<List<Integer>, Long>: Suffix sums and total sum of integers in the input list.","[1, 2, 3] -> ([0, 3, 2], 6)
(Calculates suffix sums and total sum)
[1000000, 2000000] -> ([0, 1000000], 3000000)
(Handles large numbers)
[] -> ([], 0)
(Empty input produces empty output and sum 0)","Input list must be non-null, output list size matches input with total sum computed.","private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){
  List<Integer> suffixSum=new ArrayList<>(Collections.nCopies(bounds.size(),0));
  long sum=0;
  for (int i=bounds.size() - 1; i >= 0; i--) {
    suffixSum.set(i,(int)Math.min(Integer.MAX_VALUE,sum));
    sum+=bounds.get(i);
  }
  return Pair.of(suffixSum,sum);
}
",0,reference
636767461a6d9265ec017d0e,computeSuffixSum,"private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){
  List<Integer> suffixSum=new ArrayList<>(Collections.nCopies(bounds.size(),0));
  long sum=0;
  for (int i=bounds.size() - 1; i >= 0; i--) {
    suffixSum.set(i,(int)Math.min(Integer.MAX_VALUE,sum));
    sum+=bounds.get(i);
  }
  return Pair.of(suffixSum,sum);
}
","/** 
 * Computes a suffix sum of the  {@code bounds}. Returns computed suffix sum and the sum of all elements in the  {@code bounds list}.
 * @param bounds list of integers.
 * @return computed pair of suffix sum list and a sum of all elements.
 */
",Return a pair of the list of suffix sum and the sum of all elements of bounds.,Calculate reverse cumulative sums for a list.,"Computes a list of suffix sums from given bounds, constraining each to Integer.MAX_VALUE, and returns this list with the total sum.","@param bounds List<Integer>: List of integers to compute suffix sums.
@return Pair<List<Integer>, Long>: Suffix sums and total sum of integers in the input list.","[1, 2, 3] -> ([0, 3, 2], 6)
(Calculates suffix sums and total sum)
[1000000, 2000000] -> ([0, 1000000], 3000000)
(Handles large numbers)
[] -> ([], 0)
(Empty input produces empty output and sum 0)","Input list must be non-null, output list size matches input with total sum computed.","private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){
	int k = bounds.size();
	List<Integer> s = new ArrayList<>(k);
	s.add(bounds.get(0));
	Long t = s.get(0);
	for(int i=1;i<k;i++){
		int h = s.get(i-1) + bounds.get(i);
		s.add(h);
		t += h;
	}
	return new Pair<>(s,t);
}",1,starcoder2-7b
636767491a6d9265ec017d90,reverse,"public static final <V>void reverse(V[] arr,int from,int to){
  for (int i=from, j=to; i < j; ++i, --j) {
    swap(arr,i,j);
  }
}
","/** 
 * Reverses the order of the elements in the specified range within the given array.
 * @param < V > the type of elements in the array
 * @param arr the array
 * @param from the index of the first element (inclusive) inside the range to reverse
 * @param to the index of the last element (inclusive) inside the range to reverse
 */
",Reverse the order of the given elements in the specified range.,Reverses array elements between specified indices.,The function reverses the order of elements in the array from index 'from' to 'to'. It swaps elements symmetrically until the middle of the specified range is reached.,"@param arr V[]: Array whose elements are to be reversed.
   @param from int: Start index of the segment to reverse.
   @param to int: End index of the segment to reverse.","[1, 2, 3, 4, 5], 1, 3 -> [1, 4, 3, 2, 5] (subarray [2, 3, 4] reversed)
['a', 'b', 'c', 'd'], 0, 2 -> ['c', 'b', 'a', 'd'] (subarray ['a', 'b', 'c'] reversed)
[5, 4, 3], 0, 2 -> [3, 4, 5] (entire array reversed)","Indices must be within array bounds; 'from' <= 'to'. After execution, the array elements between 'from' and 'to' are reversed.","public static final <V> void reverse(V[] arr, int from, int to) {
    if (arr == null || from < 0 || to >= arr.length || from >= to) {
        return;
    }
    while (from < to) {
        V temp = arr[from];
        arr[from] = arr[to];
        arr[to] = temp;
        from++;
        to--;
    }
}",0,gpt-4-turbo
636767491a6d9265ec017d90,reverse,"public static final <V>void reverse(V[] arr,int from,int to){
  for (int i=from, j=to; i < j; ++i, --j) {
    swap(arr,i,j);
  }
}
","/** 
 * Reverses the order of the elements in the specified range within the given array.
 * @param < V > the type of elements in the array
 * @param arr the array
 * @param from the index of the first element (inclusive) inside the range to reverse
 * @param to the index of the last element (inclusive) inside the range to reverse
 */
",Reverse the order of the given elements in the specified range.,Reverses array elements between specified indices.,The function reverses the order of elements in the array from index 'from' to 'to'. It swaps elements symmetrically until the middle of the specified range is reached.,"@param arr V[]: Array whose elements are to be reversed.
   @param from int: Start index of the segment to reverse.
   @param to int: End index of the segment to reverse.","[1, 2, 3, 4, 5], 1, 3 -> [1, 4, 3, 2, 5] (subarray [2, 3, 4] reversed)
['a', 'b', 'c', 'd'], 0, 2 -> ['c', 'b', 'a', 'd'] (subarray ['a', 'b', 'c'] reversed)
[5, 4, 3], 0, 2 -> [3, 4, 5] (entire array reversed)","Indices must be within array bounds; 'from' <= 'to'. After execution, the array elements between 'from' and 'to' are reversed.","public static final <V>void reverse(V[] arr,int from,int to){
    for(int i=from, j=to-1; i<j; i++,j--){
        V t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
    }
}",1,CodeLlama-7b-Instruct-hf
6367674a1a6d9265ec017da9,moveAllListNodes,"private void moveAllListNodes(DoublyLinkedList<E> list){
  for (ListNodeIteratorImpl it=list.new ListNodeIteratorImpl(0); it.hasNext(); ) {
    ListNodeImpl<E> node=it.nextNode();
    assert node.list == list;
    node.list=this;
  }
  size+=list.size;
  list.size=0;
  modCount++;
  list.modCount++;
}
","/** 
 * Atomically moves all  {@link ListNode ListNodes} from {@code list} to this list as if eachnode was removed with  {@link #removeListNode(ListNodeImpl)} from {@code list} andsubsequently added to this list by  {@link #addListNode(ListNodeImpl)}.
 */
",Move the nodes of the given doubly linked list to a new list sequentially.,Moves nodes from one list to another.,"Transfers all nodes from a given list to the current list, updating list size and modification counters.",@param <E> DoublyLinkedList<E>: List from which nodes are moved,"list1, list2; list2 not empty -> list1 has all nodes (list2 is empty after operation)
list1 empty, list2 -> all nodes in list1 (list2 becomes empty)","Both lists are non-null, nodes from one list are moved to another, source list is emptied.","private void moveAllListNodes(DoublyLinkedList<E> list){
  for (ListNodeIteratorImpl it=list.new ListNodeIteratorImpl(0); it.hasNext(); ) {
    ListNodeImpl<E> node=it.nextNode();
    assert node.list == list;
    node.list=this;
  }
  size+=list.size;
  list.size=0;
  modCount++;
  list.modCount++;
}
",0,reference
6367674a1a6d9265ec017da9,moveAllListNodes,"private void moveAllListNodes(DoublyLinkedList<E> list){
  for (ListNodeIteratorImpl it=list.new ListNodeIteratorImpl(0); it.hasNext(); ) {
    ListNodeImpl<E> node=it.nextNode();
    assert node.list == list;
    node.list=this;
  }
  size+=list.size;
  list.size=0;
  modCount++;
  list.modCount++;
}
","/** 
 * Atomically moves all  {@link ListNode ListNodes} from {@code list} to this list as if eachnode was removed with  {@link #removeListNode(ListNodeImpl)} from {@code list} andsubsequently added to this list by  {@link #addListNode(ListNodeImpl)}.
 */
",Move the nodes of the given doubly linked list to a new list sequentially.,Moves nodes from one list to another.,"Transfers all nodes from a given list to the current list, updating list size and modification counters.",@param <E> DoublyLinkedList<E>: List from which nodes are moved,"list1, list2; list2 not empty -> list1 has all nodes (list2 is empty after operation)
list1 empty, list2 -> all nodes in list1 (list2 becomes empty)","Both lists are non-null, nodes from one list are moved to another, source list is emptied.","private void moveAllListNodes(DoublyLinkedList<E> list){
    if(list == null){
        return;
    }
    headNode = list.headNode;
    tailNode = list.tailNode;
    list.headNode = list.tailNode = null; //set the links in the old list null.
}",1,starcoder2-7b
636767151a6d9265ec017b6b,startsWith,"private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){
  if (str == null || prefix == null) {
    return str == null && prefix == null;
  }
  if (prefix.length() > str.length()) {
    return false;
  }
  return str.regionMatches(ignoreCase,0,prefix,0,prefix.length());
}
","/** 
 * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>
 * @see String#startsWith(String)
 * @param str  the String to check, may be null
 * @param prefix the prefix to find, may be null
 * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.
 * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>
 */
","Return true if the given string has the specified prefix with optional cases which can be ignored,or both string and prefix are null.Otherwise return false. ",Checks if a string starts with a specified prefix.,"Determines if the given string begins with the specified prefix, optionally ignoring case.","@param str String: The main string to check.
   @param prefix String: The prefix to compare against the start of the main string.
   @param ignoreCase boolean: Whether to ignore case during comparison.
   @return boolean: True if the main string starts with the prefix, considering case sensitivity based on the ignoreCase flag.","""hello"", ""he"", false -> true (Exact case match)
""hello"", ""HE"", true -> true (Case ignored)
""world"", ""wo"", false -> true (Exact case match)
""hello"", null, false -> false (Null prefix not matched)",Strings may be null; function returns false if prefix is longer than the main string.,"private static boolean startsWith(final String str, final String prefix, final boolean ignoreCase) {
    if (str == null || prefix == null) {
        return str == null && prefix == null;
    }
    if (ignoreCase) {
        return str.toLowerCase().startsWith(prefix.toLowerCase());
    } else {
        return str.startsWith(prefix);
    }
}",0,gpt-4-turbo
636767151a6d9265ec017b6b,startsWith,"private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){
  if (str == null || prefix == null) {
    return str == null && prefix == null;
  }
  if (prefix.length() > str.length()) {
    return false;
  }
  return str.regionMatches(ignoreCase,0,prefix,0,prefix.length());
}
","/** 
 * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>
 * @see String#startsWith(String)
 * @param str  the String to check, may be null
 * @param prefix the prefix to find, may be null
 * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.
 * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>
 */
","Return true if the given string has the specified prefix with optional cases which can be ignored,or both string and prefix are null.Otherwise return false. ",Checks if a string starts with a specified prefix.,"Determines if the given string begins with the specified prefix, optionally ignoring case.","@param str String: The main string to check.
   @param prefix String: The prefix to compare against the start of the main string.
   @param ignoreCase boolean: Whether to ignore case during comparison.
   @return boolean: True if the main string starts with the prefix, considering case sensitivity based on the ignoreCase flag.","""hello"", ""he"", false -> true (Exact case match)
""hello"", ""HE"", true -> true (Case ignored)
""world"", ""wo"", false -> true (Exact case match)
""hello"", null, false -> false (Null prefix not matched)",Strings may be null; function returns false if prefix is longer than the main string.,"public static boolean startsWith(final String str, final String prefix, final boolean ignoreCase) {
    if (str == null || prefix == null) {
        return false;
    }
    if (str.length() < prefix.length() || (ignoreCase && str.equalsIgnoreCase(prefix))) {
        return true;
    }
    return str.startsWith(prefix);
}",1,Phi-3-mini-4k-instruct
636766fe1a6d9265ec01781c,toCharacterObject,"public static Character toCharacterObject(final char ch){
  if (ch < CharUtils.CHAR_ARRAY.length) {
    return CharUtils.CHAR_ARRAY[ch];
  }
  return new Character(ch);
}
","/** 
 * <p>Converts the character to a Character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same Character object each time.</p> <pre> CharUtils.toCharacterObject(' ')  = ' ' CharUtils.toCharacterObject('A')  = 'A' </pre>
 * @param ch  the character to convert
 * @return a Character of the specified character
 */
",Return the Character object converted from the given character.,Converts a char to a Character object using an array cache.,"Checks if the character can be returned from a predefined array; otherwise, creates a new Character object.","@param ch char: input character
   @return Character: Character object corresponding to the input","'a' -> Character object (using the array)
256 -> Character object (created new)
65 -> Character object (using the array)",Input character is a valid char; returns a Character object.,"public static Character toCharacterObject(final char ch){
    return ch;
}",0,starcoder2-7b
636766fe1a6d9265ec01781c,toCharacterObject,"public static Character toCharacterObject(final char ch){
  if (ch < CharUtils.CHAR_ARRAY.length) {
    return CharUtils.CHAR_ARRAY[ch];
  }
  return new Character(ch);
}
","/** 
 * <p>Converts the character to a Character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same Character object each time.</p> <pre> CharUtils.toCharacterObject(' ')  = ' ' CharUtils.toCharacterObject('A')  = 'A' </pre>
 * @param ch  the character to convert
 * @return a Character of the specified character
 */
",Return the Character object converted from the given character.,Converts a char to a Character object using an array cache.,"Checks if the character can be returned from a predefined array; otherwise, creates a new Character object.","@param ch char: input character
   @return Character: Character object corresponding to the input","'a' -> Character object (using the array)
256 -> Character object (created new)
65 -> Character object (using the array)",Input character is a valid char; returns a Character object.,"public static Character toCharacterObject(final char ch){
String str= String.valueOf(ch);
return new Character(str);
}",1,starcoder2-7b
636766fb1a6d9265ec0177c1,isAsciiAlphaUpper,"public static boolean isAsciiAlphaUpper(final char ch){
  return ch >= 'A' && ch <= 'Z';
}
","/** 
 * <p>Checks whether the character is ASCII 7 bit alphabetic upper case.</p> <pre> CharUtils.isAsciiAlphaUpper('a')  = false CharUtils.isAsciiAlphaUpper('A')  = true CharUtils.isAsciiAlphaUpper('3')  = false CharUtils.isAsciiAlphaUpper('-')  = false CharUtils.isAsciiAlphaUpper('\n') = false CharUtils.isAsciiAlphaUpper('&copy;') = false </pre>
 * @param ch  the character to check
 * @return true if between 65 and 90 inclusive
 */
",Return true if the character is ASCII alphabetic upper case.Otherwise return false.,Checks if a character is an uppercase ASCII letter.,Determines if the input character is an uppercase English alphabetic character by comparing its value to ASCII ranges.,"@param ch char: Character to be evaluated
   @return boolean: True if the character is an uppercase ASCII letter, false otherwise","'A' -> true (A is uppercase)
'Z' -> true (Z is uppercase)
'a' -> false (a is lowercase)
'1' -> false (1 is not a letter)","Input is a single character, output is true only if the input is between 'A' and 'Z' (inclusive).","public static boolean isAsciiAlphaUpper(final char ch){
	return (ch >= 'A') && (ch <= 'Z');
}",0,CodeLlama-7b-Instruct-hf
636766fb1a6d9265ec0177c1,isAsciiAlphaUpper,"public static boolean isAsciiAlphaUpper(final char ch){
  return ch >= 'A' && ch <= 'Z';
}
","/** 
 * <p>Checks whether the character is ASCII 7 bit alphabetic upper case.</p> <pre> CharUtils.isAsciiAlphaUpper('a')  = false CharUtils.isAsciiAlphaUpper('A')  = true CharUtils.isAsciiAlphaUpper('3')  = false CharUtils.isAsciiAlphaUpper('-')  = false CharUtils.isAsciiAlphaUpper('\n') = false CharUtils.isAsciiAlphaUpper('&copy;') = false </pre>
 * @param ch  the character to check
 * @return true if between 65 and 90 inclusive
 */
",Return true if the character is ASCII alphabetic upper case.Otherwise return false.,Checks if a character is an uppercase ASCII letter.,Determines if the input character is an uppercase English alphabetic character by comparing its value to ASCII ranges.,"@param ch char: Character to be evaluated
   @return boolean: True if the character is an uppercase ASCII letter, false otherwise","'A' -> true (A is uppercase)
'Z' -> true (Z is uppercase)
'a' -> false (a is lowercase)
'1' -> false (1 is not a letter)","Input is a single character, output is true only if the input is between 'A' and 'Z' (inclusive).","public static boolean isAsciiAlphaUpper(final char ch){
if(!(((ch)>=91) && ((ch)<=90))) {
{
return false;
}
}
return true;
}",1,CodeLlama-7b-Instruct-hf
636767781a6d9265ec018250,decide,"public int decide(LoggingEvent event){
  String msg=event.getRenderedMessage();
  if (msg == null || stringToMatch == null)   return Filter.NEUTRAL;
  if (msg.indexOf(stringToMatch) == -1) {
    return Filter.NEUTRAL;
  }
 else {
    if (acceptOnMatch) {
      return Filter.ACCEPT;
    }
 else {
      return Filter.DENY;
    }
  }
}
","/** 
 * Returns  {@link Filter#NEUTRAL} is there is no string match.
 */
",Return a decision based on the message generated by the event and whether the given string is matched.,Determines filter result based on message match.,"Checks if a message contains a specific string and returns ACCEPT, DENY, or NEUTRAL based on match and settings.","@param event LoggingEvent: the event containing the message.
   @return int: the filter decision, either ACCEPT, DENY, or NEUTRAL.","message containing ""error"", acceptOnMatch=true -> Filter.ACCEPT (matches and acceptOnMatch is true)
message containing ""error"", acceptOnMatch=false -> Filter.DENY (matches but acceptOnMatch is false)
message not containing ""error"" -> Filter.NEUTRAL (does not match)",String to match and message must be non-null for relevant comparison; returns a filter result.,"public int decide(LoggingEvent event){
  String msg=event.getRenderedMessage();
  if (msg == null || stringToMatch == null)   return Filter.NEUTRAL;
  if (msg.indexOf(stringToMatch) == -1) {
    return Filter.NEUTRAL;
  }
 else {
    if (acceptOnMatch) {
      return Filter.ACCEPT;
    }
 else {
      return Filter.DENY;
    }
  }
}
",0,reference
636767781a6d9265ec018250,decide,"public int decide(LoggingEvent event){
  String msg=event.getRenderedMessage();
  if (msg == null || stringToMatch == null)   return Filter.NEUTRAL;
  if (msg.indexOf(stringToMatch) == -1) {
    return Filter.NEUTRAL;
  }
 else {
    if (acceptOnMatch) {
      return Filter.ACCEPT;
    }
 else {
      return Filter.DENY;
    }
  }
}
","/** 
 * Returns  {@link Filter#NEUTRAL} is there is no string match.
 */
",Return a decision based on the message generated by the event and whether the given string is matched.,Determines filter result based on message match.,"Checks if a message contains a specific string and returns ACCEPT, DENY, or NEUTRAL based on match and settings.","@param event LoggingEvent: the event containing the message.
   @return int: the filter decision, either ACCEPT, DENY, or NEUTRAL.","message containing ""error"", acceptOnMatch=true -> Filter.ACCEPT (matches and acceptOnMatch is true)
message containing ""error"", acceptOnMatch=false -> Filter.DENY (matches but acceptOnMatch is false)
message not containing ""error"" -> Filter.NEUTRAL (does not match)",String to match and message must be non-null for relevant comparison; returns a filter result.,"public int decide(LoggingEvent event){
    // Retrieve the logger name from the event
    String loggerName = event.getLoggerName();
    // Check if the logger name matches the specified pattern or condition
    if (loggerName.equals(""com.example.logger"")) {
        return Decision.ACCEPT;
    } else {
        return Decision.DENY;
    }
}",1,Qwen2.5-Coder-7B-Instruct
636766861a6d9265ec017553,isTemplateVariablePresent,"public final boolean isTemplateVariablePresent(String name){
  for (  String s : templateVariables) {
    if (s.equals(name))     return true;
  }
  return false;
}
","/** 
 * Ascertain if a template variable is a member of this template.
 * @param name name The template variable.
 * @return true if the template variable is a member of the template, otherwisefalse.
 */
","Return true if the given name is a member variable of this template,otherwise return false.",Check if a string is present in a list.,"The function iterates over a list of strings and returns true if the specified string is found; otherwise, it returns false.","@param name String: the string to search for in the list.
@return boolean: true if the string is present, false otherwise.","""var1"" -> true (List contains ""var1"")
""unknown"" -> false (List does not contain ""unknown"")
""template"" -> true (List contains ""template"")",Input string is non-null. List of template variables is initialized and non-null.,"public final boolean isTemplateVariablePresent(String name){
  for (  String s : templateVariables) {
    if (s.equals(name))     return true;
  }
  return false;
}
",0,reference
636766861a6d9265ec017553,isTemplateVariablePresent,"public final boolean isTemplateVariablePresent(String name){
  for (  String s : templateVariables) {
    if (s.equals(name))     return true;
  }
  return false;
}
","/** 
 * Ascertain if a template variable is a member of this template.
 * @param name name The template variable.
 * @return true if the template variable is a member of the template, otherwisefalse.
 */
","Return true if the given name is a member variable of this template,otherwise return false.",Check if a string is present in a list.,"The function iterates over a list of strings and returns true if the specified string is found; otherwise, it returns false.","@param name String: the string to search for in the list.
@return boolean: true if the string is present, false otherwise.","""var1"" -> true (List contains ""var1"")
""unknown"" -> false (List does not contain ""unknown"")
""template"" -> true (List contains ""template"")",Input string is non-null. List of template variables is initialized and non-null.,"public final boolean isTemplateVariablePresent(String name) {
    for (MemberVariable variable : template.getMemberVariables()) {
        if (variable.getName().equals(name)) {
            return true;
        }
    }
    return false;
}",1,Phi-3-mini-4k-instruct
6367670a1a6d9265ec0179d9,length,"public static int length(final String str){
  return str == null ? 0 : str.length();
}
","/** 
 * Gets a String's length or <code>0</code> if the String is <code>null</code>.
 * @param str a String or <code>null</code>
 * @return String length or <code>0</code> if the String is <code>null</code>.
 * @since 2.4
 */
","Return the given string's length.If the string is null,and zero will be returned.",Returns string length or zero if null.,Determines the length of the input string. Returns 0 if the input is null.,"@param str String: Input string to measure
   @return int: The length of the string or 0 if null","""hello"" -> 5 (normal case)
null -> 0 (null input)
"""" -> 0 (empty string)",Input can be a string or null. Returns the length of the string or 0 for null input.,"public static int length(final String str){
    if(str == null){
        return 0;
    }else{
        return str.length();
    }
}",0,deepseek-coder-6.7b-instruct
6367670a1a6d9265ec0179d9,length,"public static int length(final String str){
  return str == null ? 0 : str.length();
}
","/** 
 * Gets a String's length or <code>0</code> if the String is <code>null</code>.
 * @param str a String or <code>null</code>
 * @return String length or <code>0</code> if the String is <code>null</code>.
 * @since 2.4
 */
","Return the given string's length.If the string is null,and zero will be returned.",Returns string length or zero if null.,Determines the length of the input string. Returns 0 if the input is null.,"@param str String: Input string to measure
   @return int: The length of the string or 0 if null","""hello"" -> 5 (normal case)
null -> 0 (null input)
"""" -> 0 (empty string)",Input can be a string or null. Returns the length of the string or 0 for null input.,"public static int length(final String str) {
    return str.length();
}",1,Phi-3-mini-4k-instruct
636767ab1a6d9265ec018676,isHex,"private static boolean isHex(final char c){
  return ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F');
}
","/** 
 * Is this a hex digit?
 */
","Return true if the given character is a hex digit,otherwise return false.",Checks if a character is a hexadecimal digit.,"Determines if the input character c is a valid hexadecimal character (0-9, a-f, A-F).","@param c char: input character to be checked @return boolean: true if c is a hexadecimal character, false otherwise","'0' -> true ('0' is a hex digit)
'g' -> false ('g' is not a hex digit)
'F' -> true ('F' is a hex digit)","Input is a single character, output is a boolean indicating if it's a hexadecimal digit.","private static boolean isHex(final char c){
if('0'<=c && c<='9') return true;
if('a'<=c && c<='f') return true;
if('A'<=c && c<='F') return true;
return false;
}",0,starcoder2-7b
636767ab1a6d9265ec018676,isHex,"private static boolean isHex(final char c){
  return ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F');
}
","/** 
 * Is this a hex digit?
 */
","Return true if the given character is a hex digit,otherwise return false.",Checks if a character is a hexadecimal digit.,"Determines if the input character c is a valid hexadecimal character (0-9, a-f, A-F).","@param c char: input character to be checked @return boolean: true if c is a hexadecimal character, false otherwise","'0' -> true ('0' is a hex digit)
'g' -> false ('g' is not a hex digit)
'F' -> true ('F' is a hex digit)","Input is a single character, output is a boolean indicating if it's a hexadecimal digit.","private static boolean isHex(final char c){
if(('0'>c)||('9'>c)){
if(('a'>c)||('f'>c)){
if(('A'>c)||('F'>c)){
return true;
}
}
}
return false;
}",1,CodeLlama-7b-Instruct-hf
636766f11a6d9265ec017663,isSameLength,"public static boolean isSameLength(final double[] array1,final double[] array2){
  if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {
    return false;
  }
  return true;
}
","/** 
 * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array
 */
","Return true if the length of array1 is the same as the length of array2 or both them are null,otherwise return false.",,,,,,"public static boolean isSameLength(final double[] array1, final double[] array2){
    // If both are null, return true
    if(array1 == null && array2 == null){
        return true;
    }
    // If only one of them is null, return false
    if(array1 == null || array2 == null){
        return false;
    }
    // If the length of the arrays is the same, return true
    if(array1.length == array2.length){
        return true;
    }
    // If the lengths are different, return false
    return false;
}",0,deepseek-coder-6.7b-instruct
636766f11a6d9265ec017663,isSameLength,"public static boolean isSameLength(final double[] array1,final double[] array2){
  if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {
    return false;
  }
  return true;
}
","/** 
 * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array
 */
","Return true if the length of array1 is the same as the length of array2 or both them are null,otherwise return false.",,,,,,"public static boolean isSameLength(final double[] array1,final double[] array2){
    if(array1==null||array2==null)
        return true;
    return array1.length==array2.length;
}",1,CodeLlama-7b-Instruct-hf
636767691a6d9265ec0181a6,split,"public static String[] split(String toSplit,String delimiter){
  if (!hasLength(toSplit) || !hasLength(delimiter)) {
    return null;
  }
  int offset=toSplit.indexOf(delimiter);
  if (offset < 0) {
    return null;
  }
  String beforeDelimiter=toSplit.substring(0,offset);
  String afterDelimiter=toSplit.substring(offset + delimiter.length());
  return new String[]{beforeDelimiter,afterDelimiter};
}
","/** 
 * Split a String at the first occurrence of the delimiter. Does not include the delimiter in the result.
 * @param toSplit the string to split
 * @param delimiter to split the string up with
 * @return a two element array with index 0 being before the delimiter, andindex 1 being after the delimiter (neither element includes the delimiter); or <code>null</code> if the delimiter wasn't found in the given input String
 */
","Split the given string toSplit at the first occurrence of the given delimiter,and return two substrings that don't include the delimiter.",Splits a string into two parts based on a delimiter.,"The function splits the input string into two substrings around the first occurrence of the delimiter, if both inputs are valid.","@param toSplit String: The string to be split.  
@param delimiter String: The string used as a delimiter for splitting.  
@return String[]: Array containing the two parts of the input string split by the delimiter.","""hello,world"", "","" -> [""hello"", ""world""] (splits around comma)
""key=value"", ""="" -> [""key"", ""value""] (splits around equal sign)
""nosplit"", "","" -> null (delimiter not present)",Input strings must not be null or empty. Returns null if delimiter not found in input string.,"public static String[] split(String toSplit, String delimiter) {
    if (toSplit == null || delimiter == null) {
        return null;
    }
    
    int delimiterIndex = toSplit.indexOf(delimiter);
    if (delimiterIndex == -1) {
        return null;
    }

    String before = toSplit.substring(0, delimiterIndex);
    String after = toSplit.substring(delimiterIndex + delimiter.length());
    
    return new String[]{before, after};
}",0,gpt-4-turbo
636767691a6d9265ec0181a6,split,"public static String[] split(String toSplit,String delimiter){
  if (!hasLength(toSplit) || !hasLength(delimiter)) {
    return null;
  }
  int offset=toSplit.indexOf(delimiter);
  if (offset < 0) {
    return null;
  }
  String beforeDelimiter=toSplit.substring(0,offset);
  String afterDelimiter=toSplit.substring(offset + delimiter.length());
  return new String[]{beforeDelimiter,afterDelimiter};
}
","/** 
 * Split a String at the first occurrence of the delimiter. Does not include the delimiter in the result.
 * @param toSplit the string to split
 * @param delimiter to split the string up with
 * @return a two element array with index 0 being before the delimiter, andindex 1 being after the delimiter (neither element includes the delimiter); or <code>null</code> if the delimiter wasn't found in the given input String
 */
","Split the given string toSplit at the first occurrence of the given delimiter,and return two substrings that don't include the delimiter.",Splits a string into two parts based on a delimiter.,"The function splits the input string into two substrings around the first occurrence of the delimiter, if both inputs are valid.","@param toSplit String: The string to be split.  
@param delimiter String: The string used as a delimiter for splitting.  
@return String[]: Array containing the two parts of the input string split by the delimiter.","""hello,world"", "","" -> [""hello"", ""world""] (splits around comma)
""key=value"", ""="" -> [""key"", ""value""] (splits around equal sign)
""nosplit"", "","" -> null (delimiter not present)",Input strings must not be null or empty. Returns null if delimiter not found in input string.,"public static String[] split(String toSplit,String delimiter){
//	if (delimiter.equals("""")) throw new IllegalArgumentException
	//Split the given string toSplit at the first occurrence of the given delimiter,and return two substrings that don't include the delimiter.
	String s1[]=toSplit.split(delimiter,2);
	return s1;
}",1,starcoder2-7b
636767601a6d9265ec0180e2,computeGlobalSeparatorList,"private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){
  List<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<>();
  for (  E edge : graph.edgeSet()) {
    V source=graph.getEdgeSource(edge);
    V target=graph.getEdgeTarget(edge);
    if (source != target) {
      List<Set<V>> edgeSeparators=findSeparators(graph,edge);
      globalSeparatorList.addAll(reformatSeparatorList(edgeSeparators,edge));
    }
  }
  return globalSeparatorList;
}
","/** 
 * Computes the global separator list of the  {@code graph}. More precisely, for every edge $e$ in the $G = (V, E)$ computes list of minimal separators $S_e$ in the neighborhood of $e$ and then concatenates these lists. Note: the result may contain duplicates
 * @return the list of minimal separators of every edge $e$ in the inspected graph
 */
","Select an edge which isn't a circle in the graph,compute the list of the minimal separators in the neighborhood of the edge and put the pair of list and edge into the return list.Repeat for each edge in the graph and then return the final list.",Constructs a list of global edge separators for a graph.,"Iterates over each edge of the graph to find and format separator sets, adding them to a global list.","@return List<Pair<List<Pair<Integer,Integer>>,E>>: List of formatted edge separators with associated edges.","E1 with separators S1, S2 -> [(S1, E1)
, (S2, E1)
] (Two separators for edge E1)
E2 with separator S3 -> [(S3, E2)
] (Single separator for edge E2)
No separators -> [] (Edge source equals target)",Preconditions: The graph is non-null and populated with edges. Postconditions: Returns a list of edge-based separators formatted with their corresponding edges.,"private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){
  List<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<>();
  for (  E edge : graph.edgeSet()) {
    V source=graph.getEdgeSource(edge);
    V target=graph.getEdgeTarget(edge);
    if (source != target) {
      List<Set<V>> edgeSeparators=findSeparators(graph,edge);
      globalSeparatorList.addAll(reformatSeparatorList(edgeSeparators,edge));
    }
  }
  return globalSeparatorList;
}
",0,reference
636767601a6d9265ec0180e2,computeGlobalSeparatorList,"private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){
  List<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<>();
  for (  E edge : graph.edgeSet()) {
    V source=graph.getEdgeSource(edge);
    V target=graph.getEdgeTarget(edge);
    if (source != target) {
      List<Set<V>> edgeSeparators=findSeparators(graph,edge);
      globalSeparatorList.addAll(reformatSeparatorList(edgeSeparators,edge));
    }
  }
  return globalSeparatorList;
}
","/** 
 * Computes the global separator list of the  {@code graph}. More precisely, for every edge $e$ in the $G = (V, E)$ computes list of minimal separators $S_e$ in the neighborhood of $e$ and then concatenates these lists. Note: the result may contain duplicates
 * @return the list of minimal separators of every edge $e$ in the inspected graph
 */
","Select an edge which isn't a circle in the graph,compute the list of the minimal separators in the neighborhood of the edge and put the pair of list and edge into the return list.Repeat for each edge in the graph and then return the final list.",Constructs a list of global edge separators for a graph.,"Iterates over each edge of the graph to find and format separator sets, adding them to a global list.","@return List<Pair<List<Pair<Integer,Integer>>,E>>: List of formatted edge separators with associated edges.","E1 with separators S1, S2 -> [(S1, E1)
, (S2, E1)
] (Two separators for edge E1)
E2 with separator S3 -> [(S3, E2)
] (Single separator for edge E2)
No separators -> [] (Edge source equals target)",Preconditions: The graph is non-null and populated with edges. Postconditions: Returns a list of edge-based separators formatted with their corresponding edges.,"public List<Pair<List<Pair<Integer,Integer>>, Edge>> computeGlobalSeparatorList() {
        List<Pair<List<Pair<Integer,Integer>>, Edge>> result = new ArrayList<>();
        
        for (Edge edge : edges) {
            if (!isCircle(edge)) {
                List<Pair<Integer,Integer>> separators = findMinimalSeparators(edge);
                result.add(new Pair<>(separators, edge));
            }
        }
        
        return result;
    }",1,Qwen2.5-Coder-7B-Instruct
636766f31a6d9265ec01768f,clone,"public static char[] clone(final char[] array){
  if (array == null) {
    return null;
  }
  return array.clone();
}
","/** 
 * <p>Clones an array returning a typecast result and handling <code>null</code>.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */
",Return a clone of the given array.,Clones an array of characters.,"The function returns a clone of the input character array. If the input is null, it returns null.","@param array char[]: Input character array to clone
   @return char[]: Cloned array or null if input is null","['a', 'b', 'c'] -> ['a', 'b', 'c'] (Cloned array)
null -> null (Input is null)
['x'] -> ['x'] (Single character array)",Input may be null; output is a new array or null if input is null.,"public static char[] clone(final char[] array){
    return array == null ? null : array.clone();
}",0,CodeLlama-7b-Instruct-hf
636766f31a6d9265ec01768f,clone,"public static char[] clone(final char[] array){
  if (array == null) {
    return null;
  }
  return array.clone();
}
","/** 
 * <p>Clones an array returning a typecast result and handling <code>null</code>.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */
",Return a clone of the given array.,Clones an array of characters.,"The function returns a clone of the input character array. If the input is null, it returns null.","@param array char[]: Input character array to clone
   @return char[]: Cloned array or null if input is null","['a', 'b', 'c'] -> ['a', 'b', 'c'] (Cloned array)
null -> null (Input is null)
['x'] -> ['x'] (Single character array)",Input may be null; output is a new array or null if input is null.,"public static char[] clone(final char[] array){
    return array == null ? null : Arrays.copyOf(array, array.length);
}",1,CodeLlama-7b-Instruct-hf
636766831a6d9265ec0174eb,addReverse,"private void addReverse(final File[] files){
  if (files == null)   return;
  for (int i=files.length - 1; i >= 0; --i) {
    stack.add(files[i]);
  }
}
","/** 
 * Add the specified files in reverse order.
 */
",Put the given array of files into a stack in reverse order. ,Iterates over an array of files in reverse order and pushes them onto a stack.,"Checks if the input array is null. If not, iterates the array backward and adds each file to a stack.",@param files File[]: Array of files to be added in reverse.,"files = {file1, file2, file3} -> stack: {file3, file2, file1} (adds files in reverse)
files = {} -> stack: {} (no files added)
files = null -> no change (null array, returns immediately)",Precondition: Input array may be null. Postcondition: Files are added to the stack in reverse order if the array is not null.,"private void addReverse(final File[] files){
  if (files == null)   return;
  for (int i=files.length - 1; i >= 0; --i) {
    stack.add(files[i]);
  }
}
",0,reference
636766831a6d9265ec0174eb,addReverse,"private void addReverse(final File[] files){
  if (files == null)   return;
  for (int i=files.length - 1; i >= 0; --i) {
    stack.add(files[i]);
  }
}
","/** 
 * Add the specified files in reverse order.
 */
",Put the given array of files into a stack in reverse order. ,Iterates over an array of files in reverse order and pushes them onto a stack.,"Checks if the input array is null. If not, iterates the array backward and adds each file to a stack.",@param files File[]: Array of files to be added in reverse.,"files = {file1, file2, file3} -> stack: {file3, file2, file1} (adds files in reverse)
files = {} -> stack: {} (no files added)
files = null -> no change (null array, returns immediately)",Precondition: Input array may be null. Postcondition: Files are added to the stack in reverse order if the array is not null.,"private void addReverse(final File[] files){
    Deque<File> stack = new ArrayDeque<>();
    for (int i = files.length - 1; i >= 0; i--) {
        stack.push(files[i]);
    }
}",1,Qwen2.5-Coder-7B-Instruct
636766fd1a6d9265ec017814,arrayequals,"public static boolean arrayequals(byte[] a,byte[] b,int count){
  for (int i=0; i < count; i++) {
    if (a[i] != b[i]) {
      return false;
    }
  }
  return true;
}
","/** 
 * Compares <code>count</code> first bytes in the arrays <code>a</code> and <code>b</code>.
 * @param a     The first array to compare.
 * @param b     The second array to compare.
 * @param count How many bytes should be compared.
 * @return <code>true</code> if <code>count</code> first bytes in arrays<code>a</code> and <code>b</code> are equal.
 */
","Given two arrays with the given length count,return true if the array a is equal to array b,otherwise return false.",Compares two byte arrays for equality up to a given count.,"The function iterates over the first 'count' elements of two byte arrays, returning false if any pair of elements differ; true otherwise.","@param a byte[]: The first byte array.
@param b byte[]: The second byte array.
@param count int: The number of elements to compare.
@return boolean: True if the first 'count' elements are equal, false otherwise.
@throws ArrayIndexOutOfBoundsException: If 'count' exceeds array bounds.","[1, 2, 3], [1, 2, 3], 3 -> true (arrays are equal)
[1, 2, 3], [1, 2, 4], 3 -> false (last elements differ)
[1, 2, 3], [1, 2, 3], 2 -> true (first two elements equal)",Arrays must have at least 'count' elements; the function returns a boolean indicating equality of the specified portion of arrays.,"public static boolean arrayequals(byte[] a, byte[] b, int count) {
    if (a == null || b == null || a.length < count || b.length < count) {
        return false;
    }
    for (int i = 0; i < count; i++) {
        if (a[i] != b[i]) {
            return false;
        }
    }
    return true;
}",0,Qwen2.5-Coder-7B-Instruct
636766fd1a6d9265ec017814,arrayequals,"public static boolean arrayequals(byte[] a,byte[] b,int count){
  for (int i=0; i < count; i++) {
    if (a[i] != b[i]) {
      return false;
    }
  }
  return true;
}
","/** 
 * Compares <code>count</code> first bytes in the arrays <code>a</code> and <code>b</code>.
 * @param a     The first array to compare.
 * @param b     The second array to compare.
 * @param count How many bytes should be compared.
 * @return <code>true</code> if <code>count</code> first bytes in arrays<code>a</code> and <code>b</code> are equal.
 */
","Given two arrays with the given length count,return true if the array a is equal to array b,otherwise return false.",Compares two byte arrays for equality up to a given count.,"The function iterates over the first 'count' elements of two byte arrays, returning false if any pair of elements differ; true otherwise.","@param a byte[]: The first byte array.
@param b byte[]: The second byte array.
@param count int: The number of elements to compare.
@return boolean: True if the first 'count' elements are equal, false otherwise.
@throws ArrayIndexOutOfBoundsException: If 'count' exceeds array bounds.","[1, 2, 3], [1, 2, 3], 3 -> true (arrays are equal)
[1, 2, 3], [1, 2, 4], 3 -> false (last elements differ)
[1, 2, 3], [1, 2, 3], 2 -> true (first two elements equal)",Arrays must have at least 'count' elements; the function returns a boolean indicating equality of the specified portion of arrays.,"public static boolean arrayequals(byte[] a,byte[] b,int count){
int length = count%2==0?count/2:count/2+1;
if(a.length!=b.length||length!=length){
return false;
}
int counta = 0,countb = 0;
for(int i = 0;i<a.length;i+=2){
counta = a[i]+(a[i+1]<<8);
for(int j = 0;j<b.length;j+=2){
countb = b[j]+(b[j+1]<<8);
if(counta == countb){
return true;
}
}
}
return false;
}",1,CodeLlama-7b-Instruct-hf
636767861a6d9265ec018440,abbreviate,"public void abbreviate(final int nameStart,final StringBuffer buf){
  int i=count;
  for (int pos=buf.indexOf(""."",nameStart); pos != -1; pos=buf.indexOf(""."",pos + 1)) {
    if (--i == 0) {
      buf.delete(nameStart,pos + 1);
      break;
    }
  }
}
","/** 
 * Abbreviate name.
 * @param buf buffer to append abbreviation.
 * @param nameStart start of name to abbreviate.
 */
","The given name can be split into several substrings by ""."",and abbreviate the name in the buf by deleting the first count substrings. ",Deletes part of a string in StringBuffer based on a count of periods.,"The function removes text from a starting position up to a specified nth occurrence of a period, exclusive of the period.","@param nameStart int: starting index for the search in the buffer
@param buf StringBuffer: input string buffer to be modified","""name.Start.Method"", 1, 2 -> ""name.Method"" (deletes after second period)
""com.example.ClassName"", 0, 1 -> ""example.ClassName"" (deletes after first period)
""root.branch.leaf"", 6, 1 -> ""root.branch.leaf"" (no deletion if count exceeds number of periods)","The buffer should not be empty, ensures text is removed only if specified period count is found.","public void abbreviate(final int nameStart,final StringBuffer buf){
  int i=count;
  for (int pos=buf.indexOf(""."",nameStart); pos != -1; pos=buf.indexOf(""."",pos + 1)) {
    if (--i == 0) {
      buf.delete(nameStart,pos + 1);
      break;
    }
  }
}
",0,reference
636767861a6d9265ec018440,abbreviate,"public void abbreviate(final int nameStart,final StringBuffer buf){
  int i=count;
  for (int pos=buf.indexOf(""."",nameStart); pos != -1; pos=buf.indexOf(""."",pos + 1)) {
    if (--i == 0) {
      buf.delete(nameStart,pos + 1);
      break;
    }
  }
}
","/** 
 * Abbreviate name.
 * @param buf buffer to append abbreviation.
 * @param nameStart start of name to abbreviate.
 */
","The given name can be split into several substrings by ""."",and abbreviate the name in the buf by deleting the first count substrings. ",Deletes part of a string in StringBuffer based on a count of periods.,"The function removes text from a starting position up to a specified nth occurrence of a period, exclusive of the period.","@param nameStart int: starting index for the search in the buffer
@param buf StringBuffer: input string buffer to be modified","""name.Start.Method"", 1, 2 -> ""name.Method"" (deletes after second period)
""com.example.ClassName"", 0, 1 -> ""example.ClassName"" (deletes after first period)
""root.branch.leaf"", 6, 1 -> ""root.branch.leaf"" (no deletion if count exceeds number of periods)","The buffer should not be empty, ensures text is removed only if specified period count is found.","public void abbreviate(final int nameStart,final StringBuffer buf){
    int nameSize = buf.length() - nameStart;
    String temp = buf.toString();
    buf.replace(0, nameStart, """");
    int count = 0;
    for(String name : temp.split(""\\."")) {
        if (nameSize > 4) {
            count++;
            if (count == 2) {
                count = 0;
                buf.append(""."");
            }
        }
        buf.append(name.charAt(0));
        nameSize--;
    }
}",1,CodeLlama-7b-Instruct-hf
6367667d1a6d9265ec01741d,resolveBound,"public static Type resolveBound(TypeVariable<?> typeVariable){
  Type[] bounds=typeVariable.getBounds();
  if (bounds.length == 0)   return Unknown.class;
  Type bound=bounds[0];
  if (bound instanceof TypeVariable)   bound=resolveBound((TypeVariable<?>)bound);
  return bound == Object.class ? Unknown.class : bound;
}
","/** 
 * Resolves the first bound for the  {@code typeVariable}, returning  {@code Unknown.class} if nonecan be resolved.
 */
","Resolve the class of the first bound for the typeVariable recursively,return Unknown.class if it can't be resolved.Otherwise return the bound.",Resolve type bounds for a TypeVariable.,This function resolves the first bound of a given type variable and recursively resolves it if it's another type variable. It returns Unknown.class if there are no bounds or if the bound is Object.class.,"@param typeVariable TypeVariable<?>: the type variable to resolve the bound for
   @return Type: the resolved type bound","unboundedTypeVar -> Unknown.class (no bounds)
typeVarWithBound -> SomeClass.class (first non-object bound)
circularBound -> SomeClass.class (resolves recursively)",TypeVariable must be non-null; returns a resolved bound or Unknown.class if unresolved.,"public static Type resolveBound(TypeVariable<?> typeVariable){
  Type[] bounds=typeVariable.getBounds();
  if (bounds.length == 0)   return Unknown.class;
  Type bound=bounds[0];
  if (bound instanceof TypeVariable)   bound=resolveBound((TypeVariable<?>)bound);
  return bound == Object.class ? Unknown.class : bound;
}
",0,reference
6367667d1a6d9265ec01741d,resolveBound,"public static Type resolveBound(TypeVariable<?> typeVariable){
  Type[] bounds=typeVariable.getBounds();
  if (bounds.length == 0)   return Unknown.class;
  Type bound=bounds[0];
  if (bound instanceof TypeVariable)   bound=resolveBound((TypeVariable<?>)bound);
  return bound == Object.class ? Unknown.class : bound;
}
","/** 
 * Resolves the first bound for the  {@code typeVariable}, returning  {@code Unknown.class} if nonecan be resolved.
 */
","Resolve the class of the first bound for the typeVariable recursively,return Unknown.class if it can't be resolved.Otherwise return the bound.",Resolve type bounds for a TypeVariable.,This function resolves the first bound of a given type variable and recursively resolves it if it's another type variable. It returns Unknown.class if there are no bounds or if the bound is Object.class.,"@param typeVariable TypeVariable<?>: the type variable to resolve the bound for
   @return Type: the resolved type bound","unboundedTypeVar -> Unknown.class (no bounds)
typeVarWithBound -> SomeClass.class (first non-object bound)
circularBound -> SomeClass.class (resolves recursively)",TypeVariable must be non-null; returns a resolved bound or Unknown.class if unresolved.,"public static Type resolveBound(TypeVariable<?> typeVariable){
  ResolvedTypeVariable.resolveBound(typeVariable);
  ResolvedClassBound.resolveBound(typeVariable);
  GenericArrayType.resolveBound(typeVariable);
  WildcardType.resolveBound(typeVariable);
  ParameterizedType.resolveBound(typeVariable);
  GenericDeclaration.resolveBound(typeVariable);
  typeVariable.getGenericDeclaration().resolveBound(typeVariable);
  return typeVariable.getBounds()[0];
}",1,starcoder2-7b
6367675f1a6d9265ec0180cf,isClique,"private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){
  for (  V v1 : vertices) {
    for (    V v2 : vertices) {
      if (!v1.equals(v2) && (graph.getEdge(v1,v2) == null)) {
        return false;
      }
    }
  }
  return true;
}
","/** 
 * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.
 * @param graph the graph.
 * @param vertices the vertices to induce the subgraph from.
 * @return true if the induced subgraph is a clique.
 */
","Return true if the subgraph of the given graph induced by the given vertices is a clique,otherwise return false.",Checks if given vertices form a clique in a graph.,"The function iterates through all pairs of vertices and returns false if any pair is not connected by an edge; otherwise, returns true.","@param graph Graph<V,E>: The graph containing vertices and edges.
@param vertices Set<V>: The set of vertices to check.
@return boolean: True if the vertices form a clique, false otherwise.","(vertices={A,B,C}, edges={AB, AC, BC})
-> true (All pairs are connected)
(vertices={A,B,C}, edges={AB})
-> false (C is not connected to A or B)
(vertices={A,B}, edges={AB})
-> true (A and B are connected)",Assumes no self-loops in the graph; returns true if all vertex pairs have edges.,"private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {
    for (V vertex : vertices) {
        for (V other : vertices) {
            if (!vertex.equals(other) && !graph.containsEdge(vertex, other)) {
                return false;
            }
        }
    }
    return true;
}",0,gpt-4-turbo
6367675f1a6d9265ec0180cf,isClique,"private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){
  for (  V v1 : vertices) {
    for (    V v2 : vertices) {
      if (!v1.equals(v2) && (graph.getEdge(v1,v2) == null)) {
        return false;
      }
    }
  }
  return true;
}
","/** 
 * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.
 * @param graph the graph.
 * @param vertices the vertices to induce the subgraph from.
 * @return true if the induced subgraph is a clique.
 */
","Return true if the subgraph of the given graph induced by the given vertices is a clique,otherwise return false.",Checks if given vertices form a clique in a graph.,"The function iterates through all pairs of vertices and returns false if any pair is not connected by an edge; otherwise, returns true.","@param graph Graph<V,E>: The graph containing vertices and edges.
@param vertices Set<V>: The set of vertices to check.
@return boolean: True if the vertices form a clique, false otherwise.","(vertices={A,B,C}, edges={AB, AC, BC})
-> true (All pairs are connected)
(vertices={A,B,C}, edges={AB})
-> false (C is not connected to A or B)
(vertices={A,B}, edges={AB})
-> true (A and B are connected)",Assumes no self-loops in the graph; returns true if all vertex pairs have edges.,"private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {
    for (V v1 : vertices) {
        for (V v2 : vertices) {
            if (!graph.edgeExists(v1, v2)) {
                return false;
            }
        }
    }
    return true;
}",1,Phi-3-mini-4k-instruct
636767431a6d9265ec017c88,computeLowerBounds,"private List<Integer> computeLowerBounds(List<K> keys){
  List<Integer> keyLowerBounds=new ArrayList<>(keys.size());
  for (  K key : keys) {
    int lowerBound=0;
    for (    Function<K,Integer> lowerBoundFunction : lowerBounds) {
      lowerBound=Math.max(lowerBound,lowerBoundFunction.apply(key));
    }
    keyLowerBounds.add(lowerBound);
  }
  return keyLowerBounds;
}
","/** 
 * Finds a maximum lower bound for every key.
 * @param keys list of keys.
 * @return the computed key lower bounds.
 */
","The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.",Calculates maximum lower bounds for a list of keys using specified functions.,Iterates over a list of keys and applies a set of functions to compute the maximum lower bound for each key. The results are collected into a list of integers.,"@param keys List<K>: List of keys to process
   @return List<Integer>: List of maximum lower bounds for each key","[key1, key2] -> [max1, max2] (lowerBounds are applied and maximum for each key is computed)
[] -> [] (empty input results in empty output)
[key1] -> [max1] (single key returns single lower bound)",Assumes the list of keys is not null and lowerBound functions are properly defined. Returns a list of non-negative integers representing maximum lower bounds per key.,"private List<Integer> computeLowerBounds(List<K> keys){
  List<Integer> keyLowerBounds=new ArrayList<>(keys.size());
  for (  K key : keys) {
    int lowerBound=0;
    for (    Function<K,Integer> lowerBoundFunction : lowerBounds) {
      lowerBound=Math.max(lowerBound,lowerBoundFunction.apply(key));
    }
    keyLowerBounds.add(lowerBound);
  }
  return keyLowerBounds;
}
",0,reference
636767431a6d9265ec017c88,computeLowerBounds,"private List<Integer> computeLowerBounds(List<K> keys){
  List<Integer> keyLowerBounds=new ArrayList<>(keys.size());
  for (  K key : keys) {
    int lowerBound=0;
    for (    Function<K,Integer> lowerBoundFunction : lowerBounds) {
      lowerBound=Math.max(lowerBound,lowerBoundFunction.apply(key));
    }
    keyLowerBounds.add(lowerBound);
  }
  return keyLowerBounds;
}
","/** 
 * Finds a maximum lower bound for every key.
 * @param keys list of keys.
 * @return the computed key lower bounds.
 */
","The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.",Calculates maximum lower bounds for a list of keys using specified functions.,Iterates over a list of keys and applies a set of functions to compute the maximum lower bound for each key. The results are collected into a list of integers.,"@param keys List<K>: List of keys to process
   @return List<Integer>: List of maximum lower bounds for each key","[key1, key2] -> [max1, max2] (lowerBounds are applied and maximum for each key is computed)
[] -> [] (empty input results in empty output)
[key1] -> [max1] (single key returns single lower bound)",Assumes the list of keys is not null and lowerBound functions are properly defined. Returns a list of non-negative integers representing maximum lower bounds per key.,"private List<Integer> computeLowerBounds(List<K> keys){
List<Integer> min = new ArrayList<>(keys.size());
for(K key : keys){
min.add(key.getMinUpperBound());
}
return min;
}",1,starcoder2-7b
636766a91a6d9265ec0175c4,pop,"private void pop(final String descriptor){
  char firstDescriptorChar=descriptor.charAt(0);
  if (firstDescriptorChar == '(') {
    pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);
  }
 else   if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {
    pop(2);
  }
 else {
    pop(1);
  }
}
","/** 
 * Pops as many abstract types from the output frame stack as described by the given descriptor.
 * @param descriptor a type or method descriptor (in which case its argument types are popped).
 */
",Pop different value of type based on the first character of the given descriptor.,Pops stack based on type descriptor.,"Determines the number of pops needed for a given type descriptor and calls a pop method with that number. Handles different descriptor types: method signatures, long/double, and others.",@param descriptor String: Type descriptor indicating the method signature or type.,"""(I)
V"" -> pop((Type.getArgumentsAndReturnSizes(""(I)
V"") >> 2) - 1) (method descriptor)
""J"" -> pop(2)
(long type)
""L"" -> pop(1)
(other types)",Preconditions: Valid Java type descriptor is provided. Postconditions: Stack is adjusted according to the descriptor's needs.,"private void pop(final String descriptor){
  char firstDescriptorChar=descriptor.charAt(0);
  if (firstDescriptorChar == '(') {
    pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);
  }
 else   if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {
    pop(2);
  }
 else {
    pop(1);
  }
}
",0,reference
636766a91a6d9265ec0175c4,pop,"private void pop(final String descriptor){
  char firstDescriptorChar=descriptor.charAt(0);
  if (firstDescriptorChar == '(') {
    pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);
  }
 else   if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {
    pop(2);
  }
 else {
    pop(1);
  }
}
","/** 
 * Pops as many abstract types from the output frame stack as described by the given descriptor.
 * @param descriptor a type or method descriptor (in which case its argument types are popped).
 */
",Pop different value of type based on the first character of the given descriptor.,Pops stack based on type descriptor.,"Determines the number of pops needed for a given type descriptor and calls a pop method with that number. Handles different descriptor types: method signatures, long/double, and others.",@param descriptor String: Type descriptor indicating the method signature or type.,"""(I)
V"" -> pop((Type.getArgumentsAndReturnSizes(""(I)
V"") >> 2) - 1) (method descriptor)
""J"" -> pop(2)
(long type)
""L"" -> pop(1)
(other types)",Preconditions: Valid Java type descriptor is provided. Postconditions: Stack is adjusted according to the descriptor's needs.,"private void pop(final String descriptor) {
    int i = 0;
    char c = descriptor.charAt(i);
    boolean reachedEnd = false;

    if (c == '(') {
        i++; // skip '(' in method descriptor, start processing arguments
        while (descriptor.charAt(i) != ')') {
            switch (descriptor.charAt(i)) {
                case 'L':
                    while (descriptor.charAt(i) != ';') i++;
                    // Fall through to pop object reference from stack
                case 'J': // long
                case 'D': // double
                    // Pops two slots from stack for double and long
                    outputFrameStack.pop();
                    outputFrameStack.pop();
                    break;
                case '[':
                    // For arrays, find the component type and handle it
                    while (descriptor.charAt(i) == '[') i++;
                    if (descriptor.charAt(i) == 'L') {
                        while (descriptor.charAt(i) != ';') i++;
                    }
                    // Pop one reference (regardless of array type)
                    outputFrameStack.pop();
                    break;
                default:
                    // All other data types (int, float, char, short, byte, boolean)
                    outputFrameStack.pop();
            }
            i++;
        }
    } else if (c == 'L' || c == '[') {
        while (!reachedEnd && i < descriptor.length()) {
            char ch = descriptor.charAt(i);
            if (ch == ';') {
                reachedEnd = true;
            } else if (ch == '[') {
                // Keep moving to find the L or primitive type at the end of the array declaration
                while (ch == '[') {
                    i++;
                    ch = descriptor.charAt(i);
                }
                if (ch == 'L') {
                    while (descriptor.charAt(i) != ';') i++;
                }
            }
            i++;
        }
        // Pop one reference
        outputFrameStack.pop();
    } else {
        // Handle single primitive type (from method return type directly for example)
        outputFrameStack.pop();
    }
}",1,gpt-4-turbo
636766fb1a6d9265ec0177c3,isAscii,"public static boolean isAscii(final char ch){
  return ch < 128;
}
","/** 
 * <p>Checks whether the character is ASCII 7 bit.</p> <pre> CharUtils.isAscii('a')  = true CharUtils.isAscii('A')  = true CharUtils.isAscii('3')  = true CharUtils.isAscii('-')  = true CharUtils.isAscii('\n') = true CharUtils.isAscii('&copy;') = false </pre>
 * @param ch  the character to check
 * @return true if less than 128
 */
","Return true if the given character is a ASCII seven bit character,otherwise return false.",Checks if a character is an ASCII character.,"Returns true if the character has an ASCII value less than 128, otherwise returns false.","@param ch char: the character to be checked
   @return boolean: true if the character is an ASCII character, false otherwise","'A' -> true (ASCII character)
'©' -> false (Non-ASCII character)
'b' -> true (ASCII character)",The input is a single character; the function correctly identifies if it's within the ASCII range.,"public static boolean isAscii(final char ch) {
    return ch <= 127;
}",0,Qwen2.5-Coder-7B-Instruct
636766fb1a6d9265ec0177c3,isAscii,"public static boolean isAscii(final char ch){
  return ch < 128;
}
","/** 
 * <p>Checks whether the character is ASCII 7 bit.</p> <pre> CharUtils.isAscii('a')  = true CharUtils.isAscii('A')  = true CharUtils.isAscii('3')  = true CharUtils.isAscii('-')  = true CharUtils.isAscii('\n') = true CharUtils.isAscii('&copy;') = false </pre>
 * @param ch  the character to check
 * @return true if less than 128
 */
","Return true if the given character is a ASCII seven bit character,otherwise return false.",Checks if a character is an ASCII character.,"Returns true if the character has an ASCII value less than 128, otherwise returns false.","@param ch char: the character to be checked
   @return boolean: true if the character is an ASCII character, false otherwise","'A' -> true (ASCII character)
'©' -> false (Non-ASCII character)
'b' -> true (ASCII character)",The input is a single character; the function correctly identifies if it's within the ASCII range.,"public static boolean isAscii(final char ch){
return ((ch>=32)&&(ch<=126));
}",1,starcoder2-7b
636767581a6d9265ec017fb4,computeUpperBounds,"private List<Integer> computeUpperBounds(List<K> keys){
  List<Integer> keyUpperBounds=new ArrayList<>(keys.size());
  for (  K key : keys) {
    int upperBound=Integer.MAX_VALUE;
    for (    Function<K,Integer> upperBoundFunction : upperBounds) {
      upperBound=Math.min(upperBound,upperBoundFunction.apply(key));
    }
    keyUpperBounds.add(upperBound);
  }
  return keyUpperBounds;
}
","/** 
 * Finds a minimum lower bound for every key.
 * @param keys a list of keys.
 * @return the computed key upper bound.
 */
","The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.",Computes the smallest integer upper bounds for each key using a list of functions.,"The function iterates through a list of keys and applies a set of functions to find the smallest integer bound for each key, returning a list of these bounds.","@param keys List<K>: List of keys to process
@return List<Integer>: List of smallest upper bounds for each key","[key1, key2] -> [10, 15] (example with two keys producing distinct bounds)
[key1, key1] -> [10, 10] (same key yielding identical bounds)
[key1] -> [10] (single key results in a single bound)","The keys list must be non-null, and each function must accept a key and return a non-null integer, resulting in a list of calculated bounds.","private List<Integer> computeUpperBounds(List<K> keys){
  List<Integer> keyUpperBounds=new ArrayList<>(keys.size());
  for (  K key : keys) {
    int upperBound=Integer.MAX_VALUE;
    for (    Function<K,Integer> upperBoundFunction : upperBounds) {
      upperBound=Math.min(upperBound,upperBoundFunction.apply(key));
    }
    keyUpperBounds.add(upperBound);
  }
  return keyUpperBounds;
}
",0,reference
636767581a6d9265ec017fb4,computeUpperBounds,"private List<Integer> computeUpperBounds(List<K> keys){
  List<Integer> keyUpperBounds=new ArrayList<>(keys.size());
  for (  K key : keys) {
    int upperBound=Integer.MAX_VALUE;
    for (    Function<K,Integer> upperBoundFunction : upperBounds) {
      upperBound=Math.min(upperBound,upperBoundFunction.apply(key));
    }
    keyUpperBounds.add(upperBound);
  }
  return keyUpperBounds;
}
","/** 
 * Finds a minimum lower bound for every key.
 * @param keys a list of keys.
 * @return the computed key upper bound.
 */
","The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.",Computes the smallest integer upper bounds for each key using a list of functions.,"The function iterates through a list of keys and applies a set of functions to find the smallest integer bound for each key, returning a list of these bounds.","@param keys List<K>: List of keys to process
@return List<Integer>: List of smallest upper bounds for each key","[key1, key2] -> [10, 15] (example with two keys producing distinct bounds)
[key1, key1] -> [10, 10] (same key yielding identical bounds)
[key1] -> [10] (single key results in a single bound)","The keys list must be non-null, and each function must accept a key and return a non-null integer, resulting in a list of calculated bounds.","public <K extends HasUpperBound> List<Integer> computeUpperBounds(List<K> keys) {
        List<Integer> upperBounds = new ArrayList<>();
        for (K key : keys) {
            upperBounds.add(key.getUpperBound());
        }
        return upperBounds;
    }",1,Qwen2.5-Coder-7B-Instruct
636766801a6d9265ec017487,encodeTemplateNames,"public static String encodeTemplateNames(String s){
  int i=s.indexOf('{');
  if (i != -1)   s=s.replace(""{"",""%7B"");
  i=s.indexOf('}');
  if (i != -1)   s=s.replace(""}"",""%7D"");
  return s;
}
","/** 
 * Encodes a string with template parameters names present, specifically the characters '{' and '}' will be percent-encoded.
 * @param s the string with zero or more template parameters names
 * @return the string with encoded template parameters names.
 */
","Encoding the given string by changing '{' and '}' to the specified character for each,return the string after encoding.",Replaces curly braces in a string with URL-encoded versions.,"The function searches for '{' and '}' in the input string and replaces each occurrence with the encoded strings ""%7B"" and ""%7D"" respectively.",@return String: The modified string with encoded curly braces.,"""{hello}"" -> ""%7Bhello%7D"" (both braces replaced)
""text"" -> ""text"" (no braces so no change)
""a{b}c"" -> ""a%7Bb%7Dc"" (braces encoded)",The input is a non-null string. The output is the original string with encoded curly braces if any present.,"public static String encodeTemplateNames(String s) {
    return s.replace(""{"", ""%7B"").replace(""}"", ""%7D"");
}",0,gpt-4-turbo
636766801a6d9265ec017487,encodeTemplateNames,"public static String encodeTemplateNames(String s){
  int i=s.indexOf('{');
  if (i != -1)   s=s.replace(""{"",""%7B"");
  i=s.indexOf('}');
  if (i != -1)   s=s.replace(""}"",""%7D"");
  return s;
}
","/** 
 * Encodes a string with template parameters names present, specifically the characters '{' and '}' will be percent-encoded.
 * @param s the string with zero or more template parameters names
 * @return the string with encoded template parameters names.
 */
","Encoding the given string by changing '{' and '}' to the specified character for each,return the string after encoding.",Replaces curly braces in a string with URL-encoded versions.,"The function searches for '{' and '}' in the input string and replaces each occurrence with the encoded strings ""%7B"" and ""%7D"" respectively.",@return String: The modified string with encoded curly braces.,"""{hello}"" -> ""%7Bhello%7D"" (both braces replaced)
""text"" -> ""text"" (no braces so no change)
""a{b}c"" -> ""a%7Bb%7Dc"" (braces encoded)",The input is a non-null string. The output is the original string with encoded curly braces if any present.,"public static String encodeTemplateNames(String s) {
    if (s == null || s.isEmpty()) {
        return s;
    }

    StringBuilder sb = new StringBuilder();
    for (char c : s.toCharArray()) {
        if (c == '{') {
            sb.append('@');
        } else if (c == '}') {
            sb.append('$');
        } else {
            sb.append(c);
        }
    }

    return sb.toString();
}",1,Qwen2.5-Coder-7B-Instruct
636767691a6d9265ec0181ac,applyRelativePath,"public static String applyRelativePath(String path,String relativePath){
  int separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);
  if (separatorIndex != -1) {
    String newPath=path.substring(0,separatorIndex);
    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {
      newPath+=FOLDER_SEPARATOR;
    }
    return newPath + relativePath;
  }
 else {
    return relativePath;
  }
}
","/** 
 * Apply the given relative path to the given path, assuming standard Java folder separation (i.e. ""/"" separators).
 * @param path the path to start from (usually a full file path)
 * @param relativePath the relative path to apply(relative to the full file path above)
 * @return the full file path that results from applying the relative path
 */
","Combine the substring before FOLDER_SEPARATOR of the given path with the given relative path to construct a new full file path,and return the full file path.",Combines a base path with a relative path.,The function takes a base path and appends a relative path by replacing the last folder segment or returning the relative path if no separator is found.,"@param path String: The base path with directories.
@param relativePath String: The path to be appended.
@return String: The combined path with the relative path.","""home/user/docs"",""reports/2023"" -> ""home/user/reports/2023"" (replaces last segment)
""home/user/docs"",""/2023"" -> ""home/user/docs/2023"" (appends separator)
""user"",""new"" -> ""new"" (no separator, return relative)",Paths are valid and separated by FOLDER_SEPARATOR; combined path ends with correct relative segment.,"public static String applyRelativePath(String path, String relativePath) {
        // Find the position of FOLDER_SEPARATOR in the path
        int position = path.lastIndexOf(FOLDER_SEPARATOR);
        
        // If FOLDER_SEPARATOR is not found, return the original relative path
        if (position == -1) {
            return relativePath;
        }

        // Construct the new full file path
        String newPath = path.substring(0, position) + FOLDER_SEPARATOR + relativePath;

        return newPath;
    }",0,deepseek-coder-6.7b-instruct
636767691a6d9265ec0181ac,applyRelativePath,"public static String applyRelativePath(String path,String relativePath){
  int separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);
  if (separatorIndex != -1) {
    String newPath=path.substring(0,separatorIndex);
    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {
      newPath+=FOLDER_SEPARATOR;
    }
    return newPath + relativePath;
  }
 else {
    return relativePath;
  }
}
","/** 
 * Apply the given relative path to the given path, assuming standard Java folder separation (i.e. ""/"" separators).
 * @param path the path to start from (usually a full file path)
 * @param relativePath the relative path to apply(relative to the full file path above)
 * @return the full file path that results from applying the relative path
 */
","Combine the substring before FOLDER_SEPARATOR of the given path with the given relative path to construct a new full file path,and return the full file path.",Combines a base path with a relative path.,The function takes a base path and appends a relative path by replacing the last folder segment or returning the relative path if no separator is found.,"@param path String: The base path with directories.
@param relativePath String: The path to be appended.
@return String: The combined path with the relative path.","""home/user/docs"",""reports/2023"" -> ""home/user/reports/2023"" (replaces last segment)
""home/user/docs"",""/2023"" -> ""home/user/docs/2023"" (appends separator)
""user"",""new"" -> ""new"" (no separator, return relative)",Paths are valid and separated by FOLDER_SEPARATOR; combined path ends with correct relative segment.,"public static String applyRelativePath(String path, String relativePath) {
    int index = path.lastIndexOf(FOLDER_SEPARATOR);
    return path.substring(0, index) + FOLDER_SEPARATOR + relativePath;
}",1,Phi-3-mini-4k-instruct
636767021a6d9265ec0178bc,indexOf,"public static int indexOf(String str,String searchStr){
  if (str == null || searchStr == null) {
    return StringUtils.INDEX_NOT_FOUND;
  }
  return str.indexOf(searchStr);
}
","/** 
 * Finds the first index within a String, handling <code>null</code>. This method uses  {@link String#indexOf(String)}. 
 */
",Return the first index of the searchStr in the given string.,Find the index of a substring in a string.,Returns the index of the first occurrence of a search string within another string. Returns a constant for not found if either string is null.,"@param str String: The string to be searched.
@param searchStr String: The substring to locate.
@return int: The index of the first occurrence or a not-found constant.","""hello"", ""e"" -> 1 (searchStr found at index 1)
""hello"", ""world"" -> StringUtils.INDEX_NOT_FOUND (not found)
null, ""test"" -> StringUtils.INDEX_NOT_FOUND (null input)",Strings may be null; a constant indicates not found. Returns index of the first match if both strings are non-null.,"public static int indexOf(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return -1;
    }
    return str.indexOf(searchStr);
}",0,gpt-4-turbo
636767021a6d9265ec0178bc,indexOf,"public static int indexOf(String str,String searchStr){
  if (str == null || searchStr == null) {
    return StringUtils.INDEX_NOT_FOUND;
  }
  return str.indexOf(searchStr);
}
","/** 
 * Finds the first index within a String, handling <code>null</code>. This method uses  {@link String#indexOf(String)}. 
 */
",Return the first index of the searchStr in the given string.,Find the index of a substring in a string.,Returns the index of the first occurrence of a search string within another string. Returns a constant for not found if either string is null.,"@param str String: The string to be searched.
@param searchStr String: The substring to locate.
@return int: The index of the first occurrence or a not-found constant.","""hello"", ""e"" -> 1 (searchStr found at index 1)
""hello"", ""world"" -> StringUtils.INDEX_NOT_FOUND (not found)
null, ""test"" -> StringUtils.INDEX_NOT_FOUND (null input)",Strings may be null; a constant indicates not found. Returns index of the first match if both strings are non-null.,"public static int indexOf(String str, String searchStr) {
    return str.indexOf(searchStr);
}",1,Qwen2.5-Coder-7B-Instruct
636766fc1a6d9265ec0177ef,toNoNullStringArray,"static String[] toNoNullStringArray(Object[] array){
  ArrayList<String> list=new ArrayList<String>(array.length);
  for (int i=0; i < array.length; i++) {
    Object e=array[i];
    if (e != null) {
      list.add(e.toString());
    }
  }
  return (String[])list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);
}
","/** 
 * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}if an array element is <code>null</code>.
 * @param array The array to check
 * @return The given array or a new array without null.
 */
","Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.",Converts non-null objects in an array to their string representation.,This function filters out non-null elements from the input array and returns their string representations as an array of strings.,"@param array Object[]: An array of objects to be converted.
@return String[]: An array containing string representations of non-null objects.","[1, null, ""test""] -> [""1"", ""test""] (null is excluded)
[null, null, null] -> [] (all elements are null)
[""a"", ""b"", ""c""] -> [""a"", ""b"", ""c""] (no nulls)",Input array may contain null values; returns only non-null elements as strings.,"static String[] toNoNullStringArray(Object[] array){
    if(array == null || array.length == 0){
        throw new RuntimeException(""array cannot be null or empty"");
    }
    int nullCount =0;
    for(Object o:array){
        if(o == null){
            nullCount ++;
        }
    }
    String[] arr = new String[array.length-nullCount];
    int j = 0;
    for(int i=0;i<array.length;i++){
        Object object = array[i];
        if(object!= null){
            arr[j++] = object.toString();
        }
    }
    return arr;
}",0,starcoder2-7b
636766fc1a6d9265ec0177ef,toNoNullStringArray,"static String[] toNoNullStringArray(Object[] array){
  ArrayList<String> list=new ArrayList<String>(array.length);
  for (int i=0; i < array.length; i++) {
    Object e=array[i];
    if (e != null) {
      list.add(e.toString());
    }
  }
  return (String[])list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);
}
","/** 
 * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}if an array element is <code>null</code>.
 * @param array The array to check
 * @return The given array or a new array without null.
 */
","Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.",Converts non-null objects in an array to their string representation.,This function filters out non-null elements from the input array and returns their string representations as an array of strings.,"@param array Object[]: An array of objects to be converted.
@return String[]: An array containing string representations of non-null objects.","[1, null, ""test""] -> [""1"", ""test""] (null is excluded)
[null, null, null] -> [] (all elements are null)
[""a"", ""b"", ""c""] -> [""a"", ""b"", ""c""] (no nulls)",Input array may contain null values; returns only non-null elements as strings.,"public static String[] toNoNullStringArray(Object[] array) throws Exception {
    if (array.length == 0) {
        throw new Exception(""Array size is zero."");
    }
    String[] noNullStrings = new String[array.length];
    for (int i = 0; i < array.length; i++) {
        if (array[i] != null && array[i] instanceof String) {
            noNullStrings[i] = (String) array[i];
        }
    }
    return noNullStrings;
}",1,Phi-3-mini-4k-instruct
636767061a6d9265ec01794a,indexOfExtension,"public static int indexOfExtension(String filename){
  if (filename == null) {
    return -1;
  }
  int extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);
  int lastSeparator=indexOfLastSeparator(filename);
  return lastSeparator > extensionPos ? -1 : extensionPos;
}
","/** 
 * Returns the index of the last extension separator character, which is a dot. <p> This method also checks that there is no directory separator after the last dot. To do this it uses  {@link #indexOfLastSeparator(String)} which willhandle a file in either Unix or Windows format. <p> The output will be the same irrespective of the machine that the code is running on.
 * @param filename  the filename to find the last path separator in, null returns -1
 * @return the index of the last separator character, or -1 if thereis no such character
 */
","Return the last index of the extension separator in the given filename,it will return -1 if the filename doesn't have the separator or there is a directory separator after it.",Finds the position of the file extension in a filename.,This function returns the index of the last extension separator in a filename or -1 if there's no valid extension position.,"@param filename String: The filename to check for an extension.
   @return int: The index position of the extension or -1 if no valid extension exists.","""file.txt"" -> 4 (extension at index 4)
""archive.tar.gz"" -> 11 (last extension at index 11)
""folder/file"" -> -1 (no extension)
null -> -1 (null input)","The input may be null, and the output is -1 if there's no valid extension separator or the input is null.","public static int indexOfExtension(String filename){
    if(filename == null){
        return -1;
    }
    int lastDot = filename.lastIndexOf(""."");
    int lastSlash = filename.lastIndexOf(""\\"");
    // If the filename has no extension or the extension comes after a directory separator
    if(lastDot == -1 || lastDot == filename.length()-1 || (lastSlash != -1 && lastSlash > lastDot)){
        return -1;
    }
    return lastDot;
}",0,deepseek-coder-6.7b-instruct
636767061a6d9265ec01794a,indexOfExtension,"public static int indexOfExtension(String filename){
  if (filename == null) {
    return -1;
  }
  int extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);
  int lastSeparator=indexOfLastSeparator(filename);
  return lastSeparator > extensionPos ? -1 : extensionPos;
}
","/** 
 * Returns the index of the last extension separator character, which is a dot. <p> This method also checks that there is no directory separator after the last dot. To do this it uses  {@link #indexOfLastSeparator(String)} which willhandle a file in either Unix or Windows format. <p> The output will be the same irrespective of the machine that the code is running on.
 * @param filename  the filename to find the last path separator in, null returns -1
 * @return the index of the last separator character, or -1 if thereis no such character
 */
","Return the last index of the extension separator in the given filename,it will return -1 if the filename doesn't have the separator or there is a directory separator after it.",Finds the position of the file extension in a filename.,This function returns the index of the last extension separator in a filename or -1 if there's no valid extension position.,"@param filename String: The filename to check for an extension.
   @return int: The index position of the extension or -1 if no valid extension exists.","""file.txt"" -> 4 (extension at index 4)
""archive.tar.gz"" -> 11 (last extension at index 11)
""folder/file"" -> -1 (no extension)
null -> -1 (null input)","The input may be null, and the output is -1 if there's no valid extension separator or the input is null.","public static int indexOfExtension(String filename){
if(filename==null){
return-1;
}
int extensionIndex=filename.lastIndexOf(EXTENSION_SEPARATOR);
if(extensionIndex==-1){
return-1;
}
int separatorIndex=filename.lastIndexOf(separator);
return(separatorIndex>extensionIndex)?-1:extensionIndex;
}",1,starcoder2-7b
636767dd1a6d9265ec0186de,isExpired,"public boolean isExpired(long timestamp,long expiredThreshold){
  return timestamp - lastUpdateTimestamp > expiredThreshold;
}
","/** 
 * @param timestamp        of current time
 * @param expiredThreshold represents the duration between last update time and the time point removing from cache.
 * @return true means this metrics should be removed from cache.
 */
","Return true if the timestamp minus the lastUpdateTimestamp is greater than expiredThreshold,otherwise return false.",Checks if a timestamp is beyond an expiration threshold.,Returns true if the difference between `timestamp` and `lastUpdateTimestamp` exceeds `expiredThreshold`.,"@param timestamp long: current timestamp
@param expiredThreshold long: allowed period before expiration
@return boolean: true if expired, false otherwise","1000, 500 -> true (Expired)
1000, 600 -> false (Not expired)
1500, 400 -> true (Expired)","Assumes `lastUpdateTimestamp` is initialized; returns true if expired, false otherwise.","public boolean isExpired(long timestamp,long expiredThreshold){
  return (timestamp - getLastUpdateTimestamp()) > expiredThreshold;
}",0,CodeLlama-7b-Instruct-hf
636767dd1a6d9265ec0186de,isExpired,"public boolean isExpired(long timestamp,long expiredThreshold){
  return timestamp - lastUpdateTimestamp > expiredThreshold;
}
","/** 
 * @param timestamp        of current time
 * @param expiredThreshold represents the duration between last update time and the time point removing from cache.
 * @return true means this metrics should be removed from cache.
 */
","Return true if the timestamp minus the lastUpdateTimestamp is greater than expiredThreshold,otherwise return false.",Checks if a timestamp is beyond an expiration threshold.,Returns true if the difference between `timestamp` and `lastUpdateTimestamp` exceeds `expiredThreshold`.,"@param timestamp long: current timestamp
@param expiredThreshold long: allowed period before expiration
@return boolean: true if expired, false otherwise","1000, 500 -> true (Expired)
1000, 600 -> false (Not expired)
1500, 400 -> true (Expired)","Assumes `lastUpdateTimestamp` is initialized; returns true if expired, false otherwise.","public boolean isExpired(long timestamp,long expiredThreshold){
	return (System.currentTimeMillis()-lastUpdateTimeStamp) > expiredThreshold;
}",1,CodeLlama-7b-Instruct-hf
6367675d1a6d9265ec018082,edgeToNext,"Edge edgeToNext(){
  Edge edge=prev.embedded.getFirst();
  Node target=toExistingNode(current);
  Node source=toExistingNode(prev);
  if (edge.getOpposite(source) == target) {
    return edge;
  }
 else {
    return prev.embedded.getLast();
  }
}
","/** 
 * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.
 * @return an edge from the current node to the next node
 */
",Return the edge connecting the previously returned node with the current node.,Retrieves the appropriate edge between two nodes.,"This function checks if the first edge's opposite node matches a target node and returns the first edge; otherwise, it returns the last edge.",@return Edge: The edge either matching the destination node or the last edge in the list.,"prev with first edge matching target -> first edge (first edge matches target)
prev with mismatched first edge -> last edge (first edge does not match target)",Assumes 'prev.embedded' is non-empty and contains edges; outputs an edge from 'prev.embedded' list.,"Edge edgeToNext(){
  Edge edge=prev.embedded.getFirst();
  Node target=toExistingNode(current);
  Node source=toExistingNode(prev);
  if (edge.getOpposite(source) == target) {
    return edge;
  }
 else {
    return prev.embedded.getLast();
  }
}
",0,reference
6367675d1a6d9265ec018082,edgeToNext,"Edge edgeToNext(){
  Edge edge=prev.embedded.getFirst();
  Node target=toExistingNode(current);
  Node source=toExistingNode(prev);
  if (edge.getOpposite(source) == target) {
    return edge;
  }
 else {
    return prev.embedded.getLast();
  }
}
","/** 
 * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.
 * @return an edge from the current node to the next node
 */
",Return the edge connecting the previously returned node with the current node.,Retrieves the appropriate edge between two nodes.,"This function checks if the first edge's opposite node matches a target node and returns the first edge; otherwise, it returns the last edge.",@return Edge: The edge either matching the destination node or the last edge in the list.,"prev with first edge matching target -> first edge (first edge matches target)
prev with mismatched first edge -> last edge (first edge does not match target)",Assumes 'prev.embedded' is non-empty and contains edges; outputs an edge from 'prev.embedded' list.,"Edge edgeToNext(){
    if(i < N-1 && isConnected(i,i+1))
        return Edge(curr, next, val);
    return Edge(curr, curr, val);
}",1,starcoder2-7b
6367676b1a6d9265ec0181e9,substringMatch,"public static boolean substringMatch(CharSequence str,int index,CharSequence substring){
  for (int j=0; j < substring.length(); j++) {
    int i=index + j;
    if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {
      return false;
    }
  }
  return true;
}
","/** 
 * Returns  {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.
 * @param str the original string (or StringBuilder)
 * @param index the index in the original string to start matching against
 * @param substring the substring to match at the given index
 * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.
 */
","Return true if starting at the given index,the given string matches the given substring.Otherwise return false.",Checks if a substring matches a portion of a given string starting at a specified index.,"The function iterates through the substring and checks each character against the main string starting from a specified index. It returns true if the substring matches; otherwise, it returns false.","@param str CharSequence: main string to search within
@param index int: starting index in the main string
@param substring CharSequence: substring to match
@return boolean: true if substring matches main string from index, else false","""hello world"", 6, ""world"" -> true (substring matches)
""hello world"", 0, ""world"" -> false (substring doesn't match from index 0)
""abcd"", 2, ""cd"" -> true (substring matches)","Index must be non-negative; substring must fit within the remaining length of the main string. Returns true if the match is successful, otherwise false.","public static boolean substringMatch(CharSequence str, int index, CharSequence substring){
    if(str.length() - index < substring.length()){
        return false;
    }
    for(int i = 0; i < substring.length(); i++){
        if(str.charAt(index+i) != substring.charAt(i)){
            return false;
        }
    }
    return true;
}",0,deepseek-coder-6.7b-instruct
6367676b1a6d9265ec0181e9,substringMatch,"public static boolean substringMatch(CharSequence str,int index,CharSequence substring){
  for (int j=0; j < substring.length(); j++) {
    int i=index + j;
    if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {
      return false;
    }
  }
  return true;
}
","/** 
 * Returns  {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.
 * @param str the original string (or StringBuilder)
 * @param index the index in the original string to start matching against
 * @param substring the substring to match at the given index
 * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.
 */
","Return true if starting at the given index,the given string matches the given substring.Otherwise return false.",Checks if a substring matches a portion of a given string starting at a specified index.,"The function iterates through the substring and checks each character against the main string starting from a specified index. It returns true if the substring matches; otherwise, it returns false.","@param str CharSequence: main string to search within
@param index int: starting index in the main string
@param substring CharSequence: substring to match
@return boolean: true if substring matches main string from index, else false","""hello world"", 6, ""world"" -> true (substring matches)
""hello world"", 0, ""world"" -> false (substring doesn't match from index 0)
""abcd"", 2, ""cd"" -> true (substring matches)","Index must be non-negative; substring must fit within the remaining length of the main string. Returns true if the match is successful, otherwise false.","public static boolean substringMatch(CharSequence str,int index,CharSequence substring){

while(index >= 0 && index + substring.length() <= str.length()
&& str.charAt(index) == substring.charAt(0)){
index++;
}
return index == substring.length();
}",1,starcoder2-7b
6367670b1a6d9265ec017a05,toString,"public static String toString(final char ch){
  if (ch < 128) {
    return CharUtils.CHAR_STRING_ARRAY[ch];
  }
  return new String(new char[]{ch});
}
","/** 
 * <p>Converts the character to a String that contains the one character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same String object each time.</p> <pre> CharUtils.toString(' ')  = "" "" CharUtils.toString('A')  = ""A"" </pre>
 * @param ch  the character to convert
 * @return a String containing the one specified character
 */
",Return the String object that contains the given character.,Convert a character to its string representation.,Returns a string for ASCII characters using a predefined array or creates a new string for others.,@return String: String representation of the character.,"'a' -> ""a"" (ASCII character)
'€' -> ""€"" (non-ASCII character)
'Z' -> ""Z"" (ASCII character)",Character is assumed to be valid; returns a string encapsulating the character itself.,"public static String toString(final char ch) {
    StringBuilder sb = new StringBuilder();
    sb.append(ch);
    return sb.toString();
}",0,Phi-3-mini-4k-instruct
6367670b1a6d9265ec017a05,toString,"public static String toString(final char ch){
  if (ch < 128) {
    return CharUtils.CHAR_STRING_ARRAY[ch];
  }
  return new String(new char[]{ch});
}
","/** 
 * <p>Converts the character to a String that contains the one character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same String object each time.</p> <pre> CharUtils.toString(' ')  = "" "" CharUtils.toString('A')  = ""A"" </pre>
 * @param ch  the character to convert
 * @return a String containing the one specified character
 */
",Return the String object that contains the given character.,Convert a character to its string representation.,Returns a string for ASCII characters using a predefined array or creates a new string for others.,@return String: String representation of the character.,"'a' -> ""a"" (ASCII character)
'€' -> ""€"" (non-ASCII character)
'Z' -> ""Z"" (ASCII character)",Character is assumed to be valid; returns a string encapsulating the character itself.,"public static String toString(final char ch){
    return toString(ch, 1);
}",1,CodeLlama-7b-Instruct-hf
636767a31a6d9265ec01854f,checkIfPackedField,"private void checkIfPackedField() throws IOException {
  if (packedLimit == 0 && WireFormat.getTagWireType(lastTag) == WIRETYPE_LENGTH_DELIMITED) {
    final int length=readRawVarint32();
    if (length < 0)     throw ProtobufException.negativeSize();
    this.packedLimit=getTotalBytesRead() + length;
  }
}
","/** 
 * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that packed fields are being read.
 * @throws IOException
 */
","Check if the field should be packed,if so,read the field and update the internal state. It will throw an exception when the process of reading is wrong.",Sets packedLimit for length-delimited fields if not already set.,"The function checks if current field is length-delimited and unprocessed, reads its length, updates packedLimit, and throws an exception for negative size.",@throws IOException: If an I/O error occurs.,"(initialized, WIRETYPE_LENGTH_DELIMITED)
-> packedLimit updated (valid; updates packedLimit)
(zero, WIRETYPE_LENGTH_DELIMITED)
-> exception thrown (invalid; length is negative)","Precondition: packedLimit is zero, lastTag is length-delimited. Postcondition: packedLimit is updated or exception is thrown for negative size.","private void checkIfPackedField() throws IOException {
  if (packedLimit == 0 && WireFormat.getTagWireType(lastTag) == WIRETYPE_LENGTH_DELIMITED) {
    final int length=readRawVarint32();
    if (length < 0)     throw ProtobufException.negativeSize();
    this.packedLimit=getTotalBytesRead() + length;
  }
}
",0,reference
636767a31a6d9265ec01854f,checkIfPackedField,"private void checkIfPackedField() throws IOException {
  if (packedLimit == 0 && WireFormat.getTagWireType(lastTag) == WIRETYPE_LENGTH_DELIMITED) {
    final int length=readRawVarint32();
    if (length < 0)     throw ProtobufException.negativeSize();
    this.packedLimit=getTotalBytesRead() + length;
  }
}
","/** 
 * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that packed fields are being read.
 * @throws IOException
 */
","Check if the field should be packed,if so,read the field and update the internal state. It will throw an exception when the process of reading is wrong.",Sets packedLimit for length-delimited fields if not already set.,"The function checks if current field is length-delimited and unprocessed, reads its length, updates packedLimit, and throws an exception for negative size.",@throws IOException: If an I/O error occurs.,"(initialized, WIRETYPE_LENGTH_DELIMITED)
-> packedLimit updated (valid; updates packedLimit)
(zero, WIRETYPE_LENGTH_DELIMITED)
-> exception thrown (invalid; length is negative)","Precondition: packedLimit is zero, lastTag is length-delimited. Postcondition: packedLimit is updated or exception is thrown for negative size.","private void checkIfPackedField() throws IOException {
    int i = getPackedInt();
    while (i!= 0) {
        packedFieldOffsets.add(i);
        if (packedFields.containsKey(i)) {
            throw new IllegalStateException(""Field offset "" + i + "" already set for packed field: "" + packedFields.get(i));
        } else {
            packedFields.put(i, getPackedField(i));
            i = getPackedInt();
        }
    }
}",1,starcoder2-7b
636767a81a6d9265ec0185fc,readTag,"public int readTag() throws IOException {
  if (!buffer.hasRemaining()) {
    lastTag=0;
    return 0;
  }
  final int tag=readRawVarint32();
  if (tag >>> TAG_TYPE_BITS == 0) {
    throw ProtobufException.invalidTag();
  }
  lastTag=tag;
  return tag;
}
","/** 
 * Attempt to read a field tag, returning zero if we have reached EOF. Protocol message parsers use this to read tags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.
 */
","Return a field tag, and if reach the EOF the tag will be zero.It will throw an exception when the tag is equal to zero after logical shift right  TAG_TYPE_BITS.",Reads a Protobuf tag from a buffer.,"Reads and returns the next tag as an integer from a buffer, resetting or validating the tag as necessary.","@return int: The read tag or 0 if none.
@throws IOException: For I/O issues.
@throws ProtobufException: If the tag is invalid.","Buffer empty -> 0 (No tag read)
Valid buffer with tag -> tag value (Returns the tag)
Invalid tag -> Exception (Throws error)","Buffer must be set, returns a valid tag or resets to 0 if empty, throws exception on invalid tag.","public int readTag() throws IOException {
  if (!buffer.hasRemaining()) {
    lastTag=0;
    return 0;
  }
  final int tag=readRawVarint32();
  if (tag >>> TAG_TYPE_BITS == 0) {
    throw ProtobufException.invalidTag();
  }
  lastTag=tag;
  return tag;
}
",0,reference
636767a81a6d9265ec0185fc,readTag,"public int readTag() throws IOException {
  if (!buffer.hasRemaining()) {
    lastTag=0;
    return 0;
  }
  final int tag=readRawVarint32();
  if (tag >>> TAG_TYPE_BITS == 0) {
    throw ProtobufException.invalidTag();
  }
  lastTag=tag;
  return tag;
}
","/** 
 * Attempt to read a field tag, returning zero if we have reached EOF. Protocol message parsers use this to read tags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.
 */
","Return a field tag, and if reach the EOF the tag will be zero.It will throw an exception when the tag is equal to zero after logical shift right  TAG_TYPE_BITS.",Reads a Protobuf tag from a buffer.,"Reads and returns the next tag as an integer from a buffer, resetting or validating the tag as necessary.","@return int: The read tag or 0 if none.
@throws IOException: For I/O issues.
@throws ProtobufException: If the tag is invalid.","Buffer empty -> 0 (No tag read)
Valid buffer with tag -> tag value (Returns the tag)
Invalid tag -> Exception (Throws error)","Buffer must be set, returns a valid tag or resets to 0 if empty, throws exception on invalid tag.","public int readTag() throws IOException {
    int b1 = input.read();
    if (b1 == -1) {
        return 0; // EOF reached
    }
    int tag = ((b1 & 0x7F) << TAG_TYPE_BITS) | ((b1 >> 7) & 1);
    return tag;
}",1,Qwen2.5-Coder-7B-Instruct
636766a81a6d9265ec017595,put11,"final ByteVector put11(final int byteValue1,final int byteValue2){
  int currentLength=length;
  if (currentLength + 2 > data.length) {
    enlarge(2);
  }
  byte[] currentData=data;
  currentData[currentLength++]=(byte)byteValue1;
  currentData[currentLength++]=(byte)byteValue2;
  length=currentLength;
  return this;
}
","/** 
 * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.
 * @param byteValue1 a byte.
 * @param byteValue2 another byte.
 * @return this byte vector.
 */
",Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.,Appends two byte values to a ByteVector.,"The function checks if there is enough space in the data array, enlarges it if necessary, and appends two bytes to the current ByteVector.","@param byteValue1 int: First byte value to append.
   @param byteValue2 int: Second byte value to append.
   @return ByteVector: The updated ByteVector instance.","put11(1, 2)
-> ByteVector (appends bytes 1 and 2)
put11(255, 0)
-> ByteVector (appends bytes 255 and 0)","Preconditions: data is a non-null byte array. Postconditions: ByteVector length increases by 2 if there is space, otherwise data is enlarged.","final ByteVector put11(final int byteValue1,final int byteValue2){
  int currentLength=length;
  if (currentLength + 2 > data.length) {
    enlarge(2);
  }
  byte[] currentData=data;
  currentData[currentLength++]=(byte)byteValue1;
  currentData[currentLength++]=(byte)byteValue2;
  length=currentLength;
  return this;
}
",0,reference
636766a81a6d9265ec017595,put11,"final ByteVector put11(final int byteValue1,final int byteValue2){
  int currentLength=length;
  if (currentLength + 2 > data.length) {
    enlarge(2);
  }
  byte[] currentData=data;
  currentData[currentLength++]=(byte)byteValue1;
  currentData[currentLength++]=(byte)byteValue2;
  length=currentLength;
  return this;
}
","/** 
 * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.
 * @param byteValue1 a byte.
 * @param byteValue2 another byte.
 * @return this byte vector.
 */
",Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.,Appends two byte values to a ByteVector.,"The function checks if there is enough space in the data array, enlarges it if necessary, and appends two bytes to the current ByteVector.","@param byteValue1 int: First byte value to append.
   @param byteValue2 int: Second byte value to append.
   @return ByteVector: The updated ByteVector instance.","put11(1, 2)
-> ByteVector (appends bytes 1 and 2)
put11(255, 0)
-> ByteVector (appends bytes 255 and 0)","Preconditions: data is a non-null byte array. Postconditions: ByteVector length increases by 2 if there is space, otherwise data is enlarged.","final ByteVector put11(final int byteValue1,final int byteValue2){
    return put1(byteValue1).put1(byteValue2);
}",1,CodeLlama-7b-Instruct-hf
636766ae1a6d9265ec0175d8,buildContentRange,"private String buildContentRange(){
  Integer limit=drc.getLimit() == null ? getDefaultNumberPagination() - 1 : drc.getLimit();
  Integer offset=drc.getOffset() == null ? 0 : drc.getOffset();
  Long count=drc.getCount() == null ? 0 : drc.getCount();
  return offset + ""-"" + (limit.equals(0) ? count - 1 : limit)+ ""/""+ count;
}
","/** 
 * Build the 'Content-Range' HTTP Header value.
 * @return 'Content-Range' value
 */
","Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.",Builds a content range string for pagination.,"Constructs a string representing a range of data items being accessed, based on limit, offset, and total count values.","@return String: A content range string formatted as ""offset-limit/count"".","limit=10, offset=5, count=50 -> ""5-9/50"" (normal range scenario)
limit=null, offset=null, count=null -> ""0-49/0"" (fall back to defaults)
limit=0, offset=10, count=15 -> ""10-14/15"" (limit is 0, output adjusted)","Limit, offset, and count may be null and, if so, are assigned default values, the string reflects range from offset to limit or count.","private String buildContentRange(){
  Integer limit=drc.getLimit() == null ? getDefaultNumberPagination() - 1 : drc.getLimit();
  Integer offset=drc.getOffset() == null ? 0 : drc.getOffset();
  Long count=drc.getCount() == null ? 0 : drc.getCount();
  return offset + ""-"" + (limit.equals(0) ? count - 1 : limit)+ ""/""+ count;
}
",0,reference
636766ae1a6d9265ec0175d8,buildContentRange,"private String buildContentRange(){
  Integer limit=drc.getLimit() == null ? getDefaultNumberPagination() - 1 : drc.getLimit();
  Integer offset=drc.getOffset() == null ? 0 : drc.getOffset();
  Long count=drc.getCount() == null ? 0 : drc.getCount();
  return offset + ""-"" + (limit.equals(0) ? count - 1 : limit)+ ""/""+ count;
}
","/** 
 * Build the 'Content-Range' HTTP Header value.
 * @return 'Content-Range' value
 */
","Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.",Builds a content range string for pagination.,"Constructs a string representing a range of data items being accessed, based on limit, offset, and total count values.","@return String: A content range string formatted as ""offset-limit/count"".","limit=10, offset=5, count=50 -> ""5-9/50"" (normal range scenario)
limit=null, offset=null, count=null -> ""0-49/0"" (fall back to defaults)
limit=0, offset=10, count=15 -> ""10-14/15"" (limit is 0, output adjusted)","Limit, offset, and count may be null and, if so, are assigned default values, the string reflects range from offset to limit or count.","public String buildContentRange(int offset, int limit, int count) {
    if (limit == 0) {
        limit = count - 1;
    }
    return ""Content-Range: items "" + offset + ""-"" + limit + ""/"" + count;
}",1,Qwen2.5-Coder-7B-Instruct
